# P2é˜¶æ®µè¯¦ç»†è®¾è®¡ï¼šæ¿€æ´»L2/L3å±‚ï¼ˆå…¨çƒæˆ˜ç•¥ + è‡ªæˆ‘è®¤çŸ¥ï¼‰

## ğŸ“‹ é˜¶æ®µæ¦‚è¿°

**ç›®æ ‡**: æ¿€æ´»L2ï¼ˆå…¨çƒæˆ˜ç•¥å±‚ï¼‰å’ŒL3ï¼ˆè‡ªæˆ‘è®¤çŸ¥å±‚ï¼‰ï¼Œå®ç°é•¿æœŸè®°å¿†ã€è‡ªæˆ‘è®¤çŸ¥å’Œèƒ½åŠ›ç®¡ç†ã€‚

**æ ¸å¿ƒä»·å€¼**:
- è·¨ä¼šè¯çš„ä¸Šä¸‹æ–‡è¿ç»­æ€§
- æ™ºèƒ½ä½“"è®°ä½"ç”¨æˆ·åå¥½å’Œæˆ˜ç•¥ç›®æ ‡
- åŠ¨æ€ç®¡ç†æŠ€èƒ½èƒ½åŠ›ï¼Œè‡ªåŠ¨è§„é¿æ•…éšœæŠ€èƒ½
- å»ºç«‹é•¿æœŸä¸–ç•Œæ¨¡å‹

**é¢„è®¡å·¥æœŸ**: 2å‘¨ï¼ˆ10ä¸ªå·¥ä½œæ—¥ï¼‰

**å‰ç½®ä¾èµ–**: âœ… P0-P1é˜¶æ®µå®Œæˆï¼ˆL5/L6/L4å±‚å·²æ¿€æ´»ï¼‰

---

## ğŸ¯ é˜¶æ®µç›®æ ‡

### ä¸»è¦ç›®æ ‡
1. âœ… **æ¿€æ´»L3è‡ªæˆ‘è®¤çŸ¥å±‚**ï¼ˆAgent Model Layerï¼‰
   - åŠ¨æ€ç»´æŠ¤æŠ€èƒ½æ¸…å•
   - è‡ªåŠ¨æ ‡è®°æ•…éšœæŠ€èƒ½
   - ä¸SkillManageræ·±åº¦é›†æˆ
   - æ”¯æŒæŠ€èƒ½èƒ½åŠ›è¾¹ç•Œç®¡ç†

2. âœ… **æ¿€æ´»L2å…¨çƒæˆ˜ç•¥å±‚**ï¼ˆGlobal Strategy Layerï¼‰
   - ç»´æŠ¤é•¿æœŸæˆ˜ç•¥å’Œä¸–ç•Œæ¨¡å‹
   - ä½¿ç”¨LanceDBç»Ÿä¸€å­˜å‚¨
   - è·¨ä¼šè¯çš„ä¸Šä¸‹æ–‡è¿ç»­æ€§
   - æˆ˜ç•¥å­¦ä¹ ä¸è°ƒæ•´

3. âœ… **æ·±åº¦é›†æˆé¡¹ç›®ç°æœ‰ç»„ä»¶**
   - SkillManagerï¼šæŠ€èƒ½ç”Ÿå‘½å‘¨æœŸç®¡ç†
   - ToolRetrievalServiceï¼šLanceDBå‘é‡æ£€ç´¢
   - ReActStrategyï¼šåŠ¨æ€æ³¨é”€æœºåˆ¶

4. âœ… **é•¿æœŸè®°å¿†æœºåˆ¶**
   - ä»»åŠ¡å®Œæˆåæ›´æ–°ä¸–ç•Œæ¨¡å‹
   - æˆ˜ç•¥å­¦ä¹ å­˜å‚¨åˆ°LanceDB
   - ä¼šè¯å¼€å§‹æ—¶åŠ è½½æˆ˜ç•¥ä¸Šä¸‹æ–‡

---

## ğŸ” å½“å‰é¡¹ç›®é€»è¾‘åˆ†æ

### 1. SkillManagerç°çŠ¶åˆ†æ

**ä½ç½®**: `src/services/SkillManager.ts`

**å½“å‰èƒ½åŠ›**:
- âœ… æŠ€èƒ½å®‰è£…/å¸è½½/æ›´æ–°
- âœ… å‘é‡ç´¢å¼•ï¼ˆToolRetrievalServiceï¼‰
- âœ… æŠ€èƒ½åˆ—è¡¨å’ŒæŸ¥è¯¢
- âœ… ç»Ÿè®¡ä¿¡æ¯

**ACE L3æ˜ å°„ç‚¹**:
- âœ… å·²æœ‰æŠ€èƒ½æ¸…å•ç®¡ç†
- âœ… æ”¯æŒåŠ¨æ€æ³¨å†Œ/æ³¨é”€
- âŒ ç¼ºå°‘ä¸ACEå±‚çº§çš„é€šä¿¡
- âŒ æ²¡æœ‰æŠ€èƒ½æ•…éšœæ ‡è®°æœºåˆ¶
- âŒ æ²¡æœ‰ä¸ReActStrategyè‡ªåŠ¨æ³¨é”€æœºåˆ¶é›†æˆ

### 2. ToolRetrievalServiceç°çŠ¶åˆ†æ

**ä½ç½®**: `src/services/ToolRetrievalService.ts`ï¼ˆä»ä¹‹å‰è¯»å–å¯çŸ¥ï¼‰

**å½“å‰èƒ½åŠ›**:
- âœ… LanceDBå‘é‡æ•°æ®åº“
- âœ… æŠ€èƒ½ç´¢å¼•å’Œæ£€ç´¢
- âœ… ç›¸ä¼¼åº¦æœç´¢
- âœ… æ‰¹é‡ç´¢å¼•

**ACE L2/L3æ˜ å°„ç‚¹**:
- âœ… å·²æœ‰LanceDBå®ç°ï¼ˆç¬¦åˆç»Ÿä¸€è¦æ±‚ï¼‰
- âœ… æ”¯æŒå‘é‡å­˜å‚¨å’Œæ£€ç´¢
- âŒ ç¼ºå°‘æˆ˜ç•¥å­¦ä¹ å­˜å‚¨
- âŒ ç¼ºå°‘ä¸–ç•Œæ¨¡å‹ç®¡ç†

### 3. ReActStrategyè‡ªåŠ¨æ³¨é”€æœºåˆ¶

**ä½ç½®**: `src/strategies/ReActStrategy.ts`

**å½“å‰å®ç°**:
```typescript
// åŠ¨æ€Skillsè‡ªåŠ¨æ³¨é”€æœºåˆ¶
private dynamicSkillsLastAccess: Map<string, number> = new Map();
private cleanupTimer: NodeJS.Timeout | null = null;
private readonly SKILL_TIMEOUT_MS = 5 * 60 * 1000; // 5åˆ†é’Ÿ

// å¯åŠ¨è‡ªåŠ¨æ¸…ç†å®šæ—¶å™¨
this.startCleanupTimer();

// æ¸…ç†è¶…è¿‡5åˆ†é’Ÿæœªä½¿ç”¨çš„Skills
private cleanupUnusedSkills(): void {
  // ... å®ç°
}
```

**ACE L3é›†æˆç‚¹**:
- âœ… å·²æœ‰è‡ªåŠ¨æ³¨é”€æœºåˆ¶
- âœ… åŠ¨æ€è¿½è¸ªæŠ€èƒ½è®¿é—®æ—¶é—´
- âŒ æ²¡æœ‰ä¸ŠæŠ¥åˆ°L3å±‚
- âŒ æ²¡æœ‰ä¸SkillManageré›†æˆ

---

## ğŸ—ï¸ è¯¦ç»†è®¾è®¡æ–¹æ¡ˆ

### æ–¹æ¡ˆ1: åˆ›å»ºAceCapabilityManagerï¼ˆL3è‡ªæˆ‘è®¤çŸ¥å±‚ï¼‰

#### 1.1 æ ¸å¿ƒæ¶æ„è®¾è®¡

**æ–‡ä»¶ä½ç½®**: `src/services/AceCapabilityManager.ts`

**è®¾è®¡æ€è·¯**:
```typescript
/**
 * ACEèƒ½åŠ›ç®¡ç†å™¨ï¼ˆæ˜ å°„åˆ°L3 - Agent Model Layerï¼‰
 * æ·±åº¦æ•´åˆé¡¹ç›®ç°æœ‰çš„æŠ€èƒ½ç³»ç»Ÿ
 */
export class AceCapabilityManager {
  constructor(
    private aceIntegrator: AceIntegrator,    // ACEé›†æˆ
    private skillManager: SkillManager,      // æŠ€èƒ½ç®¡ç†
    private toolRetrievalService: ToolRetrievalService // å‘é‡æ£€ç´¢
  ) {}

  // æ ¸å¿ƒåŠŸèƒ½
  async registerSkill(skill: SkillTool): Promise<void>
  async markSkillAsFaulty(skillName: string, error: string): Promise<void>
  async getAvailableCapabilities(): Promise<string[]>
  async updateSkillActivity(skillName: string): Promise<void>
  async cleanupInactiveSkills(): Promise<void>
}
```

#### 1.2 æŠ€èƒ½æ³¨å†Œä¸èƒ½åŠ›æ›´æ–°

**æŠ€èƒ½æ³¨å†Œæ—¶æ›´æ–°L3**:
```typescript
async registerSkill(skill: SkillTool): Promise<void> {
  // ä¸ŠæŠ¥ç»™L3å±‚
  await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
    type: 'CAPABILITY_UPDATE',
    content: `New skill registered: ${skill.name}`,
    metadata: {
      skillName: skill.name,
      skillType: skill.type,
      capabilities: skill.description,
      tags: skill.tags,
      version: skill.version,
      timestamp: Date.now()
    }
  });

  // âœ… æ›´æ–°å‘é‡æ£€ç´¢ç´¢å¼•ï¼ˆä¸SkillManagerä¿æŒä¸€è‡´ï¼‰
  try {
    await this.toolRetrievalService.indexSkill({
      name: skill.name,
      description: skill.description,
      tags: skill.tags || [],
      path: skill.path,
      version: skill.version,
      metadata: {
        parameters: skill.parameters,
        registeredAt: Date.now(),
        layer: 'L3_AGENT_MODEL'
      }
    });

    logger.info(`[AceCapabilityManager] Skill registered and indexed: ${skill.name}`);
  } catch (error) {
    logger.warn(`[AceCapabilityManager] Failed to index skill: ${skill.name}`, error);
  }
}
```

#### 1.3 æŠ€èƒ½æ•…éšœæ ‡è®°

**æŠ€èƒ½å¤±è´¥æ—¶æ›´æ–°L3**:
```typescript
async markSkillAsFaulty(skillName: string, error: string): Promise<void> {
  // ä¸ŠæŠ¥ç»™L3å±‚
  await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
    type: 'CAPABILITY_UPDATE',
    content: `Skill ${skillName} marked as faulty: ${error}`,
    metadata: {
      skillName,
      status: 'faulty',
      error,
      timestamp: Date.now(),
      faultCount: await this.getFaultCount(skillName)
    }
  });

  // âœ… è§¦å‘è‡ªåŠ¨æ³¨é”€æœºåˆ¶ï¼ˆä¸ReActStrategyé›†æˆï¼‰
  logger.warn(`[AceCapabilityManager] Skill marked as faulty: ${skillName}`);

  // å¯é€‰ï¼šè‡ªåŠ¨ç¦ç”¨æ•…éšœæŠ€èƒ½
  // await this.skillManager.disableSkill(skillName);
}
```

**æ•…éšœè®¡æ•°ç®¡ç†**:
```typescript
private faultCounts: Map<string, number> = new Map();

private async getFaultCount(skillName: string): Promise<number> {
  return this.faultCounts.get(skillName) || 0;
}

private async incrementFaultCount(skillName: string): Promise<number> {
  const count = this.faultCounts.get(skillName) || 0;
  const newCount = count + 1;
  this.faultCounts.set(skillName, newCount);
  return newCount;
}
```

#### 1.4 èƒ½åŠ›æŸ¥è¯¢ä¸æ´»åŠ¨è¿½è¸ª

**L3æŸ¥è¯¢ï¼šå½“å‰å¯ç”¨æŠ€èƒ½**:
```typescript
async getAvailableCapabilities(): Promise<string[]> {
  // âœ… ä½¿ç”¨é¡¹ç›®ç°æœ‰çš„SkillManagerè·å–æŠ€èƒ½åˆ—è¡¨
  const skills = await this.skillManager.listSkills();
  const enabledSkills = skills.filter(s => s.enabled);

  // ä¸ŠæŠ¥èƒ½åŠ›æŸ¥è¯¢äº‹ä»¶
  await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
    type: 'CAPABILITY_QUERY',
    content: `Querying available capabilities: ${enabledSkills.length} skills`,
    metadata: {
      queryTime: Date.now(),
      skillCount: enabledSkills.length
    }
  });

  return enabledSkills.map(s => s.name);
}
```

**L3åŠ¨æ€æŠ€èƒ½è¿½è¸ª**:
```typescript
async updateSkillActivity(skillName: string): Promise<void> {
  // ä½¿ç”¨é¡¹ç›®ç°æœ‰çš„æŠ€èƒ½çŠ¶æ€è¿½è¸ª
  await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
    type: 'ACTIVITY_UPDATE',
    content: `Skill ${skillName} accessed`,
    metadata: {
      skillName,
      timestamp: Date.now(),
      status: 'active',
      lastAccess: Date.now()
    }
  });

  // âœ… ä¸ReActStrategyçš„åŠ¨æ€æ³¨é”€æœºåˆ¶é›†æˆ
  // è¿™é‡Œå¯ä»¥é€šçŸ¥ReActStrategyæ›´æ–°è®¿é—®æ—¶é—´
  if (this.activityCallback) {
    this.activityCallback(skillName);
  }
}
```

#### 1.5 æ¸…ç†ä¸æ´»è·ƒæŠ€èƒ½

**è§¦å‘ReActStrategyçš„è‡ªåŠ¨æ¸…ç†**:
```typescript
async cleanupInactiveSkills(): Promise<void> {
  // âœ… ä½¿ç”¨é¡¹ç›®ç°æœ‰çš„è‡ªåŠ¨æ¸…ç†æœºåˆ¶
  // ReActStrategyå·²ç»æœ‰5åˆ†é’Ÿè¶…æ—¶æ¸…ç†ï¼Œæ— éœ€é‡å¤å®ç°
  logger.debug('[AceCapabilityManager] Using ReActStrategy auto-cleanup mechanism');

  // ä¸ŠæŠ¥æ¸…ç†äº‹ä»¶
  await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
    type: 'CLEANUP_UPDATE',
    content: `Inactive skills cleanup triggered`,
    metadata: {
      timestamp: Date.now(),
      cleanupStrategy: 'reactive_timeout'
    }
  });
}
```

---

### æ–¹æ¡ˆ2: åˆ›å»ºAceStrategyManagerï¼ˆL2å…¨çƒæˆ˜ç•¥å±‚ï¼‰

#### 2.1 æ ¸å¿ƒæ¶æ„è®¾è®¡

**æ–‡ä»¶ä½ç½®**: `src/services/AceStrategyManager.ts`

**è®¾è®¡æ€è·¯**:
```typescript
/**
 * ACEæˆ˜ç•¥ç®¡ç†å™¨ï¼ˆæ˜ å°„åˆ°L2 - Global Strategy Layerï¼‰
 * ä½¿ç”¨é¡¹ç›®ç°æœ‰çš„LanceDBè¿›è¡Œé•¿æœŸè®°å¿†
 */
export class AceStrategyManager {
  constructor(
    private aceIntegrator: AceIntegrator,        // ACEé›†æˆ
    private toolRetrievalService: ToolRetrievalService // âœ… ä½¿ç”¨é¡¹ç›®ç°æœ‰çš„LanceDB
  ) {}

  // æ ¸å¿ƒåŠŸèƒ½
  async loadStrategicContext(userId: string): Promise<string>
  async updateWorldModel(sessionId: string, outcome: {
    summary: string;
    learnings: string[]
  }): Promise<void>
  private async storeStrategicLearning(outcome: {
    summary: string;
    learnings: string[]
  }): Promise<void>
}
```

#### 2.2 ä¼šè¯å¼€å§‹æ—¶åŠ è½½æˆ˜ç•¥ä¸Šä¸‹æ–‡

**ä»L2åŠ è½½é•¿æœŸæˆ˜ç•¥**:
```typescript
async loadStrategicContext(userId: string): Promise<string> {
  try {
    // âœ… ä½¿ç”¨é¡¹ç›®ç°æœ‰çš„ToolRetrievalServiceï¼ˆLanceDBï¼‰
    const query = `User ${userId} strategic goals plans learning`;
    const relevantPlans = await this.toolRetrievalService.findRelevantSkills(
      query,
      5, // limit
      0.5 // threshold
    );

    if (relevantPlans.length === 0) {
      return 'No previous strategic context found.';
    }

    // æ„å»ºæˆ˜ç•¥ä¸Šä¸‹æ–‡
    const pastStrategies = relevantPlans.map(r => {
      const metadata = r.tool.metadata || {};
      return `- ${r.tool.name}: ${r.tool.description} (${metadata.type || 'learning'})`;
    }).join('\n');

    // ä¸ŠæŠ¥åŠ è½½äº‹ä»¶
    await this.aceIntegrator.sendToLayer('GLOBAL_STRATEGY', {
      type: 'CONTEXT_LOAD',
      content: `Loaded strategic context for user ${userId}`,
      metadata: {
        userId,
        loadedMemories: relevantPlans.length,
        timestamp: Date.now()
      }
    });

    return `Past Strategic Goals:\n${pastStrategies}`;
  } catch (error) {
    logger.error('[AceStrategyManager] Failed to load strategic context:', error);
    return 'Failed to load strategic context.';
  }
}
```

#### 2.3 ä»»åŠ¡å®Œæˆåæ›´æ–°ä¸–ç•Œæ¨¡å‹

**å°†å­¦ä¹ å­˜å‚¨åˆ°L2**:
```typescript
async updateWorldModel(
  sessionId: string,
  outcome: { summary: string; learnings: string[] }
): Promise<void> {
  // ä¸ŠæŠ¥åˆ°L2
  await this.aceIntegrator.sendToLayer('GLOBAL_STRATEGY', {
    type: 'STATUS_UPDATE',
    content: `Mission accomplished: ${outcome.summary}`,
    metadata: {
      learnings: outcome.learnings,
      sessionId,
      timestamp: Date.now()
    }
  });

  // âœ… å°†æˆ˜ç•¥å­¦ä¹ å­˜å‚¨åˆ°LanceDBï¼ˆä½œä¸ºç‰¹æ®Š"æˆ˜ç•¥æŠ€èƒ½"ï¼‰
  await this.storeStrategicLearning(outcome);

  // ğŸ†• è§¦å‘L2çš„æˆ˜ç•¥è°ƒæ•´ï¼ˆä½¿ç”¨æœ¬åœ°äº‹ä»¶æ€»çº¿ï¼‰
  this.aceIntegrator.getAceService()?.getEngine()?.bus.northbound.emit('GLOBAL_STRATEGY', {
    data: {
      trigger: {
        type: 'MISSION_COMPLETE',
        level: 'GLOBAL_STRATEGY',
        sessionId,
        traceId: crypto.randomUUID(),
        timestamp: Date.now(),
        context: outcome.summary
      }
    }
  });
}
```

#### 2.4 æˆ˜ç•¥å­¦ä¹ å­˜å‚¨

**å°†æˆ˜ç•¥å­¦ä¹ å­˜å‚¨ä¸ºå‘é‡è®°å½•**:
```typescript
private async storeStrategicLearning(outcome: {
  summary: string;
  learnings: string[]
}): Promise<void> {
  try {
    const learningText = `Strategic Learning: ${outcome.summary}\nLearnings: ${outcome.learnings.join('; ')}`;

    // ä½¿ç”¨ToolRetrievalServiceä½œä¸ºé€šç”¨å‘é‡å­˜å‚¨
    await this.toolRetrievalService.indexSkill({
      name: `strategic_learning_${Date.now()}`,
      description: learningText,
      tags: ['strategic', 'learning', 'long-term'],
      path: 'memory://strategic',
      metadata: {
        type: 'strategic_learning',
        learnings: outcome.learnings,
        storedAt: Date.now(),
        layer: 'L2_GLOBAL_STRATEGY'
      }
    });

    logger.info('[AceStrategyManager] Strategic learning stored in LanceDB');
  } catch (error) {
    logger.error('[AceStrategyManager] Failed to store strategic learning:', error);
  }
}
```

---

### æ–¹æ¡ˆ3: é›†æˆç°æœ‰ç»„ä»¶

#### 3.1 SkillManageré›†æˆ

**ä¿®æ”¹ä½ç½®**: `src/services/SkillManager.ts`

**æ–°å¢é›†æˆç‚¹**:
```typescript
export class SkillManager {
  // ğŸ†• æ³¨å…¥AceCapabilityManager
  private capabilityManager?: AceCapabilityManager;

  setCapabilityManager(manager: AceCapabilityManager): void {
    this.capabilityManager = manager;
  }

  // ä¿®æ”¹registerSkillæ–¹æ³•
  async installSkill(zipBuffer: Buffer, options: SkillInstallOptions = {}): Promise<InstallResult> {
    // ... ç°æœ‰ä»£ç  ...

    // ğŸ†• æŠ€èƒ½å®‰è£…æˆåŠŸåä¸ŠæŠ¥åˆ°L3
    if (this.capabilityManager && metadata) {
      await this.capabilityManager.registerSkill({
        name: metadata.name,
        type: ToolType.SKILL,
        description: metadata.description,
        parameters: metadata.parameters || { type: 'object', properties: {}, required: [] },
        version: metadata.version,
        tags: metadata.tags || [],
        author: metadata.author,
        enabled: true,
        path: targetDir,
        level: 1
      });
    }

    return result;
  }
}
```

#### 3.2 ReActStrategyé›†æˆ

**ä¿®æ”¹ä½ç½®**: `src/strategies/ReActStrategy.ts`

**æ–°å¢ä¸L3çš„é›†æˆ**:
```typescript
export class ReActStrategy {
  // ğŸ†• æ³¨å…¥AceCapabilityManager
  private capabilityManager?: AceCapabilityManager;

  setCapabilityManager(manager: AceCapabilityManager): void {
    this.capabilityManager = manager;
  }

  // ä¿®æ”¹registerSkillAsBuiltInToolæ–¹æ³•
  private registerSkillAsBuiltInTool(skill: SkillTool): void {
    // ... ç°æœ‰ä»£ç  ...

    // ğŸ†• ä¸ŠæŠ¥æŠ€èƒ½æ³¨å†Œåˆ°L3
    if (this.capabilityManager) {
      this.capabilityManager.registerSkill(skill).catch(err => {
        logger.warn('[ReActStrategy] Failed to report skill registration to L3:', err);
      });
    }

    // ... ç°æœ‰ä»£ç  ...
  }

  // ä¿®æ”¹å·¥å…·æ‰§è¡Œæ–¹æ³•
  private async executeTool(toolName: string, params: Record<string, any>): Promise<any> {
    // ... ç°æœ‰ä»£ç  ...

    // ğŸ†• æ›´æ–°L3æŠ€èƒ½æ´»åŠ¨çŠ¶æ€
    if (this.capabilityManager && result.success) {
      this.capabilityManager.updateSkillActivity(toolName).catch(err => {
        logger.warn('[ReActStrategy] Failed to update skill activity in L3:', err);
      });
    }

    // ğŸ†• æ ‡è®°æ•…éšœæŠ€èƒ½
    if (!result.success && this.capabilityManager) {
      this.capabilityManager.markSkillAsFaulty(toolName, result.error).catch(err => {
        logger.warn('[ReActStrategy] Failed to mark faulty skill in L3:', err);
      });
    }

    return result;
  }
}
```

#### 3.3 ChatServiceé›†æˆ

**ä¿®æ”¹ä½ç½®**: `src/services/ChatService.ts`

**æ–°å¢L2/L3åˆå§‹åŒ–**:
```typescript
export class ChatService {
  private capabilityManager: AceCapabilityManager;
  private strategyManager: AceStrategyManager;

  constructor(...) {
    // ... ç°æœ‰ä»£ç  ...

    // ğŸ†• åˆå§‹åŒ–L3èƒ½åŠ›ç®¡ç†å™¨
    this.capabilityManager = new AceCapabilityManager(
      this.aceIntegrator,
      this.skillManager,
      this.toolRetrievalService
    );

    // ğŸ†• åˆå§‹åŒ–L2æˆ˜ç•¥ç®¡ç†å™¨
    this.strategyManager = new AceStrategyManager(
      this.aceIntegrator,
      this.toolRetrievalService
    );

    // ğŸ†• ä¼ é€’èƒ½åŠ›ç®¡ç†å™¨åˆ°SkillManagerå’ŒReActStrategy
    this.skillManager.setCapabilityManager(this.capabilityManager);
    this.reActStrategy.setCapabilityManager(this.capabilityManager);
  }

  async chat(messages: Message[], options: ChatOptions): Promise<ChatResult> {
    // ğŸ†• ä¼šè¯å¼€å§‹æ—¶åŠ è½½L2æˆ˜ç•¥ä¸Šä¸‹æ–‡
    if (options.userId && this.shouldLoadStrategicContext(messages)) {
      const strategicContext = await this.strategyManager.loadStrategicContext(options.userId);
      // å°†æˆ˜ç•¥ä¸Šä¸‹æ–‡æ·»åŠ åˆ°ç³»ç»Ÿæ¶ˆæ¯ä¸­
      messages = this.prependStrategicContext(messages, strategicContext);
    }

    // ... ç°æœ‰ä»£ç  ...

    // ğŸ†• ä»»åŠ¡å®Œæˆåæ›´æ–°L2ä¸–ç•Œæ¨¡å‹
    if (options.userId && result.shouldUpdateWorldModel) {
      await this.strategyManager.updateWorldModel(options.sessionId!, {
        summary: `User request completed: ${messages[messages.length - 1]?.content}`,
        learnings: result.learnings || []
      });
    }

    return result;
  }
}
```

---

## ğŸ“ å®æ–½æ­¥éª¤

### Step 1: åˆ›å»ºAceCapabilityManager (Day 1-2)

**ä»»åŠ¡æ¸…å•**:
- [ ] åˆ›å»º`src/services/AceCapabilityManager.ts`
- [ ] å®ç°registerSkillæ–¹æ³•
- [ ] å®ç°markSkillAsFaultyæ–¹æ³•
- [ ] å®ç°getAvailableCapabilitiesæ–¹æ³•
- [ ] å®ç°updateSkillActivityæ–¹æ³•

**éªŒæ”¶æ ‡å‡†**:
- [ ] å•å…ƒæµ‹è¯•é€šè¿‡ï¼ˆæ‰€æœ‰æ–¹æ³•ï¼‰
- [ ] ä¸SkillManageré›†æˆæ­£å¸¸
- [ ] æ•…éšœæ ‡è®°æœºåˆ¶æ­£å¸¸

### Step 2: åˆ›å»ºAceStrategyManager (Day 3-4)

**ä»»åŠ¡æ¸…å•**:
- [ ] åˆ›å»º`src/services/AceStrategyManager.ts`
- [ ] å®ç°loadStrategicContextæ–¹æ³•
- [ ] å®ç°updateWorldModelæ–¹æ³•
- [ ] å®ç°storeStrategicLearningæ–¹æ³•
- [ ] ä¸ToolRetrievalServiceé›†æˆæ­£å¸¸

**éªŒæ”¶æ ‡å‡†**:
- [ ] å•å…ƒæµ‹è¯•é€šè¿‡ï¼ˆæ‰€æœ‰æ–¹æ³•ï¼‰
- [ ] å‘é‡å­˜å‚¨å’Œæ£€ç´¢æ­£å¸¸
- [ ] æˆ˜ç•¥ä¸Šä¸‹æ–‡åŠ è½½æ­£ç¡®

### Step 3: é›†æˆSkillManager (Day 5-6)

**ä»»åŠ¡æ¸…å•**:
- [ ] ä¿®æ”¹SkillManagerï¼Œæ³¨å…¥AceCapabilityManager
- [ ] åœ¨installSkillæˆåŠŸåä¸ŠæŠ¥åˆ°L3
- [ ] æµ‹è¯•æŠ€èƒ½å®‰è£…æµç¨‹
- [ ] éªŒè¯å‘é‡ç´¢å¼•åŒæ­¥

**éªŒæ”¶æ ‡å‡†**:
- [ ] æŠ€èƒ½å®‰è£…åL3æ­£ç¡®æ”¶åˆ°é€šçŸ¥
- [ ] å‘é‡ç´¢å¼•æ­£å¸¸æ›´æ–°
- [ ] å‘åå…¼å®¹æ€§æ­£å¸¸

### Step 4: é›†æˆReActStrategy (Day 7-8)

**ä»»åŠ¡æ¸…å•**:
- [ ] ä¿®æ”¹ReActStrategyï¼Œæ³¨å…¥AceCapabilityManager
- [ ] åœ¨æŠ€èƒ½æ³¨å†Œæ—¶ä¸ŠæŠ¥åˆ°L3
- [ ] åœ¨å·¥å…·æ‰§è¡Œæ—¶æ›´æ–°æ´»åŠ¨çŠ¶æ€
- [ ] åœ¨å·¥å…·å¤±è´¥æ—¶æ ‡è®°æ•…éšœ

**éªŒæ”¶æ ‡å‡†**:
- [ ] åŠ¨æ€æŠ€èƒ½æ³¨å†Œæ­£ç¡®ä¸ŠæŠ¥
- [ ] æŠ€èƒ½æ´»åŠ¨çŠ¶æ€æ­£ç¡®è¿½è¸ª
- [ ] æ•…éšœæŠ€èƒ½æ­£ç¡®æ ‡è®°

### Step 5: é›†æˆChatService (Day 9)

**ä»»åŠ¡æ¸…å•**:
- [ ] ä¿®æ”¹ChatServiceï¼Œåˆå§‹åŒ–L2/L3ç®¡ç†å™¨
- [ ] å®ç°ä¼šè¯å¼€å§‹æ—¶åŠ è½½æˆ˜ç•¥ä¸Šä¸‹æ–‡
- [ ] å®ç°ä»»åŠ¡å®Œæˆåæ›´æ–°ä¸–ç•Œæ¨¡å‹
- [ ] é›†æˆæ‰€æœ‰ç»„ä»¶

**éªŒæ”¶æ ‡å‡†**:
- [ ] æˆ˜ç•¥ä¸Šä¸‹æ–‡æ­£ç¡®åŠ è½½
- [ ] ä¸–ç•Œæ¨¡å‹æ­£ç¡®æ›´æ–°
- [ ] è·¨ç»„ä»¶é›†æˆæ­£å¸¸

### Step 6: æµ‹è¯•éªŒè¯ (Day 10)

**æµ‹è¯•åœºæ™¯**:
- [ ] æŠ€èƒ½å®‰è£…/æ³¨å†Œæµç¨‹æµ‹è¯•
- [ ] æ•…éšœæŠ€èƒ½æ ‡è®°æµ‹è¯•
- [ ] æˆ˜ç•¥ä¸Šä¸‹æ–‡åŠ è½½æµ‹è¯•
- [ ] ä¸–ç•Œæ¨¡å‹æ›´æ–°æµ‹è¯•
- [ ] è·¨ä¼šè¯è®°å¿†æµ‹è¯•

**æ€§èƒ½æµ‹è¯•**:
- [ ] å‘é‡æ£€ç´¢æ€§èƒ½æµ‹è¯•
- [ ] é•¿æœŸè®°å¿†å­˜å‚¨æµ‹è¯•
- [ ] å†…å­˜ä½¿ç”¨ç›‘æ§

---

## ğŸ”§ å…³é”®ä»£ç ç¤ºä¾‹

### ç¤ºä¾‹1: å®Œæ•´çš„AceCapabilityManager

```typescript
// src/services/AceCapabilityManager.ts
export class AceCapabilityManager {
  private faultCounts: Map<string, number> = new Map();
  private activityCallback?: (skillName: string) => void;

  constructor(
    private aceIntegrator: AceIntegrator,
    private skillManager: SkillManager,
    private toolRetrievalService: ToolRetrievalService
  ) {}

  async registerSkill(skill: SkillTool): Promise<void> {
    // ä¸ŠæŠ¥ç»™L3å±‚
    await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
      type: 'CAPABILITY_UPDATE',
      content: `New skill registered: ${skill.name}`,
      metadata: {
        skillName: skill.name,
        skillType: skill.type,
        capabilities: skill.description,
        tags: skill.tags,
        version: skill.version,
        timestamp: Date.now()
      }
    });

    // æ›´æ–°å‘é‡æ£€ç´¢ç´¢å¼•
    try {
      await this.toolRetrievalService.indexSkill({
        name: skill.name,
        description: skill.description,
        tags: skill.tags || [],
        path: skill.path,
        version: skill.version,
        metadata: {
          parameters: skill.parameters,
          registeredAt: Date.now(),
          layer: 'L3_AGENT_MODEL'
        }
      });

      logger.info(`[AceCapabilityManager] Skill registered and indexed: ${skill.name}`);
    } catch (error) {
      logger.warn(`[AceCapabilityManager] Failed to index skill: ${skill.name}`, error);
    }
  }

  async markSkillAsFaulty(skillName: string, error: string): Promise<void> {
    // å¢åŠ æ•…éšœè®¡æ•°
    const faultCount = await this.incrementFaultCount(skillName);

    // ä¸ŠæŠ¥ç»™L3å±‚
    await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
      type: 'CAPABILITY_UPDATE',
      content: `Skill ${skillName} marked as faulty: ${error}`,
      metadata: {
        skillName,
        status: 'faulty',
        error,
        timestamp: Date.now(),
        faultCount
      }
    });

    // è§¦å‘è‡ªåŠ¨æ³¨é”€æœºåˆ¶
    logger.warn(`[AceCapabilityManager] Skill marked as faulty: ${skillName} (faults: ${faultCount})`);
  }

  async getAvailableCapabilities(): Promise<string[]> {
    const skills = await this.skillManager.listSkills();
    const enabledSkills = skills.filter(s => s.enabled);

    await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
      type: 'CAPABILITY_QUERY',
      content: `Querying available capabilities: ${enabledSkills.length} skills`,
      metadata: {
        queryTime: Date.now(),
        skillCount: enabledSkills.length
      }
    });

    return enabledSkills.map(s => s.name);
  }

  async updateSkillActivity(skillName: string): Promise<void> {
    await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
      type: 'ACTIVITY_UPDATE',
      content: `Skill ${skillName} accessed`,
      metadata: {
        skillName,
        timestamp: Date.now(),
        status: 'active'
      }
    });

    if (this.activityCallback) {
      this.activityCallback(skillName);
    }
  }

  async cleanupInactiveSkills(): Promise<void> {
    logger.debug('[AceCapabilityManager] Using ReActStrategy auto-cleanup mechanism');

    await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
      type: 'CLEANUP_UPDATE',
      content: `Inactive skills cleanup triggered`,
      metadata: {
        timestamp: Date.now(),
        cleanupStrategy: 'reactive_timeout'
      }
    });
  }

  private async getFaultCount(skillName: string): Promise<number> {
    return this.faultCounts.get(skillName) || 0;
  }

  private async incrementFaultCount(skillName: string): Promise<number> {
    const count = this.faultCounts.get(skillName) || 0;
    const newCount = count + 1;
    this.faultCounts.set(skillName, newCount);
    return newCount;
  }

  setActivityCallback(callback: (skillName: string) => void): void {
    this.activityCallback = callback;
  }
}
```

### ç¤ºä¾‹2: å®Œæ•´çš„AceStrategyManager

```typescript
// src/services/AceStrategyManager.ts
export class AceStrategyManager {
  constructor(
    private aceIntegrator: AceIntegrator,
    private toolRetrievalService: ToolRetrievalService
  ) {}

  async loadStrategicContext(userId: string): Promise<string> {
    try {
      const query = `User ${userId} strategic goals plans learning`;
      const relevantPlans = await this.toolRetrievalService.findRelevantSkills(
        query,
        5, // limit
        0.5 // threshold
      );

      if (relevantPlans.length === 0) {
        return 'No previous strategic context found.';
      }

      const pastStrategies = relevantPlans.map(r => {
        const metadata = r.tool.metadata || {};
        return `- ${r.tool.name}: ${r.tool.description} (${metadata.type || 'learning'})`;
      }).join('\n');

      await this.aceIntegrator.sendToLayer('GLOBAL_STRATEGY', {
        type: 'CONTEXT_LOAD',
        content: `Loaded strategic context for user ${userId}`,
        metadata: {
          userId,
          loadedMemories: relevantPlans.length,
          timestamp: Date.now()
        }
      });

      return `Past Strategic Goals:\n${pastStrategies}`;
    } catch (error) {
      logger.error('[AceStrategyManager] Failed to load strategic context:', error);
      return 'Failed to load strategic context.';
    }
  }

  async updateWorldModel(
    sessionId: string,
    outcome: { summary: string; learnings: string[] }
  ): Promise<void> {
    await this.aceIntegrator.sendToLayer('GLOBAL_STRATEGY', {
      type: 'STATUS_UPDATE',
      content: `Mission accomplished: ${outcome.summary}`,
      metadata: {
        learnings: outcome.learnings,
        sessionId,
        timestamp: Date.now()
      }
    });

    await this.storeStrategicLearning(outcome);

    // è§¦å‘L2çš„æˆ˜ç•¥è°ƒæ•´
    this.aceIntegrator.getAceService()?.getEngine()?.bus.northbound.emit('GLOBAL_STRATEGY', {
      data: {
        trigger: {
          type: 'MISSION_COMPLETE',
          level: 'GLOBAL_STRATEGY',
          sessionId,
          traceId: crypto.randomUUID(),
          timestamp: Date.now(),
          context: outcome.summary
        }
      }
    });
  }

  private async storeStrategicLearning(outcome: {
    summary: string;
    learnings: string[]
  }): Promise<void> {
    try {
      const learningText = `Strategic Learning: ${outcome.summary}\nLearnings: ${outcome.learnings.join('; ')}`;

      await this.toolRetrievalService.indexSkill({
        name: `strategic_learning_${Date.now()}`,
        description: learningText,
        tags: ['strategic', 'learning', 'long-term'],
        path: 'memory://strategic',
        metadata: {
          type: 'strategic_learning',
          learnings: outcome.learnings,
          storedAt: Date.now(),
          layer: 'L2_GLOBAL_STRATEGY'
        }
      });

      logger.info('[AceStrategyManager] Strategic learning stored in LanceDB');
    } catch (error) {
      logger.error('[AceStrategyManager] Failed to store strategic learning:', error);
    }
  }
}
```

---

## ğŸ“Š æ€§èƒ½ä¸èµ„æºåˆ†æ

### å‘é‡æ•°æ®åº“æ€§èƒ½

**LanceDBå­˜å‚¨å®¹é‡**:
```typescript
// æˆ˜ç•¥å­¦ä¹ è®°å½•å¤§å°
strategicLearningSize = {
  name: ~30B,           // strategic_learning_timestamp
  description: ~500B,   // å­¦ä¹ å†…å®¹
  tags: ~50B,           // ['strategic', 'learning', 'long-term']
  metadata: ~200B,      // å­¦ä¹ ä¿¡æ¯
  vector: ~1024B        // 384ç»´å‘é‡ * 4å­—èŠ‚
}

// å•æ¡è®°å½•: ~2KB
// 1000æ¡è®°å½•: ~2MB
// 10000æ¡è®°å½•: ~20MB
```

**æ£€ç´¢æ€§èƒ½**:
- å•æ¬¡æ£€ç´¢å»¶è¿Ÿ: < 50ms
- æ‰¹é‡æ£€ç´¢ï¼ˆ5æ¡ï¼‰: < 100ms
- å‘é‡ç´¢å¼•å¤§å°: 20MB (10000æ¡è®°å½•)

### å†…å­˜ä½¿ç”¨

**L3å±‚å†…å­˜**:
```typescript
l3Memory = {
  faultCounts: Map<string, number>,    // ~1KB (100ä¸ªæŠ€èƒ½)
  activityCallbacks: Map,              // ~500B
  skillMetadata: Map<string, any>      // ~5KB
}
```

**L2å±‚å†…å­˜**:
```typescript
l2Memory = {
  strategicContext: Map<string, string>,  // ç”¨æˆ·ID -> ä¸Šä¸‹æ–‡
  learningCache: Map<string, any>         // å­¦ä¹ è®°å½•ç¼“å­˜
}
```

### ç½‘ç»œI/O

**å‘é‡æ£€ç´¢é¢‘ç‡**:
- ä¼šè¯å¼€å§‹æ—¶: 1æ¬¡æ£€ç´¢ (åŠ è½½æˆ˜ç•¥ä¸Šä¸‹æ–‡)
- ä»»åŠ¡å®Œæˆå: 1æ¬¡å­˜å‚¨ (ä¿å­˜å­¦ä¹ )
- æ€»è®¡: 2æ¬¡ I/O per session

**ä¼˜åŒ–ç­–ç•¥**:
- âœ… ç¼“å­˜é¢‘ç¹æŸ¥è¯¢çš„æˆ˜ç•¥ä¸Šä¸‹æ–‡
- âœ… æ‰¹é‡å­˜å‚¨å­¦ä¹ è®°å½•
- âœ… å¼‚æ­¥æ‰§è¡Œï¼Œä¸é˜»å¡ä¸»æµç¨‹

---

## âš ï¸ é£é™©ä¸ç¼“è§£

### é£é™©1: å‘é‡æ•°æ®åº“å®¹é‡å¢é•¿
**åŸå› **: é•¿æœŸå­˜å‚¨æˆ˜ç•¥å­¦ä¹ ï¼Œæ•°æ®åº“ä¸æ–­å¢å¤§
**ç¼“è§£**:
- âœ… è®¾ç½®æœ€å¤§å­˜å‚¨æ•°é‡ï¼ˆ10000æ¡ï¼‰
- âœ… è‡ªåŠ¨æ¸…ç†è¿‡æœŸè®°å½•ï¼ˆ1å¹´ï¼‰
- âœ… å®šæœŸå‹ç¼©å’Œä¼˜åŒ–ç´¢å¼•

### é£é™©2: æ£€ç´¢å‡†ç¡®ç‡ä¸‹é™
**åŸå› **: å‘é‡ç›¸ä¼¼åº¦é˜ˆå€¼è®¾ç½®ä¸å½“
**ç¼“è§£**:
- âœ… åŠ¨æ€è°ƒæ•´é˜ˆå€¼ï¼ˆ0.5-0.7ï¼‰
- âœ… äººå·¥éªŒè¯é‡è¦å­¦ä¹ 
- âœ… å®šæœŸè¯„ä¼°æ£€ç´¢è´¨é‡

### é£é™©3: æŠ€èƒ½è¯¯æ ‡è®°ä¸ºæ•…éšœ
**åŸå› **: ä¸´æ—¶é”™è¯¯è¢«æ ‡è®°ä¸ºæ°¸ä¹…æ•…éšœ
**ç¼“è§£**:
- âœ… æ•…éšœè®¡æ•°æœºåˆ¶ï¼ˆ3æ¬¡æ‰æ ‡è®°ï¼‰
- âœ… è‡ªåŠ¨æ¢å¤æœºåˆ¶ï¼ˆ24å°æ—¶åé‡è¯•ï¼‰
- âœ… æ‰‹åŠ¨æ¢å¤æ¥å£

### é£é™©4: æˆ˜ç•¥ä¸Šä¸‹æ–‡æ±¡æŸ“
**åŸå› **: ä½è´¨é‡å­¦ä¹ æ±¡æŸ“ä¸–ç•Œæ¨¡å‹
**ç¼“è§£**:
- âœ… å­¦ä¹ è´¨é‡è¯„ä¼°ï¼ˆè‡ªåŠ¨è¿‡æ»¤ï¼‰
- âœ… ç”¨æˆ·ç¡®è®¤æœºåˆ¶ï¼ˆé‡è¦å­¦ä¹ ï¼‰
- âœ… å®šæœŸæ¸…ç†ä½è´¨é‡è®°å½•

---

## âœ… éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶
- [ ] æŠ€èƒ½å®‰è£…åæ­£ç¡®ä¸ŠæŠ¥åˆ°L3
- [ ] æ•…éšœæŠ€èƒ½æ­£ç¡®æ ‡è®°å’Œè¿½è¸ª
- [ ] æˆ˜ç•¥ä¸Šä¸‹æ–‡æ­£ç¡®åŠ è½½ï¼ˆè·¨ä¼šè¯ï¼‰
- [ ] ä¸–ç•Œæ¨¡å‹æ­£ç¡®æ›´æ–°ï¼ˆä»»åŠ¡å®Œæˆåï¼‰
- [ ] å‘é‡å­˜å‚¨å’Œæ£€ç´¢æ­£å¸¸

### æ€§èƒ½éªŒæ”¶
- [ ] å‘é‡æ£€ç´¢å»¶è¿Ÿ < 50ms
- [ ] æˆ˜ç•¥å­¦ä¹ å­˜å‚¨å»¶è¿Ÿ < 100ms
- [ ] å†…å­˜ä½¿ç”¨å¢é•¿ < 10MB (10000æ¡è®°å½•)
- [ ] æ— å†…å­˜æ³„æ¼ï¼ˆé•¿æœŸè¿è¡Œæµ‹è¯•ï¼‰

### é›†æˆéªŒæ”¶
- [ ] SkillManageré›†æˆæ­£å¸¸
- [ ] ReActStrategyé›†æˆæ­£å¸¸
- [ ] ToolRetrievalServiceé›†æˆæ­£å¸¸
- [ ] ChatServiceé›†æˆæ­£å¸¸
- [ ] å‘åå…¼å®¹æ€§100%

---

## ğŸ”— ä¾èµ–å…³ç³»

### ä¸Šæ¸¸ä¾èµ–
- âœ… P0-P1é˜¶æ®µå®Œæˆï¼ˆL5/L6/L4å±‚å·²æ¿€æ´»ï¼‰
- âœ… SkillManager - ç”¨äºæŠ€èƒ½ç®¡ç†
- âœ… ToolRetrievalService - ç”¨äºå‘é‡å­˜å‚¨
- âœ… ReActStrategy - ç”¨äºè‡ªåŠ¨æ³¨é”€

### ä¸‹æ¸¸ä¾èµ–ï¼ˆP3é˜¶æ®µï¼‰
- â³ AceEthicsGuard - æ¥æ”¶L2çš„æˆ˜ç•¥å†³ç­–
- â³ L1æ¸´æœ›å±‚ - æ¥æ”¶L2çš„é“å¾·å¯¹é½

---

## ğŸ“š å‚è€ƒå®ç°

### ç›¸å…³æ–‡ä»¶
- `src/services/AceCapabilityManager.ts` - æ–°å»º
- `src/services/AceStrategyManager.ts` - æ–°å»º
- `src/services/SkillManager.ts` - ä¿®æ”¹
- `src/strategies/ReActStrategy.ts` - ä¿®æ”¹
- `src/services/ChatService.ts` - ä¿®æ”¹

### æµ‹è¯•æ–‡ä»¶
- `tests/unit/services/AceCapabilityManager.test.ts`
- `tests/unit/services/AceStrategyManager.test.ts`
- `tests/integration/layer2-3-integration.test.ts`

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025-12-12
**ä½œè€…**: Claude Code
**å®¡æ ¸**: å¾…å®¡æ ¸
