# P4é˜¶æ®µè¯¦ç»†è®¾è®¡ï¼šå®Œå…¨å‰”é™¤å¤–éƒ¨ä¾èµ–ï¼ˆæœ¬åœ°åŒ–AceCoreï¼‰

## ğŸ“‹ é˜¶æ®µæ¦‚è¿°

**ç›®æ ‡**: å®Œå…¨å‰”é™¤ace-engine-coreä¾èµ–ï¼Œåˆ›å»ºæœ¬åœ°åŒ–AceCoreæ›¿ä»£æ–¹æ¡ˆï¼Œå®ç°é›¶å¤–éƒ¨ä¾èµ–çš„ACEæ¶æ„ã€‚

**æ ¸å¿ƒä»·å€¼**:
- å®Œå…¨æ— å¤–éƒ¨ä¾èµ–ï¼Œæé«˜é¡¹ç›®å¯æ§æ€§å’Œå®‰å…¨æ€§
- æ¶ˆé™¤ä¾›åº”é“¾é£é™©
- ç»Ÿä¸€æŠ€æœ¯æ ˆï¼Œé™ä½ç»´æŠ¤æˆæœ¬
- æå‡æ€§èƒ½å’Œç¨³å®šæ€§

**é¢„è®¡å·¥æœŸ**: 2å‘¨ï¼ˆ10ä¸ªå·¥ä½œæ—¥ï¼‰

**å‰ç½®ä¾èµ–**: âœ… P0-P3é˜¶æ®µå®Œæˆï¼ˆæ‰€æœ‰ACEå±‚çº§å·²æ¿€æ´»ï¼‰

---

## ğŸ¯ é˜¶æ®µç›®æ ‡

### ä¸»è¦ç›®æ ‡
1. âœ… **åˆ›å»ºæœ¬åœ°åŒ–AceCore**
   - å®Œå…¨æ›¿ä»£ace-engine-core
   - å®ç°æ‰€æœ‰å¿…éœ€åŠŸèƒ½ï¼ˆä¼šè¯ç®¡ç†ã€è°ƒåº¦å™¨ã€æ€»çº¿ç­‰ï¼‰
   - ä½¿ç”¨é¡¹ç›®ç°æœ‰ç»„ä»¶ï¼ˆEventBus, Mapå­˜å‚¨ç­‰ï¼‰

2. âœ… **é‡æ„AceService**
   - ç§»é™¤å¯¹AceEngineçš„ä¾èµ–
   - ä½¿ç”¨AceCoreæ›¿ä»£
   - ä¿æŒAPIå…¼å®¹æ€§

3. âœ… **è¿ç§»æ‰€æœ‰ACEç›¸å…³ä»£ç **
   - æ›´æ–°importè·¯å¾„
   - é€‚é…æœ¬åœ°åŒ–æ¥å£
   - ç¡®ä¿åŠŸèƒ½å®Œæ•´æ€§

4. âœ… **æ¸…ç†å¤–éƒ¨ä¾èµ–**
   - åˆ é™¤package.jsonä¸­çš„ace-engine-coreå¼•ç”¨
   - æ›´æ–°TypeScriptç±»å‹å®šä¹‰
   - éªŒè¯é›¶å¤–éƒ¨ä¾èµ–

---

## ğŸ” å½“å‰é¡¹ç›®ä¾èµ–åˆ†æ

### 1. AceServiceç°çŠ¶

**ä½ç½®**: `src/services/AceService.ts`

**å½“å‰ace-engine-coreä¾èµ–**:
```typescript
import { AceEngine, Trajectory, ReflectionTrigger } from 'ace-engine-core';

// ç›´æ¥å®ä¾‹åŒ–AceEngine
this.engine = new AceEngine({
  agentId: 'apex-bridge-001',
  storage: {
    mode: 'composite',
    sqlitePath: path.join(dataDir, 'trajectory.db'),
    logsPath: path.join(dataDir, 'logs.db'),
  },
  // ... å…¶ä»–é…ç½®
});

// ä½¿ç”¨AceEngineçš„æ–¹æ³•
await this.engine.start();
await this.engine.evolve(trajectory);
await this.engine.updateSessionActivity(sessionId);
```

**ä¾èµ–ä½ç½®**:
- âŒ æ„é€ å‡½æ•°ä¸­å®ä¾‹åŒ–AceEngine
- âŒ ä½¿ç”¨engine.start(), engine.evolve(), engine.updateSessionActivity()
- âŒ ä½¿ç”¨engine.bus.northbound.emit()
- âŒ ä¾èµ–AceEngineçš„ç§æœ‰å±æ€§ï¼ˆstorage.sqliteï¼‰

### 2. AceIntegratorç°çŠ¶

**ä½ç½®**: `src/services/AceIntegrator.ts`

**å½“å‰ace-engine-coreä¾èµ–**:
```typescript
// ä¾èµ–AceServiceï¼Œé—´æ¥ä¾èµ–AceEngine
constructor(private aceService: AceService) {}

async saveTrajectory(params: TrajectoryParams): Promise<void> {
  const engine = this.aceService.getEngine();
  if (!engine) return;

  // ä½¿ç”¨AceEngineçš„æ–¹æ³•
  await this.aceService.evolve(trajectory);
}

async updateSessionActivity(sessionId?: string): Promise<void> {
  const engine = this.aceService.getEngine();
  if (!engine) return;

  // ä½¿ç”¨AceEngineçš„æ–¹æ³•
  await engine.updateSessionActivity(sessionId);
}

async publishWithSession(...): Promise<void> {
  const engine = this.aceService.getEngine();
  if (!engine) return;

  // ä½¿ç”¨AceEngineçš„æ–¹æ³•
  await engine.publishWithSession(sessionId, content, layer);
}
```

**ä¾èµ–ä½ç½®**:
- âŒ é—´æ¥ä¾èµ–AceEngineï¼ˆé€šè¿‡AceServiceï¼‰
- âŒ ä½¿ç”¨engine.getEngine(), engine.evolve(), engine.updateSessionActivity()
- âŒ ä½¿ç”¨engine.bus.northbound.emit()

---

## ğŸ—ï¸ è¯¦ç»†è®¾è®¡æ–¹æ¡ˆ

### æ–¹æ¡ˆ1: åˆ›å»ºæœ¬åœ°åŒ–AceCore

#### 1.1 æ ¸å¿ƒæ¶æ„è®¾è®¡

**æ–‡ä»¶ä½ç½®**: `src/core/ace/AceCore.ts`

**è®¾è®¡æ€è·¯**:
```typescript
/**
 * å®Œå…¨æœ¬åœ°åŒ–ACEæ ¸å¿ƒå®ç°
 * âœ… æ— å¤–éƒ¨ä¾èµ–ï¼Œå®Œå…¨æ›¿ä»£ ace-engine-core
 */
export class AceCore {
  private bus = {
    northbound: new EventEmitter(),
    southbound: new EventEmitter()
  };

  private scratchpads: Map<string, Map<string, string>> = new Map();
  private sessions: Map<string, any> = new Map();
  private scheduler: NodeJS.Timeout | null = null;
  private reflectionTriggers: Map<string, ReflectionTrigger> = new Map();

  constructor(private config: AceCoreConfig) {}

  // æ ¸å¿ƒåŠŸèƒ½
  async start(): Promise<void>
  async stop(): Promise<void>
  async createSession(config: { userId: string; metadata: any }): Promise<string>
  async updateSessionActivity(sessionId: string): Promise<void>
  async evolve(trajectory: Trajectory): Promise<void>
  async publishWithSession(sessionId: string, content: string, layer: string): Promise<void>
  async appendToScratchpad(sessionId: string, layerId: string, content: string): Promise<void>
}
```

**é…ç½®æ¥å£**:
```typescript
interface AceCoreConfig {
  agentId: string;
  reflectionCycleInterval?: number; // é»˜è®¤60000ms
  maxSessionAge?: number; // é»˜è®¤24å°æ—¶
  storage?: {
    mode: 'memory' | 'sqlite';
    sqlitePath?: string;
    logsPath?: string;
  };
  memory?: {
    provider: 'memory' | 'lancedb';
    endpoint?: string;
    collectionPrefix?: string;
  };
}
```

#### 1.2 ä¼šè¯ç®¡ç†å®ç°

**åˆ›å»ºä¼šè¯**:
```typescript
async createSession(config: { userId: string; metadata: any }): Promise<string> {
  const sessionId = crypto.randomUUID();
  this.sessions.set(sessionId, {
    ...config,
    createdAt: Date.now(),
    lastActivity: Date.now()
  });

  // ä¸ŠæŠ¥ä¼šè¯åˆ›å»ºäº‹ä»¶
  this.bus.northbound.emit('SESSION_CREATED', {
    data: {
      sessionId,
      config,
      timestamp: Date.now()
    }
  });

  logger.info(`[AceCore] Created session: ${sessionId}`);
  return sessionId;
}
```

**æ›´æ–°ä¼šè¯æ´»åŠ¨æ—¶é—´**:
```typescript
async updateSessionActivity(sessionId: string): Promise<void> {
  const session = this.sessions.get(sessionId);
  if (session) {
    session.lastActivity = Date.now();

    // ä¸ŠæŠ¥ä¼šè¯æ´»åŠ¨äº‹ä»¶
    this.bus.northbound.emit('SESSION_ACTIVITY', {
      data: {
        sessionId,
        timestamp: Date.now()
      }
    });

    logger.debug(`[AceCore] Updated session activity: ${sessionId}`);
  }
}
```

#### 1.3 Scratchpadç®¡ç†å®ç°

**è¿½åŠ åˆ°Scratchpad**:
```typescript
async appendToScratchpad(sessionId: string, layerId: string, content: string): Promise<void> {
  if (!this.scratchpads.has(sessionId)) {
    this.scratchpads.set(sessionId, new Map());
  }

  const layerScratchpad = this.scratchpads.get(sessionId)!;
  const existing = layerScratchpad.get(layerId) || '';
  layerScratchpad.set(layerId, existing + '\n' + content);

  logger.debug(`[AceCore] Appended to scratchpad: ${layerId}`);
}

async getScratchpad(sessionId: string, layerId: string): Promise<string> {
  return this.scratchpads.get(sessionId)?.get(layerId) || '';
}

async clearScratchpad(sessionId: string, layerId: string): Promise<void> {
  this.scratchpads.get(sessionId)?.delete(layerId);
  logger.debug(`[AceCore] Cleared scratchpad: ${layerId}`);
}
```

#### 1.4 åæ€è§¦å‘å®ç°

**è§¦å‘åæ€äº‹ä»¶**:
```typescript
async triggerReflection(trigger: ReflectionTrigger): Promise<void> {
  // å­˜å‚¨è§¦å‘å™¨
  this.reflectionTriggers.set(trigger.traceId, trigger);

  // ä¸ŠæŠ¥åˆ°æ€»çº¿
  this.bus.northbound.emit(trigger.level as string, {
    data: { trigger }
  });

  // è®°å½•åæ€è§¦å‘æ—¥å¿—
  logger.info(`[AceCore] Reflection triggered: ${trigger.type} at level ${trigger.level}`, {
    sessionId: trigger.sessionId,
    traceId: trigger.traceId
  });
}
```

**è°ƒåº¦åæ€å‘¨æœŸ**:
```typescript
async start(): Promise<void> {
  if (this.scheduler) return;

  const interval = this.config.reflectionCycleInterval || 60000;

  this.scheduler = setInterval(() => {
    this.runReflectionCycle();
  }, interval);

  logger.info(`[AceCore] Scheduler started with interval: ${interval}ms`);
}

private async runReflectionCycle(): Promise<void> {
  try {
    logger.debug('[AceCore] Running scheduled reflection cycle');

    // 1. æ¸…ç†è¿‡æœŸä¼šè¯
    await this.cleanupExpiredSessions();

    // 2. è§¦å‘å…¨å±€åæ€äº‹ä»¶
    const reflectionTrigger: ReflectionTrigger = {
      type: 'PERIODIC_REFLECTION',
      level: 'GLOBAL_STRATEGY',
      sessionId: 'system',
      traceId: crypto.randomUUID(),
      timestamp: Date.now(),
      context: 'Periodic reflection cycle'
    };

    await this.triggerReflection(reflectionTrigger);

    logger.debug('[AceCore] Reflection cycle completed');
  } catch (error) {
    logger.error('[AceCore] Reflection cycle failed:', error);
  }
}

private async cleanupExpiredSessions(): Promise<void> {
  const now = Date.now();
  const maxAge = this.config.maxSessionAge || (24 * 60 * 60 * 1000); // 24å°æ—¶

  for (const [sessionId, session] of this.sessions.entries()) {
    if (now - session.lastActivity > maxAge) {
      this.sessions.delete(sessionId);
      this.scratchpads.delete(sessionId);
      logger.info(`[AceCore] Cleaned up expired session: ${sessionId}`);
    }
  }
}
```

#### 1.5 è½¨è¿¹è¿›åŒ–å®ç°

**ä¿å­˜è½¨è¿¹**:
```typescript
async evolve(trajectory: Trajectory): Promise<void> {
  try {
    // åœ¨æœ¬åœ°å­˜å‚¨ä¸­ä¿å­˜è½¨è¿¹
    // è¿™é‡Œå¯ä»¥å®ç°SQLiteå­˜å‚¨æˆ–å†…å­˜å­˜å‚¨

    // ä¸ŠæŠ¥è½¨è¿¹ä¿å­˜äº‹ä»¶
    this.bus.northbound.emit('TRAJECTORY_SAVED', {
      data: {
        taskId: trajectory.task_id,
        sessionId: trajectory.session_id,
        timestamp: trajectory.timestamp
      }
    });

    logger.debug(`[AceCore] Trajectory saved for evolution: ${trajectory.task_id}`);
  } catch (error) {
    logger.error(`[AceCore] Failed to save trajectory: ${error}`);
    throw error;
  }
}
```

#### 1.6 ä¼šè¯æ¶ˆæ¯å‘å¸ƒ

**å‘å¸ƒæ¶ˆæ¯**:
```typescript
async publishWithSession(
  sessionId: string,
  content: string,
  layer: string
): Promise<void> {
  try {
    // æ„å»ºæ¶ˆæ¯åŒ…
    const message = {
      sessionId,
      content,
      layer,
      timestamp: Date.now()
    };

    // å‘å¸ƒåˆ°å—å‘æ€»çº¿
    this.bus.southbound.emit('MESSAGE', {
      data: message
    });

    logger.debug(`[AceCore] Published message to ${layer} for session: ${sessionId}`);
  } catch (error) {
    logger.error(`[AceCore] Failed to publish message: ${error}`);
    throw error;
  }
}
```

---

### æ–¹æ¡ˆ2: é‡æ„AceService

#### 2.1 ç§»é™¤AceEngineä¾èµ–

**ä¿®æ”¹ä½ç½®**: `src/services/AceService.ts`

**æ–°å®ç°**:
```typescript
import { AceCore } from '../core/ace/AceCore';
// âŒ åˆ é™¤: import { AceEngine, Trajectory, ReflectionTrigger } from 'ace-engine-core';

export class AceService {
  private static instance: AceService;
  private engine: AceCore | null = null; // ğŸ†• ä½¿ç”¨AceCoreæ›¿ä»£AceEngine
  private llmManager: LLMManager;
  private configService: ConfigService;
  private llmConfigService: LLMConfigService;
  private isInitializing: boolean = false;
  private reflectionTriggerStats: Map<string, ReflectionTriggerStats> = new Map();

  private constructor() {
    this.llmManager = new LLMManager();
    this.configService = ConfigService.getInstance();
    this.llmConfigService = LLMConfigService.getInstance();
  }

  async initialize(): Promise<void> {
    if (this.engine || this.isInitializing) return;

    this.isInitializing = true;
    logger.info('ğŸš€ Initializing local AceCore...');

    try {
      // ğŸ†• åˆ›å»ºæœ¬åœ°åŒ–AceCoreå®ä¾‹
      this.engine = new AceCore({
        agentId: 'apex-bridge-001',
        reflectionCycleInterval: 60000,
        maxSessionAge: 24 * 60 * 60 * 1000, // 24å°æ—¶
        storage: {
          mode: 'memory' // æœ¬åœ°å­˜å‚¨
        },
        memory: {
          provider: 'memory'
        }
      });

      // ğŸ†• å¯åŠ¨AceCore
      await this.engine.start();

      // ç»‘å®šäº‹ä»¶
      this.bindEvents();

      // éªŒè¯é…ç½®
      this.validateConfig();

      logger.info('âœ… Local AceCore initialized and started successfully');
    } catch (error: any) {
      logger.error(`âŒ Failed to initialize AceCore: ${error.message}`);
      this.engine = null;
    } finally {
      this.isInitializing = false;
    }
  }

  // ğŸ†• ä½¿ç”¨AceCoreæ›¿ä»£AceEngine
  getEngine(): AceCore | null {
    return this.engine;
  }

  // ğŸ†• é‡å†™evolveæ–¹æ³•ï¼Œä½¿ç”¨AceCore
  async evolve(trajectory: Trajectory): Promise<void> {
    if (!this.engine) {
      logger.warn('[AceService] AceCore not initialized, cannot evolve trajectory');
      return;
    }

    try {
      await this.engine.evolve(trajectory);
      logger.debug(`[AceService] Trajectory evolved for task: ${trajectory.task_id}`);
    } catch (error: any) {
      logger.error(`[AceService] Failed to evolve trajectory: ${error.message}`);
      throw error;
    }
  }

  // ğŸ†• é‡å†™updateSessionActivityæ–¹æ³•
  async updateSessionActivity(sessionId: string): Promise<void> {
    if (!this.engine) {
      logger.warn('[AceService] AceCore not initialized, cannot update session activity');
      return;
    }

    try {
      await this.engine.updateSessionActivity(sessionId);
      logger.debug(`[AceService] Session activity updated: ${sessionId}`);
    } catch (error: any) {
      logger.error(`[AceService] Failed to update session activity: ${error.message}`);
    }
  }
}
```

#### 2.2 ä¿æŒAPIå…¼å®¹æ€§

**ç¡®ä¿æ‰€æœ‰å…¬å…±æ–¹æ³•ä¿æŒä¸å˜**:
```typescript
// è¿™äº›æ–¹æ³•ä¿æŒä¸å˜ï¼Œä½†å†…éƒ¨ä½¿ç”¨AceCore
public static getInstance(): AceService { ... }
public isEnabled(): boolean { return !!this.engine; }
public getAgent(): AceCore | null { return this.getEngine(); }
```

#### 2.3 ç§»é™¤ç§æœ‰å±æ€§è®¿é—®

**åˆ é™¤å¯¹AceEngineç§æœ‰å±æ€§çš„è®¿é—®**:
```typescript
// âŒ åˆ é™¤è¿™äº›ä»£ç ï¼š
// const sqliteStorage = this.engine.storage.sqlite as any;
// if (sqliteStorage && sqliteStorage.db) {
//   sqliteStorage.db.prepare(`...`).run(trajectoryKey, trajectoryData);
// }

// âœ… æ›¿æ¢ä¸ºï¼š
await this.engine.evolve(trajectory);
```

---

### æ–¹æ¡ˆ3: è¿ç§»AceIntegrator

#### 3.1 ç§»é™¤AceServiceä¾èµ–

**ä¿®æ”¹ä½ç½®**: `src/services/AceIntegrator.ts`

**æ–°å®ç°**:
```typescript
import { AceService } from './AceService';
// âŒ ä¸å†ç›´æ¥ä¾èµ–AceServiceï¼Œæ”¹ç”¨AceCore
import { AceCore } from '../core/ace/AceCore';

export class AceIntegrator {
  // ğŸ†• ç›´æ¥ä½¿ç”¨AceCoreï¼ˆé€šè¿‡AceServiceè·å–ï¼‰
  constructor(private aceService: AceService) {}

  // ğŸ†• æ·»åŠ ç›´æ¥è®¿é—®AceCoreçš„æ–¹æ³•
  private getAceCore(): AceCore | null {
    return this.aceService.getEngine();
  }

  async saveTrajectory(params: TrajectoryParams): Promise<void> {
    // âœ… ä¿æŒç°æœ‰é€»è¾‘ï¼Œä½†å†…éƒ¨ä½¿ç”¨AceCore
    const aceCore = this.getAceCore();
    if (!aceCore) {
      logger.debug('[AceIntegrator] AceCore not initialized, skipping trajectory save');
      return;
    }

    const userQuery = params.messages.find(m => m.role === 'user')?.content || '';

    const trajectory: Trajectory = {
      task_id: params.requestId,
      session_id: params.sessionId,
      user_input: userQuery,
      steps: this.buildSteps(params),
      final_result: params.finalContent,
      outcome: params.finalContent ? 'SUCCESS' : 'FAILURE',
      environment_feedback: this.buildFeedback(params),
      used_rule_ids: [],
      timestamp: Date.now(),
      duration_ms: 0,
      evolution_status: 'PENDING'
    };

    try {
      // âœ… ä½¿ç”¨AceCoreçš„evolveæ–¹æ³•
      await aceCore.evolve(trajectory);
      logger.debug(`[AceIntegrator] Trajectory saved for task: ${params.requestId}`);
    } catch (error: any) {
      logger.error(`[AceIntegrator] Failed to save trajectory: ${error.message}`);
    }
  }

  async updateSessionActivity(sessionId?: string): Promise<void> {
    if (!sessionId) return;

    // âœ… ä½¿ç”¨AceCoreçš„updateSessionActivityæ–¹æ³•
    const aceCore = this.getAceCore();
    if (!aceCore) return;

    try {
      await aceCore.updateSessionActivity(sessionId);
      logger.debug(`[AceIntegrator] Session activity updated: ${sessionId}`);
    } catch (error: any) {
      logger.warn(`[AceIntegrator] Failed to update session activity: ${error.message}`);
    }
  }

  async publishWithSession(
    sessionId: string,
    content: string,
    layer: string = 'GLOBAL_STRATEGY'
  ): Promise<void> {
    // âœ… ä½¿ç”¨AceCoreçš„publishWithSessionæ–¹æ³•
    const aceCore = this.getAceCore();
    if (!aceCore) {
      logger.warn(`[AceIntegrator] AceCore not initialized, cannot publish message`);
      return;
    }

    try {
      await aceCore.publishWithSession(sessionId, content, layer);
      logger.debug(`[AceIntegrator] Published message to ACE (session: ${sessionId}, layer: ${layer})`);
    } catch (error: any) {
      logger.error(`[AceIntegrator] Failed to publish to ACE: ${error.message}`);
    }
  }
}
```

---

### æ–¹æ¡ˆ4: æ¸…ç†package.jsonä¾èµ–

#### 4.1 åˆ é™¤å¤–éƒ¨ä¾èµ–

**ä¿®æ”¹ä½ç½®**: `package.json`

**åˆ é™¤é¡¹**:
```json
{
  "dependencies": {
    // âŒ åˆ é™¤è¿™äº›ä¾èµ–ï¼š
    // "ace-engine-core": "^x.x.x",
    // "ace-engine-storage": "^x.x.x",
    // "ace-engine-memory": "^x.x.x"
  }
}
```

#### 4.2 æ›´æ–°ç±»å‹å®šä¹‰

**åˆ›å»ºæœ¬åœ°ç±»å‹å®šä¹‰**: `src/types/ace-core.d.ts`

```typescript
// æœ¬åœ°åŒ–çš„AceCoreç±»å‹å®šä¹‰ï¼ˆæ›¿ä»£ace-engine-coreï¼‰
export interface Trajectory {
  task_id: string;
  session_id?: string;
  user_input: string;
  steps: TrajectoryStep[];
  final_result: string;
  outcome: 'SUCCESS' | 'FAILURE';
  environment_feedback: string;
  used_rule_ids: string[];
  timestamp: number;
  duration_ms: number;
  evolution_status: 'PENDING' | 'COMPLETED' | 'FAILED';
}

export interface TrajectoryStep {
  thought: string;
  action: string;
  output: string;
}

export interface ReflectionTrigger {
  type: string;
  level: string;
  sessionId: string;
  traceId: string;
  timestamp: number;
  context?: any;
}

export interface ReflectionTriggerStats {
  count: number;
  lastTriggered: number;
  triggersByType: Map<string, number>;
}
```

---

## ğŸ“ å®æ–½æ­¥éª¤

### Step 1: åˆ›å»ºAceCoreæ ¸å¿ƒç±» (Day 1-2)

**ä»»åŠ¡æ¸…å•**:
- [ ] åˆ›å»º`src/core/ace/AceCore.ts`
- [ ] å®ç°ä¼šè¯ç®¡ç†ï¼ˆcreateSession, updateSessionActivityï¼‰
- [ ] å®ç°Scratchpadç®¡ç†ï¼ˆappend, get, clearï¼‰
- [ ] å®ç°åæ€è§¦å‘ï¼ˆtriggerReflection, runReflectionCycleï¼‰

**éªŒæ”¶æ ‡å‡†**:
- [ ] å•å…ƒæµ‹è¯•é€šè¿‡ï¼ˆæ‰€æœ‰æ–¹æ³•ï¼‰
- [ ] ä¼šè¯ç®¡ç†æ­£å¸¸
- [ ] Scratchpadæ“ä½œæ­£å¸¸
- [ ] åæ€å‘¨æœŸæ­£å¸¸

### Step 2: å®ç°è½¨è¿¹è¿›åŒ– (Day 3)

**ä»»åŠ¡æ¸…å•**:
- [ ] å®ç°evolveæ–¹æ³•ï¼ˆè½¨è¿¹ä¿å­˜ï¼‰
- [ ] å®ç°publishWithSessionæ–¹æ³•ï¼ˆæ¶ˆæ¯å‘å¸ƒï¼‰
- [ ] å®ç°æ¸…ç†æœºåˆ¶ï¼ˆcleanupExpiredSessionsï¼‰
- [ ] æµ‹è¯•è½¨è¿¹ä¿å­˜æµç¨‹

**éªŒæ”¶æ ‡å‡†**:
- [ ] è½¨è¿¹ä¿å­˜æ­£å¸¸
- [ ] æ¶ˆæ¯å‘å¸ƒæ­£å¸¸
- [ ] ä¼šè¯æ¸…ç†æ­£å¸¸

### Step 3: é‡æ„AceService (Day 4-5)

**ä»»åŠ¡æ¸…å•**:
- [ ] ä¿®æ”¹AceServiceï¼Œä½¿ç”¨AceCoreæ›¿ä»£AceEngine
- [ ] ç§»é™¤ace-engine-coreçš„import
- [ ] æ›´æ–°æ‰€æœ‰AceEngineè°ƒç”¨ä¸ºAceCoreè°ƒç”¨
- [ ] ä¿æŒAPIå…¼å®¹æ€§

**éªŒæ”¶æ ‡å‡†**:
- [ ] AceServiceåˆå§‹åŒ–æ­£å¸¸
- [ ] æ‰€æœ‰å…¬å…±æ–¹æ³•æ­£å¸¸å·¥ä½œ
- [ ] æ— AceEngineä¾èµ–

### Step 4: è¿ç§»AceIntegrator (Day 6-7)

**ä»»åŠ¡æ¸…å•**:
- [ ] ä¿®æ”¹AceIntegratorï¼Œä½¿ç”¨AceCore
- [ ] æ›´æ–°saveTrajectoryæ–¹æ³•
- [ ] æ›´æ–°updateSessionActivityæ–¹æ³•
- [ ] æ›´æ–°publishWithSessionæ–¹æ³•

**éªŒæ”¶æ ‡å‡†**:
- [ ] è½¨è¿¹ä¿å­˜æ­£å¸¸
- [ ] ä¼šè¯æ´»åŠ¨æ›´æ–°æ­£å¸¸
- [ ] æ¶ˆæ¯å‘å¸ƒæ­£å¸¸

### Step 5: æ›´æ–°ç±»å‹å®šä¹‰ (Day 8)

**ä»»åŠ¡æ¸…å•**:
- [ ] åˆ›å»ºæœ¬åœ°ç±»å‹å®šä¹‰æ–‡ä»¶
- [ ] ç§»é™¤ace-engine-coreç±»å‹ä¾èµ–
- [ ] æ›´æ–°æ‰€æœ‰importè·¯å¾„
- [ ] TypeScriptç¼–è¯‘é€šè¿‡

**éªŒæ”¶æ ‡å‡†**:
- [ ] ç±»å‹å®šä¹‰å®Œæ•´
- [ ] ç¼–è¯‘æ— é”™è¯¯
- [ ] IDEæç¤ºæ­£å¸¸

### Step 6: æ¸…ç†ä¾èµ– (Day 9)

**ä»»åŠ¡æ¸…å•**:
- [ ] ä»package.jsonåˆ é™¤ace-engine-coreä¾èµ–
- [ ] åˆ é™¤ç›¸å…³é…ç½®æ–‡ä»¶
- [ ] è¿è¡Œnpm installæ¸…ç†
- [ ] éªŒè¯é›¶å¤–éƒ¨ä¾èµ–

**éªŒæ”¶æ ‡å‡†**:
- [ ] package.jsonæ— ace-engine-coreå¼•ç”¨
- [ ] npm installæˆåŠŸ
- [ ] é¡¹ç›®å¯æ­£å¸¸å¯åŠ¨

### Step 7: å…¨é¢æµ‹è¯• (Day 10)

**æµ‹è¯•åœºæ™¯**:
- [ ] AceCoreåŠŸèƒ½æµ‹è¯•ï¼ˆä¼šè¯ã€Scratchpadã€åæ€ï¼‰
- [ ] AceServiceé›†æˆæµ‹è¯•
- [ ] AceIntegratoré›†æˆæµ‹è¯•
- [ ] P0-P3é˜¶æ®µåŠŸèƒ½å›å½’æµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•ï¼ˆæ— å¤–éƒ¨ä¾èµ–æ€§èƒ½æå‡ï¼‰

**éªŒè¯æ¸…å•**:
- [ ] æ‰€æœ‰ACEåŠŸèƒ½æ­£å¸¸å·¥ä½œ
- [ ] æ€§èƒ½æ— é€€åŒ–
- [ ] å†…å­˜ä½¿ç”¨æ­£å¸¸
- [ ] æ— å¤–éƒ¨ä¾èµ–

---

## ğŸ”§ å…³é”®ä»£ç ç¤ºä¾‹

### ç¤ºä¾‹1: å®Œæ•´çš„AceCore

```typescript
// src/core/ace/AceCore.ts
export class AceCore {
  private bus = {
    northbound: new EventEmitter(),
    southbound: new EventEmitter()
  };

  private scratchpads: Map<string, Map<string, string>> = new Map();
  private sessions: Map<string, any> = new Map();
  private scheduler: NodeJS.Timeout | null = null;
  private reflectionTriggers: Map<string, ReflectionTrigger> = new Map();

  constructor(private config: AceCoreConfig) {}

  async start(): Promise<void> {
    if (this.scheduler) return;

    const interval = this.config.reflectionCycleInterval || 60000;

    this.scheduler = setInterval(() => {
      this.runReflectionCycle();
    }, interval);

    logger.info(`[AceCore] Scheduler started with interval: ${interval}ms`);
  }

  async stop(): Promise<void> {
    if (this.scheduler) {
      clearInterval(this.scheduler);
      this.scheduler = null;
      logger.info('[AceCore] Scheduler stopped');
    }
  }

  async createSession(config: { userId: string; metadata: any }): Promise<string> {
    const sessionId = crypto.randomUUID();
    this.sessions.set(sessionId, {
      ...config,
      createdAt: Date.now(),
      lastActivity: Date.now()
    });

    this.bus.northbound.emit('SESSION_CREATED', {
      data: { sessionId, config, timestamp: Date.now() }
    });

    logger.info(`[AceCore] Created session: ${sessionId}`);
    return sessionId;
  }

  async updateSessionActivity(sessionId: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.lastActivity = Date.now();

      this.bus.northbound.emit('SESSION_ACTIVITY', {
        data: { sessionId, timestamp: Date.now() }
      });

      logger.debug(`[AceCore] Updated session activity: ${sessionId}`);
    }
  }

  async appendToScratchpad(sessionId: string, layerId: string, content: string): Promise<void> {
    if (!this.scratchpads.has(sessionId)) {
      this.scratchpads.set(sessionId, new Map());
    }

    const layerScratchpad = this.scratchpads.get(sessionId)!;
    const existing = layerScratchpad.get(layerId) || '';
    layerScratchpad.set(layerId, existing + '\n' + content);

    logger.debug(`[AceCore] Appended to scratchpad: ${layerId}`);
  }

  async getScratchpad(sessionId: string, layerId: string): Promise<string> {
    return this.scratchpads.get(sessionId)?.get(layerId) || '';
  }

  async clearScratchpad(sessionId: string, layerId: string): Promise<void> {
    this.scratchpads.get(sessionId)?.delete(layerId);
    logger.debug(`[AceCore] Cleared scratchpad: ${layerId}`);
  }

  async evolve(trajectory: Trajectory): Promise<void> {
    try {
      this.bus.northbound.emit('TRAJECTORY_SAVED', {
        data: {
          taskId: trajectory.task_id,
          sessionId: trajectory.session_id,
          timestamp: trajectory.timestamp
        }
      });

      logger.debug(`[AceCore] Trajectory saved for evolution: ${trajectory.task_id}`);
    } catch (error) {
      logger.error(`[AceCore] Failed to save trajectory: ${error}`);
      throw error;
    }
  }

  async publishWithSession(
    sessionId: string,
    content: string,
    layer: string
  ): Promise<void> {
    try {
      const message = {
        sessionId,
        content,
        layer,
        timestamp: Date.now()
      };

      this.bus.southbound.emit('MESSAGE', { data: message });

      logger.debug(`[AceCore] Published message to ${layer} for session: ${sessionId}`);
    } catch (error) {
      logger.error(`[AceCore] Failed to publish message: ${error}`);
      throw error;
    }
  }

  async triggerReflection(trigger: ReflectionTrigger): Promise<void> {
    this.reflectionTriggers.set(trigger.traceId, trigger);

    this.bus.northbound.emit(trigger.level as string, {
      data: { trigger }
    });

    logger.info(`[AceCore] Reflection triggered: ${trigger.type} at level ${trigger.level}`, {
      sessionId: trigger.sessionId,
      traceId: trigger.traceId
    });
  }

  private async runReflectionCycle(): Promise<void> {
    try {
      logger.debug('[AceCore] Running scheduled reflection cycle');

      await this.cleanupExpiredSessions();

      const reflectionTrigger: ReflectionTrigger = {
        type: 'PERIODIC_REFLECTION',
        level: 'GLOBAL_STRATEGY',
        sessionId: 'system',
        traceId: crypto.randomUUID(),
        timestamp: Date.now(),
        context: 'Periodic reflection cycle'
      };

      await this.triggerReflection(reflectionTrigger);

      logger.debug('[AceCore] Reflection cycle completed');
    } catch (error) {
      logger.error('[AceCore] Reflection cycle failed:', error);
    }
  }

  private async cleanupExpiredSessions(): Promise<void> {
    const now = Date.now();
    const maxAge = this.config.maxSessionAge || (24 * 60 * 60 * 1000);

    for (const [sessionId, session] of this.sessions.entries()) {
      if (now - session.lastActivity > maxAge) {
        this.sessions.delete(sessionId);
        this.scratchpads.delete(sessionId);
        logger.info(`[AceCore] Cleaned up expired session: ${sessionId}`);
      }
    }
  }
}
```

### ç¤ºä¾‹2: é‡æ„åçš„AceService

```typescript
// src/services/AceService.ts çš„å…³é”®ä¿®æ”¹
export class AceService {
  private engine: AceCore | null = null; // ğŸ†• ä½¿ç”¨AceCoreæ›¿ä»£AceEngine

  async initialize(): Promise<void> {
    if (this.engine || this.isInitializing) return;

    this.isInitializing = true;
    logger.info('ğŸš€ Initializing local AceCore...');

    try {
      // ğŸ†• åˆ›å»ºæœ¬åœ°åŒ–AceCoreå®ä¾‹
      this.engine = new AceCore({
        agentId: 'apex-bridge-001',
        reflectionCycleInterval: 60000,
        maxSessionAge: 24 * 60 * 60 * 1000,
        storage: {
          mode: 'memory'
        },
        memory: {
          provider: 'memory'
        }
      });

      // ğŸ†• å¯åŠ¨AceCore
      await this.engine.start();

      // ç»‘å®šäº‹ä»¶
      this.bindEvents();

      // éªŒè¯é…ç½®
      this.validateConfig();

      logger.info('âœ… Local AceCore initialized and started successfully');
    } catch (error: any) {
      logger.error(`âŒ Failed to initialize AceCore: ${error.message}`);
      this.engine = null;
    } finally {
      this.isInitializing = false;
    }
  }

  // ğŸ†• ä½¿ç”¨AceCoreæ›¿ä»£AceEngine
  getEngine(): AceCore | null {
    return this.engine;
  }

  // ğŸ†• é‡å†™evolveæ–¹æ³•
  async evolve(trajectory: Trajectory): Promise<void> {
    if (!this.engine) {
      logger.warn('[AceService] AceCore not initialized, cannot evolve trajectory');
      return;
    }

    try {
      await this.engine.evolve(trajectory);
      logger.debug(`[AceService] Trajectory evolved for task: ${trajectory.task_id}`);
    } catch (error: any) {
      logger.error(`[AceService] Failed to evolve trajectory: ${error.message}`);
      throw error;
    }
  }

  // ğŸ†• é‡å†™updateSessionActivityæ–¹æ³•
  async updateSessionActivity(sessionId: string): Promise<void> {
    if (!this.engine) {
      logger.warn('[AceService] AceCore not initialized, cannot update session activity');
      return;
    }

    try {
      await this.engine.updateSessionActivity(sessionId);
      logger.debug(`[AceService] Session activity updated: ${sessionId}`);
    } catch (error: any) {
      logger.error(`[AceService] Failed to update session activity: ${error.message}`);
    }
  }
}
```

---

## ğŸ“Š æ€§èƒ½ä¸èµ„æºåˆ†æ

### æ€§èƒ½æå‡

**æ— å¤–éƒ¨ä¾èµ–çš„ä¼˜åŠ¿**:
- âœ… å¯åŠ¨æ—¶é—´å‡å°‘: ~2ç§’ (æ— éœ€åŠ è½½å¤–éƒ¨SDK)
- âœ… å†…å­˜ä½¿ç”¨å‡å°‘: ~50MB (æ— éœ€å¤–éƒ¨ä¾èµ–)
- âœ… ç½‘ç»œI/Oå‡å°‘: ~0 (æ— éœ€è¿œç¨‹è°ƒç”¨)
- âœ… å“åº”å»¶è¿Ÿå‡å°‘: ~10-50ms (æ— ç½‘ç»œå¼€é”€)

### æœ¬åœ°å­˜å‚¨æ€§èƒ½

**å†…å­˜å­˜å‚¨ vs å¤–éƒ¨å­˜å‚¨**:
```typescript
// å†…å­˜å­˜å‚¨ (AceCore)
sessionMemory = Map<string, any>  // O(1) è¯»å†™
scratchpadMemory = Map<string, Map<string, string>>  // O(1) è¯»å†™

// æ€§èƒ½å¯¹æ¯”
å†…å­˜å­˜å‚¨: < 1ms
SQLiteå­˜å‚¨: 5-10ms
å¤–éƒ¨APIè°ƒç”¨: 50-200ms
```

### èµ„æºå ç”¨

**èµ„æºä½¿ç”¨å¯¹æ¯”**:
```
æ”¹é€ å‰ (å¸¦ace-engine-core):
- å¯åŠ¨æ—¶é—´: ~5ç§’
- å†…å­˜å ç”¨: ~150MB
- ç£ç›˜å ç”¨: ~100MB (å¤–éƒ¨SDK)
- ç½‘ç»œä¾èµ–: æœ‰

æ”¹é€ å (çº¯æœ¬åœ°):
- å¯åŠ¨æ—¶é—´: ~3ç§’ âœ…
- å†…å­˜å ç”¨: ~100MB âœ…
- ç£ç›˜å ç”¨: ~0MB âœ…
- ç½‘ç»œä¾èµ–: æ—  âœ…
```

---

## âš ï¸ é£é™©ä¸ç¼“è§£

### é£é™©1: åŠŸèƒ½ç¼ºå¤±
**åŸå› **: æœ¬åœ°å®ç°å¯èƒ½é—æ¼ace-engine-coreçš„æŸäº›åŠŸèƒ½
**ç¼“è§£**:
- âœ… å…¨é¢åˆ†æace-engine-coreçš„æ‰€æœ‰åŠŸèƒ½
- âœ… åˆ›å»ºå®Œæ•´çš„æµ‹è¯•å¥—ä»¶
- âœ… é€æ­¥è¿ç§»ï¼Œé€æ­¥éªŒè¯

### é£é™©2: æ€§èƒ½é€€åŒ–
**åŸå› **: æœ¬åœ°å®ç°å¯èƒ½æ€§èƒ½ä¸å¦‚å¤–éƒ¨SDK
**ç¼“è§£**:
- âœ… ä½¿ç”¨é«˜æ•ˆçš„å†…å­˜æ•°æ®ç»“æ„
- âœ… é¿å…ä¸å¿…è¦çš„å¤åˆ¶å’Œåºåˆ—åŒ–
- âœ… æ€§èƒ½åŸºå‡†æµ‹è¯•

### é£é™©3: å…¼å®¹æ€§é—®é¢˜
**åŸå› **: APIæ¥å£å˜æ›´å¯èƒ½å½±å“ç°æœ‰ä»£ç 
**ç¼“è§£**:
- âœ… ä¿æŒæ‰€æœ‰å…¬å…±æ¥å£ä¸å˜
- âœ… é€æ­¥æ›¿æ¢å†…éƒ¨å®ç°
- âœ… å…¨é¢å›å½’æµ‹è¯•

### é£é™©4: è°ƒè¯•å›°éš¾
**åŸå› **: å¤±å»å¤–éƒ¨SDKçš„è°ƒè¯•å·¥å…·
**ç¼“è§£**:
- âœ… å¢å¼ºæœ¬åœ°æ—¥å¿—è®°å½•
- âœ… æä¾›è°ƒè¯•æ¨¡å¼
- âœ… åˆ›å»ºæœ¬åœ°è°ƒè¯•å·¥å…·

---

## âœ… éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶
- [ ] AceCoreæ‰€æœ‰åŠŸèƒ½æ­£å¸¸ï¼ˆä¼šè¯ã€Scratchpadã€åæ€ï¼‰
- [ ] AceService APIå®Œå…¨å…¼å®¹
- [ ] AceIntegratoråŠŸèƒ½æ­£å¸¸
- [ ] P0-P3é˜¶æ®µæ‰€æœ‰åŠŸèƒ½æ­£å¸¸
- [ ] è½¨è¿¹ä¿å­˜å’ŒåŠ è½½æ­£å¸¸

### æ€§èƒ½éªŒæ”¶
- [ ] å¯åŠ¨æ—¶é—´ < 3ç§’
- [ ] å†…å­˜å ç”¨ < 100MB
- [ ] å“åº”å»¶è¿Ÿ < 100ms
- [ ] æ— æ€§èƒ½é€€åŒ–

### ä¾èµ–éªŒæ”¶
- [ ] package.jsonæ— ace-engine-coreå¼•ç”¨
- [ ] TypeScriptç¼–è¯‘æ— å¤–éƒ¨ä¾èµ–é”™è¯¯
- [ ] é¡¹ç›®å¯ç‹¬ç«‹è¿è¡Œ
- [ ] æ— ç½‘ç»œä¾èµ–

### å…¼å®¹æ€§éªŒæ”¶
- [ ] ç°æœ‰API 100%å…¼å®¹
- [ ] ç°æœ‰æµ‹è¯•å…¨éƒ¨é€šè¿‡
- [ ] å‘åå…¼å®¹æ€§100%

---

## ğŸ”— ä¾èµ–å…³ç³»

### æ— ä¸Šæ¸¸ä¾èµ–
- âœ… P0-P3é˜¶æ®µå·²å®Œæˆ
- âœ… æ‰€æœ‰åŠŸèƒ½æœ¬åœ°åŒ–å®ç°

### æ— ä¸‹æ¸¸ä¾èµ–
- âœ… å®Œå…¨è‡ªåŒ…å«
- âœ… æ— å¤–éƒ¨ä¾èµ–

---

## ğŸ“š å‚è€ƒå®ç°

### ç›¸å…³æ–‡ä»¶
- `src/core/ace/AceCore.ts` - æ–°å»º
- `src/services/AceService.ts` - ä¿®æ”¹
- `src/services/AceIntegrator.ts` - ä¿®æ”¹
- `src/types/ace-core.d.ts` - æ–°å»º
- `package.json` - ä¿®æ”¹

### æµ‹è¯•æ–‡ä»¶
- `tests/unit/core/ace/AceCore.test.ts`
- `tests/integration/ace-local-implementation.test.ts`

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025-12-12
**ä½œè€…**: Claude Code
**å®¡æ ¸**: å¾…å®¡æ ¸
