# P1é˜¶æ®µè¯¦ç»†è®¾è®¡ï¼šæ¿€æ´»L4å±‚ï¼ˆæ‰§è¡ŒåŠŸèƒ½å±‚ï¼‰

## ğŸ“‹ é˜¶æ®µæ¦‚è¿°

**ç›®æ ‡**: å°†ChatServiceçš„å¤šè½®å¯¹è¯ç®¡ç†æå‡åˆ°L4ï¼Œå®ç°ä»»åŠ¡æ‹†è§£å’Œæµç¨‹æ§åˆ¶ï¼Œæ”¯æŒå¤æ‚ä»»åŠ¡çš„DAGç®¡ç†ã€‚

**æ ¸å¿ƒä»·å€¼**:
- æ”¯æŒ"å†™ä¸€ä¸ªå®Œæ•´çš„Webåº”ç”¨"ç­‰å¤æ‚éœ€æ±‚
- å®ç°ä»»åŠ¡è‡ªåŠ¨æ‹†è§£å’ŒDAGæ‰§è¡Œ
- å»ºç«‹å±‚çº§é—´çš„ä»»åŠ¡æµè½¬æœºåˆ¶

**é¢„è®¡å·¥æœŸ**: 1å‘¨ï¼ˆ5ä¸ªå·¥ä½œæ—¥ï¼‰

**å‰ç½®ä¾èµ–**: âœ… P0é˜¶æ®µå®Œæˆï¼ˆL5/L6å±‚å·²æ¿€æ´»ï¼‰

---

## ğŸ¯ é˜¶æ®µç›®æ ‡

### ä¸»è¦ç›®æ ‡
1. âœ… **å®ç°AceStrategyOrchestrator**ï¼ˆL4æ‰§è¡ŒåŠŸèƒ½å±‚ï¼‰
   - ä»»åŠ¡æ‹†è§£ï¼šå°†ç”¨æˆ·è¯·æ±‚åˆ†è§£ä¸ºå­ä»»åŠ¡DAG
   - ä»»åŠ¡ç¼–æ’ï¼šæŒ‰ä¾èµ–å…³ç³»é¡ºåºæ‰§è¡Œ
   - ä»»åŠ¡ç›‘æ§ï¼šè·Ÿè¸ªä»»åŠ¡çŠ¶æ€å’Œè¿›åº¦

2. âœ… **é›†æˆChatService**
   - æ”¯æŒACEç¼–æ’æ¨¡å¼
   - ä¿æŒå‘åå…¼å®¹ï¼ˆåŸæœ‰ç­–ç•¥é€‰æ‹©é€»è¾‘ï¼‰

3. âœ… **ä»»åŠ¡æµè½¬æœºåˆ¶**
   - L4 â†’ L5ï¼šä¸‹å‘å•ä¸€ä»»åŠ¡
   - L5 â†’ L4ï¼šä»»åŠ¡å®Œæˆä¸ŠæŠ¥
   - L4 â†’ L3ï¼šèƒ½åŠ›éœ€æ±‚æŸ¥è¯¢

4. âœ… **å¤ç”¨é¡¹ç›®ç°æœ‰ç»„ä»¶**
   - LLMManagerï¼šç”¨äºä»»åŠ¡æ‹†è§£åˆ†æ
   - SessionManagerï¼šç”¨äºä»»åŠ¡çŠ¶æ€ç®¡ç†
   - ChatStrategyï¼šç”¨äºå­ä»»åŠ¡æ‰§è¡Œ

---

## ğŸ” å½“å‰é¡¹ç›®é€»è¾‘åˆ†æ

### 1. ChatServiceç°çŠ¶åˆ†æ

**ä½ç½®**: `src/services/ChatService.ts`

**å½“å‰ç­–ç•¥é€‰æ‹©é€»è¾‘**:
```typescript
// ç®€åŒ–æµç¨‹
selectStrategy(options) {
  if (options.selfThinking?.enabled) {
    return this.strategies.find(s => s.getName() === 'ReActStrategy');
  }
  return this.strategies.find(s => s.getName() === 'SingleRoundStrategy');
}

chat(messages, options) {
  const strategy = this.selectStrategy(options);
  return strategy.execute(messages, options);
}
```

**é—®é¢˜è¯†åˆ«**:
- âŒ ç¼ºå°‘å¤æ‚ä»»åŠ¡æ‹†è§£èƒ½åŠ›
- âŒ æ²¡æœ‰ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†
- âŒ ç¼ºå°‘å±‚çº§é—´ä»»åŠ¡æµè½¬

### 2. LLMManagerä»»åŠ¡åˆ†æèƒ½åŠ›

**ä½ç½®**: `src/core/LLMManager.ts`

**ç°æœ‰èƒ½åŠ›**:
- âœ… æ”¯æŒèŠå¤©è¡¥å…¨ï¼ˆchatæ–¹æ³•ï¼‰
- âœ… æ”¯æŒæµå¼è¾“å‡ºï¼ˆstreamChatæ–¹æ³•ï¼‰
- âœ… æ”¯æŒå¤šæ¨¡å‹ç±»å‹ï¼ˆNLP, Embedding, Rerankï¼‰
- âœ… SQLiteé…ç½®ç®¡ç†

**ç”¨äºä»»åŠ¡æ‹†è§£çš„ä¼˜åŠ¿**:
- âœ… å¯ä»¥åˆ†æç”¨æˆ·æ„å›¾
- âœ… å¯ä»¥ç”Ÿæˆç»“æ„åŒ–è¾“å‡º
- âœ… å¯ä»¥é€’å½’åˆ†è§£ä»»åŠ¡

### 3. SessionManagerç°çŠ¶

**ä½ç½®**: `src/services/SessionManager.ts`ï¼ˆæ¨æµ‹å­˜åœ¨ï¼‰

**é¢„æœŸåŠŸèƒ½**:
- ä¼šè¯ç”Ÿå‘½å‘¨æœŸç®¡ç†
- æ¶ˆæ¯å†å²å­˜å‚¨
- å…ƒæ•°æ®ç®¡ç†

**ç”¨äºL4çš„ä¼˜åŠ¿**:
- âœ… å¯ä»¥å­˜å‚¨ä»»åŠ¡é˜Ÿåˆ—
- âœ… å¯ä»¥è·Ÿè¸ªä»»åŠ¡çŠ¶æ€
- âœ… å¯ä»¥ç®¡ç†ä¼šè¯ä¸Šä¸‹æ–‡

---

## ğŸ—ï¸ è¯¦ç»†è®¾è®¡æ–¹æ¡ˆ

### æ–¹æ¡ˆ1: åˆ›å»ºAceStrategyOrchestrator

#### 1.1 æ ¸å¿ƒæ¶æ„è®¾è®¡

**æ–‡ä»¶ä½ç½®**: `src/strategies/AceStrategyOrchestrator.ts`

**è®¾è®¡æ€è·¯**:
```typescript
/**
 * ACEç­–ç•¥ç¼–æ’å™¨
 * å°†ChatServiceçš„ç­–ç•¥é€‰æ‹©é€»è¾‘æå‡åˆ°L4ï¼ˆæ‰§è¡ŒåŠŸèƒ½å±‚ï¼‰
 */
export class AceStrategyOrchestrator {
  // ä¾èµ–æ³¨å…¥
  constructor(
    private aceIntegrator: AceIntegrator,    // ACEé›†æˆ
    private strategies: ChatStrategy[],      // ç­–ç•¥åˆ—è¡¨
    private llmManager: LLMManager,          // LLMç®¡ç†
    private sessionManager: SessionManager   // ä¼šè¯ç®¡ç†
  ) {}

  // æ ¸å¿ƒç¼–æ’æ–¹æ³•
  async orchestrate(
    messages: Message[],
    options: ChatOptions
  ): Promise<ChatResult>
}
```

#### 1.2 ä»»åŠ¡æ‹†è§£å®ç°

**æ ¸å¿ƒæ–¹æ³•**: decomposeToTasks
```typescript
private async decomposeToTasks(
  messages: Message[],
  sessionId: string
): Promise<Task[]> {
  // ä½¿ç”¨é¡¹ç›®ç°æœ‰çš„LLMManageråˆ†æç”¨æˆ·æ„å›¾
  const prompt = this.buildDecompositionPrompt(messages);

  try {
    const response = await this.llmManager.chat([
      {
        role: 'system',
        content: `You are a task decomposition expert. Analyze the user request and break it down into a DAG of subtasks.`
      },
      {
        role: 'user',
        content: prompt
      }
    ], { stream: false });

    const decomposition = response.choices[0]?.message?.content || '[]';
    return this.parseTaskQueue(decomposition);
  } catch (error) {
    logger.error('[AceStrategyOrchestrator] Task decomposition failed:', error);
    // é™çº§ä¸ºå•ä»»åŠ¡
    return this.createFallbackTask(messages);
  }
}
```

**ä»»åŠ¡æ ¼å¼å®šä¹‰**:
```typescript
interface Task {
  id: string;                    // ä»»åŠ¡å”¯ä¸€ID
  description: string;           // ä»»åŠ¡æè¿°
  dependencies: string[];        // ä¾èµ–çš„ä»»åŠ¡IDåˆ—è¡¨
  messages: Message[];           // ä»»åŠ¡ç›¸å…³çš„æ¶ˆæ¯
  options: ChatOptions;          // ä»»åŠ¡æ‰§è¡Œé€‰é¡¹
  requiresToolCall: boolean;     // æ˜¯å¦éœ€è¦å·¥å…·è°ƒç”¨
  status: 'pending' | 'running' | 'completed' | 'failed'; // ä»»åŠ¡çŠ¶æ€
  result?: any;                  // ä»»åŠ¡æ‰§è¡Œç»“æœ
  createdAt: number;             // åˆ›å»ºæ—¶é—´
  startedAt?: number;            // å¼€å§‹æ—¶é—´
  completedAt?: number;          // å®Œæˆæ—¶é—´
}
```

**æ‹†è§£æç¤ºè¯æ¨¡æ¿**:
```typescript
private buildDecompositionPrompt(messages: Message[]): string {
  const userQuery = messages[messages.length - 1]?.content || '';

  return `
ç”¨æˆ·è¯·æ±‚ï¼š${userQuery}

è¯·å°†æ­¤ä»»åŠ¡åˆ†è§£ä¸ºå¤šä¸ªå­ä»»åŠ¡ã€‚è¿”å›JSONæ ¼å¼ï¼š

{
  "tasks": [
    {
      "id": "task_1",
      "description": "ä»»åŠ¡æè¿°",
      "dependencies": [], // ä¾èµ–çš„ä»»åŠ¡ID
      "requiresToolCall": true/false
    }
  ],
  "reasoning": "ä¸ºä»€ä¹ˆè¿™æ ·åˆ†è§£"
}

çº¦æŸæ¡ä»¶ï¼š
1. æ¯ä¸ªä»»åŠ¡åº”è¯¥æ˜¯åŸå­æ€§çš„ï¼Œä¸å¯å†åˆ†
2. æŒ‰ç…§ä¾èµ–å…³ç³»æ’åºï¼Œæ— ä¾èµ–çš„ä»»åŠ¡æ’åœ¨å‰é¢
3. å¦‚æœä¸éœ€è¦å·¥å…·è°ƒç”¨ï¼Œè®¾ç½®requiresToolCallä¸ºfalse
4. ä»»åŠ¡æè¿°è¦æ¸…æ™°ã€å…·ä½“
5. å¦‚æœæ˜¯ç®€å•ä»»åŠ¡ï¼Œè¿”å›ç©ºæ•°ç»„ï¼Œä½¿ç”¨å•ä¸€ç­–ç•¥æ‰§è¡Œ
`;
}
```

#### 1.3 ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†

**æ•°æ®ç»“æ„**: ä½¿ç”¨Mapå­˜å‚¨ä»»åŠ¡é˜Ÿåˆ—
```typescript
export class AceStrategyOrchestrator {
  private taskQueues: Map<string, Task[]> = new Map();
  private taskStatus: Map<string, TaskStatus> = new Map();

  async orchestrate(messages: Message[], options: ChatOptions): Promise<ChatResult> {
    const sessionId = options.sessionId || this.generateSessionId();

    // L4åˆ†æï¼šå°†ç”¨æˆ·è¯·æ±‚æ‹†è§£ä¸ºä»»åŠ¡é˜Ÿåˆ—
    const taskQueue = await this.decomposeToTasks(messages, sessionId);

    // ç®€å•ä»»åŠ¡ï¼šç›´æ¥æ‰§è¡Œ
    if (taskQueue.length <= 1) {
      return this.executeSimpleTask(messages, options);
    }

    // å¤æ‚ä»»åŠ¡ï¼šDAGæ‰§è¡Œ
    return this.executeTaskDAG(taskQueue, sessionId, options);
  }
}
```

**DAGæ‰§è¡Œé€»è¾‘**:
```typescript
private async executeTaskDAG(
  taskQueue: Task[],
  sessionId: string,
  options: ChatOptions
): Promise<ChatResult> {
  const results: any[] = = [];
  const completedTasks = new Set<string>();

  // æ‹“æ‰‘æ’åºï¼šç¡®å®šæ‰§è¡Œé¡ºåº
  const executionOrder = this.topologicalSort(taskQueue);

  // æŒ‰é¡ºåºæ‰§è¡Œä»»åŠ¡
  for (const taskId of executionOrder) {
    const task = taskQueue.find(t => t.id === taskId)!;

    try {
      // æ£€æŸ¥ä¾èµ–æ˜¯å¦å®Œæˆ
      if (!this.areDependenciesMet(task, completedTasks)) {
        throw new Error(`Task ${taskId} dependencies not met`);
      }

      // æ›´æ–°ä»»åŠ¡çŠ¶æ€
      await this.updateTaskStatus(taskId, 'running');

      // L4 â†’ L5ï¼šä¸‹å‘å•ä¸€ä»»åŠ¡
      await this.aceIntegrator.sendToLayer('COGNITIVE_CONTROL', {
        type: 'TASK',
        content: task.description,
        metadata: {
          taskId: task.id,
          dependencies: task.dependencies
        }
      });

      // ä½¿ç”¨é¡¹ç›®ç°æœ‰çš„ç­–ç•¥é€‰æ‹©æœºåˆ¶
      const strategy = this.selectStrategyForTask(task);
      const result = await strategy.execute(task.messages, {
        ...task.options,
        sessionId,
        requestId: task.id
      });

      results.push(result);

      // L5 â†’ L4ï¼šä»»åŠ¡å®Œæˆä¸ŠæŠ¥
      await this.aceIntegrator.completeTask(sessionId, {
        summary: `Task ${task.id} completed`,
        outcome: 'success'
      });

      // æ›´æ–°ä»»åŠ¡çŠ¶æ€
      await this.updateTaskStatus(taskId, 'completed', result);
      completedTasks.add(taskId);

      logger.info(`[AceStrategyOrchestrator] Task completed: ${taskId}`);

    } catch (error) {
      logger.error(`[AceStrategyOrchestrator] Task failed: ${taskId}`, error);

      await this.updateTaskStatus(taskId, 'failed', { error: error.message });
      results.push({
        content: `Task ${taskId} failed: ${error.message}`,
        iterations: 0
      });

      // ç»§ç»­æ‰§è¡Œå…¶ä»–ä»»åŠ¡ï¼ˆå¯é€‰ï¼šä¹Ÿå¯ä»¥åœæ­¢ï¼‰
    }
  }

  return this.mergeResults(results);
}
```

**æ‹“æ‰‘æ’åºç®—æ³•**:
```typescript
private topologicalSort(tasks: Task[]): string[] {
  const inDegree = new Map<string, number>();
  const graph = new Map<string, string[]>();

  // åˆå§‹åŒ–
  tasks.forEach(task => {
    inDegree.set(task.id, task.dependencies.length);
    graph.set(task.id, []);
  });

  // æ„å»ºå›¾
  tasks.forEach(task => {
    task.dependencies.forEach(dep => {
      if (graph.has(dep)) {
        graph.get(dep)!.push(task.id);
      }
    });
  });

  // Kahnç®—æ³•
  const queue: string[] = [];
  inDegree.forEach((degree, taskId) => {
    if (degree === 0) {
      queue.push(taskId);
    }
  });

  const result: string[] = [];

  while (queue.length > 0) {
    const current = queue.shift()!;
    result.push(current);

    graph.get(current)!.forEach(neighbor => {
      const newDegree = inDegree.get(neighbor)! - 1;
      inDegree.set(neighbor, newDegree);
      if (newDegree === 0) {
        queue.push(neighbor);
      }
    });
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰ç¯
  if (result.length !== tasks.length) {
    throw new Error('Task dependency cycle detected');
  }

  return result;
}
```

#### 1.4 ç­–ç•¥é€‰æ‹©æœºåˆ¶

**å¤ç”¨é¡¹ç›®ç°æœ‰çš„supportsæœºåˆ¶**:
```typescript
private selectStrategyForTask(task: Task): ChatStrategy {
  // âœ… ä½¿ç”¨ç­–ç•¥çš„ supports æ–¹æ³•è¿›è¡ŒåŒ¹é…
  for (const strategy of this.strategies) {
    if (strategy.supports(task.options)) {
      return strategy;
    }
  }

  // é»˜è®¤è¿”å›ReActç­–ç•¥
  return this.strategies.find(s => s.getName() === 'ReActStrategy') || this.strategies[0];
}
```

**ä»»åŠ¡é€‰é¡¹ç”Ÿæˆ**:
```typescript
private buildTaskOptions(originalOptions: ChatOptions, task: Task): ChatOptions {
  return {
    ...originalOptions,
    // ç¡®ä¿ACEåŠŸèƒ½å¼€å¯
    selfThinking: {
      enabled: task.requiresToolCall,
      includeThoughtsInResponse: false, // ç¼–æ’æ¨¡å¼ä¸‹ä¸è¾“å‡ºæ€è€ƒè¿‡ç¨‹
      maxIterations: 10,
      enableStreamThoughts: true,
      enableToolActionParsing: true
    },
    // æ·»åŠ ä»»åŠ¡ä¸Šä¸‹æ–‡
    taskContext: {
      taskId: task.id,
      taskDescription: task.description,
      parentTask: originalOptions.taskContext?.taskId
    }
  };
}
```

---

### æ–¹æ¡ˆ2: ChatServiceé›†æˆ

#### 2.1 æ·»åŠ ACEç¼–æ’æ”¯æŒ

**ä¿®æ”¹ä½ç½®**: `src/services/ChatService.ts`

**æ–°å¢åˆ¤æ–­é€»è¾‘**:
```typescript
export class ChatService {
  private aceOrchestrator: AceStrategyOrchestrator;

  constructor(...) {
    // ... ç°æœ‰ä»£ç  ...

    // ğŸ†• åˆå§‹åŒ–ACEç¼–æ’å™¨
    this.aceOrchestrator = new AceStrategyOrchestrator(
      this.aceIntegrator,
      this.strategies,
      this.llmManager,
      this.sessionManager
    );
  }

  async chat(messages: Message[], options: ChatOptions): Promise<ChatResult> {
    // ğŸ†• åˆ¤æ–­æ˜¯å¦å¯ç”¨ACEç¼–æ’
    if (this.shouldUseACEOrchestration(messages, options)) {
      logger.info('[ChatService] Using ACE orchestration for complex task');
      return this.aceOrchestrator.orchestrate(messages, options);
    }

    // âœ… åŸæœ‰é€»è¾‘ï¼šç›´æ¥ç­–ç•¥é€‰æ‹©ï¼ˆä¿æŒå…¼å®¹æ€§ï¼‰
    const strategy = this.selectStrategy(options);
    return strategy.execute(messages, options);
  }

  // ğŸ†• åˆ¤æ–­æ˜¯å¦ä½¿ç”¨ACEç¼–æ’
  private shouldUseACEOrchestration(
    messages: Message[],
    options: ChatOptions
  ): boolean {
    // æ˜¾å¼å¯ç”¨
    if (options.aceOrchestration?.enabled) {
      return true;
    }

    // è‡ªåŠ¨æ£€æµ‹å¤æ‚ä»»åŠ¡
    const userQuery = messages[messages.length - 1]?.content || '';
    const complexityScore = this.estimateTaskComplexity(userQuery);

    // å¤æ‚åº¦è¶…è¿‡é˜ˆå€¼åˆ™ä½¿ç”¨ACEç¼–æ’
    return complexityScore >= 0.7;
  }

  // ğŸ†• ä»»åŠ¡å¤æ‚åº¦è¯„ä¼°
  private estimateTaskComplexity(query: string): number {
    // ç®€å•å¯å‘å¼è¯„ä¼°
    let score = 0;

    // å…³é”®è¯æ£€æµ‹
    const complexKeywords = [
      'é¡¹ç›®', 'ç³»ç»Ÿ', 'åº”ç”¨', 'ç½‘ç«™', 'å¹³å°',
      'å¼€å‘', 'æ„å»º', 'å®ç°', 'è®¾è®¡',
      'å®Œæ•´', 'å…¨é¢', 'ç»¼åˆ'
    ];

    complexKeywords.forEach(keyword => {
      if (query.includes(keyword)) {
        score += 0.2;
      }
    });

    // é•¿åº¦æ£€æµ‹
    if (query.length > 50) {
      score += 0.2;
    }

    // å¤šæ­¥éª¤æ£€æµ‹
    if (query.includes('é¦–å…ˆ') || query.includes('ç„¶å') || query.includes('æœ€å')) {
      score += 0.3;
    }

    return Math.min(score, 1.0);
  }
}
```

#### 2.2 ä»»åŠ¡ä¸Šä¸‹æ–‡ä¼ é€’

**ä¿®æ”¹ç­–ç•¥åŸºç±»**: å¯èƒ½éœ€è¦æ‰©å±•ChatStrategyæ¥å£

**æ–°å¢æ¥å£**:
```typescript
// src/strategies/ChatStrategy.ts
export interface ChatStrategy {
  // ... ç°æœ‰æ–¹æ³• ...

  // ğŸ†• æ”¯æŒä»»åŠ¡ä¸Šä¸‹æ–‡
  supports(options: ChatOptions, taskContext?: TaskContext): boolean;
}

interface TaskContext {
  taskId: string;
  taskDescription: string;
  parentTask?: string;
}
```

---

### æ–¹æ¡ˆ3: ä»»åŠ¡çŠ¶æ€ç®¡ç†

#### 3.1 ä»»åŠ¡çŠ¶æ€æŒä¹…åŒ–

**ä½¿ç”¨SessionManagerå­˜å‚¨**:
```typescript
export class AceStrategyOrchestrator {
  // ğŸ†• ä¿å­˜ä»»åŠ¡é˜Ÿåˆ—åˆ°ä¼šè¯
  private async saveTaskQueue(sessionId: string, tasks: Task[]): Promise<void> {
    try {
      await this.sessionManager.updateSessionData(sessionId, {
        aceTaskQueue: tasks,
        aceTaskStatus: this.taskStatus
      });
    } catch (error) {
      logger.warn('[AceStrategyOrchestrator] Failed to save task queue:', error);
    }
  }

  // ğŸ†• ä»ä¼šè¯åŠ è½½ä»»åŠ¡é˜Ÿåˆ—
  private async loadTaskQueue(sessionId: string): Promise<Task[] | null> {
    try {
      const sessionData = await this.sessionManager.getSessionData(sessionId);
      return sessionData?.aceTaskQueue || null;
    } catch (error) {
      logger.warn('[AceStrategyOrchestrator] Failed to load task queue:', error);
      return null;
    }
  }
}
```

#### 3.2 ä»»åŠ¡è¿›åº¦è¿½è¸ª

**è¿›åº¦ä¸ŠæŠ¥æœºåˆ¶**:
```typescript
// ğŸ†• æ›´æ–°ä»»åŠ¡çŠ¶æ€å¹¶ä¸ŠæŠ¥åˆ°L3
private async updateTaskStatus(
  taskId: string,
  status: Task['status'],
  result?: any
): Promise<void> {
  const taskStatus: TaskStatus = {
    taskId,
    status,
    result,
    updatedAt: Date.now()
  };

  this.taskStatus.set(taskId, taskStatus);

  // ä¸ŠæŠ¥åˆ°L3ï¼ˆAgent Model Layerï¼‰
  await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
    type: 'TASK_STATUS_UPDATE',
    content: `Task ${taskId} status changed to ${status}`,
    metadata: {
      taskId,
      status,
      result,
      timestamp: Date.now()
    }
  });

  // é€šçŸ¥å‰ç«¯ï¼ˆå¯é€‰ï¼‰
  if (this.progressCallback) {
    this.progressCallback(taskStatus);
  }
}
```

---

## ğŸ“ å®æ–½æ­¥éª¤

### Step 1: åˆ›å»ºAceStrategyOrchestratoræ ¸å¿ƒç±» (Day 1)

**ä»»åŠ¡æ¸…å•**:
- [ ] åˆ›å»º`src/strategies/AceStrategyOrchestrator.ts`
- [ ] å®ç°ä»»åŠ¡æ‹†è§£æ–¹æ³•ï¼ˆdecomposeToTasksï¼‰
- [ ] å®ç°ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†ï¼ˆtaskQueues, taskStatusï¼‰
- [ ] å®ç°æ‹“æ‰‘æ’åºç®—æ³•

**éªŒæ”¶æ ‡å‡†**:
- [ ] å•å…ƒæµ‹è¯•é€šè¿‡ï¼ˆä»»åŠ¡æ‹†è§£ï¼‰
- [ ] æ‹“æ‰‘æ’åºæ­£ç¡®å¤„ç†ä¾èµ–å…³ç³»
- [ ] ç®€å•ä»»åŠ¡é™çº§å¤„ç†æ­£å¸¸

### Step 2: å®ç°DAGæ‰§è¡Œé€»è¾‘ (Day 2)

**ä»»åŠ¡æ¸…å•**:
- [ ] å®ç°executeTaskDAGæ–¹æ³•
- [ ] å®ç°ä»»åŠ¡çŠ¶æ€æ›´æ–°ï¼ˆupdateTaskStatusï¼‰
- [ ] å®ç°ç»“æœåˆå¹¶ï¼ˆmergeResultsï¼‰
- [ ] å®ç°ç­–ç•¥é€‰æ‹©ï¼ˆselectStrategyForTaskï¼‰

**éªŒæ”¶æ ‡å‡†**:
- [ ] DAGæ‰§è¡Œé¡ºåºæ­£ç¡®
- [ ] ä»»åŠ¡çŠ¶æ€æ­£ç¡®è¿½è¸ª
- [ ] é”™è¯¯å¤„ç†æœºåˆ¶æ­£å¸¸

### Step 3: é›†æˆChatService (Day 3)

**ä»»åŠ¡æ¸…å•**:
- [ ] ä¿®æ”¹ChatServiceï¼Œæ·»åŠ aceOrchestrator
- [ ] å®ç°shouldUseACEOrchestrationåˆ¤æ–­
- [ ] å®ç°estimateTaskComplexityè¯„ä¼°
- [ ] ç¡®ä¿å‘åå…¼å®¹æ€§

**éªŒæ”¶æ ‡å‡†**:
- [ ] ç°æœ‰chatæ¥å£æ­£å¸¸å·¥ä½œ
- [ ] ACEç¼–æ’æ¨¡å¼æ­£ç¡®è§¦å‘
- [ ] ç®€å•ä»»åŠ¡ä¿æŒåŸæœ‰é€»è¾‘

### Step 4: é›†æˆSessionManager (Day 4)

**ä»»åŠ¡æ¸…å•**:
- [ ] å®ç°ä»»åŠ¡é˜Ÿåˆ—æŒä¹…åŒ–ï¼ˆsaveTaskQueue, loadTaskQueueï¼‰
- [ ] ä¼šè¯æ¢å¤æœºåˆ¶ï¼ˆä»æŒä¹…åŒ–æ•°æ®æ¢å¤ä»»åŠ¡çŠ¶æ€ï¼‰
- [ ] ä»»åŠ¡è¿›åº¦ä¸ŠæŠ¥åˆ°L3å±‚

**éªŒæ”¶æ ‡å‡†**:
- [ ] ä¼šè¯é‡å¯åä»»åŠ¡é˜Ÿåˆ—æ­£ç¡®æ¢å¤
- [ ] ä»»åŠ¡è¿›åº¦æ­£ç¡®ä¸ŠæŠ¥
- [ ] å¼‚å¸¸æ¢å¤æœºåˆ¶æ­£å¸¸

### Step 5: æµ‹è¯•éªŒè¯ (Day 5)

**æµ‹è¯•åœºæ™¯**:
- [ ] ç®€å•ä»»åŠ¡æµ‹è¯•ï¼ˆæ— æ‹†è§£ï¼‰
- [ ] å¤æ‚ä»»åŠ¡æµ‹è¯•ï¼ˆå¤šå­ä»»åŠ¡ï¼‰
- [ ] ä¾èµ–å…³ç³»æµ‹è¯•ï¼ˆDAGï¼‰
- [ ] é”™è¯¯å¤„ç†æµ‹è¯•ï¼ˆä»»åŠ¡å¤±è´¥ï¼‰
- [ ] ä¼šè¯æ¢å¤æµ‹è¯•ï¼ˆé‡å¯åæ¢å¤ï¼‰

**æ€§èƒ½æµ‹è¯•**:
- [ ] ä»»åŠ¡æ‹†è§£å»¶è¿Ÿ < 2s
- [ ] ä»»åŠ¡æ‰§è¡Œååé‡æµ‹è¯•
- [ ] å†…å­˜ä½¿ç”¨ç›‘æ§ï¼ˆä»»åŠ¡é˜Ÿåˆ—å¤§å°ï¼‰

---

## ğŸ”§ å…³é”®ä»£ç ç¤ºä¾‹

### ç¤ºä¾‹1: å®Œæ•´çš„AceStrategyOrchestrator

```typescript
// src/strategies/AceStrategyOrchestrator.ts
export class AceStrategyOrchestrator {
  private taskQueues: Map<string, Task[]> = new Map();
  private taskStatus: Map<string, TaskStatus> = new Map();
  private progressCallback?: (status: TaskStatus) => void;

  constructor(
    private aceIntegrator: AceIntegrator,
    private strategies: ChatStrategy[],
    private llmManager: LLMManager,
    private sessionManager: SessionManager
  ) {}

  async orchestrate(
    messages: Message[],
    options: ChatOptions
  ): Promise<ChatResult> {
    const sessionId = options.sessionId || this.generateSessionId();

    // L4åˆ†æï¼šå°†ç”¨æˆ·è¯·æ±‚æ‹†è§£ä¸ºä»»åŠ¡é˜Ÿåˆ—
    const taskQueue = await this.decomposeToTasks(messages, sessionId);

    // ç®€å•ä»»åŠ¡ï¼šç›´æ¥æ‰§è¡Œ
    if (taskQueue.length <= 1) {
      return this.executeSimpleTask(messages, options);
    }

    // å¤æ‚ä»»åŠ¡ï¼šDAGæ‰§è¡Œ
    return this.executeTaskDAG(taskQueue, sessionId, options);
  }

  private async decomposeToTasks(
    messages: Message[],
    sessionId: string
  ): Promise<Task[]> {
    const userQuery = messages[messages.length - 1]?.content || '';
    const prompt = this.buildDecompositionPrompt(userQuery);

    try {
      const response = await this.llmManager.chat([
        {
          role: 'system',
          content: `You are a task decomposition expert. Analyze the user request and break it down into a DAG of subtasks.`
        },
        {
          role: 'user',
          content: prompt
        }
      ], { stream: false });

      const decomposition = response.choices[0]?.message?.content || '[]';
      return this.parseTaskQueue(decomposition, messages, options);
    } catch (error) {
      logger.error('[AceStrategyOrchestrator] Task decomposition failed:', error);
      return this.createFallbackTask(messages, options);
    }
  }

  private buildDecompositionPrompt(query: string): string {
    return `
ç”¨æˆ·è¯·æ±‚ï¼š${query}

è¯·å°†æ­¤ä»»åŠ¡åˆ†è§£ä¸ºå¤šä¸ªå­ä»»åŠ¡ã€‚è¿”å›JSONæ ¼å¼ï¼š

{
  "tasks": [
    {
      "id": "task_1",
      "description": "ä»»åŠ¡æè¿°",
      "dependencies": [], // ä¾èµ–çš„ä»»åŠ¡ID
      "requiresToolCall": true/false
    }
  ],
  "reasoning": "ä¸ºä»€ä¹ˆè¿™æ ·åˆ†è§£"
}

çº¦æŸæ¡ä»¶ï¼š
1. æ¯ä¸ªä»»åŠ¡åº”è¯¥æ˜¯åŸå­æ€§çš„ï¼Œä¸å¯å†åˆ†
2. æŒ‰ç…§ä¾èµ–å…³ç³»æ’åºï¼Œæ— ä¾èµ–çš„ä»»åŠ¡æ’åœ¨å‰é¢
3. å¦‚æœä¸éœ€è¦å·¥å…·è°ƒç”¨ï¼Œè®¾ç½®requiresToolCallä¸ºfalse
4. ä»»åŠ¡æè¿°è¦æ¸…æ™°ã€å…·ä½“
5. å¦‚æœæ˜¯ç®€å•ä»»åŠ¡ï¼Œè¿”å›ç©ºæ•°ç»„ï¼Œä½¿ç”¨å•ä¸€ç­–ç•¥æ‰§è¡Œ
`;
  }

  private parseTaskQueue(
    jsonStr: string,
    messages: Message[],
    options: ChatOptions
  ): Task[] {
    try {
      const parsed = JSON.parse(jsonStr);
      if (!parsed.tasks || !Array.isArray(parsed.tasks)) {
        throw new Error('Invalid task format');
      }

      return parsed.tasks.map((task: any) => ({
        id: task.id || `task_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
        description: task.description || 'No description',
        dependencies: Array.isArray(task.dependencies) ? task.dependencies : [],
        messages, // ä»»åŠ¡ç›¸å…³çš„æ¶ˆæ¯
        options: this.buildTaskOptions(options, task),
        requiresToolCall: Boolean(task.requiresToolCall),
        status: 'pending' as const,
        createdAt: Date.now()
      }));
    } catch (error) {
      logger.warn('[AceStrategyOrchestrator] Failed to parse task queue, using single task:', error);
      return this.createFallbackTask(messages, options);
    }
  }

  private async executeTaskDAG(
    taskQueue: Task[],
    sessionId: string,
    options: ChatOptions
  ): Promise<ChatResult> {
    const results: any[] = [];
    const completedTasks = new Set<string>();

    // æ‹“æ‰‘æ’åºï¼šç¡®å®šæ‰§è¡Œé¡ºåº
    const executionOrder = this.topologicalSort(taskQueue);

    // æŒ‰é¡ºåºæ‰§è¡Œä»»åŠ¡
    for (const taskId of executionOrder) {
      const task = taskQueue.find(t => t.id === taskId)!;

      try {
        // æ£€æŸ¥ä¾èµ–
        if (!this.areDependenciesMet(task, completedTasks)) {
          throw new Error(`Task ${taskId} dependencies not met`);
        }

        // æ›´æ–°çŠ¶æ€
        await this.updateTaskStatus(taskId, 'running');

        // L4 â†’ L5ï¼šä¸‹å‘ä»»åŠ¡
        await this.aceIntegrator.sendToLayer('COGNITIVE_CONTROL', {
          type: 'TASK',
          content: task.description,
          metadata: {
            taskId: task.id,
            dependencies: task.dependencies
          }
        });

        // é€‰æ‹©ç­–ç•¥å¹¶æ‰§è¡Œ
        const strategy = this.selectStrategyForTask(task);
        const result = await strategy.execute(task.messages, {
          ...task.options,
          sessionId,
          requestId: task.id
        });

        results.push(result);

        // L5 â†’ L4ï¼šä»»åŠ¡å®Œæˆä¸ŠæŠ¥
        await this.aceIntegrator.completeTask(sessionId, {
          summary: `Task ${task.id} completed`,
          outcome: 'success'
        });

        // æ›´æ–°çŠ¶æ€
        await this.updateTaskStatus(taskId, 'completed', result);
        completedTasks.add(taskId);

        logger.info(`[AceStrategyOrchestrator] Task completed: ${taskId}`);

      } catch (error) {
        logger.error(`[AceStrategyOrchestrator] Task failed: ${taskId}`, error);
        await this.updateTaskStatus(taskId, 'failed', { error: error.message });
        results.push({
          content: `Task ${taskId} failed: ${error.message}`,
          iterations: 0
        });
      }
    }

    return this.mergeResults(results);
  }

  private topologicalSort(tasks: Task[]): string[] {
    const inDegree = new Map<string, number>();
    const graph = new Map<string, string[]>();

    tasks.forEach(task => {
      inDegree.set(task.id, task.dependencies.length);
      graph.set(task.id, []);
    });

    tasks.forEach(task => {
      task.dependencies.forEach(dep => {
        if (graph.has(dep)) {
          graph.get(dep)!.push(task.id);
        }
      });
    });

    const queue: string[] = [];
    inDegree.forEach((degree, taskId) => {
      if (degree === 0) queue.push(taskId);
    });

    const result: string[] = [];

    while (queue.length > 0) {
      const current = queue.shift()!;
      result.push(current);

      graph.get(current)!.forEach(neighbor => {
        const newDegree = inDegree.get(neighbor)! - 1;
        inDegree.set(neighbor, newDegree);
        if (newDegree === 0) {
          queue.push(neighbor);
        }
      });
    }

    if (result.length !== tasks.length) {
      throw new Error('Task dependency cycle detected');
    }

    return result;
  }

  private selectStrategyForTask(task: Task): ChatStrategy {
    for (const strategy of this.strategies) {
      if (strategy.supports(task.options)) {
        return strategy;
      }
    }
    return this.strategies.find(s => s.getName() === 'ReActStrategy') || this.strategies[0];
  }

  private async updateTaskStatus(
    taskId: string,
    status: Task['status'],
    result?: any
  ): Promise<void> {
    const taskStatus: TaskStatus = {
      taskId,
      status,
      result,
      updatedAt: Date.now()
    };

    this.taskStatus.set(taskId, taskStatus);

    // ä¸ŠæŠ¥åˆ°L3
    await this.aceIntegrator.sendToLayer('AGENT_MODEL', {
      type: 'TASK_STATUS_UPDATE',
      content: `Task ${taskId} status changed to ${status}`,
      metadata: {
        taskId,
        status,
        result,
        timestamp: Date.now()
      }
    });

    if (this.progressCallback) {
      this.progressCallback(taskStatus);
    }
  }

  private mergeResults(results: any[]): ChatResult {
    return {
      content: results.map(r => r.content).join('\n---\n'),
      iterations: results.reduce((sum, r) => sum + (r.iterations || 0), 0)
    };
  }

  private generateSessionId(): string {
    return `ace_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

### ç¤ºä¾‹2: ChatServiceé›†æˆ

```typescript
// src/services/ChatService.ts çš„å…³é”®ä¿®æ”¹
export class ChatService {
  private aceOrchestrator: AceStrategyOrchestrator;

  constructor(...) {
    // ... ç°æœ‰ä»£ç  ...

    // ğŸ†• åˆå§‹åŒ–ACEç¼–æ’å™¨
    this.aceOrchestrator = new AceStrategyOrchestrator(
      this.aceIntegrator,
      this.strategies,
      this.llmManager,
      this.sessionManager
    );
  }

  async chat(messages: Message[], options: ChatOptions): Promise<ChatResult> {
    // ğŸ†• åˆ¤æ–­æ˜¯å¦å¯ç”¨ACEç¼–æ’
    if (this.shouldUseACEOrchestration(messages, options)) {
      logger.info('[ChatService] Using ACE orchestration for complex task');
      return this.aceOrchestrator.orchestrate(messages, options);
    }

    // âœ… åŸæœ‰é€»è¾‘ï¼šç›´æ¥ç­–ç•¥é€‰æ‹©ï¼ˆä¿æŒå…¼å®¹æ€§ï¼‰
    const strategy = this.selectStrategy(options);
    return strategy.execute(messages, options);
  }

  private shouldUseACEOrchestration(
    messages: Message[],
    options: ChatOptions
  ): boolean {
    // æ˜¾å¼å¯ç”¨
    if (options.aceOrchestration?.enabled) {
      return true;
    }

    // è‡ªåŠ¨æ£€æµ‹å¤æ‚ä»»åŠ¡
    const userQuery = messages[messages.length - 1]?.content || '';
    const complexityScore = this.estimateTaskComplexity(userQuery);

    return complexityScore >= 0.7;
  }

  private estimateTaskComplexity(query: string): number {
    let score = 0;

    const complexKeywords = [
      'é¡¹ç›®', 'ç³»ç»Ÿ', 'åº”ç”¨', 'ç½‘ç«™', 'å¹³å°',
      'å¼€å‘', 'æ„å»º', 'å®ç°', 'è®¾è®¡',
      'å®Œæ•´', 'å…¨é¢', 'ç»¼åˆ'
    ];

    complexKeywords.forEach(keyword => {
      if (query.includes(keyword)) {
        score += 0.2;
      }
    });

    if (query.length > 50) {
      score += 0.2;
    }

    if (query.includes('é¦–å…ˆ') || query.includes('ç„¶å') || query.includes('æœ€å')) {
      score += 0.3;
    }

    return Math.min(score, 1.0);
  }
}
```

---

## ğŸ“Š æ€§èƒ½ä¸èµ„æºåˆ†æ

### ä»»åŠ¡æ‹†è§£æ€§èƒ½

**å»¶è¿Ÿé¢„ç®—**:
- LLMè°ƒç”¨ï¼ˆä»»åŠ¡åˆ†æï¼‰: 1-2ç§’
- JSONè§£æå’ŒéªŒè¯: < 50ms
- æ‹“æ‰‘æ’åº: < 10ms
- æ€»ä½“å»¶è¿Ÿ: 1-2ç§’

**ä¼˜åŒ–ç­–ç•¥**:
- âœ… ç¼“å­˜å¸¸è§ä»»åŠ¡çš„æ‹†è§£ç»“æœ
- âœ… ä½¿ç”¨è½»é‡çº§æ¨¡å‹è¿›è¡Œåˆæ­¥åˆ†æ
- âœ… å¼‚æ­¥æ‰§è¡Œï¼Œä¸é˜»å¡ä¸»æµç¨‹

### å†…å­˜ä½¿ç”¨

**ä»»åŠ¡é˜Ÿåˆ—å†…å­˜**:
```typescript
// æ¯ä¸ªä»»åŠ¡çš„å†…å­˜å ç”¨
taskMemory = {
  id: string,              // 16B
  description: string,     // ~200B
  dependencies: string[],  // ~100B
  messages: Message[],     // ~1KB
  options: ChatOptions,    // ~500B
  metadata: any            // ~200B
}

// å¹³å‡ä»»åŠ¡å¤§å°: ~2KB
// 100ä¸ªä»»åŠ¡: ~200KB
// 1000ä¸ªä»»åŠ¡: ~2MB
```

**å†…å­˜æ§åˆ¶**:
- âœ… ä»»åŠ¡å®Œæˆåæ¸…ç†é˜Ÿåˆ—
- âœ… ä¼šè¯è¶…æ—¶è‡ªåŠ¨æ¸…ç†
- âœ… é™åˆ¶å•ä¼šè¯æœ€å¤§ä»»åŠ¡æ•°ï¼ˆ100ï¼‰

### å¹¶å‘å¤„ç†

**å¹¶å‘é™åˆ¶**:
- æœ€å¤§å¹¶å‘ä»»åŠ¡æ•°: 3ï¼ˆä¸ReActEngineä¸€è‡´ï¼‰
- é˜Ÿåˆ—å¤§å°é™åˆ¶: 100
- è¶…æ—¶æ—¶é—´: 30ç§’/ä»»åŠ¡

---

## âš ï¸ é£é™©ä¸ç¼“è§£

### é£é™©1: ä»»åŠ¡æ‹†è§£å¤±è´¥
**åŸå› **: LLMåˆ†æé”™è¯¯æˆ–è¿”å›æ ¼å¼æ— æ•ˆ
**ç¼“è§£**:
- âœ… é™çº§ä¸ºå•ä»»åŠ¡æ‰§è¡Œ
- âœ… æ ¼å¼éªŒè¯å’Œé”™è¯¯æ¢å¤
- âœ… ç¼“å­˜æˆåŠŸçš„æ‹†è§£ç»“æœ

### é£é™©2: ä»»åŠ¡ä¾èµ–å¾ªç¯
**åŸå› **: ç”¨æˆ·è¯·æ±‚ä¸­å­˜åœ¨å¾ªç¯ä¾èµ–
**ç¼“è§£**:
- âœ… æ‹“æ‰‘æ’åºå‰æ£€æµ‹ç¯
- âœ… è‡ªåŠ¨å°è¯•æ‰“ç ´ç¯ï¼ˆåˆ é™¤æœ€åä¸€æ¡ä¾èµ–ï¼‰
- âœ… é”™è¯¯ä¸ŠæŠ¥ç»™ç”¨æˆ·

### é£é™©3: ä»»åŠ¡æ‰§è¡Œè¶…æ—¶
**åŸå› **: å­ä»»åŠ¡æ‰§è¡Œæ—¶é—´è¿‡é•¿
**ç¼“è§£**:
- âœ… è®¾ç½®ä»»åŠ¡è¶…æ—¶ï¼ˆ30ç§’ï¼‰
- âœ… å¹¶å‘é™åˆ¶ï¼ˆæœ€å¤š3ä¸ªä»»åŠ¡ï¼‰
- âœ… è¶…æ—¶ä»»åŠ¡æ ‡è®°å¹¶ç»§ç»­

### é£é™©4: å†…å­˜æ³„æ¼
**åŸå› **: ä»»åŠ¡é˜Ÿåˆ—æœªæ­£ç¡®æ¸…ç†
**ç¼“è§£**:
- âœ… ä»»åŠ¡å®Œæˆåç«‹å³æ¸…ç†
- âœ… ä¼šè¯è¶…æ—¶è‡ªåŠ¨æ¸…ç†
- âœ… å®šæœŸç›‘æ§é˜Ÿåˆ—å¤§å°

---

## âœ… éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶
- [ ] ç®€å•ä»»åŠ¡æ­£å¸¸æ‰§è¡Œï¼ˆåŸæœ‰é€»è¾‘ï¼‰
- [ ] å¤æ‚ä»»åŠ¡æ­£ç¡®æ‹†è§£ä¸ºå­ä»»åŠ¡
- [ ] ä»»åŠ¡ä¾èµ–å…³ç³»æ­£ç¡®å¤„ç†ï¼ˆDAGï¼‰
- [ ] ä»»åŠ¡çŠ¶æ€æ­£ç¡®è¿½è¸ªå’Œä¸ŠæŠ¥
- [ ] é”™è¯¯å¤„ç†æœºåˆ¶æ­£å¸¸ï¼ˆä»»åŠ¡å¤±è´¥ä¸å½±å“å…¶ä»–ä»»åŠ¡ï¼‰

### æ€§èƒ½éªŒæ”¶
- [ ] ä»»åŠ¡æ‹†è§£å»¶è¿Ÿ < 2ç§’
- [ ] ä»»åŠ¡æ‰§è¡Œååé‡ > 10 tasks/min
- [ ] å†…å­˜ä½¿ç”¨å¢é•¿ < 5MB (100 tasks)
- [ ] æ— å†…å­˜æ³„æ¼ï¼ˆ24å°æ—¶å‹åŠ›æµ‹è¯•ï¼‰

### å…¼å®¹æ€§éªŒæ”¶
- [ ] ç°æœ‰chatæ¥å£æ­£å¸¸å·¥ä½œ
- [ ] ç°æœ‰ç­–ç•¥é€‰æ‹©é€»è¾‘ä¸å—å½±å“
- [ ] WebSocketæµå¼æ¥å£æ­£å¸¸å·¥ä½œ
- [ ] å‘åå…¼å®¹æ€§100%

---

## ğŸ”— ä¾èµ–å…³ç³»

### ä¸Šæ¸¸ä¾èµ–
- âœ… P0é˜¶æ®µå®Œæˆï¼ˆL5/L6å±‚å·²æ¿€æ´»ï¼‰
- âœ… LLMManager - ç”¨äºä»»åŠ¡æ‹†è§£
- âœ… ChatStrategy - ç”¨äºå­ä»»åŠ¡æ‰§è¡Œ
- âœ… SessionManager - ç”¨äºä»»åŠ¡çŠ¶æ€ç®¡ç†

### ä¸‹æ¸¸ä¾èµ–ï¼ˆP2é˜¶æ®µï¼‰
- â³ AceCapabilityManager - æ¥æ”¶L4çš„èƒ½åŠ›éœ€æ±‚
- â³ AceStrategyManager - æ¥æ”¶L4çš„æˆ˜ç•¥è°ƒæ•´

---

## ğŸ“š å‚è€ƒå®ç°

### ç›¸å…³æ–‡ä»¶
- `src/strategies/AceStrategyOrchestrator.ts` - æ–°å»º
- `src/services/ChatService.ts` - ä¿®æ”¹
- `src/core/LLMManager.ts` - å¤ç”¨
- `src/services/SessionManager.ts` - å¤ç”¨

### æµ‹è¯•æ–‡ä»¶
- `tests/unit/strategies/AceStrategyOrchestrator.test.ts`
- `tests/integration/services/ChatService-ace.test.ts`

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025-12-12
**ä½œè€…**: Claude Code
**å®¡æ ¸**: å¾…å®¡æ ¸
