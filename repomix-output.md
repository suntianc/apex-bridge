This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
config/
  disclosure.yaml
  hybrid-retrieval.yaml
  skills-config.yaml
src/
  api/
    controllers/
      chat/
        ChatCompletionsHandler.ts
        ChatController.ts
        index.ts
        MessageValidation.ts
        StreamResponseHandler.ts
      ChatController.ts
      ModelController.ts
      ProviderController.ts
      SkillsController.ts
    middleware/
      rateLimit/
        inMemoryRateLimiter.ts
        redisRateLimiter.ts
        types.ts
      auditLoggerMiddleware.ts
      authMiddleware.ts
      customValidators.ts
      errorHandler.ts
      rateLimitMiddleware.ts
      sanitizationMiddleware.ts
      securityHeadersMiddleware.ts
      securityLoggerMiddleware.ts
      validationMiddleware.ts
      validationSchemas.ts
    routes/
      mcpRoutes.ts
      skillRoutes.ts
    utils/
      response-formatter.ts
      stream-parser.ts
    validators/
      chat-request-validator.ts
    websocket/
      channels/
        ChatChannel.ts
      WebSocketManager.ts
  config/
    endpoint-mappings.ts
    index.ts
  constants/
    compression.ts
    index.ts
    retention.ts
    retrieval.ts
  core/
    llm/
      adapters/
        BaseAdapter.ts
        ClaudeAdapter.ts
        CustomAdapter.ts
        DeepSeekAdapter.ts
        index.ts
        LLMAdapterFactory.ts
        OllamaAdapter.ts
        OpenAIAdapter.ts
        ZhipuAdapter.ts
    protocol/
      ABPProtocolParser.ts
    security/
      PromptInjectionGuard.ts
    stream-orchestrator/
      CachedLLMAdapter.ts
      LLMAdapter.ts
      ReActEngine.ts
      ReActEnginePool.ts
      ToolExecutor.ts
      types.ts
    tool/
      registry.ts
      tool.ts
    tool-action/
      ErrorHandler.ts
      index.ts
      ParameterConverter.ts
      StreamTagDetector.ts
      ToolActionParser.ts
      ToolDispatcher.ts
      types.ts
    tools/
      builtin/
        FileReadTool.ts
        FileWriteTool.ts
        PlatformDetectorTool.ts
        ReadSkillTool.ts
        VectorSearchTool.ts
    variable/
      index.ts
      VariableEngine.ts
    EventBus.ts
    LLMManager.ts
    ProtocolEngine.ts
  database/
    migrations/
      001_create_type_vocabulary.sql
      002_create_type_similarity_matrix.sql
      003_create_type_evolution_history.sql
      005_create_prompt_templates.sql
      index.ts
    index.ts
    MigrationRunner.ts
    run-migrations.ts
  services/
    agent/
      index.ts
      ResourceStats.ts
    cache/
      SemanticCache.ts
    chat/
      ChatServiceFactory.ts
      ConversationSaver.ts
      MessagePreprocessor.ts
      StrategySelector.ts
    compat/
      AllowedToolsValidator.ts
      ClaudeCodeSkillParser.ts
      ContextModeExecutor.ts
      index.ts
      LifecycleManager.ts
      PermissionValidator.ts
      ScriptExecutor.ts
      types.ts
    context-compression/
      strategies/
        HybridStrategy.ts
        IContextCompressionStrategy.ts
        index.ts
        PruneStrategy.ts
        SummaryStrategy.ts
        TruncateStrategy.ts
      ContextCompressionService.ts
      index.ts
      TokenEstimator.ts
    embedding/
      BatchEmbeddingService.ts
    executors/
      BuiltInExecutor.ts
      SkillsSandboxExecutor.ts
      ToolExecutor.ts
    mcp/
      convert.ts
    skill/
      BuiltInSkillLoader.ts
      DynamicSkillManager.ts
      index.ts
      SkillManager.ts
      SkillValidator.ts
      UserSkillLoader.ts
    tool-retrieval/
      BatchEmbeddingService.ts
      DisclosureManager.ts
      EmbeddingGenerator.ts
      HybridRetrievalEngine.ts
      index.ts
      IndexConfigOptimizer.ts
      LanceDBConnection.ts
      LanceDBConnectionManager.ts
      LanceDBConnectionPool.ts
      MCPToolSupport.ts
      SearchEngine.ts
      SkillIndexer.ts
      TagMatchingEngine.ts
      ToolRetrievalConfig.ts
      ToolRetrievalService.ts
      types.ts
      UnifiedScoringEngine.ts
      VectorIndexManager.ts
    warmup/
      ApplicationWarmupService.ts
      CacheWarmupManager.ts
      index.ts
      IndexPrewarmService.ts
    BuiltInToolsRegistry.ts
    ChatService.ts
    ConfigService.ts
    ConversationHistoryService.ts
    DatabaseManager.ts
    IdleScheduler.ts
    LLMConfigService.ts
    MCPConfigService.ts
    MCPIntegrationService.ts
    MCPServerManager.ts
    ModelRegistry.ts
    PathService.ts
    RedisService.ts
    RequestTracker.ts
    SessionManager.ts
    SkillManager.ts
    SystemPromptService.ts
    ToolRetrievalService.ts
    TrajectoryStore.ts
    UnifiedToolManager.ts
  strategies/
    ChatStrategy.ts
    ReActStrategy.ts
    SingleRoundStrategy.ts
  types/
    config/
      admin.ts
      api-key.ts
      index.ts
      rate-limit.ts
      redis.ts
    abp.ts
    config.ts
    enhanced-skill.ts
    errors.ts
    index.ts
    llm-models.ts
    mcp.ts
    message-v2.ts
    react.ts
    reflector.ts
    request-abort.ts
    task-queue.ts
    tool-state.ts
    tool-system.ts
    trajectory.ts
    variable.ts
    vector.ts
  utils/
    config/
      disclosure-config.ts
      index.ts
    cache.ts
    config-constants.ts
    config-loader.ts
    config-validator.ts
    config-writer.ts
    error-classifier.ts
    error-serializer.ts
    errors.ts
    jwt.ts
    logger.ts
    message-utils.ts
    metrics.ts
    request-id.ts
    retry.ts
  server.ts
.eslintignore
.gitignore
.repomixignore
.versionrc
LICENSE
```

# Files

## File: src/api/controllers/chat/ChatCompletionsHandler.ts
````typescript
/**
 * ChatCompletionsHandler - Chat Completions Handling
 *
 * Handles the main chat completions API endpoint.
 */

import { Request, Response } from "express";
import { logger } from "../../../utils/logger";
import { ChatService } from "../../../services/ChatService";
import { parseChatRequest } from "../../validators/chat-request-validator";
import type { ChatRequestOptions } from "../../validators/chat-request-validator";

export interface CompletionsResult {
  success: boolean;
  response?: any;
  error?: string;
}

/**
 * ChatCompletionsHandler - Chat Completions Handling
 *
 * Responsible for processing chat completion requests.
 */
export class ChatCompletionsHandler {
  private chatService: ChatService;

  constructor(chatService: ChatService) {
    this.chatService = chatService;
    logger.info("ChatCompletionsHandler initialized");
  }

  /**
   * Handle chat completions request
   */
  async handleCompletions(req: Request, res: Response): Promise<CompletionsResult> {
    try {
      const body = req.body;

      // DEBUG: Check multimodal messages in original request
      if (body.messages && Array.isArray(body.messages)) {
        const multimodalCount = body.messages.filter(
          (m: any) => Array.isArray(m.content) && m.content.some((p: any) => p.type === "image_url")
        ).length;
        if (multimodalCount > 0) {
          logger.debug(`[ChatCompletionsHandler] Received ${multimodalCount} multimodal messages`);
        }
      }

      // Validate request
      const validation = parseChatRequest(body);
      if (!validation.success) {
        logger.warn("[ChatCompletionsHandler] Invalid request:", validation.error);
        res.status(400).json({
          error: {
            message: validation.error || "Invalid request parameters",
            type: "invalid_request",
          },
        });
        return { success: false, error: validation.error };
      }

      const options = validation.data;
      const messages = body.messages;

      // Check if stream is enabled
      if (options.stream) {
        // Stream handling will be done by StreamResponseHandler
        return { success: true, response: { stream: true, options, messages } };
      }

      // Non-streaming response
      const result = await this.chatService.processMessage(messages, options);

      return {
        success: true,
        response: result,
      };
    } catch (error) {
      logger.error("Error in chat completions:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Validate request
   */
  validateRequest(body: any): { valid: boolean; error?: string; data?: ChatRequestOptions } {
    const validation = parseChatRequest(body);

    if (!validation.success) {
      return { valid: false, error: validation.error };
    }

    return { valid: true, data: validation.data };
  }

  /**
   * Extract messages from request
   */
  extractMessages(body: any): any[] {
    return body.messages || [];
  }

  /**
   * Get actual model to use
   */
  async getActualModel(options: ChatRequestOptions): Promise<string> {
    if (options.model) {
      return options.model;
    }

    // Default to gpt-4 if no model specified
    return "gpt-4";
  }
}

/**
 * Create ChatCompletionsHandler instance
 */
export function createChatCompletionsHandler(chatService: ChatService): ChatCompletionsHandler {
  return new ChatCompletionsHandler(chatService);
}
````

## File: src/api/controllers/chat/ChatController.ts
````typescript
/**
 * ChatController - Chat Controller Coordinator
 *
 * Main controller coordinating all chat-related operations.
 */

import { Request, Response } from "express";
import { ChatService } from "../../../services/ChatService";
import { LLMManager } from "../../../core/LLMManager";
import { logger } from "../../../utils/logger";
import { ChatCompletionsHandler, createChatCompletionsHandler } from "./ChatCompletionsHandler";
import { StreamResponseHandler, createStreamResponseHandler } from "./StreamResponseHandler";
import { MessageValidation, createMessageValidation } from "./MessageValidation";
import { normalizeUsage, buildChatResponse } from "../../utils/response-formatter";
import type { Message } from "../../../types";
import type { ChatRequestOptions } from "../../validators/chat-request-validator";
import { LLMModelType } from "../../../types/llm-models";
import { InterruptRequest, InterruptResponse } from "../../../types/request-abort";

export interface SessionInfo {
  sessionId: string;
  conversationId: string;
  status: string;
  messageCount: number;
  lastActivityAt: number;
}

export interface SessionListResult {
  sessions: SessionInfo[];
  total: number;
}

/**
 * ChatController - Main Chat Controller Coordinator
 *
 * Orchestrates all chat-related operations including completions,
 * streaming, session management, and message handling.
 */
export class ChatController {
  private chatService: ChatService;
  private completionsHandler: ChatCompletionsHandler;
  private streamHandler: StreamResponseHandler;
  private messageValidation: MessageValidation;
  private llmClient: LLMManager | null;

  constructor(chatService: ChatService) {
    this.chatService = chatService;
    this.completionsHandler = createChatCompletionsHandler(chatService);
    this.streamHandler = createStreamResponseHandler(chatService);
    this.messageValidation = createMessageValidation();
    this.llmClient = null;

    logger.info("ChatController initialized");
  }

  /**
   * Handle chat completions (POST /v1/chat/completions)
   */
  async chatCompletions(req: Request, res: Response): Promise<void> {
    try {
      const result = await this.completionsHandler.handleCompletions(req, res);

      if (!result.success) {
        res.status(400).json({
          error: {
            message: result.error || "Invalid request",
            type: "invalid_request",
          },
        });
        return;
      }

      if (result.response?.stream) {
        // Handle streaming
        const messages = this.completionsHandler.extractMessages(req.body);
        const options = result.response.options;
        await this.streamHandler.handleStream(res, messages, options);
      } else {
        // Handle non-streaming
        const actualModel = await this.getActualModel(req.body);
        const usage = normalizeUsage(result.response.usage);
        const response = buildChatResponse(result.response.content, actualModel, usage);
        res.json(response);
      }
    } catch (error: any) {
      logger.error("Error in chatCompletions:", error);
      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * Get available models (GET /v1/models)
   */
  async getModels(req: Request, res: Response): Promise<void> {
    try {
      const llmClient = await this.getLLMClient();
      const models = await llmClient.getAllModels();

      res.json({
        object: "list",
        data: models.map((m) => ({
          id: m.id,
          object: "model",
          owned_by: m.provider,
          created: Math.floor(Date.now() / 1000),
        })),
      });

      logger.info(`Returned ${models.length} models`);
    } catch (error: any) {
      logger.error("Error in getModels:", error);

      const statusCode =
        error.message?.includes("not available") || error.message?.includes("Failed to initialize")
          ? 503
          : 500;

      res.status(statusCode).json({
        error: {
          message: error.message || "Failed to fetch models",
          type: statusCode === 503 ? "service_unavailable" : "server_error",
        },
      });
    }
  }

  /**
   * Interrupt a request (POST /v1/interrupt)
   */
  async interruptRequest(req: Request, res: Response): Promise<void> {
    try {
      const body: InterruptRequest = req.body;
      const { requestId } = body;

      if (!requestId || typeof requestId !== "string") {
        res.status(400).json({
          success: false,
          error: "Bad Request",
          message: "Missing or invalid requestId",
        });
        return;
      }

      logger.info(`[ChatController] Interrupt request for: ${requestId}`);

      const interrupted = await this.chatService.interruptRequest(requestId);

      if (interrupted) {
        const response: InterruptResponse = {
          success: true,
          message: "Request interrupted successfully",
          requestId: requestId,
          interrupted: true,
        };

        logger.info(`Request interrupted: ${requestId}`);
        res.json(response);
      } else {
        const response: InterruptResponse = {
          success: false,
          message: "Request not found or already completed",
          requestId: requestId,
          reason: "not_found",
        };

        logger.warn(`Request not found for interrupt: ${requestId}`);
        res.status(404).json(response);
      }
    } catch (error: any) {
      logger.error("Error in interruptRequest:", error);

      const response: InterruptResponse = {
        success: false,
        message: error.message || "Failed to interrupt request",
        error: error.toString(),
      };

      res.status(500).json(response);
    }
  }

  /**
   * Delete session (DELETE /v1/chat/sessions/:conversationId)
   */
  async deleteSession(req: Request, res: Response): Promise<void> {
    try {
      const conversationId = req.params.conversationId;

      if (!conversationId) {
        res.status(400).json({
          error: {
            message: "conversationId is required",
            type: "invalid_request",
          },
        });
        return;
      }

      await this.chatService.endSession(conversationId);

      res.json({
        success: true,
        message: "Session deleted successfully",
      });
    } catch (error: any) {
      logger.error("Error in deleteSession:", error);
      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * Get session (GET /v1/chat/sessions/:conversationId)
   */
  async getSession(req: Request, res: Response): Promise<void> {
    try {
      const conversationId = req.params.conversationId;

      if (!conversationId) {
        res.status(400).json({
          error: {
            message: "conversationId is required",
            type: "invalid_request",
          },
        });
        return;
      }

      const sessionId = this.chatService.getSessionIdByConversationId(conversationId);

      if (!sessionId) {
        res.status(404).json({
          error: {
            message: "Session not found",
            type: "not_found",
          },
        });
        return;
      }

      const messageCount = await this.chatService.getConversationMessageCount(conversationId);
      const lastMessage = await this.chatService.getConversationLastMessage(conversationId);

      const sessionState = {
        sessionId,
        conversationId,
        status: "active",
        messageCount,
        lastActivityAt: lastMessage?.created_at || Date.now(),
        metadata: {
          hasHistory: messageCount > 0,
        },
      };

      res.json({
        success: true,
        data: sessionState,
      });
    } catch (error: any) {
      logger.error("Error in getSession:", error);
      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * Get active sessions (GET /v1/chat/sessions/active)
   */
  async getActiveSessions(req: Request, res: Response): Promise<void> {
    try {
      const conversationIds = await this.chatService.getAllConversationsWithHistory();

      const sessions = await Promise.all(
        conversationIds.map(async (sessionId) => {
          try {
            const messageCount = await this.chatService.getConversationMessageCount(sessionId);
            const lastMessage = await this.chatService.getConversationLastMessage(sessionId);
            const firstMessage = await this.chatService.getConversationFirstMessage(sessionId);

            return {
              sessionId,
              conversationId: sessionId,
              status: "active",
              messageCount,
              lastActivityAt: lastMessage?.created_at || 0,
              lastMessage: lastMessage?.content?.substring(0, 100) || "",
              firstMessage: firstMessage?.content?.substring(0, 100) || "",
            };
          } catch (error: any) {
            logger.warn(
              `[ChatController] Failed to get session info for ${sessionId}: ${error.message}`
            );
            return null;
          }
        })
      );

      const activeSessions = sessions.filter((s) => s !== null);

      res.json({
        success: true,
        data: {
          sessions: activeSessions,
          total: activeSessions.length,
        },
      });
    } catch (error: any) {
      logger.error("Error in getActiveSessions:", error);
      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * Get session history (GET /v1/chat/sessions/:conversationId/history)
   */
  async getSessionHistory(req: Request, res: Response): Promise<void> {
    try {
      const { conversationId } = req.params;
      const { type = "all", limit = "100" } = req.query;

      if (!conversationId) {
        res.status(400).json({
          error: {
            message: "conversationId is required",
            type: "invalid_request",
          },
        });
        return;
      }

      const sessionId = this.chatService.getSessionIdByConversationId(conversationId);
      if (!sessionId) {
        res.status(404).json({
          error: {
            message: "Session not found",
            type: "not_found",
          },
        });
        return;
      }

      const history: any = {};
      const limitNum = parseInt(limit as string) || 100;

      if (type === "all" || type === "state") {
        const messageCount = await this.chatService.getConversationMessageCount(conversationId);
        const lastMessage = await this.chatService.getConversationLastMessage(conversationId);

        history.sessionState = {
          sessionId,
          conversationId,
          status: "active",
          messageCount,
          lastActivityAt: lastMessage?.created_at || Date.now(),
        };
      }

      res.json({
        success: true,
        data: history,
      });
    } catch (error: any) {
      logger.error("Error in getSessionHistory:", error);
      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * Get conversation messages (GET /v1/chat/sessions/:conversationId/messages)
   */
  async getConversationMessages(req: Request, res: Response): Promise<void> {
    try {
      const { conversationId } = req.params;
      const { limit = "100", offset = "0" } = req.query;

      if (!conversationId) {
        res.status(400).json({
          error: {
            message: "conversationId is required",
            type: "invalid_request",
          },
        });
        return;
      }

      const messages = await this.chatService.getConversationHistory(
        conversationId,
        parseInt(limit as string) || 100,
        parseInt(offset as string) || 0
      );

      const total = await this.chatService.getConversationMessageCount(conversationId);

      res.json({
        success: true,
        data: {
          messages,
          total,
          limit: parseInt(limit as string) || 100,
          offset: parseInt(offset as string) || 0,
        },
      });
    } catch (error: any) {
      logger.error("Error in getConversationMessages:", error);
      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * Simple chat stream (POST /v1/chat/simple-stream)
   */
  async simpleChatStream(req: Request, res: Response): Promise<void> {
    try {
      const { messages } = req.body;
      const body = req.body;

      if (!messages || !Array.isArray(messages)) {
        res.status(400).json({
          error: {
            message: "messages is required and must be an array",
            type: "validation_error",
          },
        });
        return;
      }

      const options: ChatRequestOptions = {
        provider: body.provider,
        model: body.model,
        temperature: body.temperature,
        max_tokens: body.max_tokens,
        stream: true,
        user: body.user,
      };

      if (!options.model) {
        res.status(400).json({
          error: {
            message: "model is required",
            type: "validation_error",
          },
        });
        return;
      }

      await this.streamHandler.handleStream(res, messages, options);
    } catch (error: any) {
      logger.error("Error in simpleChatStream:", error);

      if (!res.headersSent) {
        res.status(500).json({
          error: {
            message: error.message || "Internal server error",
            type: "server_error",
          },
        });
      }
    }
  }

  /**
   * Get actual model
   */
  private async getActualModel(body: any): Promise<string> {
    if (body.model) {
      return body.model;
    }

    try {
      const llmClient = await this.getLLMClient();
      const models = llmClient.getAllModels();
      const defaultModel = models.find((m) => m.type === LLMModelType.NLP);
      if (defaultModel) {
        return defaultModel.id;
      }
    } catch (error) {
      logger.warn("[ChatController] Failed to get default model, using fallback");
    }

    return "gpt-4";
  }

  /**
   * Get LLM client
   */
  private async getLLMClient(): Promise<LLMManager> {
    if (this.llmClient) {
      return this.llmClient;
    }

    try {
      const { LLMManager } = await import("../../../core/LLMManager");
      const client = new LLMManager() as LLMManager;
      if (!client) {
        throw new Error("LLMClient not available");
      }
      this.llmClient = client;
      return client;
    } catch (error: any) {
      throw new Error(`Failed to initialize LLMClient: ${error.message || error}`);
    }
  }
}

/**
 * Create ChatController instance
 */
export function createChatController(chatService: ChatService): ChatController {
  return new ChatController(chatService);
}
````

## File: src/api/controllers/chat/index.ts
````typescript
/**
 * chat controller module - Unified Exports
 *
 * Main entry point for the chat controller module.
 */

// Main controller
export { ChatController, createChatController } from "./ChatController";

// Sub-modules
export { ChatCompletionsHandler, createChatCompletionsHandler } from "./ChatCompletionsHandler";
export type { CompletionsResult } from "./ChatCompletionsHandler";

export { StreamResponseHandler, createStreamResponseHandler } from "./StreamResponseHandler";

export { MessageValidation, createMessageValidation } from "./MessageValidation";
export type { ValidationResult, ValidatedMessage, MessagePart } from "./MessageValidation";
````

## File: src/api/controllers/chat/MessageValidation.ts
````typescript
/**
 * MessageValidation - Message Validation
 *
 * Handles message validation, format checking, and content verification.
 */

import { logger } from "../../../utils/logger";

export interface ValidationResult<T = any> {
  valid: boolean;
  data?: T;
  error?: string;
  warnings?: string[];
}

export interface MessagePart {
  type: "text" | "image_url";
  text?: string;
  image_url?: {
    url: string;
  };
}

export interface ValidatedMessage {
  role: "system" | "user" | "assistant" | "tool" | "function";
  content: string | MessagePart[];
  name?: string;
}

/**
 * MessageValidation - Message Validation
 *
 * Responsible for validating chat messages and their content.
 */
export class MessageValidation {
  private allowedRoles: Set<string>;
  private maxMessageLength: number;
  private maxContentArrayLength: number;

  constructor(
    options: {
      allowedRoles?: string[];
      maxMessageLength?: number;
      maxContentArrayLength?: number;
    } = {}
  ) {
    this.allowedRoles = new Set(options.allowedRoles || ["system", "user", "assistant"]);
    this.maxMessageLength = options.maxMessageLength || 100000;
    this.maxContentArrayLength = options.maxContentArrayLength || 100;
    logger.info("MessageValidation initialized", {
      allowedRoles: Array.from(this.allowedRoles),
      maxMessageLength: this.maxMessageLength,
    });
  }

  /**
   * Validate a single message
   */
  validateMessage(message: any): ValidationResult<ValidatedMessage> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Check role
    if (!message.role) {
      errors.push("Message role is required");
    } else if (!this.allowedRoles.has(message.role)) {
      errors.push(`Invalid message role: ${message.role}`);
    }

    // Check content
    if (message.content === undefined || message.content === null) {
      errors.push("Message content is required");
    } else if (typeof message.content === "string") {
      if (message.content.length > this.maxMessageLength) {
        errors.push(`Message content exceeds maximum length of ${this.maxMessageLength}`);
      }
    } else if (Array.isArray(message.content)) {
      if (message.content.length > this.maxContentArrayLength) {
        errors.push(`Content array exceeds maximum length of ${this.maxContentArrayLength}`);
      }

      // Validate content parts
      for (let i = 0; i < message.content.length; i++) {
        const part = message.content[i];
        const partValidation = this.validateContentPart(part);

        if (!partValidation.valid) {
          errors.push(`Content part ${i}: ${partValidation.error}`);
        }

        warnings.push(...(partValidation.warnings || []));
      }
    } else {
      errors.push("Message content must be a string or array");
    }

    if (errors.length > 0) {
      return {
        valid: false,
        error: errors.join("; "),
        warnings,
      };
    }

    return {
      valid: true,
      data: {
        role: message.role,
        content: message.content,
        name: message.name,
      },
      warnings,
    };
  }

  /**
   * Validate content part
   */
  validateContentPart(part: any): ValidationResult<MessagePart> {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!part.type) {
      errors.push("Content part type is required");
      return { valid: false, error: errors.join("; "), warnings };
    }

    if (!["text", "image_url"].includes(part.type)) {
      errors.push(`Invalid content part type: ${part.type}`);
    }

    if (part.type === "text") {
      if (typeof part.text !== "string" || part.text.length === 0) {
        errors.push("Text part must have non-empty text");
      }
    } else if (part.type === "image_url") {
      if (!part.image_url) {
        errors.push("Image URL part must have image_url");
      } else if (
        typeof part.image_url !== "string" &&
        (!part.image_url.url || typeof part.image_url.url !== "string")
      ) {
        errors.push("Image URL must be a valid URL string");
      } else if (typeof part.image_url === "string" && part.image_url.length > 2000) {
        warnings.push("Image URL is very long, may affect performance");
      }
    }

    return {
      valid: errors.length === 0,
      data: part,
      error: errors.length > 0 ? errors.join("; ") : undefined,
      warnings,
    };
  }

  /**
   * Validate message array
   */
  validateMessageArray(messages: any[]): ValidationResult<ValidatedMessage[]> {
    const errors: string[] = [];
    const warnings: string[] = [];
    const validatedMessages: ValidatedMessage[] = [];

    if (!Array.isArray(messages)) {
      return { valid: false, error: "Messages must be an array" };
    }

    if (messages.length === 0) {
      return { valid: false, error: "Messages array cannot be empty" };
    }

    for (let i = 0; i < messages.length; i++) {
      const messageValidation = this.validateMessage(messages[i]);

      if (!messageValidation.valid) {
        errors.push(`Message ${i}: ${messageValidation.error}`);
      } else if (messageValidation.data) {
        validatedMessages.push(messageValidation.data);
      }

      warnings.push(...(messageValidation.warnings || []));
    }

    if (errors.length > 0) {
      return {
        valid: false,
        error: errors.join("; "),
        warnings,
      };
    }

    return {
      valid: true,
      data: validatedMessages,
      warnings,
    };
  }

  /**
   * Check if message has multimodal content
   */
  hasMultimodalContent(message: any): boolean {
    if (Array.isArray(message.content)) {
      return message.content.some((part: any) => part.type === "image_url");
    }
    return false;
  }

  /**
   * Count multimodal messages
   */
  countMultimodalMessages(messages: any[]): number {
    return messages.filter((m) => this.hasMultimodalContent(m)).length;
  }

  /**
   * Extract image URLs from messages
   */
  extractImageUrls(messages: any[]): string[] {
    const urls: string[] = [];

    for (const message of messages) {
      if (Array.isArray(message.content)) {
        for (const part of message.content) {
          if (part.type === "image_url") {
            const url = typeof part.image_url === "string" ? part.image_url : part.image_url?.url;
            if (url) {
              urls.push(url);
            }
          }
        }
      }
    }

    return urls;
  }

  /**
   * Add allowed role
   */
  addAllowedRole(role: string): void {
    this.allowedRoles.add(role);
  }

  /**
   * Remove allowed role
   */
  removeAllowedRole(role: string): void {
    this.allowedRoles.delete(role);
  }

  /**
   * Get allowed roles
   */
  getAllowedRoles(): string[] {
    return Array.from(this.allowedRoles);
  }
}

/**
 * Create MessageValidation instance
 */
export function createMessageValidation(options?: {
  allowedRoles?: string[];
  maxMessageLength?: number;
  maxContentArrayLength?: number;
}): MessageValidation {
  return new MessageValidation(options);
}
````

## File: src/api/controllers/chat/StreamResponseHandler.ts
````typescript
/**
 * StreamResponseHandler - Streaming Response Handling
 *
 * Handles SSE (Server-Sent Events) streaming responses for chat.
 */

import { Response } from "express";
import { ChatService } from "../../../services/ChatService";
import { parseLLMChunk } from "../../utils/stream-parser";
import { logger } from "../../../utils/logger";
import type { Message } from "../../../types";
import type { ChatRequestOptions } from "../../validators/chat-request-validator";

export interface StreamConfig {
  enableStreamThoughts?: boolean;
  conversationId?: string;
}

/**
 * StreamResponseHandler - Streaming Response Handling
 *
 * Responsible for handling SSE streaming responses.
 */
export class StreamResponseHandler {
  private chatService: ChatService;

  constructor(chatService: ChatService) {
    this.chatService = chatService;
    logger.info("StreamResponseHandler initialized");
  }

  /**
   * Handle streaming response
   */
  async handleStream(
    res: Response,
    messages: Message[],
    options: ChatRequestOptions
  ): Promise<void> {
    const actualModel = options.model || "gpt-4";

    // Set SSE headers
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.setHeader("X-Accel-Buffering", "no");

    const responseId = `chatcmpl-${Date.now()}`;
    let chunkIndex = 0;

    // Check if thinking process streaming is enabled
    const enableStreamThoughts = options.selfThinking?.enableStreamThoughts ?? false;

    try {
      for await (const chunk of this.chatService.streamMessage(messages, options)) {
        // Handle metadata markers
        if (chunk.startsWith("__META__:")) {
          const metaJson = chunk.substring(9);
          try {
            const metaData = JSON.parse(metaJson);

            if (metaData.type === "requestId") {
              res.write(`data: ${JSON.stringify({ requestId: metaData.value })}\n\n`);
            } else if (metaData.type === "interrupted") {
              const interruptedChunk = {
                id: responseId,
                object: "chat.completion.chunk",
                created: Math.floor(Date.now() / 1000),
                model: actualModel,
                choices: [
                  {
                    index: 0,
                    delta: { content: "" },
                    finish_reason: "stop",
                  },
                ],
              };
              res.write(`data: ${JSON.stringify(interruptedChunk)}\n\n`);
              res.write("data: [DONE]\n\n");
              res.end();
              logger.info(`Stream interrupted for request ${responseId}`);
              return;
            }
          } catch (parseError) {
            logger.warn("[StreamResponseHandler] Failed to parse meta chunk:", metaJson);
          }
          continue;
        }

        // Skip thought markers if not enabled
        if (
          !enableStreamThoughts &&
          (chunk.startsWith("__THOUGHT") ||
            chunk.startsWith("__ACTION") ||
            chunk.startsWith("__OBSERVATION") ||
            chunk.startsWith("__ANSWER"))
        ) {
          continue;
        }

        // Handle thought process metadata
        if (chunk.startsWith("__THOUGHT_START__:")) {
          try {
            const data = JSON.parse(chunk.substring(18).trim());
            res.write(`event: thought_start\n`);
            res.write(
              `data: ${JSON.stringify({
                iteration: data.iteration,
                timestamp: data.timestamp,
              })}\n\n`
            );
            chunkIndex++;
          } catch (e) {
            logger.warn("[StreamResponseHandler] Failed to parse thought_start:", e);
          }
          continue;
        }

        if (chunk.startsWith("__THOUGHT__:")) {
          try {
            const data = JSON.parse(chunk.substring(12).trim());
            const sseData = {
              id: responseId,
              object: "chat.completion.chunk",
              created: Math.floor(Date.now() / 1000),
              model: actualModel,
              choices: [
                {
                  index: 0,
                  delta: {
                    content: data.content,
                    role: "assistant",
                  },
                  finish_reason: null,
                },
              ],
              _type: "thought",
              _iteration: data.iteration,
            };
            res.write(`data: ${JSON.stringify(sseData)}\n\n`);
            chunkIndex++;
          } catch (e) {
            logger.warn("[StreamResponseHandler] Failed to parse thought:", e);
          }
          continue;
        }

        if (chunk.startsWith("__THOUGHT_END__:")) {
          try {
            const data = JSON.parse(chunk.substring(16).trim());
            res.write(`event: thought_end\n`);
            res.write(`data: ${JSON.stringify({ iteration: data.iteration })}\n\n`);
            chunkIndex++;
          } catch (e) {
            logger.warn("[StreamResponseHandler] Failed to parse thought_end:", e);
          }
          continue;
        }

        if (chunk.startsWith("__ACTION_START__:")) {
          try {
            const data = JSON.parse(chunk.substring(17).trim());
            res.write(`event: action_start\n`);
            res.write(
              `data: ${JSON.stringify({
                iteration: data.iteration,
                tool: data.tool,
                params: data.params,
              })}\n\n`
            );
            chunkIndex++;
          } catch (e) {
            logger.warn("[StreamResponseHandler] Failed to parse action_start:", e);
          }
          continue;
        }

        if (chunk.startsWith("__OBSERVATION__:")) {
          try {
            const data = JSON.parse(chunk.substring(16).trim());
            res.write(`event: observation\n`);
            res.write(
              `data: ${JSON.stringify({
                iteration: data.iteration,
                tool: data.tool,
                result: data.result,
                error: data.error,
              })}\n\n`
            );
            chunkIndex++;
          } catch (e) {
            logger.warn("[StreamResponseHandler] Failed to parse observation:", e);
          }
          continue;
        }

        if (chunk.startsWith("__ANSWER__:")) {
          try {
            const data = JSON.parse(chunk.substring(11).trim());
            const sseData = {
              id: responseId,
              object: "chat.completion.chunk",
              created: Math.floor(Date.now() / 1000),
              model: actualModel,
              choices: [
                {
                  index: 0,
                  delta: { content: data.content },
                  finish_reason: null,
                },
              ],
              _type: "answer",
            };
            res.write(`data: ${JSON.stringify(sseData)}\n\n`);
            chunkIndex++;
          } catch (e) {
            logger.warn("[StreamResponseHandler] Failed to parse answer:", e);
          }
          continue;
        }

        // Parse LLM chunk
        const parsedChunk = parseLLMChunk(chunk);

        const sseData = {
          id: responseId,
          object: "chat.completion.chunk",
          created: Math.floor(Date.now() / 1000),
          model: actualModel,
          choices: [
            {
              index: 0,
              delta: {
                reasoning_content: parsedChunk.isReasoning ? parsedChunk.content : null,
                content: parsedChunk.isReasoning ? null : parsedChunk.content,
              },
              finish_reason: null,
            },
          ],
        };

        res.write(`data: ${JSON.stringify(sseData)}\n\n`);
        chunkIndex++;
      }

      // Send done signal
      res.write("data: [DONE]\n\n");

      // Send conversationId event if available
      if (options.conversationId) {
        res.write(`event: conversation_id\n`);
        res.write(`data: ${JSON.stringify({ conversationId: options.conversationId })}\n\n`);
      }

      res.end();
      logger.info(`Streamed ${chunkIndex} chunks for request ${responseId}`);
    } catch (streamError: any) {
      logger.error("Error during streaming:", streamError);

      res.write(
        `data: ${JSON.stringify({
          error: {
            message: streamError.message,
            type: "server_error",
          },
        })}\n\n`
      );
      res.end();
    }
  }

  /**
   * Create SSE data for chunk
   */
  createChunkData(
    responseId: string,
    model: string,
    content: string,
    isReasoning: boolean = false
  ): object {
    return {
      id: responseId,
      object: "chat.completion.chunk",
      created: Math.floor(Date.now() / 1000),
      model,
      choices: [
        {
          index: 0,
          delta: {
            reasoning_content: isReasoning ? content : null,
            content: isReasoning ? null : content,
          },
          finish_reason: null,
        },
      ],
    };
  }

  /**
   * Create SSE event
   */
  createEvent(eventType: string, data: object): string {
    return `event: ${eventType}\ndata: ${JSON.stringify(data)}\n\n`;
  }
}

/**
 * Create StreamResponseHandler instance
 */
export function createStreamResponseHandler(chatService: ChatService): StreamResponseHandler {
  return new StreamResponseHandler(chatService);
}
````

## File: src/constants/compression.ts
````typescript
/**
 * 上下文压缩常量
 *
 * 集中管理上下文压缩相关的魔法数字
 */

/**
 * 摘要保留消息数
 * 生成摘要时保留最近的消息数量
 */
export const COMPRESSION = {
  /** 保留最近消息数（用于摘要生成） */
  KEEP_RECENT_MESSAGES: 10,

  /** 摘要最大字符长度（用于截断） */
  SUMMARY_MAX_CHARS: 200,

  /** 消息摘要最大 token 数 */
  SUMMARY_MAX_TOKENS: 500,
} as const;

/**
 * 压缩阈值配置
 */
export const COMPACTION = {
  /** 默认溢出检测阈值（Tokens） */
  OVERFLOW_THRESHOLD: 4000,

  /** 严重溢出阈值（上下文比例） */
  SEVERE_THRESHOLD: 0.8,

  /** 绝对最小 Token 限制 */
  ABSOLUTE_MIN_TOKENS: 1000,

  /** 默认输出保留空间（Tokens） */
  DEFAULT_OUTPUT_RESERVE: 4000,

  /** 默认模型上下文限制 */
  DEFAULT_CONTEXT_LIMIT: 8000,
} as const;
````

## File: src/constants/retention.ts
````typescript
/**
 * 保留和超时常量
 *
 * 集中管理技能保留、超时等时间相关配置
 */

/**
 * 技能自动注销配置
 */
export const SKILL_TIMEOUT_MS = 5 * 60 * 1000; // 5分钟

/**
 * 技能自动注销配置
 */
export const SKILL_RETENTION = {
  /** 技能超时时间（毫秒，5分钟） */
  TIMEOUT_MS: 5 * 60 * 1000,

  /** 清理定时器间隔（毫秒，1分钟） */
  CLEANUP_INTERVAL_MS: 60 * 1000,

  /** 缓存 TTL（毫秒，5分钟） */
  CACHE_TTL_MS: 5 * 60 * 1000,
} as const;

/**
 * 自动注销检查配置
 */
export const AUTO_UNREGISTER = {
  /** 检查间隔（毫秒） */
  CHECK_INTERVAL_MS: 60 * 1000,

  /** 超时时间（毫秒） */
  TIMEOUT_MS: 5 * 60 * 1000,
} as const;
````

## File: src/constants/retrieval.ts
````typescript
/**
 * 检索相关常量定义
 *
 * 集中管理向量检索相关的魔法数字，提高代码可维护性
 */

// ==================== 向量检索常量 ====================

export const VECTOR_RETRIEVAL = {
  /** 默认向量维度 */
  DEFAULT_DIMENSIONS: 384,

  /** 向量搜索相似度阈值 (过滤噪声) */
  SIMILARITY_THRESHOLD: 0.4,

  /** 相关 Skills 检索阈值 (降低以提高召回率) */
  RELEVANT_SKILLS_THRESHOLD: 0.4,

  /** 向量搜索返回数量限制 */
  SEARCH_LIMIT: 10,

  /** 单次向量搜索的最大结果数 */
  MAX_RESULTS: 10,

  /** 向量索引分区数 */
  INDEX_PARTITIONS: 64,

  /** 向量子向量数 */
  INDEX_SUB_VECTORS: 8,
} as const;

// ==================== 缓存常量 ====================

export const CACHE = {
  /** 默认缓存大小 */
  DEFAULT_SIZE: 1000,

  /** Skills 缓存 TTL (毫秒, 5分钟) */
  SKILL_TTL_MS: 5 * 60 * 1000,

  /** 适配器缓存 TTL (毫秒, 5分钟) */
  ADAPTER_TTL_MS: 5 * 60 * 1000,
} as const;

// ==================== 超时常量 (毫秒) ====================

export const RETRIEVAL_TIMEOUT = {
  /** 默认超时 */
  DEFAULT: 30000,

  /** 工具执行超时 */
  TOOL_EXECUTION: 30000,

  /** LLM 请求超时 */
  LLM_REQUEST: 60000,

  /** Skills 超时 */
  SKILL: 30000,

  /** MCP 工具超时 */
  MCP: 60000,

  /** 内置工具超时 */
  BUILTIN: 10000,

  /** 文件读取超时 */
  FILE_READ: 15000,

  /** 文件写入超时 */
  FILE_WRITE: 15000,

  /** 向量搜索超时 */
  VECTOR_SEARCH: 20000,

  /** 网络搜索超时 */
  WEB_SEARCH: 30000,

  /** 清理定时器间隔 */
  CLEANUP_INTERVAL: 60000,

  /** 技能自动注销时间 (毫秒, 5分钟) */
  SKILL_AUTO_UNREGISTER: 5 * 60 * 1000,
} as const;

// ==================== 导出辅助函数 ====================

/**
 * 获取超时时间
 */
export function getRetrievalTimeout(key: keyof typeof RETRIEVAL_TIMEOUT): number {
  return RETRIEVAL_TIMEOUT[key];
}

/**
 * 获取向量检索配置
 */
export function getVectorRetrievalConfig() {
  return {
    dimensions: VECTOR_RETRIEVAL.DEFAULT_DIMENSIONS,
    similarityThreshold: VECTOR_RETRIEVAL.SIMILARITY_THRESHOLD,
    searchLimit: VECTOR_RETRIEVAL.SEARCH_LIMIT,
  };
}
````

## File: src/services/skill/BuiltInSkillLoader.ts
````typescript
/**
 * BuiltInSkillLoader - Built-in Skill Loading
 *
 * Handles loading and registration of built-in skills during startup.
 */

import * as fs from "fs/promises";
import * as path from "path";
import { logger } from "../../utils/logger";
import { ToolRetrievalService } from "../ToolRetrievalService";
import { SkillMetadata, SkillTool, ToolType } from "../../types/tool-system";

export interface BuiltInSkillInfo {
  name: string;
  description: string;
  category?: string;
  version: string;
  tags: string[];
  author?: string;
  path: string;
}

/**
 * BuiltInSkillLoader - Built-in Skill Loading
 *
 * Responsible for loading built-in skills during system startup.
 */
export class BuiltInSkillLoader {
  private retrievalService: ToolRetrievalService;
  private builtInSkillsDir: string;

  constructor(retrievalService: ToolRetrievalService, builtInSkillsDir: string = "./skills") {
    this.retrievalService = retrievalService;
    this.builtInSkillsDir = builtInSkillsDir;
    logger.info("BuiltInSkillLoader initialized", {
      builtInSkillsDir,
    });
  }

  /**
   * Load all built-in skills
   */
  async loadAllBuiltInSkills(): Promise<BuiltInSkillInfo[]> {
    logger.info("Loading built-in skills from:", this.builtInSkillsDir);

    try {
      const entries = await fs.readdir(this.builtInSkillsDir, { withFileTypes: true });
      const skillDirs = entries.filter((entry) => entry.isDirectory()).map((entry) => entry.name);

      const loadedSkills: BuiltInSkillInfo[] = [];

      for (const skillName of skillDirs) {
        try {
          const skillPath = path.join(this.builtInSkillsDir, skillName);
          const metadata = await this.loadBuiltInSkill(skillPath);

          if (metadata) {
            loadedSkills.push({
              ...metadata,
              path: skillPath,
            });
          }
        } catch (error) {
          logger.warn(`Failed to load built-in skill: ${skillName}`, error);
        }
      }

      logger.info(`Loaded ${loadedSkills.length} built-in skills`);
      return loadedSkills;
    } catch (error) {
      logger.warn("Failed to load built-in skills directory:", error);
      return [];
    }
  }

  /**
   * Load a single built-in skill
   */
  async loadBuiltInSkill(skillPath: string): Promise<SkillMetadata | null> {
    try {
      const skillMdPath = path.join(skillPath, "SKILL.md");

      if (!(await this.fileExists(skillMdPath))) {
        logger.warn(`SKILL.md not found for built-in skill: ${skillPath}`);
        return null;
      }

      const content = await fs.readFile(skillMdPath, "utf8");
      const metadata = await this.parseSkillMetadata(content);

      // Index the built-in skill
      await this.retrievalService.indexSkill({
        name: metadata.name,
        description: metadata.description,
        tags: metadata.tags || [],
        path: skillPath,
        version: metadata.version,
        metadata: metadata,
      });

      logger.debug(`Loaded built-in skill: ${metadata.name}`);
      return metadata;
    } catch (error) {
      logger.warn(`Failed to load built-in skill: ${skillPath}`, error);
      return null;
    }
  }

  /**
   * Parse skill metadata from content
   */
  private async parseSkillMetadata(content: string): Promise<SkillMetadata> {
    const matter = await import("gray-matter");
    const parsed = matter.default(content);

    return {
      name: parsed.data.name || "Unnamed Skill",
      description: parsed.data.description || "",
      category: parsed.data.category || "uncategorized",
      tools: parsed.data.tools || [],
      version: parsed.data.version || "1.0.0",
      tags: parsed.data.tags || [],
      author: parsed.data.author || "System",
      dependencies: parsed.data.dependencies || [],
      parameters: parsed.data.parameters,
    };
  }

  /**
   * Convert to SkillTool format
   */
  convertToSkillTool(metadata: SkillMetadata, skillPath: string): SkillTool {
    return {
      name: metadata.name,
      type: ToolType.SKILL,
      description: metadata.description,
      parameters: metadata.parameters || {
        type: "object",
        properties: {},
        required: [],
      },
      version: metadata.version,
      tags: metadata.tags,
      author: metadata.author,
      enabled: true,
      path: skillPath,
      level: 1,
    };
  }

  /**
   * Check if file exists
   */
  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get built-in skills directory
   */
  getBuiltInSkillsDir(): string {
    return this.builtInSkillsDir;
  }
}

/**
 * Create BuiltInSkillLoader instance
 */
export function createBuiltInSkillLoader(
  retrievalService: ToolRetrievalService,
  builtInSkillsDir?: string
): BuiltInSkillLoader {
  return new BuiltInSkillLoader(retrievalService, builtInSkillsDir);
}
````

## File: src/services/skill/DynamicSkillManager.ts
````typescript
/**
 * DynamicSkillManager - Dynamic Skill Management
 *
 * Handles dynamically adding, removing, and updating skills at runtime.
 */

import { logger } from "../../utils/logger";
import { ToolRetrievalService } from "../ToolRetrievalService";
import {
  SkillMetadata,
  SkillTool,
  ToolType,
  ToolError,
  ToolErrorCode,
} from "../../types/tool-system";
import { SkillValidator } from "./SkillValidator";
import { UserSkillLoader } from "./UserSkillLoader";
import { BuiltInSkillLoader } from "./BuiltInSkillLoader";

export interface DynamicSkillUpdate {
  skillName: string;
  type: "add" | "remove" | "update" | "enable" | "disable";
  timestamp: Date;
  metadata?: SkillMetadata;
  error?: string;
}

export interface DynamicSkillStats {
  totalSkills: number;
  enabledSkills: number;
  disabledSkills: number;
  recentlyAdded: string[];
  recentlyRemoved: string[];
}

/**
 * DynamicSkillManager - Dynamic Skill Management
 *
 * Responsible for managing skills dynamically at runtime.
 */
export class DynamicSkillManager {
  private retrievalService: ToolRetrievalService;
  private validator: SkillValidator;
  private userLoader: UserSkillLoader;
  private builtInLoader: BuiltInSkillLoader;

  // Track dynamic changes
  private updateHistory: DynamicSkillUpdate[] = [];
  private disabledSkills: Set<string> = new Set();

  constructor(
    retrievalService: ToolRetrievalService,
    userLoader: UserSkillLoader,
    builtInLoader: BuiltInSkillLoader
  ) {
    this.retrievalService = retrievalService;
    this.validator = new SkillValidator();
    this.userLoader = userLoader;
    this.builtInLoader = builtInLoader;

    logger.info("DynamicSkillManager initialized");
  }

  /**
   * Add a new skill dynamically
   */
  async addSkill(skillData: {
    name: string;
    description: string;
    tags?: string[];
    version?: string;
    metadata?: Record<string, any>;
  }): Promise<{ success: boolean; skillName?: string; error?: string }> {
    try {
      logger.info(`Adding dynamic skill: ${skillData.name}`);

      // Validate skill data
      const validation = this.validator.validateMetadata(skillData);
      if (!validation.valid) {
        return {
          success: false,
          error: validation.errors.join(", "),
        };
      }

      // Create metadata
      const metadata: SkillMetadata = {
        name: skillData.name,
        description: skillData.description,
        category: "dynamic",
        tools: [],
        version: skillData.version || "1.0.0",
        tags: skillData.tags || [],
        author: "Dynamic",
        dependencies: [],
        parameters: undefined,
        ...skillData.metadata,
      };

      // Index the skill
      await this.retrievalService.indexSkill({
        name: metadata.name,
        description: metadata.description,
        tags: metadata.tags || [],
        path: "", // Dynamic skills may not have a path
        version: metadata.version,
        metadata: metadata,
      });

      // Track the update
      this.recordUpdate({
        skillName: metadata.name,
        type: "add",
        timestamp: new Date(),
        metadata,
      });

      logger.info(`Successfully added dynamic skill: ${metadata.name}`);
      return {
        success: true,
        skillName: metadata.name,
      };
    } catch (error) {
      logger.error(`Failed to add dynamic skill: ${skillData.name}`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Remove a skill dynamically
   */
  async removeSkill(skillName: string): Promise<{ success: boolean; error?: string }> {
    try {
      logger.info(`Removing dynamic skill: ${skillName}`);

      // Check if skill is disabled
      if (this.disabledSkills.has(skillName)) {
        this.disabledSkills.delete(skillName);
      }

      // Remove from index
      await this.retrievalService.removeSkill(skillName);

      // Track the update
      this.recordUpdate({
        skillName,
        type: "remove",
        timestamp: new Date(),
      });

      logger.info(`Successfully removed dynamic skill: ${skillName}`);
      return { success: true };
    } catch (error) {
      logger.error(`Failed to remove dynamic skill: ${skillName}`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Update a skill dynamically
   */
  async updateSkill(
    skillName: string,
    updates: Partial<SkillMetadata>
  ): Promise<{ success: boolean; error?: string }> {
    try {
      logger.info(`Updating dynamic skill: ${skillName}`);

      // Validate updates
      const validation = this.validator.validateMetadata({
        name: updates.name,
        description: updates.description,
        version: updates.version,
        tags: updates.tags,
      });

      if (!validation.valid) {
        return {
          success: false,
          error: validation.errors.join(", "),
        };
      }

      // Remove old version
      await this.retrievalService.removeSkill(skillName);

      // Add updated version
      await this.retrievalService.indexSkill({
        name: updates.name || skillName,
        description: updates.description || "",
        tags: updates.tags || [],
        version: updates.version || "1.0.0",
        path: "",
        metadata: updates,
      });

      // Track the update
      this.recordUpdate({
        skillName: updates.name || skillName,
        type: "update",
        timestamp: new Date(),
      });

      logger.info(`Successfully updated dynamic skill: ${skillName}`);
      return { success: true };
    } catch (error) {
      logger.error(`Failed to update dynamic skill: ${skillName}`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Enable a skill
   */
  async enableSkill(skillName: string): Promise<{ success: boolean; error?: string }> {
    try {
      logger.info(`Enabling skill: ${skillName}`);

      if (this.disabledSkills.has(skillName)) {
        this.disabledSkills.delete(skillName);

        this.recordUpdate({
          skillName,
          type: "enable",
          timestamp: new Date(),
        });

        logger.info(`Successfully enabled skill: ${skillName}`);
        return { success: true };
      }

      return {
        success: false,
        error: `Skill ${skillName} is not disabled`,
      };
    } catch (error) {
      logger.error(`Failed to enable skill: ${skillName}`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Disable a skill
   */
  async disableSkill(skillName: string): Promise<{ success: boolean; error?: string }> {
    try {
      logger.info(`Disabling skill: ${skillName}`);

      if (!this.disabledSkills.has(skillName)) {
        this.disabledSkills.add(skillName);

        this.recordUpdate({
          skillName,
          type: "disable",
          timestamp: new Date(),
        });

        logger.info(`Successfully disabled skill: ${skillName}`);
        return { success: true };
      }

      return {
        success: false,
        error: `Skill ${skillName} is already disabled`,
      };
    } catch (error) {
      logger.error(`Failed to disable skill: ${skillName}`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Get all dynamic skills
   */
  async getAllDynamicSkills(): Promise<SkillTool[]> {
    // This would query the retrieval service for all indexed skills
    // that are marked as dynamic
    const allSkills = await this.listSkills(1000);
    return allSkills.filter((skill) => !skill.path || skill.path === "");
  }

  /**
   * List skills with filtering
   */
  async listSkills(limit: number = 50): Promise<SkillTool[]> {
    try {
      // This is a simplified implementation
      // In practice, this would query the retrieval service
      const stats = await this.retrievalService.getStatistics();
      logger.debug("Listing skills, current stats:", stats);

      return [];
    } catch (error) {
      logger.error("Failed to list skills:", error);
      return [];
    }
  }

  /**
   * Get dynamic skill statistics
   */
  async getStats(): Promise<DynamicSkillStats> {
    const allSkills = await this.getAllDynamicSkills();

    return {
      totalSkills: allSkills.length,
      enabledSkills: allSkills.filter((s) => !this.disabledSkills.has(s.name)).length,
      disabledSkills: this.disabledSkills.size,
      recentlyAdded: this.updateHistory
        .filter((u) => u.type === "add")
        .slice(-5)
        .map((u) => u.skillName),
      recentlyRemoved: this.updateHistory
        .filter((u) => u.type === "remove")
        .slice(-5)
        .map((u) => u.skillName),
    };
  }

  /**
   * Get update history
   */
  getUpdateHistory(limit: number = 50): DynamicSkillUpdate[] {
    return this.updateHistory.slice(-limit);
  }

  /**
   * Get disabled skills
   */
  getDisabledSkills(): string[] {
    return Array.from(this.disabledSkills);
  }

  /**
   * Check if skill is enabled
   */
  isSkillEnabled(skillName: string): boolean {
    return !this.disabledSkills.has(skillName);
  }

  /**
   * Record an update
   */
  private recordUpdate(update: DynamicSkillUpdate): void {
    this.updateHistory.push(update);

    // Keep history limited
    if (this.updateHistory.length > 1000) {
      this.updateHistory = this.updateHistory.slice(-500);
    }
  }

  /**
   * Clear update history
   */
  clearHistory(): void {
    this.updateHistory = [];
  }
}

/**
 * Create DynamicSkillManager instance
 */
export function createDynamicSkillManager(
  retrievalService: ToolRetrievalService,
  userLoader: UserSkillLoader,
  builtInLoader: BuiltInSkillLoader
): DynamicSkillManager {
  return new DynamicSkillManager(retrievalService, userLoader, builtInLoader);
}
````

## File: src/services/skill/index.ts
````typescript
/**
 * skill module - Unified Exports
 *
 * Main entry point for the skill management service module.
 */

// Types
export * from "../../types/tool-system";

// Main service
export { SkillManager, getSkillManager } from "./SkillManager";
export type { InstallResult, UninstallResult, UpdateResult } from "./SkillManager";

// Sub-modules
export { BuiltInSkillLoader, createBuiltInSkillLoader } from "./BuiltInSkillLoader";
export type { BuiltInSkillInfo } from "./BuiltInSkillLoader";

export { UserSkillLoader, createUserSkillLoader } from "./UserSkillLoader";
export type { UserSkillLoadResult } from "./UserSkillLoader";

export { DynamicSkillManager, createDynamicSkillManager } from "./DynamicSkillManager";
export type { DynamicSkillUpdate, DynamicSkillStats } from "./DynamicSkillManager";

export { SkillValidator, createSkillValidator } from "./SkillValidator";
export type { ValidationResult, SkillValidationConfig } from "./SkillValidator";
````

## File: src/services/skill/SkillManager.ts
````typescript
/**
 * SkillManager - Skill Management Coordinator
 *
 * Main coordinator for skill management, orchestrating all skill-related operations.
 */

import * as fs from "fs/promises";
import * as path from "path";
import { logger } from "../../utils/logger";
import { ToolRetrievalService } from "../ToolRetrievalService";
import {
  SkillTool,
  SkillInstallOptions,
  SkillListOptions,
  SkillListResult,
  ToolType,
} from "../../types/tool-system";
import { BuiltInSkillLoader, createBuiltInSkillLoader } from "./BuiltInSkillLoader";
import { UserSkillLoader, createUserSkillLoader } from "./UserSkillLoader";
import { DynamicSkillManager, createDynamicSkillManager } from "./DynamicSkillManager";
import { SkillValidator, createSkillValidator } from "./SkillValidator";

export interface InstallResult {
  success: boolean;
  message: string;
  skillName?: string;
  installedAt?: Date;
  duration?: number;
  vectorized?: boolean;
}

export interface UninstallResult {
  success: boolean;
  message: string;
  skillName?: string;
  uninstalledAt?: Date;
  duration?: number;
}

export interface UpdateResult {
  success: boolean;
  message: string;
  skillName?: string;
  updatedAt?: Date;
  duration?: number;
  reindexed?: boolean;
}

/**
 * SkillManager - Main Skill Management Coordinator
 *
 * Orchestrates all skill-related operations including loading,
 * installation, uninstallation, updates, and dynamic management.
 */
export class SkillManager {
  private static instance: SkillManager | null = null;

  private retrievalService: ToolRetrievalService;
  private builtInLoader: BuiltInSkillLoader;
  private userLoader: UserSkillLoader;
  private dynamicManager: DynamicSkillManager;
  private validator: SkillValidator;
  private skillsBasePath: string;
  private initializationPromise: Promise<void> | null = null;

  protected constructor(skillsBasePath?: string) {
    // Initialize services
    const pathService = require("../PathService").PathService.getInstance();
    const dataDir = pathService.getDataDir();
    this.skillsBasePath = skillsBasePath || path.join(dataDir, "skills");

    const vectorDbPath = path.join(dataDir, "skills.lance");
    this.retrievalService = new ToolRetrievalService({
      vectorDbPath,
      model: "all-MiniLM-L6-v2",
      dimensions: 384,
      similarityThreshold: 0.4,
      cacheSize: 1000,
    });

    // Initialize loaders and managers
    this.builtInLoader = createBuiltInSkillLoader(this.retrievalService);
    this.userLoader = createUserSkillLoader(this.retrievalService, this.skillsBasePath);
    this.dynamicManager = createDynamicSkillManager(
      this.retrievalService,
      this.userLoader,
      this.builtInLoader
    );
    this.validator = createSkillValidator();

    logger.debug("SkillManager initialized", {
      skillsBasePath: this.skillsBasePath,
    });

    // Start async initialization
    this.initializationPromise = this.initializeSkillsIndex().catch((error) => {
      logger.error("Failed to initialize skills index during startup:", error);
    });
  }

  /**
   * Get singleton instance
   */
  static getInstance(skillsBasePath?: string): SkillManager {
    if (!SkillManager.instance) {
      SkillManager.instance = new SkillManager(skillsBasePath);
    }
    return SkillManager.instance;
  }

  /**
   * Reset instance (for testing)
   */
  static resetInstance(): void {
    SkillManager.instance = null;
  }

  /**
   * Install a skill from ZIP buffer
   */
  async installSkill(zipBuffer: Buffer, options: SkillInstallOptions = {}): Promise<InstallResult> {
    const startTime = Date.now();

    try {
      const result = await this.userLoader.installSkillFromZip(zipBuffer, options);

      if (result.success && result.metadata) {
        return {
          success: true,
          message: `Skill '${result.skillName}' installed successfully`,
          skillName: result.skillName,
          installedAt: new Date(),
          duration: Date.now() - startTime,
          vectorized: true,
        };
      } else {
        return {
          success: false,
          message: result.error || "Installation failed",
          duration: Date.now() - startTime,
        };
      }
    } catch (error) {
      logger.error("Skill installation failed:", error);
      return {
        success: false,
        message: error instanceof Error ? error.message : "Installation failed",
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * Uninstall a skill
   */
  async uninstallSkill(skillName: string): Promise<UninstallResult> {
    const startTime = Date.now();

    try {
      const result = await this.userLoader.uninstallSkill(skillName);

      if (result.success) {
        return {
          success: true,
          message: `Skill '${skillName}' uninstalled successfully`,
          skillName,
          uninstalledAt: new Date(),
          duration: Date.now() - startTime,
        };
      } else {
        return {
          success: false,
          message: result.error || "Uninstallation failed",
          skillName,
          duration: Date.now() - startTime,
        };
      }
    } catch (error) {
      logger.error("Skill uninstallation failed:", error);
      return {
        success: false,
        message: error instanceof Error ? error.message : "Uninstallation failed",
        skillName,
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * Update a skill
   */
  async updateSkill(skillName: string, newDescription: string): Promise<UpdateResult> {
    const startTime = Date.now();

    try {
      const result = await this.userLoader.updateSkillDescription(skillName, newDescription);

      if (result.success) {
        return {
          success: true,
          message: `Skill '${skillName}' updated successfully`,
          skillName,
          updatedAt: new Date(),
          duration: Date.now() - startTime,
          reindexed: true,
        };
      } else {
        return {
          success: false,
          message: result.error || "Update failed",
          skillName,
          duration: Date.now() - startTime,
        };
      }
    } catch (error) {
      logger.error("Skill update failed:", error);
      return {
        success: false,
        message: error instanceof Error ? error.message : "Update failed",
        skillName,
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * List all skills
   */
  async listSkills(options: SkillListOptions = {}): Promise<SkillListResult> {
    try {
      const skills = await this.dynamicManager.listSkills(options.limit || 50);

      // Apply filtering
      let filtered = skills;

      if (options.name) {
        const nameFilter = options.name.toLowerCase();
        filtered = filtered.filter(
          (skill) =>
            skill.name.toLowerCase().includes(nameFilter) ||
            skill.description.toLowerCase().includes(nameFilter)
        );
      }

      if (options.tags && options.tags.length > 0) {
        filtered = filtered.filter((skill) =>
          skill.tags.some((tag) => options.tags!.includes(tag))
        );
      }

      // Sort
      const sortBy = options.sortBy || "name";
      const sortOrder = options.sortOrder || "asc";
      filtered.sort((a, b) => {
        let aVal: any, bVal: any;
        switch (sortBy) {
          case "name":
            aVal = a.name;
            bVal = b.name;
            break;
          default:
            aVal = a.name;
            bVal = b.name;
        }
        const compare = String(aVal).localeCompare(String(bVal));
        return sortOrder === "desc" ? -compare : compare;
      });

      // Paginate
      const page = options.page || 1;
      const limit = options.limit || 50;
      const startIndex = (page - 1) * limit;
      const endIndex = startIndex + limit;
      const paginated = filtered.slice(startIndex, endIndex);

      return {
        skills: paginated,
        total: filtered.length,
        page,
        limit,
        totalPages: Math.ceil(filtered.length / limit),
      };
    } catch (error) {
      logger.error("Failed to list skills:", error);
      throw error;
    }
  }

  /**
   * Get a specific skill by name
   */
  async getSkillByName(skillName: string): Promise<SkillTool | null> {
    try {
      const skills = await this.dynamicManager.listSkills(1000);
      return skills.find((s) => s.name === skillName) || null;
    } catch (error) {
      logger.error(`Failed to get skill: ${skillName}`, error);
      return null;
    }
  }

  /**
   * Check if a skill exists
   */
  async isSkillExist(skillName: string): Promise<boolean> {
    const skill = await this.getSkillByName(skillName);
    return skill !== null;
  }

  /**
   * Add a dynamic skill
   */
  async addDynamicSkill(skillData: {
    name: string;
    description: string;
    tags?: string[];
    version?: string;
    metadata?: Record<string, any>;
  }): Promise<{ success: boolean; skillName?: string; error?: string }> {
    return this.dynamicManager.addSkill(skillData);
  }

  /**
   * Remove a dynamic skill
   */
  async removeDynamicSkill(skillName: string): Promise<{ success: boolean; error?: string }> {
    return this.dynamicManager.removeSkill(skillName);
  }

  /**
   * Enable a skill
   */
  async enableSkill(skillName: string): Promise<{ success: boolean; error?: string }> {
    return this.dynamicManager.enableSkill(skillName);
  }

  /**
   * Disable a skill
   */
  async disableSkill(skillName: string): Promise<{ success: boolean; error?: string }> {
    return this.dynamicManager.disableSkill(skillName);
  }

  /**
   * Get skill statistics
   */
  async getStatistics(): Promise<{
    total: number;
    enabled: number;
    disabled: number;
    byTag: Record<string, number>;
  }> {
    const stats = await this.dynamicManager.getStats();
    const skills = await this.dynamicManager.getAllDynamicSkills();

    const byTag: Record<string, number> = {};
    for (const skill of skills) {
      for (const tag of skill.tags) {
        byTag[tag] = (byTag[tag] || 0) + 1;
      }
    }

    return {
      total: stats.totalSkills,
      enabled: stats.enabledSkills,
      disabled: stats.disabledSkills,
      byTag,
    };
  }

  /**
   * Get retrieval service
   */
  getRetrievalService(): ToolRetrievalService {
    return this.retrievalService;
  }

  /**
   * Wait for initialization
   */
  async waitForInitialization(): Promise<void> {
    if (this.initializationPromise) {
      try {
        await this.initializationPromise;
      } catch (error) {
        logger.warn("Skills initialization failed, but system will continue", error);
      }
    }
  }

  /**
   * Initialize skills index
   */
  private async initializeSkillsIndex(): Promise<void> {
    logger.debug("Initializing skills index during startup");

    try {
      await this.retrievalService.initialize();
      await this.retrievalService.scanAndIndexAllSkills(this.skillsBasePath);

      logger.debug("Skills index initialization completed");
    } catch (error) {
      logger.error("Failed to initialize skills index:", error);
      throw error;
    }
  }
}

/**
 * Get default SkillManager
 */
export function getSkillManager(skillsBasePath?: string): SkillManager {
  return SkillManager.getInstance(skillsBasePath);
}
````

## File: src/services/skill/SkillValidator.ts
````typescript
/**
 * SkillValidator - Skill Validation Logic
 *
 * Handles skill definition validation, structure checks, and metadata verification.
 */

import * as fs from "fs/promises";
import * as path from "path";
import matter from "gray-matter";
import { logger } from "../../utils/logger";
import { SkillMetadata, SkillTool, ToolError, ToolErrorCode } from "../../types/tool-system";

export interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
  metadata?: SkillMetadata;
}

export interface SkillValidationConfig {
  requireName?: boolean;
  requireDescription?: boolean;
  requireVersion?: boolean;
  requireScripts?: boolean;
  maxDescriptionLength?: number;
  maxTagsCount?: number;
  maxNameLength?: number;
}

const DEFAULT_CONFIG: SkillValidationConfig = {
  requireName: true,
  requireDescription: true,
  requireVersion: true,
  requireScripts: false,
  maxDescriptionLength: 1024,
  maxTagsCount: 10,
  maxNameLength: 100,
};

/**
 * SkillValidator - Skill Validation Logic
 *
 * Responsible for validating skill definitions and structure.
 */
export class SkillValidator {
  private config: SkillValidationConfig;

  constructor(config: Partial<SkillValidationConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Validate skill metadata
   */
  validateMetadata(metadata: Partial<SkillMetadata>): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Required fields
    if (this.config.requireName && !metadata.name) {
      errors.push("Skill name is required");
    }

    if (this.config.requireDescription && !metadata.description) {
      errors.push("Skill description is required");
    }

    if (this.config.requireVersion && !metadata.version) {
      errors.push("Skill version is required");
    }

    // Length validations
    if (metadata.name && metadata.name.length > this.config.maxNameLength) {
      errors.push(`Skill name exceeds maximum length of ${this.config.maxNameLength}`);
    }

    if (metadata.description && metadata.description.length > this.config.maxDescriptionLength) {
      errors.push(
        `Skill description exceeds maximum length of ${this.config.maxDescriptionLength}`
      );
    }

    if (metadata.tags && metadata.tags.length > this.config.maxTagsCount) {
      warnings.push(`Skill has more than ${this.config.maxTagsCount} tags`);
    }

    // Version format validation
    if (metadata.version && !this.isValidVersion(metadata.version)) {
      errors.push("Invalid version format. Expected semantic versioning (e.g., 1.0.0)");
    }

    // Tags validation
    if (metadata.tags) {
      for (let i = 0; i < metadata.tags.length; i++) {
        const tag = metadata.tags[i];
        if (typeof tag !== "string") {
          errors.push(`Tag at index ${i} is not a string`);
        } else if (tag.length === 0) {
          errors.push(`Tag at index ${i} is empty`);
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
      metadata: errors.length === 0 ? (metadata as SkillMetadata) : undefined,
    };
  }

  /**
   * Validate skill directory structure
   */
  async validateSkillDirectory(skillPath: string): Promise<ValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    try {
      // Check if directory exists
      const exists = await this.directoryExists(skillPath);
      if (!exists) {
        return {
          valid: false,
          errors: [`Skill directory does not exist: ${skillPath}`],
          warnings: [],
        };
      }

      // Check for SKILL.md
      const skillMdPath = path.join(skillPath, "SKILL.md");
      if (!(await this.fileExists(skillMdPath))) {
        errors.push("SKILL.md is required");
        return {
          valid: false,
          errors,
          warnings,
        };
      }

      // Read and parse SKILL.md
      const content = await fs.readFile(skillMdPath, "utf8");
      const parsed = matter(content);

      // Validate metadata
      const metadataValidation = this.validateMetadata(parsed.data);
      errors.push(...metadataValidation.errors);
      warnings.push(...metadataValidation.warnings);

      // Check scripts directory if required
      if (this.config.requireScripts) {
        const scriptsDir = path.join(skillPath, "scripts");
        if (!(await this.directoryExists(scriptsDir))) {
          errors.push("Scripts directory is required in strict validation mode");
        } else {
          const executeScript = path.join(scriptsDir, "execute.js");
          if (!(await this.fileExists(executeScript))) {
            errors.push("execute.js is required in scripts directory");
          }
        }
      }

      return {
        valid: errors.length === 0,
        errors,
        warnings,
        metadata: metadataValidation.valid ? (parsed.data as SkillMetadata) : undefined,
      };
    } catch (error) {
      logger.error(`Failed to validate skill directory: ${skillPath}`, error);
      return {
        valid: false,
        errors: [`Validation failed: ${error instanceof Error ? error.message : String(error)}`],
        warnings: [],
      };
    }
  }

  /**
   * Validate skill tool definition
   */
  validateSkillTool(tool: Partial<SkillTool>): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!tool.name) {
      errors.push("Tool name is required");
    }

    if (!tool.description) {
      errors.push("Tool description is required");
    }

    if (tool.parameters) {
      if (tool.parameters.type !== "object") {
        errors.push("Parameters must be of type object");
      }

      if (tool.parameters.properties) {
        for (const [key, prop] of Object.entries(tool.parameters.properties)) {
          const property = prop as any;
          if (!property.type) {
            warnings.push(`Property '${key}' has no type defined`);
          }
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  /**
   * Validate skill installation options
   */
  validateInstallOptions(options: {
    overwrite?: boolean;
    skipVectorization?: boolean;
    validationLevel?: "basic" | "strict";
  }): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (options.validationLevel && !["basic", "strict"].includes(options.validationLevel)) {
      errors.push(`Invalid validation level: ${options.validationLevel}`);
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * Check if directory exists
   */
  private async directoryExists(dirPath: string): Promise<boolean> {
    try {
      const stat = await fs.stat(dirPath);
      return stat.isDirectory();
    } catch {
      return false;
    }
  }

  /**
   * Check if file exists
   */
  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Validate semantic version format
   */
  private isValidVersion(version: string): boolean {
    // Basic semantic versioning regex
    const semverRegex = /^\d+\.\d+\.\d+(-[a-zA-Z0-9.-]+)?(\+[a-zA-Z0-9.-]+)?$/;
    return semverRegex.test(version);
  }

  /**
   * Update validation config
   */
  updateConfig(config: Partial<SkillValidationConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Get current config
   */
  getConfig(): SkillValidationConfig {
    return { ...this.config };
  }
}

/**
 * Create SkillValidator instance
 */
export function createSkillValidator(config?: Partial<SkillValidationConfig>): SkillValidator {
  return new SkillValidator(config);
}
````

## File: src/services/skill/UserSkillLoader.ts
````typescript
/**
 * UserSkillLoader - User Skill Loading
 *
 * Handles loading user-defined skills from the skills directory.
 */

import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";
import * as crypto from "crypto";
import * as AdmZip from "adm-zip";
import matter from "gray-matter";
import { logger } from "../../utils/logger";
import { SkillMetadata, SkillTool, ToolType, SkillInstallOptions } from "../../types/tool-system";
import { ToolRetrievalService } from "../ToolRetrievalService";

export interface UserSkillLoadResult {
  success: boolean;
  skillName?: string;
  metadata?: SkillMetadata;
  error?: string;
}

/**
 * UserSkillLoader - User Skill Loading
 *
 * Responsible for loading and managing user-defined skills.
 */
export class UserSkillLoader {
  private retrievalService: ToolRetrievalService;
  private skillsBasePath: string;

  constructor(retrievalService: ToolRetrievalService, skillsBasePath: string) {
    this.retrievalService = retrievalService;
    this.skillsBasePath = skillsBasePath;
    logger.info("UserSkillLoader initialized", {
      skillsBasePath,
    });
  }

  /**
   * Load all user skills
   */
  async loadAllUserSkills(): Promise<UserSkillLoadResult[]> {
    logger.info("Loading user skills from:", this.skillsBasePath);

    try {
      await this.ensureSkillsDirectory();

      const entries = await fs.readdir(this.skillsBasePath, { withFileTypes: true });
      const skillDirs = entries.filter((entry) => entry.isDirectory()).map((entry) => entry.name);

      const results: UserSkillLoadResult[] = [];

      for (const skillName of skillDirs) {
        try {
          const skillPath = path.join(this.skillsBasePath, skillName);
          const result = await this.loadUserSkill(skillPath);
          results.push(result);
        } catch (error) {
          results.push({
            success: false,
            skillName,
            error: error instanceof Error ? error.message : String(error),
          });
        }
      }

      logger.info(`Loaded ${results.filter((r) => r.success).length} user skills`);
      return results;
    } catch (error) {
      logger.warn("Failed to load user skills directory:", error);
      return [];
    }
  }

  /**
   * Load a single user skill
   */
  async loadUserSkill(skillPath: string): Promise<UserSkillLoadResult> {
    try {
      const skillName = path.basename(skillPath);
      const metadata = await this.readSkillMetadata(skillPath);

      // Index the user skill
      await this.retrievalService.indexSkill({
        name: metadata.name,
        description: metadata.description,
        tags: metadata.tags || [],
        path: skillPath,
        version: metadata.version,
        metadata: metadata,
      });

      logger.debug(`Loaded user skill: ${metadata.name}`);
      return {
        success: true,
        skillName: metadata.name,
        metadata,
      };
    } catch (error) {
      logger.warn(`Failed to load user skill: ${skillPath}`, error);
      return {
        success: false,
        skillName: path.basename(skillPath),
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Install a skill from ZIP buffer
   */
  async installSkillFromZip(
    zipBuffer: Buffer,
    options: SkillInstallOptions = {}
  ): Promise<UserSkillLoadResult> {
    try {
      // Extract to temp directory
      const tempDir = await this.extractZipToTemp(zipBuffer);
      logger.debug(`Extracted ZIP to temp directory: ${tempDir}`);

      // Validate skill structure
      const metadata = await this.validateSkillStructure(tempDir, options.validationLevel);

      // Check for name conflicts
      const targetDir = path.join(this.skillsBasePath, metadata.name);
      const exists = await this.directoryExists(targetDir);

      if (exists && !options.overwrite) {
        return {
          success: false,
          skillName: metadata.name,
          error: `Skill '${metadata.name}' already exists. Use overwrite: true to replace.`,
        };
      }

      // If exists and overwrite, remove first
      if (exists) {
        await this.removeSkillDirectory(targetDir);
      }

      // Move to target directory
      await fs.mkdir(path.dirname(targetDir), { recursive: true });
      await fs.rename(tempDir, targetDir);

      // Create .vectorized file
      const vectorizedFile = path.join(targetDir, ".vectorized");
      await fs.writeFile(vectorizedFile, "");

      // Index the skill
      await this.retrievalService.indexSkill({
        name: metadata.name,
        description: metadata.description,
        tags: metadata.tags || [],
        path: targetDir,
        version: metadata.version,
        metadata: metadata,
      });

      logger.info(`Successfully installed user skill: ${metadata.name}`);
      return {
        success: true,
        skillName: metadata.name,
        metadata,
      };
    } catch (error) {
      logger.error("Failed to install skill from ZIP:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Uninstall a user skill
   */
  async uninstallSkill(skillName: string): Promise<UserSkillLoadResult> {
    try {
      const skillPath = path.join(this.skillsBasePath, skillName);

      if (!(await this.directoryExists(skillPath))) {
        return {
          success: false,
          skillName,
          error: `Skill '${skillName}' not found`,
        };
      }

      // Remove from index
      await this.retrievalService.removeSkill(skillName);

      // Remove directory
      await this.removeSkillDirectory(skillPath);

      logger.info(`Successfully uninstalled user skill: ${skillName}`);
      return {
        success: true,
        skillName,
      };
    } catch (error) {
      logger.error(`Failed to uninstall skill: ${skillName}`, error);
      return {
        success: false,
        skillName,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Update skill description
   */
  async updateSkillDescription(
    skillName: string,
    newDescription: string
  ): Promise<UserSkillLoadResult> {
    try {
      const skillPath = path.join(this.skillsBasePath, skillName);

      if (!(await this.directoryExists(skillPath))) {
        return {
          success: false,
          skillName,
          error: `Skill '${skillName}' not found`,
        };
      }

      const skillMdPath = path.join(skillPath, "SKILL.md");

      if (!(await this.fileExists(skillMdPath))) {
        return {
          success: false,
          skillName,
          error: `SKILL.md not found in skill '${skillName}'`,
        };
      }

      // Read and parse SKILL.md
      const content = await fs.readFile(skillMdPath, "utf8");
      const parsed = matter(content);

      // Update description
      parsed.data.description = newDescription;
      parsed.data.updatedAt = new Date().toISOString();

      // Write back
      const yaml = await import("js-yaml");
      const yamlStr = yaml.dump(parsed.data, { indent: 2 });
      const newContent = `---\n${yamlStr}---\n${parsed.content}`;
      await fs.writeFile(skillMdPath, newContent);

      // Reindex
      const metadata = await this.readSkillMetadata(skillPath);
      await this.retrievalService.removeSkill(metadata.name);
      await this.retrievalService.indexSkill({
        name: metadata.name,
        description: metadata.description,
        tags: metadata.tags || [],
        path: skillPath,
        version: metadata.version,
        metadata: metadata,
      });

      logger.info(`Successfully updated skill description: ${skillName}`);
      return {
        success: true,
        skillName,
        metadata,
      };
    } catch (error) {
      logger.error(`Failed to update skill description: ${skillName}`, error);
      return {
        success: false,
        skillName,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Read skill metadata
   */
  private async readSkillMetadata(skillPath: string): Promise<SkillMetadata> {
    const skillMdPath = path.join(skillPath, "SKILL.md");

    if (!(await this.fileExists(skillMdPath))) {
      throw new Error(`SKILL.md not found in ${skillPath}`);
    }

    const content = await fs.readFile(skillMdPath, "utf8");
    const parsed = matter(content);

    return {
      name: parsed.data.name,
      description: parsed.data.description,
      category: parsed.data.category || "uncategorized",
      tools: parsed.data.tools || [],
      version: parsed.data.version,
      tags: parsed.data.tags || [],
      author: parsed.data.author,
      dependencies: parsed.data.dependencies || [],
      parameters: parsed.data.parameters,
    };
  }

  /**
   * Validate skill structure
   */
  private async validateSkillStructure(
    skillPath: string,
    validationLevel: SkillInstallOptions["validationLevel"] = "basic"
  ): Promise<SkillMetadata> {
    const requiredFiles = ["SKILL.md"];

    for (const file of requiredFiles) {
      const filePath = path.join(skillPath, file);
      if (!(await this.fileExists(filePath))) {
        throw new Error(`Required file missing: ${file}`);
      }
    }

    const metadata = await this.readSkillMetadata(skillPath);

    if (!metadata.name || !metadata.description) {
      throw new Error("SKILL.md must contain name and description");
    }

    if (validationLevel === "strict") {
      const scriptsDir = path.join(skillPath, "scripts");
      if (!(await this.directoryExists(scriptsDir))) {
        throw new Error("Scripts directory not found in strict validation mode");
      }

      const executeScript = path.join(scriptsDir, "execute.js");
      if (!(await this.fileExists(executeScript))) {
        throw new Error("execute.js not found in scripts directory");
      }
    }

    return metadata;
  }

  /**
   * Extract ZIP to temp directory
   */
  private async extractZipToTemp(zipBuffer: Buffer): Promise<string> {
    const tempId = `${Date.now()}_${crypto.randomBytes(4).toString("hex")}`;
    const tempDir = path.join(os.tmpdir(), "skill-install", tempId);

    await fs.mkdir(tempDir, { recursive: true });

    const zip = new AdmZip(zipBuffer);
    zip.extractAllTo(tempDir, true);

    return tempDir;
  }

  /**
   * Check if directory exists
   */
  private async directoryExists(dirPath: string): Promise<boolean> {
    try {
      const stat = await fs.stat(dirPath);
      return stat.isDirectory();
    } catch {
      return false;
    }
  }

  /**
   * Check if file exists
   */
  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Remove skill directory
   */
  private async removeSkillDirectory(skillPath: string): Promise<void> {
    await fs.rm(skillPath, { recursive: true, force: true });
  }

  /**
   * Ensure skills directory exists
   */
  private async ensureSkillsDirectory(): Promise<void> {
    try {
      const exists = await this.directoryExists(this.skillsBasePath);
      if (!exists) {
        await fs.mkdir(this.skillsBasePath, { recursive: true });
      }
    } catch (error) {
      logger.warn(`Failed to create skills directory: ${this.skillsBasePath}`, error);
    }
  }

  /**
   * Get skills base path
   */
  getSkillsBasePath(): string {
    return this.skillsBasePath;
  }
}

/**
 * Create UserSkillLoader instance
 */
export function createUserSkillLoader(
  retrievalService: ToolRetrievalService,
  skillsBasePath?: string
): UserSkillLoader {
  // Use environment variable or default path
  const dataDir = process.env.APEX_BRIDGE_DATA_DIR || path.join(process.cwd(), ".data");
  const defaultPath = skillsBasePath || path.join(dataDir, "skills");

  return new UserSkillLoader(retrievalService, defaultPath);
}
````

## File: src/services/tool-retrieval/LanceDBConnectionManager.ts
````typescript
/**
 * LanceDBConnectionManager - LanceDB连接池和连接状态管理
 * 负责管理数据库连接池、健康检查、连接状态
 */

import * as lancedb from "@lancedb/lancedb";
import * as fs from "fs/promises";
import * as path from "path";
import { ToolError, ToolErrorCode } from "../../types/tool-system";
import { logger } from "../../utils/logger";

export class LanceDBConnectionManager {
  private db: lancedb.Connection | null = null;
  private config: {
    vectorDbPath: string;
  };
  private isConnected = false;

  constructor(config: { vectorDbPath: string }) {
    this.config = config;
    logger.info("LanceDBConnectionManager created with config:", {
      vectorDbPath: config.vectorDbPath,
    });
  }

  /**
   * 连接到LanceDB
   */
  async connect(): Promise<void> {
    try {
      // 确保数据库目录存在
      await fs.mkdir(this.config.vectorDbPath, { recursive: true });

      // 连接到LanceDB
      this.db = await lancedb.connect(this.config.vectorDbPath);

      this.isConnected = true;
      logger.info(`Connected to LanceDB at: ${this.config.vectorDbPath}`);
    } catch (error) {
      logger.error("Failed to connect to LanceDB:", error);
      this.isConnected = false;
      throw new ToolError(
        `Failed to connect to LanceDB: ${this.formatError(error)}`,
        ToolErrorCode.VECTOR_DB_ERROR
      );
    }
  }

  /**
   * 检查连接状态
   */
  getConnectionStatus(): { connected: boolean; path: string } {
    return {
      connected: this.isConnected,
      path: this.config.vectorDbPath,
    };
  }

  /**
   * 获取数据库实例
   */
  getDatabase(): lancedb.Connection | null {
    return this.db;
  }

  /**
   * 获取数据库实例（如果未连接则抛出错误）
   */
  requireDatabase(): lancedb.Connection {
    if (!this.db) {
      throw new ToolError(
        "Database not connected. Call connect() first.",
        ToolErrorCode.VECTOR_DB_ERROR
      );
    }
    return this.db;
  }

  /**
   * 健康检查
   */
  async healthCheck(): Promise<boolean> {
    try {
      if (!this.db || !this.isConnected) {
        return false;
      }
      // 尝试执行简单查询验证连接
      const tableNames = await this.getTableNames();
      return true;
    } catch (error) {
      logger.warn("LanceDB health check failed:", error);
      return false;
    }
  }

  /**
   * 获取表名列表
   */
  async getTableNames(): Promise<string[]> {
    try {
      // LanceDB的连接对象可能有不同的API
      // 这里假设可以直接访问表列表
      return [];
    } catch (error) {
      logger.warn("Failed to get table names:", error);
      return [];
    }
  }

  /**
   * 完全删除表和物理文件
   * 确保残留的 .lance 文件不会导致后续查询错误
   */
  async dropTableCompletely(tableName: string): Promise<void> {
    try {
      // 首先从 LanceDB 删除表
      await this.db!.dropTable(tableName);
      logger.info(`Dropped table from LanceDB: ${tableName}`);

      // 然后手动删除物理文件确保完全清理
      const tablePath = path.join(this.config.vectorDbPath, tableName);
      try {
        await fs.rm(tablePath, { recursive: true, force: true });
        logger.info(`Completely removed physical files: ${tablePath}`);
      } catch (rmError: any) {
        if (rmError.code !== "ENOENT") {
          logger.warn(`Failed to remove physical files (may not exist): ${rmError.message}`);
        }
      }
    } catch (error) {
      logger.error("Failed to drop table completely:", error);
      throw error;
    }
  }

  /**
   * 关闭数据库连接
   */
  async close(): Promise<void> {
    logger.info("Closing LanceDB connection...");

    try {
      if (this.db) {
        try {
          await this.db.close();
          logger.info("LanceDB connection closed successfully");
        } catch (error) {
          logger.warn("Error closing LanceDB connection:", error);
        }
        this.db = null;
      }

      this.isConnected = false;
      logger.info("LanceDB connection cleanup completed");
    } catch (error) {
      logger.error("LanceDB connection cleanup failed:", error);
      throw new ToolError(
        `LanceDB cleanup failed: ${this.formatError(error)}`,
        ToolErrorCode.VECTOR_DB_ERROR
      );
    }
  }

  /**
   * 格式化错误信息
   */
  private formatError(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error occurred in LanceDBConnectionManager";
  }
}

/**
 * 创建LanceDBConnectionManager实例
 */
export function createLanceDBConnectionManager(vectorDbPath: string): LanceDBConnectionManager {
  return new LanceDBConnectionManager({ vectorDbPath });
}
````

## File: src/services/tool-retrieval/ToolRetrievalConfig.ts
````typescript
/**
 * ToolRetrievalConfig - 工具检索服务配置类型定义
 */

import { LLMModelType } from "../../types/llm-models";

/**
 * 工具检索配置
 */
export interface ToolRetrievalConfig {
  /** 向量数据库路径 */
  vectorDbPath: string;
  /** 嵌入模型名称 */
  model: string;
  /** 向量维度 */
  dimensions: number;
  /** 缓存大小 */
  cacheSize: number;
  /** 相似度阈值 */
  similarityThreshold: number;
  /** 最大结果数 */
  maxResults: number;
}

/**
 * 技能工具定义
 */
export interface SkillTool {
  /** 工具名称 */
  name: string;
  /** 工具描述 */
  description: string;
  /** 工具类型 */
  type: "skill" | "mcp" | "builtin";
  /** 标签 */
  tags: string[];
  /** 版本 */
  version?: string;
  /** 路径 */
  path?: string;
  /** 来源 */
  source?: string;
  /** 元数据 */
  metadata?: Record<string, any>;
  /** 参数定义 */
  parameters?: {
    type: "object";
    properties: Record<string, any>;
    required?: string[];
  };
  /** 是否启用 */
  enabled?: boolean;
  /** 级别 */
  level?: number;
}

/**
 * 工具检索结果
 */
export interface ToolRetrievalResult {
  /** 工具信息 */
  tool: SkillTool;
  /** 相似度分数 (0-1) */
  score: number;
  /** 匹配原因 */
  reason: string;
}

/**
 * 工具错误代码
 */
export enum ToolErrorCode {
  VECTOR_DB_ERROR = "VECTOR_DB_ERROR",
  EMBEDDING_MODEL_ERROR = "EMBEDDING_MODEL_ERROR",
  TOOL_EXECUTION_FAILED = "TOOL_EXECUTION_FAILED",
  SKILL_NOT_FOUND = "SKILL_NOT_FOUND",
  SKILL_ALREADY_EXISTS = "SKILL_ALREADY_EXISTS",
  SKILL_INVALID_STRUCTURE = "SKILL_INVALID_STRUCTURE",
}

/**
 * 工具错误
 */
export class ToolError extends Error {
  code: ToolErrorCode;
  details?: Record<string, any>;

  constructor(message: string, code: ToolErrorCode, details?: Record<string, any>) {
    super(message);
    this.name = "ToolError";
    this.code = code;
    this.details = details;
  }
}

/**
 * 工具类型
 */
export enum ToolType {
  SKILL = "skill",
  MCP = "mcp",
  BUILTIN = "builtin",
}

/**
 * 默认配置
 */
export const DEFAULT_TOOL_RETRIEVAL_CONFIG: ToolRetrievalConfig = {
  vectorDbPath: "./.data",
  model: "nomic-embed-text:latest",
  cacheSize: 1000,
  dimensions: 768,
  similarityThreshold: 0.4,
  maxResults: 10,
};
````

## File: src/services/tool-retrieval/VectorIndexManager.ts
````typescript
/**
 * VectorIndexManager - 向量索引操作管理
 * 负责索引创建、查询、更新、删除操作
 */

import * as arrow from "apache-arrow";
import * as lancedb from "@lancedb/lancedb";
import { Index } from "@lancedb/lancedb";
import { ToolError, ToolErrorCode } from "../../types/tool-system";
import { logger } from "../../utils/logger";
import { IndexConfigOptimizer } from "./IndexConfigOptimizer";
import { LanceDBConnectionManager } from "./LanceDBConnectionManager";

export interface VectorIndexConfig {
  numPartitions: number;
  numSubVectors: number;
}

export interface VectorSearchOptions {
  queryVector: number[];
  limit?: number;
  distanceType?: "cosine" | "l2" | "dot";
}

export interface VectorSearchResult {
  data: any[];
  rowCount: number;
}

export class VectorIndexManager {
  private connectionManager: LanceDBConnectionManager;
  private table: lancedb.Table | null = null;
  private dimensions: number;
  private optimizer: IndexConfigOptimizer;

  constructor(connectionManager: LanceDBConnectionManager, dimensions: number) {
    this.connectionManager = connectionManager;
    this.dimensions = dimensions;
    this.optimizer = new IndexConfigOptimizer();
    logger.info("VectorIndexManager created", {
      dimensions,
    });
  }

  /**
   * 初始化向量表
   */
  async initializeTable(tableName: string): Promise<lancedb.Table> {
    const db = this.connectionManager.requireDatabase();

    try {
      // 尝试直接打开表，如果失败则说明表不存在
      try {
        this.table = await db.openTable(tableName);
        logger.info(`Table '${tableName}' exists, checking dimensions...`);

        // 表已存在，检查维度是否匹配
        const dimensionsMatch = await this.checkTableDimensions(tableName);
        logger.info(`Dimension check result: ${dimensionsMatch ? "MATCH" : "MISMATCH"}`);

        if (!dimensionsMatch) {
          // 维度不匹配，需要重新创建表
          logger.warn(`Table dimensions mismatch. Dropping and recreating table: ${tableName}`);

          // 完全删除旧表（包括物理文件）
          await this.connectionManager.dropTableCompletely(tableName);

          // 继续创建新表
        } else {
          // 维度匹配，使用现有表
          logger.info(`Using existing table: ${tableName}`);

          // 获取表中的记录数
          const count = await this.getTableCount();
          logger.info(`Table contains ${count} vector records`);

          // 检查是否需要添加新字段（MCP支持）
          await this.checkAndAddMissingFields(tableName);

          // 创建向量索引
          await this.createVectorIndex();
          return this.table;
        }
      } catch (openError: any) {
        // 表不存在，继续创建新表
        logger.info(
          `Table '${tableName}' does not exist (${openError.message}), will create new table`
        );
      }

      // 创建新表 - 使用 Apache Arrow Schema（支持 Skills 和 MCP 工具）
      const schema = new arrow.Schema([
        new arrow.Field("id", new arrow.Utf8(), false),
        new arrow.Field("name", new arrow.Utf8(), false),
        new arrow.Field("description", new arrow.Utf8(), false),
        new arrow.Field(
          "tags",
          new arrow.List(new arrow.Field("item", new arrow.Utf8(), true)),
          false
        ),
        new arrow.Field("path", new arrow.Utf8(), true), // 可选，Skill 才有
        new arrow.Field("version", new arrow.Utf8(), true), // 可选，Skill 才有
        new arrow.Field("source", new arrow.Utf8(), true), // MCP 服务器 ID 或 skill 名称
        new arrow.Field("toolType", new arrow.Utf8(), false), // 'skill' | 'mcp'
        new arrow.Field("metadata", new arrow.Utf8(), false), // 对象存储为JSON字符串
        new arrow.Field(
          "vector",
          new arrow.FixedSizeList(
            this.dimensions,
            new arrow.Field("item", new arrow.Float32(), true)
          ),
          false
        ),
        new arrow.Field("indexedAt", new arrow.Timestamp(arrow.TimeUnit.MICROSECOND), false),
      ]);

      // 创建空表
      this.table = await db.createTable(tableName, [], { schema });

      logger.info(`Created new table: ${tableName} with ${this.dimensions} dimensions`);

      // 创建向量索引
      await this.createVectorIndex();

      return this.table;
    } catch (error) {
      logger.error("Failed to initialize vector table:", error);
      throw error;
    }
  }

  /**
   * 检查表的向量维度是否匹配
   */
  async checkTableDimensions(tableName: string): Promise<boolean> {
    try {
      logger.debug(`Checking table dimensions for: ${tableName}`);

      // 打开表
      const tempTable = await this.connectionManager.requireDatabase().openTable(tableName);

      // 从表的 schema 中获取实际的向量维度
      const actualDimension = await this.getTableVectorDimension(tempTable);

      if (actualDimension === null) {
        logger.warn(`Could not determine vector dimension from table schema`);
        return false;
      }

      const configDimension = this.dimensions;
      const matches = actualDimension === configDimension;

      if (matches) {
        logger.info(`Table dimensions match: config=${configDimension}, actual=${actualDimension}`);
      } else {
        logger.info(
          `Table dimensions mismatch: config=${configDimension}, actual=${actualDimension}`
        );
      }

      return matches;
    } catch (error) {
      logger.error("Failed to check table dimensions:", error);
      return false;
    }
  }

  /**
   * 从表的 schema 中获取向量字段的维度
   */
  private async getTableVectorDimension(table: lancedb.Table): Promise<number | null> {
    try {
      // 获取表的 Arrow schema
      const schema = await table.schema();

      // 查找 vector 字段
      const vectorField = schema.fields.find((f: { name: string }) => f.name === "vector");

      if (!vectorField) {
        logger.warn("No vector field found in table schema");
        return null;
      }

      // FixedSizeList 类型在 Arrow 中表示向量
      const type = vectorField.type;

      // 检查是否是 FixedSizeList 类型
      if (type && typeof type === "object" && "children" in type) {
        if (Array.isArray((type as { children: unknown }).children)) {
          const dimensionValue = (
            type as { children: [unknown, { value?: number; length?: number }] }
          ).children;
          if (dimensionValue[1] && typeof dimensionValue[1] === "object") {
            return dimensionValue[1].value || dimensionValue[1].length || null;
          }
        }
      }

      // 备选方案：直接从 type 对象获取维度
      if ("numChildren" in type) {
        return (type as { numChildren: number }).numChildren;
      }

      logger.warn(`Unknown vector field type: ${JSON.stringify(type)}`);
      return null;
    } catch (error) {
      logger.error("Failed to get table vector dimension:", error);
      return null;
    }
  }

  /**
   * 检查并添加缺失的字段（为MCP支持）
   */
  private async checkAndAddMissingFields(tableName: string): Promise<void> {
    try {
      if (!this.table) {
        return;
      }

      // 尝试插入一个包含所有字段的测试记录
      const testVector = new Array(this.dimensions).fill(0.0);

      const testRecord = {
        id: `field-check-${Date.now()}`,
        name: "Field Check",
        description: "Checking for missing fields",
        tags: [],
        path: null,
        version: null,
        source: null, // MCP 字段
        toolType: "mcp", // MCP 字段
        metadata: "{}",
        vector: testVector,
        indexedAt: new Date(),
      };

      await this.table.add([testRecord]);
      logger.info("All fields (including MCP fields) are present");

      // 删除测试记录
      await this.table.delete(`id == "${testRecord.id}"`);
    } catch (error: any) {
      // 检查是否是字段缺失错误
      if (error.message && error.message.includes("Found field not in schema")) {
        logger.warn("Table is missing MCP-related fields. Recreating table...");

        // 删除旧表并重新创建
        await this.connectionManager.requireDatabase().dropTable(tableName);
        logger.info(`Dropped existing table for recreation: ${tableName}`);

        // 重新创建表
        const schema = new arrow.Schema([
          new arrow.Field("id", new arrow.Utf8(), false),
          new arrow.Field("name", new arrow.Utf8(), false),
          new arrow.Field("description", new arrow.Utf8(), false),
          new arrow.Field(
            "tags",
            new arrow.List(new arrow.Field("item", new arrow.Utf8(), true)),
            false
          ),
          new arrow.Field("path", new arrow.Utf8(), true),
          new arrow.Field("version", new arrow.Utf8(), true),
          new arrow.Field("source", new arrow.Utf8(), true), // MCP 服务器 ID 或 skill 名称
          new arrow.Field("toolType", new arrow.Utf8(), false), // 'skill' | 'mcp'
          new arrow.Field("metadata", new arrow.Utf8(), false),
          new arrow.Field(
            "vector",
            new arrow.FixedSizeList(
              this.dimensions,
              new arrow.Field("item", new arrow.Float32(), true)
            ),
            false
          ),
          new arrow.Field("indexedAt", new arrow.Timestamp(arrow.TimeUnit.MICROSECOND), false),
        ]);

        this.table = await this.connectionManager.requireDatabase().createTable(tableName, [], {
          schema,
        });
        logger.info(`Recreated table: ${tableName} with MCP support`);

        // 重新创建索引
        await this.createVectorIndex();
      } else {
        // 其他错误，重新抛出
        throw error;
      }
    }
  }

  /**
   * 创建向量索引
   */
  async createVectorIndex(): Promise<void> {
    if (!this.table) {
      return;
    }

    try {
      const rowCount = await this.table.countRows();
      const dimension = this.dimensions;

      const optimizationResult = this.optimizer.calculateOptimalConfig(
        rowCount,
        dimension,
        0.95,
        false
      );

      logger.info(`[VectorIndexManager] ${optimizationResult.reasoning}`);

      await this.table.createIndex("vector", {
        config: Index.ivfPq({
          numPartitions: optimizationResult.config.numPartitions,
          numSubVectors: optimizationResult.config.numSubVectors,
        }),
        replace: true,
      });

      logger.info(
        `[VectorIndexManager] Created optimized vector index: ${optimizationResult.config.numPartitions} partitions, ` +
          `${optimizationResult.config.numSubVectors} sub-vectors, ` +
          `est. recall: ${(optimizationResult.estimatedRecall * 100).toFixed(1)}%`
      );
    } catch (error) {
      logger.debug("Vector index may already exist:", error);
    }
  }

  /**
   * 获取表的记录数
   */
  async getTableCount(): Promise<number> {
    try {
      if (!this.table) {
        return 0;
      }

      // 使用count查询
      const count = await this.table.countRows();
      return count;
    } catch (error) {
      logger.warn("Failed to get table count:", error);
      return 0;
    }
  }

  /**
   * 执行向量搜索
   */
  async search(options: VectorSearchOptions): Promise<VectorSearchResult> {
    if (!this.table) {
      throw new ToolError(
        "Vector table is not initialized. Call initializeTable() first.",
        ToolErrorCode.VECTOR_DB_ERROR
      );
    }

    const limit = options.limit || 10;
    const distanceType = options.distanceType || "cosine";

    // 执行向量搜索
    const vectorQuery = this.table
      .query()
      .nearestTo(options.queryVector) // 使用nearestTo进行向量搜索
      .distanceType(distanceType) // 设置距离类型
      .limit(limit * 2); // 获取多一些结果以应用阈值过滤

    const results = await vectorQuery.toArray();

    return {
      data: results,
      rowCount: results.length,
    };
  }

  /**
   * 添加记录到向量表
   */
  async addRecords(records: Record<string, unknown>[]): Promise<void> {
    if (!this.table) {
      throw new ToolError(
        "Vector table is not initialized. Call initializeTable() first.",
        ToolErrorCode.VECTOR_DB_ERROR
      );
    }

    await this.table.add(records);
  }

  /**
   * 从向量表删除记录
   */
  async deleteRecords(filter: string): Promise<void> {
    if (!this.table) {
      return;
    }

    await this.table.delete(filter);
  }

  /**
   * 获取当前表
   */
  getTable(): lancedb.Table | null {
    return this.table;
  }

  /**
   * 更新维度配置
   */
  updateDimensions(dimensions: number): void {
    this.dimensions = dimensions;
    logger.info(`Updated VectorIndexManager dimensions to: ${dimensions}`);
  }
}
````

## File: src/utils/error-serializer.ts
````typescript
/**
 * 错误响应序列化工具
 *
 * 提供安全的错误响应序列化逻辑，避免重复代码
 */

import { logger } from "./logger";

/**
 * 序列化错误响应数据
 *
 * @param error - 错误对象，包含 response 属性
 * @returns 格式化的错误详情字符串
 */
export function serializeErrorResponse(error: unknown): string {
  try {
    const err = error as Record<string, unknown>;
    if (
      err.response &&
      typeof err.response === "object" &&
      (err.response as Record<string, unknown>).data &&
      typeof (err.response as Record<string, unknown>).data === "object"
    ) {
      return JSON.stringify((err.response as { data: unknown }).data, null, 2);
    }
    const responseData = (err.response as { data: unknown })?.data;
    return responseData !== undefined ? String(responseData) : "无详细信息";
  } catch {
    return "[无法序列化响应数据]";
  }
}

/**
 * 记录错误响应的详细信息
 *
 * @param providerName - 提供商名称
 * @param error - 错误对象
 * @param context - 额外的上下文信息
 */
export function logErrorResponse(
  providerName: string,
  error: unknown,
  context: "chat" | "stream" | "embed" = "chat"
): void {
  const err = error as Record<string, unknown>;
  const errorMessage = error instanceof Error ? error.message : String(error);
  logger.error(`❌ ${providerName} ${context} error:`, errorMessage);

  if (err.response) {
    const status = (err.response as { status?: number }).status;
    if (status !== undefined) {
      logger.error(`   HTTP状态: ${status}`);
    }
    const serialized = serializeErrorResponse(error);
    logger.error(`   错误详情: ${serialized}`);
  }
}

/**
 * 创建错误响应对象
 *
 * @param providerName - 提供商名称
 * @param error - 原始错误
 * @returns 标准化的错误消息
 */
export function createErrorMessage(providerName: string, error: unknown): string {
  const errorMessage = error instanceof Error ? error.message : String(error);
  return `${providerName} request failed: ${errorMessage}`;
}
````

## File: src/utils/metrics.ts
````typescript
/**
 * 性能指标收集工具
 *
 * 提供关键性能指标的收集和记录功能
 */

import { logger } from "./logger";

/**
 * 指标类型
 */
export type MetricType = "counter" | "gauge" | "histogram" | "timer";

/**
 * 指标接口
 */
export interface Metric {
  name: string;
  type: MetricType;
  value: number;
  labels?: Record<string, string>;
  timestamp: number;
}

/**
 * 性能指标收集器
 */
export class MetricsCollector {
  private static instance: MetricsCollector | null = null;
  private metrics: Map<string, Metric[]> = new Map();
  private enabled: boolean;

  constructor() {
    this.enabled = process.env.NODE_ENV === "production";
  }

  /**
   * 获取单例实例
   */
  static getInstance(): MetricsCollector {
    if (!MetricsCollector.instance) {
      MetricsCollector.instance = new MetricsCollector();
    }
    return MetricsCollector.instance;
  }

  /**
   * 记录指标
   */
  record(name: string, value: number, type: MetricType, labels?: Record<string, string>): void {
    if (!this.enabled) {
      return;
    }

    const metric: Metric = {
      name,
      type,
      value,
      labels,
      timestamp: Date.now(),
    };

    const key = this.getKey(name, labels);
    if (!this.metrics.has(key)) {
      this.metrics.set(key, []);
    }
    this.metrics.get(key)!.push(metric);

    logger.debug(`[Metrics] Recorded ${name}: ${value}`);
  }

  /**
   * 增加计数器
   */
  increment(name: string, labels?: Record<string, string>): void {
    this.record(name, 1, "counter", labels);
  }

  /**
   * 设置仪表值
   */
  gauge(name: string, value: number, labels?: Record<string, string>): void {
    this.record(name, value, "gauge", labels);
  }

  /**
   * 记录直方图值
   */
  histogram(name: string, value: number, labels?: Record<string, string>): void {
    this.record(name, value, "histogram", labels);
  }

  /**
   * 记录计时器值（毫秒）
   */
  timer(name: string, duration: number, labels?: Record<string, string>): void {
    this.record(name, duration, "timer", labels);
  }

  /**
   * 获取指标
   */
  getMetrics(name?: string, labels?: Record<string, string>): Metric[] {
    if (name) {
      const key = this.getKey(name, labels);
      return this.metrics.get(key) || [];
    }
    const allMetrics: Metric[] = [];
    for (const metrics of this.metrics.values()) {
      allMetrics.push(...metrics);
    }
    return allMetrics;
  }

  /**
   * 清除所有指标
   */
  clear(): void {
    this.metrics.clear();
  }

  /**
   * 获取指标键
   */
  private getKey(name: string, labels?: Record<string, string>): string {
    if (!labels) {
      return name;
    }
    const labelStr = Object.entries(labels)
      .map(([k, v]) => `${k}=${v}`)
      .join(",");
    return `${name}{${labelStr}}`;
  }
}

/**
 * 上下文压缩指标收集器
 */
export class ContextCompressionMetrics {
  private static instance: ContextCompressionMetrics | null = null;
  private compressionCount = 0;
  private successCount = 0;
  private failureCount = 0;
  private totalOriginalTokens = 0;
  private totalCompressedTokens = 0;
  private totalSavings = 0;

  constructor() {
    // 私有构造函数
  }

  static getInstance(): ContextCompressionMetrics {
    if (!ContextCompressionMetrics.instance) {
      ContextCompressionMetrics.instance = new ContextCompressionMetrics();
    }
    return ContextCompressionMetrics.instance;
  }

  /**
   * 记录压缩结果
   */
  recordCompression(success: boolean, originalTokens: number, compressedTokens: number): void {
    this.compressionCount++;
    if (success) {
      this.successCount++;
    } else {
      this.failureCount++;
    }

    this.totalOriginalTokens += originalTokens;
    this.totalCompressedTokens += compressedTokens;
    this.totalSavings += originalTokens - compressedTokens;
  }

  /**
   * 获取压缩统计
   */
  getStats(): {
    total: number;
    success: number;
    failure: number;
    successRate: number;
    avgSavingsRatio: number;
  } {
    const successRate = this.compressionCount > 0 ? this.successCount / this.compressionCount : 0;
    const avgSavingsRatio =
      this.totalOriginalTokens > 0 ? this.totalSavings / this.totalOriginalTokens : 0;

    return {
      total: this.compressionCount,
      success: this.successCount,
      failure: this.failureCount,
      successRate,
      avgSavingsRatio,
    };
  }

  /**
   * 重置统计
   */
  reset(): void {
    this.compressionCount = 0;
    this.successCount = 0;
    this.failureCount = 0;
    this.totalOriginalTokens = 0;
    this.totalCompressedTokens = 0;
    this.totalSavings = 0;
  }
}

/**
 * 工具检索指标收集器
 */
export class ToolRetrievalMetrics {
  private static instance: ToolRetrievalMetrics | null = null;
  private retrievalCount = 0;
  private totalLatency = 0;
  private cacheHits = 0;
  private cacheMisses = 0;

  constructor() {
    // 私有构造函数
  }

  static getInstance(): ToolRetrievalMetrics {
    if (!ToolRetrievalMetrics.instance) {
      ToolRetrievalMetrics.instance = new ToolRetrievalMetrics();
    }
    return ToolRetrievalMetrics.instance;
  }

  /**
   * 记录检索
   */
  recordRetrieval(latencyMs: number, cacheHit: boolean): void {
    this.retrievalCount++;
    this.totalLatency += latencyMs;

    if (cacheHit) {
      this.cacheHits++;
    } else {
      this.cacheMisses++;
    }
  }

  /**
   * 获取检索统计
   */
  getStats(): {
    total: number;
    avgLatency: number;
    cacheHits: number;
    cacheMisses: number;
    cacheHitRate: number;
  } {
    const cacheHitRate = this.retrievalCount > 0 ? this.cacheHits / this.retrievalCount : 0;
    const avgLatency = this.retrievalCount > 0 ? this.totalLatency / this.retrievalCount : 0;

    return {
      total: this.retrievalCount,
      avgLatency,
      cacheHits: this.cacheHits,
      cacheMisses: this.cacheMisses,
      cacheHitRate,
    };
  }

  /**
   * 重置统计
   */
  reset(): void {
    this.retrievalCount = 0;
    this.totalLatency = 0;
    this.cacheHits = 0;
    this.cacheMisses = 0;
  }
}

/**
 * 导出便捷函数
 */
export const metrics = MetricsCollector.getInstance();
export const compressionMetrics = ContextCompressionMetrics.getInstance();
export const retrievalMetrics = ToolRetrievalMetrics.getInstance();
````

## File: config/disclosure.yaml
````yaml
# ApexBridge Disclosure Configuration
# Phase 2: Progressive Disclosure Mechanism

# 启用披露机制
enabled: true

# 匹配度阈值配置
thresholds:
  l2: 0.7 # L2 触发阈值: score >= 0.7 时披露 CONTENT 级别
  l3: 0.85 # L3 触发阈值: score >= 0.85 时披露 RESOURCES 级别

# Token 预算配置
tokenBudget:
  l1MaxTokens: 120 # L1 (METADATA) 最大 Token 预算
  l2MaxTokens: 5000 # L2 (CONTENT) 最大 Token 预算
  adaptiveMaxTokens: 3000 # 自适应披露的最大 Token 上限

# 缓存配置
cache:
  enabled: true # 启用缓存
  maxSize: 2000 # 最大缓存条目数
  l1TtlMs: 300000 # L1 缓存 TTL: 5 分钟 (毫秒)
  l2TtlMs: 300000 # L2 缓存 TTL: 5 分钟 (毫秒)
  cleanupIntervalMs: 300000 # 清理间隔: 5 分钟 (毫秒)

# 并行加载配置
parallelLoad:
  enabled: true # 启用并行加载
  maxConcurrency: 8 # 最大并行数

# 性能指标配置
metrics:
  enabled: true # 启用指标采集
  sampleRate: 1.0 # 采样率: 1.0 = 100%
````

## File: config/hybrid-retrieval.yaml
````yaml
# Hybrid Retrieval Configuration
# Phase 1: 混合检索框架配置

# 检索权重配置 (总和应为 1.0)
retrieval:
  weights:
    vector: 0.5 # 向量相似度权重
    keyword: 0.3 # 关键词匹配权重
    semantic: 0.2 # 语义匹配权重
    tag: 0.1 # 标签匹配权重

  # RRF 融合参数
  rrf:
    k: 60 # RRF 常数 k

  # 检索限制
  limits:
    minScore: 0.1 # 最小分数阈值
    maxResults: 10 # 最大返回结果数

# 标签匹配配置
tagMatching:
  enabled: true
  maxDepth: 3 # 最大层级深度
  enableAliases: true
  minScore: 0.5 # 最小匹配分数

# 披露策略配置
disclosure:
  strategy: "metadata" # metadata | content | resources | adaptive
  levels:
    metadata:
      maxTokens: 500
      includeExamples: false
      includeResources: false
    content:
      maxTokens: 2000
      includeExamples: true
      includeResources: false
    resources:
      maxTokens: 5000
      includeExamples: true
      includeResources: true
  adaptive:
    minTokens: 200
    maxTokens: 3000
    preferMetadataBelow: 500

# 缓存配置
caching:
  enabled: true
  ttl: 300 # 缓存 TTL (秒)
  maxSize: 1000 # 最大缓存条目数
  maxMemory: 100MB # 最大内存使用

# 性能配置
performance:
  timeout: 5000 # 检索超时 (毫秒)
  parallel: true # 并行执行检索
  maxConcurrency: 4 # 最大并发数

# 标签层级配置
tagHierarchy:
  levels:
    - category # 一级分类
    - subcategory # 二级分类
    - tag # 标签
  aliases:
    cat: category
    sub: subcategory
    t: tag
    c: category
    s: subcategory
````

## File: src/api/controllers/SkillsController.ts
````typescript
/**
 * SkillsController - Skills管理 API 控制器
 * 提供Skills的安装、卸载、查询等RESTful接口
 */

import { Request, Response } from 'express';
import multer from 'multer';
import { SkillManager } from '../../services/SkillManager';
import { logger } from '../../utils/logger';
import { ToolError, ToolErrorCode } from '../../types/tool-system';

const skillManager = SkillManager.getInstance();

/**
 * 统一处理服务层错误
 * 将ToolError转换为合适的HTTP状态码
 */
function handleServiceError(res: Response, error: any, action: string): boolean {
  logger.error(`❌ Failed to ${action}:`, error);

  if (error instanceof ToolError) {
    switch (error.code) {
      case ToolErrorCode.SKILL_NOT_FOUND:
        res.status(404).json({
          error: 'Skill not found',
          message: error.message,
          code: error.code
        });
        return true;

      case ToolErrorCode.SKILL_ALREADY_EXISTS:
        res.status(409).json({
          error: 'Skill already exists',
          message: error.message,
          code: error.code
        });
        return true;

      case ToolErrorCode.SKILL_INVALID_STRUCTURE:
        res.status(400).json({
          error: 'Invalid skill structure',
          message: error.message,
          code: error.code
        });
        return true;

      case ToolErrorCode.VECTOR_DB_ERROR:
        res.status(503).json({
          error: 'Vector database error',
          message: error.message,
          code: error.code
        });
        return true;

      default:
        res.status(500).json({
          error: `Failed to ${action}`,
          message: error.message,
          code: error.code
        });
        return true;
    }
  }

  // 默认返回 500
  res.status(500).json({
    error: `Failed to ${action}`,
    message: error.message || 'Unknown error'
  });
  return true;
}

/**
 * 转换为 Skill DTO
 * 统一响应结构，确保所有接口返回格式一致
 */
function toSkillDTO(skill: any) {
  return {
    name: skill.name,
    description: skill.description,
    type: skill.type,
    tags: skill.tags || [],
    version: skill.version,
    author: skill.author,
    enabled: skill.enabled,
    level: skill.level,
    path: skill.path,
    parameters: skill.parameters || {
      type: 'object',
      properties: {},
      required: []
    }
  };
}

/**
 * 安装Skills
 * POST /api/skills/install
 * Content-Type: multipart/form-data
 * Body: { file: ZIP文件, overwrite?: boolean, skipVectorization?: boolean }
 */
export async function installSkill(req: Request, res: Response): Promise<void> {
  try {
    const startTime = Date.now();

    // 检查文件是否存在
    if (!req.file) {
      res.status(400).json({
        error: 'No file uploaded',
        message: 'Please upload a ZIP file containing the skill'
      });
      return;
    }

    // 验证文件类型
    if (!req.file.originalname.endsWith('.zip')) {
      res.status(400).json({
        error: 'Invalid file type',
        message: 'Only ZIP files are supported'
      });
      return;
    }

    // 检查文件大小（限制100MB）
    if (req.file.size > 100 * 1024 * 1024) {
      res.status(400).json({
        error: 'File too large',
        message: 'Maximum file size is 100MB'
      });
      return;
    }

    logger.info(`📦 Installing skill from file: ${req.file.originalname} (${req.file.size} bytes)`);

    // 解析选项
    const options = {
      overwrite: req.body.overwrite === 'true' || req.body.overwrite === true,
      skipVectorization: req.body.skipVectorization === 'true' || req.body.skipVectorization === true,
      validationLevel: req.body.validationLevel || 'basic'
    };

    // 安装Skills
    const result = await skillManager.installSkill(req.file.buffer, options);

    logger.info(`✅ Skill installed successfully: ${result.skillName} (${Date.now() - startTime}ms)`);

    // 返回成功响应
    res.status(201).json({
      success: true,
      message: result.message,
      skillName: result.skillName,
      installedAt: result.installedAt,
      duration: result.duration,
      vectorized: result.vectorized
    });

  } catch (error) {
    handleServiceError(res, error, 'install skill');
  }
}

/**
 * 卸载Skills
 * DELETE /api/skills/:name
 */
export async function uninstallSkill(req: Request, res: Response): Promise<void> {
  try {
    const { name } = req.params;
    const startTime = Date.now();

    logger.info(`🗑️ Uninstalling skill: ${name}`);

    const result = await skillManager.uninstallSkill(name);

    logger.info(`✅ Skill uninstalled successfully: ${name} (${Date.now() - startTime}ms)`);

    res.json({
      success: true,
      message: result.message,
      skillName: result.skillName,
      uninstalledAt: result.uninstalledAt,
      duration: result.duration
    });

  } catch (error) {
    handleServiceError(res, error, 'uninstall skill');
  }
}

/**
 * 更新Skills描述
 * PUT /api/skills/:name/description
 * Body: { description: string }
 */
export async function updateSkillDescription(req: Request, res: Response): Promise<void> {
  try {
    const { name } = req.params;
    const { description } = req.body;
    const startTime = Date.now();

    // 验证描述不能为空
    if (!description || typeof description !== 'string') {
      res.status(400).json({
        error: 'Invalid description',
        message: 'Description is required and must be a string'
      });
      return;
    }

    logger.info(`✏️ Updating skill description: ${name}`);

    const result = await skillManager.updateSkill(name, description);

    logger.info(`✅ Skill description updated: ${name} (${Date.now() - startTime}ms)`);

    res.json({
      success: true,
      message: result.message,
      skillName: result.skillName,
      updatedAt: result.updatedAt,
      duration: result.duration,
      reindexed: result.reindexed
    });

  } catch (error) {
    handleServiceError(res, error, 'update skill description');
  }
}

/**
 * 列出Skills
 * GET /api/skills?page=1&limit=50&name=&tags=&sortBy=name&sortOrder=asc
 */
export async function listSkills(req: Request, res: Response): Promise<void> {
  try {
    const startTime = Date.now();

    // 解析查询参数
    const sortBy = (req.query.sortBy as string) || 'name';
    const validSortFields = ['updatedAt', 'name', 'installedAt'];
    if (!validSortFields.includes(sortBy)) {
      res.status(400).json({
        error: 'Invalid sortBy parameter',
        message: 'sortBy must be one of: updatedAt, name, installedAt'
      });
      return;
    }

    const options = {
      page: parseInt(req.query.page as string) || 1,
      limit: parseInt(req.query.limit as string) || 50,
      name: req.query.name as string || undefined,
      tags: req.query.tags ? (req.query.tags as string).split(',') : undefined,
      sortBy: sortBy as 'updatedAt' | 'name' | 'installedAt',
      sortOrder: ((req.query.sortOrder as string) === 'desc' ? 'desc' : 'asc') as 'asc' | 'desc'
    };

    logger.debug(`📋 Listing skills: page=${options.page}, limit=${options.limit}`);

    const result = await skillManager.listSkills(options);

    logger.info(`✅ Listed ${result.skills.length} skills (${Date.now() - startTime}ms)`);

    res.json({
      success: true,
      data: {
        skills: result.skills.map(toSkillDTO),
        pagination: {
          total: result.total,
          page: result.page,
          limit: result.limit,
          totalPages: result.totalPages
        }
      }
    });

  } catch (error) {
    handleServiceError(res, error, 'list skills');
  }
}

/**
 * 获取单个Skills详情
 * GET /api/skills/:name
 */
export async function getSkill(req: Request, res: Response): Promise<void> {
  try {
    const { name } = req.params;
    const startTime = Date.now();

    logger.debug(`🔍 Getting skill details: ${name}`);

    const skill = await skillManager.getSkillByName(name);

    if (!skill) {
      res.status(404).json({
        error: 'Skill not found',
        message: `Skill '${name}' not found`
      });
      return;
    }

    logger.info(`✅ Got skill details: ${name} (${Date.now() - startTime}ms)`);

    res.json({
      success: true,
      data: toSkillDTO(skill)
    });

  } catch (error) {
    handleServiceError(res, error, 'get skill');
  }
}

/**
 * 检查Skills是否存在
 * GET /api/skills/:name/exists
 */
export async function checkSkillExists(req: Request, res: Response): Promise<void> {
  try {
    const { name } = req.params;

    logger.debug(`🔍 Checking if skill exists: ${name}`);

    const exists = await skillManager.isSkillExist(name);

    res.json({
      success: true,
      data: {
        name,
        exists
      }
    });

  } catch (error) {
    handleServiceError(res, error, 'check skill existence');
  }
}

/**
 * 获取Skills统计信息
 * GET /api/skills/stats
 */
export async function getSkillStats(req: Request, res: Response): Promise<void> {
  try {
    const startTime = Date.now();

    logger.debug('📊 Getting skill statistics');

    const stats = await skillManager.getStatistics();

    logger.info(`✅ Got skill statistics (${Date.now() - startTime}ms)`);

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    handleServiceError(res, error, 'get skill statistics');
  }
}

/**
 * 重新索引所有Skills
 * POST /api/skills/reindex
 * 用于向量数据库重建或同步
 */
export async function reindexAllSkills(req: Request, res: Response): Promise<void> {
  try {
    const startTime = Date.now();

    logger.info('🔄 Reindexing all skills');

    // TODO: 实现重新索引逻辑
    // 1. 扫描所有Skills目录
    // 2. 逐一调用 retrievalService.indexSkill()
    // 3. 更新.vectorized标识

    logger.info(`✅ All skills reindexed (${Date.now() - startTime}ms)`);

    res.json({
      success: true,
      message: 'All skills reindexed successfully'
    });

  } catch (error) {
    handleServiceError(res, error, 'reindex skills');
  }
}

// 配置Multer中间件
export const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 100 * 1024 * 1024 // 100MB
  },
  fileFilter: (req, file, cb) => {
    if (file.originalname.endsWith('.zip')) {
      cb(null, true);
    } else {
      cb(new Error('Only ZIP files are allowed'));
    }
  }
});
````

## File: src/api/middleware/rateLimit/inMemoryRateLimiter.ts
````typescript
import {
  RateLimiter,
  RateLimiterContext,
  RateLimiterHitResult,
  RateLimiterMode,
  RateLimiterRuleState
} from './types';

export interface InMemoryRateLimiterOptions {
  defaultMode?: RateLimiterMode;
  defaultBurstMultiplier?: number;
  now?: () => number;
}

interface SlidingStateEntry {
  timestamps: number[];
}

interface FixedWindowStateEntry {
  windowStart: number;
  count: number;
}

const DEFAULT_MODE: RateLimiterMode = 'sliding';

/**
 * 内存版限流器，实现滑动窗口与固定窗口两种算法，并支持突发流量放宽。
 * 设计目标：
 * - 滑动窗口：记录窗口内每次命中时间戳，保证限流的平滑性与准确性
 * - 固定窗口：对 windowMs 对齐分片计数，满足简单场景
 * - Burst：通过 burstMultiplier 扩大有效上限，允许短时突发流量
 */
export class InMemoryRateLimiter implements RateLimiter {
  private readonly now: () => number;
  private readonly defaultMode: RateLimiterMode;
  private readonly defaultBurstMultiplier: number;

  private readonly slidingState = new Map<string, Map<string, SlidingStateEntry>>();
  private readonly fixedState = new Map<string, Map<string, FixedWindowStateEntry>>();

  constructor(options?: InMemoryRateLimiterOptions) {
    this.now = options?.now ?? (() => Date.now());
    this.defaultMode = options?.defaultMode ?? DEFAULT_MODE;
    this.defaultBurstMultiplier = Math.max(options?.defaultBurstMultiplier ?? 1, 1);
  }

  async hit(key: string, rule: RateLimiterRuleState): Promise<RateLimiterHitResult> {
    const mode = rule.mode ?? this.defaultMode;
    if (mode === 'fixed') {
      return this.hitFixedWindow(key, rule);
    }
    return this.hitSlidingWindow(key, rule);
  }

  async undo(context: RateLimiterContext): Promise<void> {
    if (context.mode === 'fixed') {
      this.undoFixedWindow(context);
    } else {
      this.undoSlidingWindow(context);
    }
  }

  private hitSlidingWindow(key: string, rule: RateLimiterRuleState): RateLimiterHitResult {
    const burstMultiplier = Math.max(rule.burstMultiplier ?? this.defaultBurstMultiplier, 1);
    const limit = Math.max(Math.floor(rule.maxRequests * burstMultiplier), rule.maxRequests);
    const now = this.now();
    const windowStartThreshold = now - rule.windowMs;

    const ruleBuckets = this.ensureSlidingRule(rule.id);
    const entry = this.ensureSlidingEntry(ruleBuckets, key);
    const timestamps = entry.timestamps;

    // 清理过期时间戳（按顺序存储，O(n) 最坏，但 n 一般 <= limit）
    while (timestamps.length > 0 && timestamps[0] <= windowStartThreshold) {
      timestamps.shift();
    }

    if (timestamps.length >= limit) {
      const earliest = timestamps[0];
      const resetAt = earliest + rule.windowMs;
      return {
        allowed: false,
        limit,
        remaining: 0,
        reset: resetAt
      };
    }

    timestamps.push(now);
    const remaining = Math.max(limit - timestamps.length, 0);
    const firstTimestamp = timestamps[0] ?? now;
    const resetAt = firstTimestamp + rule.windowMs;

    return {
      allowed: true,
      limit,
      remaining,
      reset: resetAt,
      context: {
        ruleId: rule.id,
        key,
        mode: 'sliding',
        timestamp: now
      }
    };
  }

  private hitFixedWindow(key: string, rule: RateLimiterRuleState): RateLimiterHitResult {
    const burstMultiplier = Math.max(rule.burstMultiplier ?? this.defaultBurstMultiplier, 1);
    const limit = Math.max(Math.floor(rule.maxRequests * burstMultiplier), rule.maxRequests);
    const now = this.now();
    const windowStart = Math.floor(now / rule.windowMs) * rule.windowMs;

    const ruleBuckets = this.ensureFixedRule(rule.id);
    const entry = this.ensureFixedEntry(ruleBuckets, key);

    if (entry.windowStart !== windowStart) {
      entry.windowStart = windowStart;
      entry.count = 0;
    }

    if (entry.count >= limit) {
      return {
        allowed: false,
        limit,
        remaining: 0,
        reset: entry.windowStart + rule.windowMs
      };
    }

    entry.count += 1;
    const remaining = Math.max(limit - entry.count, 0);

    return {
      allowed: true,
      limit,
      remaining,
      reset: entry.windowStart + rule.windowMs,
      context: {
        ruleId: rule.id,
        key,
        mode: 'fixed',
        timestamp: now,
        windowStart: entry.windowStart
      }
    };
  }

  private undoSlidingWindow(context: RateLimiterContext): void {
    const ruleBuckets = this.slidingState.get(context.ruleId);
    if (!ruleBuckets) {
      return;
    }
    const entry = ruleBuckets.get(context.key);
    if (!entry) {
      return;
    }

    const index = entry.timestamps.lastIndexOf(context.timestamp);
    if (index >= 0) {
      entry.timestamps.splice(index, 1);
    }

    if (entry.timestamps.length === 0) {
      ruleBuckets.delete(context.key);
    }
    if (ruleBuckets.size === 0) {
      this.slidingState.delete(context.ruleId);
    }
  }

  private undoFixedWindow(context: RateLimiterContext): void {
    const ruleBuckets = this.fixedState.get(context.ruleId);
    if (!ruleBuckets) {
      return;
    }
    const entry = ruleBuckets.get(context.key);
    if (!entry) {
      return;
    }
    if (entry.windowStart !== context.windowStart || entry.count === 0) {
      return;
    }

    entry.count = Math.max(entry.count - 1, 0);
    if (entry.count === 0) {
      ruleBuckets.delete(context.key);
    }
    if (ruleBuckets.size === 0) {
      this.fixedState.delete(context.ruleId);
    }
  }

  private ensureSlidingRule(ruleId: string): Map<string, SlidingStateEntry> {
    let ruleBuckets = this.slidingState.get(ruleId);
    if (!ruleBuckets) {
      ruleBuckets = new Map<string, SlidingStateEntry>();
      this.slidingState.set(ruleId, ruleBuckets);
    }
    return ruleBuckets;
  }

  private ensureSlidingEntry(
    buckets: Map<string, SlidingStateEntry>,
    key: string
  ): SlidingStateEntry {
    let entry = buckets.get(key);
    if (!entry) {
      entry = { timestamps: [] };
      buckets.set(key, entry);
    }
    return entry;
  }

  private ensureFixedRule(ruleId: string): Map<string, FixedWindowStateEntry> {
    let ruleBuckets = this.fixedState.get(ruleId);
    if (!ruleBuckets) {
      ruleBuckets = new Map<string, FixedWindowStateEntry>();
      this.fixedState.set(ruleId, ruleBuckets);
    }
    return ruleBuckets;
  }

  private ensureFixedEntry(
    buckets: Map<string, FixedWindowStateEntry>,
    key: string
  ): FixedWindowStateEntry {
    let entry = buckets.get(key);
    if (!entry) {
      entry = { windowStart: 0, count: 0 };
      buckets.set(key, entry);
    }
    return entry;
  }
}
````

## File: src/api/middleware/rateLimit/redisRateLimiter.ts
````typescript
import type { RedisClientType } from 'redis';
import {
  RateLimiter,
  RateLimiterContext,
  RateLimiterHitResult,
  RateLimiterMode,
  RateLimiterRuleState
} from './types';

export interface RedisRateLimiterOptions {
  client: RedisClientType<any, any, any>;
  keyPrefix?: string;
  now?: () => number;
}

export class RedisRateLimiter implements RateLimiter {
  private readonly client: RedisClientType<any, any, any>;
  private readonly now: () => number;
  private readonly keyPrefix: string;

  private static readonly HIT_SCRIPT = `
    local key = KEYS[1]
    local now = tonumber(ARGV[1])
    local windowStart = tonumber(ARGV[2])
    local limit = tonumber(ARGV[3])
    local ttl = tonumber(ARGV[4])
    local member = ARGV[5]

    redis.call('ZREMRANGEBYSCORE', key, '-inf', windowStart)
    local currentCount = redis.call('ZCARD', key)

    if currentCount >= limit then
      local earliest = redis.call('ZRANGE', key, 0, 0, 'WITHSCORES')
      local resetAt = 0
      if earliest[2] then
        resetAt = tonumber(earliest[2]) + ttl
      end
      return {0, currentCount, resetAt}
    end

    redis.call('ZADD', key, now, member)
    redis.call('PEXPIRE', key, ttl)
    local newCount = currentCount + 1
    local earliest = redis.call('ZRANGE', key, 0, 0, 'WITHSCORES')
    local resetAt = 0
    if earliest[2] then
      resetAt = tonumber(earliest[2]) + ttl
    end
    return {1, newCount, resetAt}
  `;

  constructor(options: RedisRateLimiterOptions) {
    this.client = options.client;
    this.keyPrefix = options.keyPrefix ?? 'rate_limit';
    this.now = options.now ?? (() => Date.now());
  }

  public getClient(): RedisClientType<any, any, any> {
    return this.client;
  }

  public async hit(key: string, rule: RateLimiterRuleState): Promise<RateLimiterHitResult> {
    const mode: RateLimiterMode = rule.mode === 'fixed' ? 'fixed' : 'sliding';
    const burstMultiplier = Math.max(rule.burstMultiplier ?? 1, 1);
    const limit = Math.max(Math.floor(rule.maxRequests * burstMultiplier), rule.maxRequests);
    const now = this.now();
    const windowStart = now - rule.windowMs;
    const ttlMs = Math.max(rule.windowMs, 1000);
    const member = `${now}-${Math.random().toString(36).slice(2, 10)}`;

    const redisKey = this.composeKey(rule.id, key);

    const response = (await this.client.eval(RedisRateLimiter.HIT_SCRIPT, {
      keys: [redisKey],
      arguments: [
        now.toString(10),
        windowStart.toString(10),
        limit.toString(10),
        ttlMs.toString(10),
        member
      ]
    })) as [number, number, number?] | null;

    if (!response) {
      throw new Error('Redis rate limiter returned null response');
    }

    const allowed = response[0] === 1;
    const count = typeof response[1] === 'number' ? response[1] : 0;
    const resetTimestamp = typeof response[2] === 'number' ? response[2] : now + rule.windowMs;

    if (!allowed) {
      return {
        allowed: false,
        limit,
        remaining: Math.max(limit - count, 0),
        reset: resetTimestamp
      };
    }

    const remaining = Math.max(limit - count, 0);

    return {
      allowed: true,
      limit,
      remaining,
      reset: resetTimestamp,
      context: {
        ruleId: rule.id,
        key,
        mode,
        timestamp: now,
        value: member
      }
    };
  }

  public async undo(context: RateLimiterContext): Promise<void> {
    if (!context.value) {
      return;
    }

    const redisKey = this.composeKey(context.ruleId, context.key);
    try {
      await this.client.zRem(redisKey, context.value);
    } catch {
      // Silent failure; fallback limiter will handle eventual consistency.
    }
  }

  private composeKey(ruleId: string, identifier: string): string {
    return `${this.keyPrefix}:${ruleId}:${identifier}`;
  }
}
````

## File: src/api/middleware/rateLimit/types.ts
````typescript
export type RateLimiterMode = 'sliding' | 'fixed';

export interface RateLimiterRuleState {
  id: string;
  windowMs: number;
  maxRequests: number;
  mode?: RateLimiterMode;
  burstMultiplier?: number;
}

export interface RateLimiterContext {
  ruleId: string;
  key: string;
  timestamp: number;
  windowStart?: number;
  mode: RateLimiterMode;
  value?: string;
}

export interface RateLimiterHitResult {
  allowed: boolean;
  limit: number;
  remaining: number;
  reset: number;
  context?: RateLimiterContext;
}

export interface RateLimiter {
  hit(key: string, rule: RateLimiterRuleState): Promise<RateLimiterHitResult>;
  undo(context: RateLimiterContext): Promise<void>;
}
````

## File: src/api/routes/mcpRoutes.ts
````typescript
/**
 * MCP API Routes
 * MCP服务器管理的REST API端点
 */

import { Router, Request, Response } from "express";
import { mcpIntegration } from "../../services/MCPIntegrationService";
import { logger } from "../../utils/logger";

const router = Router();

/**
 * @route   GET /api/mcp/servers
 * @desc    获取所有注册的MCP服务器列表
 * @access  Public
 */
router.get("/servers", async (req: Request, res: Response) => {
  try {
    const servers = mcpIntegration.getServers();

    res.json({
      success: true,
      data: servers,
      meta: {
        total: servers.length,
        timestamp: new Date().toISOString(),
      },
    });
  } catch (error: any) {
    logger.error("[MCP API] Failed to get servers:", error);
    res.status(500).json({
      success: false,
      error: {
        code: "GET_SERVERS_FAILED",
        message: error.message || "Failed to get servers",
      },
    });
  }
});

/**
 * @route   POST /api/mcp/servers
 * @desc    注册新的MCP服务器
 * @access  Public
 */
router.post("/servers", async (req: Request, res: Response) => {
  try {
    const config = req.body;

    // 验证必要字段
    if (!config.id || !config.type || !config.command) {
      return res.status(400).json({
        success: false,
        error: {
          code: "INVALID_CONFIG",
          message: "Missing required fields: id, type, command",
        },
      });
    }

    const result = await mcpIntegration.registerServer(config);

    if (!result.success) {
      return res.status(400).json({
        success: false,
        error: {
          code: "REGISTRATION_FAILED",
          message: result.error || "Registration failed",
        },
      });
    }

    res.status(201).json({
      success: true,
      data: {
        serverId: result.serverId,
        message: "Server registered successfully",
      },
    });
  } catch (error: any) {
    logger.error("[MCP API] Failed to register server:", error);
    res.status(500).json({
      success: false,
      error: {
        code: "REGISTRATION_ERROR",
        message: error.message || "Registration error",
      },
    });
  }
});

/**
 * @route   GET /api/mcp/servers/:serverId
 * @desc    获取特定MCP服务器的详细信息
 * @access  Public
 */
router.get("/servers/:serverId", async (req: Request, res: Response) => {
  try {
    const { serverId } = req.params;
    const server = mcpIntegration.getServer(serverId);

    if (!server) {
      return res.status(404).json({
        success: false,
        error: {
          code: "SERVER_NOT_FOUND",
          message: `Server ${serverId} not found`,
        },
      });
    }

    res.json({
      success: true,
      data: server,
      meta: {
        timestamp: new Date().toISOString(),
      },
    });
  } catch (error: any) {
    logger.error("[MCP API] Failed to get server:", error);
    res.status(500).json({
      success: false,
      error: {
        code: "GET_SERVER_FAILED",
        message: error.message || "Failed to get server",
      },
    });
  }
});

/**
 * @route   DELETE /api/mcp/servers/:serverId
 * @desc    注销MCP服务器
 * @access  Public
 */
router.delete("/servers/:serverId", async (req: Request, res: Response) => {
  try {
    const { serverId } = req.params;
    const success = await mcpIntegration.unregisterServer(serverId);

    if (!success) {
      return res.status(404).json({
        success: false,
        error: {
          code: "SERVER_NOT_FOUND",
          message: `Server ${serverId} not found`,
        },
      });
    }

    res.json({
      success: true,
      data: {
        serverId,
        message: "Server unregistered successfully",
      },
    });
  } catch (error: any) {
    logger.error("[MCP API] Failed to unregister server:", error);
    res.status(500).json({
      success: false,
      error: {
        code: "UNREGISTRATION_ERROR",
        message: error.message || "Unregistration error",
      },
    });
  }
});

/**
 * @route   POST /api/mcp/servers/:serverId/restart
 * @desc    重启MCP服务器
 * @access  Public
 */
router.post("/servers/:serverId/restart", async (req: Request, res: Response) => {
  try {
    const { serverId } = req.params;
    const success = await mcpIntegration.restartServer(serverId);

    if (!success) {
      return res.status(404).json({
        success: false,
        error: {
          code: "SERVER_NOT_FOUND",
          message: `Server ${serverId} not found`,
        },
      });
    }

    res.json({
      success: true,
      data: {
        serverId,
        message: "Server restarted successfully",
      },
    });
  } catch (error: any) {
    logger.error("[MCP API] Failed to restart server:", error);
    res.status(500).json({
      success: false,
      error: {
        code: "RESTART_ERROR",
        message: error.message || "Restart error",
      },
    });
  }
});

/**
 * @route   GET /api/mcp/servers/:serverId/status
 * @desc    获取MCP服务器状态
 * @access  Public
 */
router.get("/servers/:serverId/status", async (req: Request, res: Response) => {
  try {
    const { serverId } = req.params;
    const status = mcpIntegration.getServerStatus(serverId);

    if (!status) {
      return res.status(404).json({
        success: false,
        error: {
          code: "SERVER_NOT_FOUND",
          message: `Server ${serverId} not found`,
        },
      });
    }

    res.json({
      success: true,
      data: {
        serverId,
        status,
      },
    });
  } catch (error: any) {
    logger.error("[MCP API] Failed to get server status:", error);
    res.status(500).json({
      success: false,
      error: {
        code: "GET_STATUS_FAILED",
        message: error.message || "Failed to get server status",
      },
    });
  }
});

/**
 * @route   GET /api/mcp/servers/:serverId/tools
 * @desc    获取MCP服务器的工具列表
 * @access  Public
 */
router.get("/servers/:serverId/tools", async (req: Request, res: Response) => {
  try {
    const { serverId } = req.params;
    const server = mcpIntegration.getServer(serverId);

    if (!server) {
      return res.status(404).json({
        success: false,
        error: {
          code: "SERVER_NOT_FOUND",
          message: `Server ${serverId} not found`,
        },
      });
    }

    res.json({
      success: true,
      data: {
        serverId,
        tools: server.tools,
        count: server.tools.length,
      },
    });
  } catch (error: any) {
    logger.error("[MCP API] Failed to get server tools:", error);
    res.status(500).json({
      success: false,
      error: {
        code: "GET_TOOLS_FAILED",
        message: error.message || "Failed to get server tools",
      },
    });
  }
});

/**
 * Validate tool call request parameters
 * @param serverId Server ID from params
 * @param toolName Tool name from params
 * @param arguments_ Request body arguments
 * @returns Validation result with error details if invalid
 */
interface ToolCallValidationResult {
  valid: boolean;
  error?: {
    code: string;
    message: string;
    statusCode: number;
  };
}

function validateToolCallRequest(
  serverId: string | undefined,
  toolName: string | undefined,
  arguments_: any
): ToolCallValidationResult {
  // Validate serverId
  if (!serverId || typeof serverId !== "string" || serverId.trim() === "") {
    return {
      valid: false,
      error: {
        code: "INVALID_SERVER_ID",
        message: "Missing or invalid serverId parameter",
        statusCode: 400,
      },
    };
  }

  // Validate toolName
  if (!toolName || typeof toolName !== "string" || toolName.trim() === "") {
    return {
      valid: false,
      error: {
        code: "INVALID_TOOL_NAME",
        message: "Missing or invalid toolName parameter",
        statusCode: 400,
      },
    };
  }

  // Validate arguments type
  if (arguments_ !== undefined && arguments_ !== null && typeof arguments_ !== "object") {
    return {
      valid: false,
      error: {
        code: "INVALID_ARGUMENTS",
        message: "Arguments must be an object, null, or undefined",
        statusCode: 400,
      },
    };
  }

  // Validate arguments structure if provided
  if (arguments_ && typeof arguments_ === "object") {
    // Check for circular references in arguments
    try {
      JSON.stringify(arguments_);
    } catch {
      return {
        valid: false,
        error: {
          code: "INVALID_ARGUMENTS",
          message: "Arguments contain circular references or are not serializable",
          statusCode: 400,
        },
      };
    }
  }

  return { valid: true };
}

/**
 * @route   POST /api/mcp/servers/:serverId/tools/:toolName/call
 * @desc    调用MCP工具
 * @access  Public
 */
router.post("/servers/:serverId/tools/:toolName/call", async (req: Request, res: Response) => {
  try {
    const { serverId, toolName } = req.params;
    const arguments_ = req.body;

    // Validate request parameters
    const validation = validateToolCallRequest(serverId, toolName, arguments_);
    if (!validation.valid) {
      return res.status(validation.error!.statusCode).json({
        success: false,
        error: {
          code: validation.error!.code,
          message: validation.error!.message,
        },
      });
    }

    const result = await mcpIntegration.callTool({
      toolName,
      arguments: arguments_ || {},
      serverId,
    });

    res.json({
      success: true,
      data: result,
    });
  } catch (error: any) {
    logger.error("[MCP API] Failed to call tool:", error);
    res.status(500).json({
      success: false,
      error: {
        code: "TOOL_CALL_ERROR",
        message: error.message || "Tool call error",
      },
    });
  }
});

/**
 * @route   POST /api/mcp/tools/call
 * @desc    调用MCP工具（自动发现）
 * @access  Public
 */
router.post("/tools/call", async (req: Request, res: Response) => {
  try {
    const { toolName, arguments: args } = req.body;

    if (!toolName) {
      return res.status(400).json({
        success: false,
        error: {
          code: "MISSING_TOOL_NAME",
          message: "Missing toolName",
        },
      });
    }

    const result = await mcpIntegration.callTool({
      toolName,
      arguments: args || {},
    });

    res.json({
      success: true,
      data: result,
    });
  } catch (error: any) {
    logger.error("[MCP API] Failed to call tool:", error);
    res.status(500).json({
      success: false,
      error: {
        code: "TOOL_CALL_ERROR",
        message: error.message || "Tool call error",
      },
    });
  }
});

/**
 * @route   GET /api/mcp/statistics
 * @desc    获取MCP统计信息
 * @access  Public
 */
router.get("/statistics", async (req: Request, res: Response) => {
  try {
    const stats = mcpIntegration.getStatistics();

    res.json({
      success: true,
      data: stats,
    });
  } catch (error: any) {
    logger.error("[MCP API] Failed to get statistics:", error);
    res.status(500).json({
      success: false,
      error: {
        code: "GET_STATISTICS_FAILED",
        message: error.message || "Failed to get statistics",
      },
    });
  }
});

/**
 * @route   GET /api/mcp/health
 * @desc    MCP健康检查
 * @access  Public
 */
router.get("/health", async (req: Request, res: Response) => {
  try {
    const health = await mcpIntegration.healthCheck();

    const statusCode = health.healthy ? 200 : 503;

    res.status(statusCode).json({
      success: health.healthy,
      data: health,
    });
  } catch (error: any) {
    logger.error("[MCP API] Health check failed:", error);
    res.status(503).json({
      success: false,
      error: {
        code: "HEALTH_CHECK_FAILED",
        message: error.message || "Health check failed",
      },
    });
  }
});

export default router;
````

## File: src/core/llm/adapters/CustomAdapter.ts
````typescript
/**
 * 自定义适配器
 */

import { BaseOpenAICompatibleAdapter } from './BaseAdapter';
import { LLMProviderConfig } from '../../../types';

export class CustomAdapter extends BaseOpenAICompatibleAdapter {
  constructor(config: LLMProviderConfig) {
    super('Custom', config);
  }
}
````

## File: src/core/llm/adapters/DeepSeekAdapter.ts
````typescript
/**
 * DeepSeek适配器
 * 特殊处理：不支持top_k，max_tokens最大8192
 */

import { BaseOpenAICompatibleAdapter } from './BaseAdapter';
import { LLMProviderConfig } from '../../../types';
import { ChatOptions } from '../../../types';

export class DeepSeekAdapter extends BaseOpenAICompatibleAdapter {
  constructor(config: LLMProviderConfig) {
    super('DeepSeek', config);
  }

  protected filterOptions(options: ChatOptions): ChatOptions {
    const filtered = { ...options };

    // DeepSeek不支持top_k
    if ('top_k' in filtered) {
      delete (filtered as any).top_k;
    }

    // DeepSeek限制：max_tokens最大8192
    if (filtered.max_tokens && filtered.max_tokens > 8192) {
      filtered.max_tokens = 8192;
    }

    return filtered;
  }
}
````

## File: src/core/llm/adapters/index.ts
````typescript
/**
 * LLM适配器模块导出
 */

export * from './BaseAdapter';
export * from './OpenAIAdapter';
export * from './DeepSeekAdapter';
export * from './ZhipuAdapter';
export * from './ClaudeAdapter';
export * from './OllamaAdapter';
export * from './CustomAdapter';
export * from './LLMAdapterFactory';
````

## File: src/core/llm/adapters/OpenAIAdapter.ts
````typescript
/**
 * OpenAI适配器
 */

import { BaseOpenAICompatibleAdapter } from './BaseAdapter';
import { LLMProviderConfig } from '../../../types';
import { ChatOptions } from '../../../types';

export class OpenAIAdapter extends BaseOpenAICompatibleAdapter {
  constructor(config: LLMProviderConfig) {
    super('OpenAI', config);
  }
}
````

## File: src/core/llm/adapters/ZhipuAdapter.ts
````typescript
/**
 * 智谱AI适配器
 */

import { BaseOpenAICompatibleAdapter } from './BaseAdapter';
import { LLMProviderConfig } from '../../../types';

export class ZhipuAdapter extends BaseOpenAICompatibleAdapter {
  constructor(config: LLMProviderConfig) {
    super('ZhipuAI', config);
  }
}
````

## File: src/core/security/PromptInjectionGuard.ts
````typescript
/**
 * ApexBridge - 提示注入防护
 * 提供全面的提示注入攻击检测和防护功能
 */

import { logger } from '../../utils/logger';

/**
 * 注入防护配置选项
 */
export interface InjectionGuardOptions {
  /** 是否启用直接注入检测 */
  enableDirectDetection?: boolean;
  /** 是否启用间接注入检测 */
  enableIndirectDetection?: boolean;
  /** 是否启用越狱检测 */
  enableJailbreakDetection?: boolean;
  /** 是否启用XML注入检测 */
  enableXmlDetection?: boolean;
  /** 是否自动清理检测到的注入内容 */
  autoSanitize?: boolean;
  /** 风险等级阈值 (low/medium/high/critical) */
  riskThreshold?: 'low' | 'medium' | 'high' | 'critical';
}

/**
 * 检测到的注入模式
 */
export interface DetectedPattern {
  /** 注入类型 */
  type: 'direct' | 'jailbreak' | 'xml' | 'indirect' | 'obfuscation';
  /** 匹配的 pattern */
  pattern: string;
  /** 在内容中的位置 */
  position: number;
  /** 严重程度 */
  severity: 'low' | 'medium' | 'high' | 'critical';
}

/**
 * 注入检测结果
 */
export interface InjectionDetectionResult {
  /** 是否清洁 (无检测到注入) */
  isClean: boolean;
  /** 风险等级 */
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  /** 检测到的 pattern 列表 */
  detectedPatterns: DetectedPattern[];
  /** 清理后的内容 (如果启用自动清理) */
  sanitizedContent?: string;
}

/**
 * 提示注入防护类
 * 
 * 提供多种注入攻击的检测和防护:
 * - 直接注入: 覆盖系统指令
 * - 间接注入: 通过变量、模板注入
 * - 越狱攻击: 绕过安全限制
 * - XML注入: 利用XML解析漏洞
 */
export class PromptInjectionGuard {
  /** 单例实例 */
  private static instance: PromptInjectionGuard;
  
  /** 配置选项 */
  private options: Required<InjectionGuardOptions>;
  
  /** 缓存的检测结果 */
  private resultCache: Map<string, InjectionDetectionResult> = new Map();
  
  /** 最大缓存大小 */
  private readonly MAX_CACHE_SIZE = 1000;

  // ========================================
  // 编译的正则表达式 patterns - Direct Injection
  // ========================================
  
  /** 直接注入 pattern - 忽略之前指令 */
  private readonly DIRECT_PATTERNS = [
    { regex: /ignore\s+previous\s+instructions/gi, severity: 'critical' as const },
    { regex: /forget\s+all\s+instructions/gi, severity: 'critical' as const },
    { regex: /you\s+are\s+now\s+/gi, severity: 'high' as const },
    { regex: /system\s+override/gi, severity: 'critical' as const },
    { regex: /new\s+instructions/gi, severity: 'high' as const },
    { regex: /override\s+system/gi, severity: 'critical' as const },
    { regex: /ignore\s+all\s+previous\s+rules/gi, severity: 'critical' as const },
    { regex: /disregard\s+previous\s+(?:instructions|rules)/gi, severity: 'critical' as const },
    { regex: /act\s+as\s+(?:if\s+)?you\s+(?:are|were)/gi, severity: 'high' as const },
    { regex: /pretend\s+to\s+be/gi, severity: 'high' as const },
    { regex: /bypass\s+(?:your\s+)?(?:safety|security)/gi, severity: 'critical' as const },
    { regex: /disable\s+(?:your\s+)?(?:safety|security)/gi, severity: 'critical' as const },
  ];

  // ========================================
  // 编译的正则表达式 patterns - Jailbreak
  // ========================================
  
  /** 越狱攻击 patterns */
  private readonly JAILBREAK_PATTERNS = [
    { regex: /\bDAN\b/gi, severity: 'critical' as const },
    { regex: /do\s+anything\s+now/gi, severity: 'critical' as const },
    { regex: /jailbreak/gi, severity: 'critical' as const },
    { regex: /roleplay\s+as/gi, severity: 'high' as const },
    { regex: /developer\s+mode/gi, severity: 'high' as const },
    { regex: /ignore\s+safety/gi, severity: 'critical' as const },
    { regex: /unrestricted\s+mode/gi, severity: 'critical' as const },
    { regex: /evil\s+(?:mode|bot)/gi, severity: 'critical' as const },
    { regex: /no\s+(?:ethics|rules|limits)/gi, severity: 'critical' as const },
    { regex: /ignore\s+all\s+(?:content|guidelines)/gi, severity: 'critical' as const },
    { regex: /evil\s+version/gi, severity: 'critical' as const },
    { regex: /hypothetical\s+(?:scenario|response)/gi, severity: 'medium' as const },
    { regex: /what\s+if\s+(?:you\s+)?(?:could|might)/gi, severity: 'medium' as const },
    { regex: /play\s+the\s+role\s+of/gi, severity: 'high' as const },
    { regex: /assume\s+the\s+role\s+of/gi, severity: 'high' as const },
  ];

  // ========================================
  // 编译的正则表达式 patterns - XML Injection
  // ========================================
  
  /** XML/HTML 注入 patterns */
  private readonly XML_PATTERNS = [
    { regex: /<!--/g, severity: 'medium' as const },
    { regex: /-->/g, severity: 'medium' as const },
    { regex: /<\?/g, severity: 'medium' as const },
    { regex: /\?>/g, severity: 'medium' as const },
    { regex: /\]\]\>/g, severity: 'medium' as const },
    { regex: /<script/gi, severity: 'critical' as const },
    { regex: /<\/script>/gi, severity: 'critical' as const },
    { regex: /<iframe/gi, severity: 'critical' as const },
    { regex: /<\/iframe>/gi, severity: 'critical' as const },
    { regex: /<object/gi, severity: 'critical' as const },
    { regex: /<\/object>/gi, severity: 'critical' as const },
    { regex: /<embed/gi, severity: 'critical' as const },
    { regex: /<link/gi, severity: 'medium' as const },
    { regex: /<style/gi, severity: 'medium' as const },
    { regex: /<!\[CDATA\[/g, severity: 'medium' as const },
    { regex: /<!DOCTYPE/gi, severity: 'medium' as const },
    { regex: /<svg/gi, severity: 'high' as const },
    { regex: /<math/gi, severity: 'high' as const },
    { regex: /\x00/g, severity: 'critical' as const },
    { regex: /%00/g, severity: 'critical' as const },
    { regex: /[\u0000-\u0008\u000B\u000C\u000E-\u001F]/g, severity: 'high' as const },
    { regex: /[\u200B-\u200D\u2060\uFEFF]/g, severity: 'medium' as const }, // Zero-width characters
  ];

  // ========================================
  // 编译的正则表达式 patterns - Indirect Injection
  // ========================================
  
  /** 间接注入 patterns - 变量和模板 */
  private readonly INDIRECT_PATTERNS = [
    { regex: /\{\{[^}]+\}\}/g, severity: 'medium' as const }, // {{variable}}
    { regex: /\$\{[^}]+\}/g, severity: 'medium' as const },   // ${variable}
    { regex: /#\{[^}]+\}/g, severity: 'medium' as const },    // #{variable}
    { regex: /<%[^%]+%>/g, severity: 'medium' as const },     // <%template%>
    { regex: /\$\([[^\)]+\]\)/g, severity: 'high' as const }, // $(command)
    { regex: /`[^`]+`/g, severity: 'medium' as const },       // Backtick command substitution
    { regex: /\|[a-zA-Z]+(\|[a-zA-Z]+)*/g, severity: 'medium' as const }, // Shell pipe chains
    { regex: /;&amp;|\|;|&amp;&amp;/g, severity: 'high' as const }, // Command chaining
    { regex: /\$[a-zA-Z_][a-zA-Z0-9_]*/g, severity: 'low' as const }, // $variable
    { regex: /%[a-zA-Z_][a-zA-Z0-9_]*/g, severity: 'low' as const }, // %variable%
  ];

  /**
   * 私有构造函数 - 单例模式
   */
  private constructor(options?: InjectionGuardOptions) {
    this.options = {
      enableDirectDetection: options?.enableDirectDetection ?? true,
      enableIndirectDetection: options?.enableIndirectDetection ?? true,
      enableJailbreakDetection: options?.enableJailbreakDetection ?? true,
      enableXmlDetection: options?.enableXmlDetection ?? true,
      autoSanitize: options?.autoSanitize ?? false,
      riskThreshold: options?.riskThreshold ?? 'medium',
    };
  }

  /**
   * 获取单例实例
   */
  static getInstance(options?: InjectionGuardOptions): PromptInjectionGuard {
    if (!PromptInjectionGuard.instance) {
      PromptInjectionGuard.instance = new PromptInjectionGuard(options);
    }
    return PromptInjectionGuard.instance;
  }

  /**
   * 主要检测方法 - 综合分析内容
   * 
   * @param content - 要检测的内容
   * @returns 检测结果
   */
  detect(content: string): InjectionDetectionResult {
    if (!content || typeof content !== 'string') {
      return {
        isClean: true,
        riskLevel: 'low',
        detectedPatterns: [],
      };
    }

    // 检查缓存
    const cacheKey = this.hashContent(content);
    if (this.resultCache.has(cacheKey)) {
      return this.resultCache.get(cacheKey)!;
    }

    const detectedPatterns: DetectedPattern[] = [];

    // 根据配置执行检测
    if (this.options.enableDirectDetection) {
      detectedPatterns.push(...this.scanDirectInjection(content));
    }

    if (this.options.enableJailbreakDetection) {
      detectedPatterns.push(...this.scanJailbreak(content));
    }

    if (this.options.enableXmlDetection) {
      detectedPatterns.push(...this.scanXmlInjection(content));
    }

    if (this.options.enableIndirectDetection) {
      detectedPatterns.push(...this.scanIndirectInjection(content));
    }

    // 计算风险等级
    const riskLevel = this.calculateRiskLevel(detectedPatterns);

    // 检查是否超过阈值
    const isClean = riskLevel === 'low' || 
                    this.isRiskLevelBelowThreshold(riskLevel);

    // 生成结果
    const result: InjectionDetectionResult = {
      isClean,
      riskLevel,
      detectedPatterns,
    };

    // 如果启用自动清理，生成清理后的内容
    if (this.options.autoSanitize && !isClean) {
      result.sanitizedContent = this.sanitize(content);
    }

    // 记录警告日志
    if (!isClean) {
      logger.warn(`[PromptInjectionGuard] 检测到 ${detectedPatterns.length} 个注入 pattern，风险等级: ${riskLevel}`);
    }

    // 维护缓存
    this.maintainCache(cacheKey, result);

    return result;
  }

  /**
   * 检测直接注入
   * 
   * @param content - 要检测的内容
   * @returns 是否检测到直接注入
   */
  detectDirectInjection(content: string): boolean {
    const patterns = this.scanDirectInjection(content);
    return patterns.length > 0;
  }

  /**
   * 检测间接注入
   * 
   * @param content - 要检测的内容
   * @returns 是否检测到间接注入
   */
  detectIndirectInjection(content: string): boolean {
    const patterns = this.scanIndirectInjection(content);
    return patterns.length > 0;
  }

  /**
   * 检测越狱攻击
   * 
   * @param content - 要检测的内容
   * @returns 是否检测到越狱攻击
   */
  detectJailbreak(content: string): boolean {
    const patterns = this.scanJailbreak(content);
    return patterns.length > 0;
  }

  /**
   * 检测XML注入
   * 
   * @param content - 要检测的内容
   * @returns 是否检测到XML注入
   */
  detectXmlInjection(content: string): boolean {
    const patterns = this.scanXmlInjection(content);
    return patterns.length > 0;
  }

  /**
   * 清理注入内容
   * 
   * @param content - 要清理的内容
   * @returns 清理后的内容
   */
  sanitize(content: string): string {
    if (!content || typeof content !== 'string') {
      return content;
    }

    let sanitized = content;

    // 移除 XML/HTML 注入
    for (const pattern of this.XML_PATTERNS) {
      sanitized = sanitized.replace(pattern.regex, '');
    }

    // 移除直接注入 pattern
    for (const pattern of this.DIRECT_PATTERNS) {
      sanitized = sanitized.replace(pattern.regex, '');
    }

    // 移除越狱 pattern
    for (const pattern of this.JAILBREAK_PATTERNS) {
      sanitized = sanitized.replace(pattern.regex, '');
    }

    // 移除间接注入 pattern (变量替换)
    for (const pattern of this.INDIRECT_PATTERNS) {
      sanitized = sanitized.replace(pattern.regex, '[REDACTED]');
    }

    // 清理 null 字节和控制字符
    sanitized = sanitized.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\u200B-\u200D\u2060\uFEFF]/g, '');

    // 规范化空白
    sanitized = sanitized.replace(/\s+/g, ' ').trim();

    return sanitized;
  }

  /**
   * 获取检测结果 - 是否清洁
   */
  get isClean(): boolean {
    return this.detectedPatterns.length === 0;
  }

  /**
   * 获取最后检测的风险等级
   */
  get riskLevel(): 'low' | 'medium' | 'high' | 'critical' {
    return this.lastRiskLevel;
  }

  // ========================================
  // 私有方法
  // ========================================

  /**
   * 扫描直接注入
   */
  private scanDirectInjection(content: string): DetectedPattern[] {
    const results: DetectedPattern[] = [];

    for (const { regex, severity } of this.DIRECT_PATTERNS) {
      let match: RegExpExecArray | null;
      
      // Reset regex state
      regex.lastIndex = 0;

      while ((match = regex.exec(content)) !== null) {
        results.push({
          type: 'direct',
          pattern: match[0],
          position: match.index,
          severity,
        });

        // 防止无限循环
        if (match.index === regex.lastIndex) {
          regex.lastIndex++;
        }
      }
    }

    return results;
  }

  /**
   * 扫描越狱攻击
   */
  private scanJailbreak(content: string): DetectedPattern[] {
    const results: DetectedPattern[] = [];

    for (const { regex, severity } of this.JAILBREAK_PATTERNS) {
      let match: RegExpExecArray | null;
      
      regex.lastIndex = 0;

      while ((match = regex.exec(content)) !== null) {
        results.push({
          type: 'jailbreak',
          pattern: match[0],
          position: match.index,
          severity,
        });

        if (match.index === regex.lastIndex) {
          regex.lastIndex++;
        }
      }
    }

    return results;
  }

  /**
   * 扫描XML注入
   */
  private scanXmlInjection(content: string): DetectedPattern[] {
    const results: DetectedPattern[] = [];

    for (const { regex, severity } of this.XML_PATTERNS) {
      let match: RegExpExecArray | null;
      
      regex.lastIndex = 0;

      while ((match = regex.exec(content)) !== null) {
        results.push({
          type: 'xml',
          pattern: match[0],
          position: match.index,
          severity,
        });

        if (match.index === regex.lastIndex) {
          regex.lastIndex++;
        }
      }
    }

    return results;
  }

  /**
   * 扫描间接注入
   */
  private scanIndirectInjection(content: string): DetectedPattern[] {
    const results: DetectedPattern[] = [];

    for (const { regex, severity } of this.INDIRECT_PATTERNS) {
      let match: RegExpExecArray | null;
      
      regex.lastIndex = 0;

      while ((match = regex.exec(content)) !== null) {
        results.push({
          type: 'indirect',
          pattern: match[0],
          position: match.index,
          severity,
        });

        if (match.index === regex.lastIndex) {
          regex.lastIndex++;
        }
      }
    }

    return results;
  }

  /**
   * 计算风险等级
   */
  private calculateRiskLevel(patterns: DetectedPattern[]): 'low' | 'medium' | 'high' | 'critical' {
    if (patterns.length === 0) {
      return 'low';
    }

    // 统计各严重程度的数量
    const counts = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
    };

    for (const pattern of patterns) {
      counts[pattern.severity]++;
    }

    // 关键逻辑: 任何 critical 都提升到 critical
    if (counts.critical > 0) {
      return 'critical';
    }

    // 多个 high 也提升到 critical
    if (counts.high >= 2) {
      return 'critical';
    }

    // 至少一个 high
    if (counts.high === 1) {
      return 'high';
    }

    // 多个 medium
    if (counts.medium >= 3) {
      return 'high';
    }

    // 至少一个 medium
    if (counts.medium > 0) {
      return 'medium';
    }

    // 只有 low
    return 'low';
  }

  /**
   * 检查风险等级是否低于阈值
   */
  private isRiskLevelBelowThreshold(level: 'low' | 'medium' | 'high' | 'critical'): boolean {
    const levels = ['low', 'medium', 'high', 'critical'];
    const levelIndex = levels.indexOf(level);
    const thresholdIndex = levels.indexOf(this.options.riskThreshold);

    return levelIndex < thresholdIndex;
  }

  /**
   * 计算内容的 hash (用于缓存)
   */
  private hashContent(content: string): string {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return hash.toString(36);
  }

  /**
   * 维护缓存
   */
  private maintainCache(key: string, result: InjectionDetectionResult): void {
    if (this.resultCache.size >= this.MAX_CACHE_SIZE) {
      // 清理最老的 10% 缓存
      const keysToDelete = Array.from(this.resultCache.keys()).slice(0, Math.floor(this.MAX_CACHE_SIZE * 0.1));
      for (const k of keysToDelete) {
        this.resultCache.delete(k);
      }
    }
    this.resultCache.set(key, result);
  }

  /**
   * 清空缓存
   */
  clearCache(): void {
    this.resultCache.clear();
  }

  /**
   * 更新配置
   */
  updateOptions(options: Partial<InjectionGuardOptions>): void {
    this.options = {
      ...this.options,
      ...options,
    };
    this.clearCache();
  }

  // ========================================
  // 临时存储检测结果 (供 isClean 和 riskLevel 使用)
  // ========================================

  private detectedPatterns: DetectedPattern[] = [];
  private lastRiskLevel: 'low' | 'medium' | 'high' | 'critical' = 'low';
}

export default PromptInjectionGuard.getInstance();
````

## File: src/core/stream-orchestrator/ReActEnginePool.ts
````typescript
import PQueue from 'p-queue';
import { ReActEngine } from './ReActEngine';
import type { LLMAdapter, BatchTask, BatchResult } from './types';

export interface PoolOptions {
  maxConcurrent?: number;
}

export class ReActEnginePool {
  private engine: ReActEngine;
  private queue: PQueue;

  constructor(engine?: ReActEngine, options: PoolOptions = {}) {
    this.engine = engine ?? new ReActEngine();
    this.queue = new PQueue({ concurrency: options.maxConcurrent ?? 10 });
  }

  async *executeBatch(
    tasks: BatchTask[],
    llmClient: LLMAdapter,
    maxConcurrent: number = 10
  ): AsyncGenerator<BatchResult, void, void> {
    this.queue.concurrency = maxConcurrent;

    const executeTask = async (task: BatchTask): Promise<BatchResult> => {
      const stream = this.engine.execute(task.messages, llmClient, task.options);
      const chunks: any[] = [];

      for await (const chunk of stream) {
        chunks.push(chunk);
      }

      return {
        taskId: task.taskId,
        result: chunks,
        timestamp: Date.now()
      };
    };

    const promises = tasks.map(task =>
      this.queue.add(() => executeTask(task))
    );

    for (const promise of promises) {
      yield await promise;
    }
  }

  get activeCount(): number {
    return this.queue.pending;
  }

  get queuedCount(): number {
    return this.queue.size;
  }

  async pause(): Promise<void> {
    await this.queue.pause();
  }

  async resume(): Promise<void> {
    this.queue.start();
  }

  async onIdle(): Promise<void> {
    await this.queue.onIdle();
  }
}
````

## File: src/core/tool/tool.ts
````typescript
/**
 * Tool Framework - 工具定义和工厂函数
 * 基于 OpenSpec 提案的工具框架设计
 */

/**
 * 工具命名空间
 * 提供工具定义和工厂函数
 */
export namespace Tool {
  /**
   * 工具元数据
   */
  export interface Metadata {
    [key: string]: unknown;
  }

  /**
   * 工具初始化上下文
   */
  export interface InitContext {
    agent?: {
      id: string;
      name: string;
    };
  }

  /**
   * 工具执行上下文
   */
  export interface Context {
    /** 会话 ID */
    sessionID: string;
    /** 消息 ID */
    messageID: string;
    /** Agent 标识 */
    agent: string;
    /** 中止信号 */
    abort: AbortSignal;
    /** 调用 ID */
    callID?: string;
    /** 额外数据 */
    extra?: Record<string, unknown>;
    /**
     * 设置工具响应元数据
     * @param input - 元数据输入
     */
    metadata(input: { title?: string; metadata?: Metadata }): void;
  }

  /**
   * 文件附件类型
   */
  export interface FilePart {
    type: 'file';
    file: {
      filename: string;
      fileData?: string;
      mimeType?: string;
    };
  }

  /**
   * 工具定义接口
   * @typeParam Parameters - 参数类型
   * @typeParam M - 元数据类型
   */
  export interface Info<
    Parameters = Record<string, unknown>,
    M extends Metadata = Metadata,
  > {
    /** 工具唯一标识符 */
    id: string;
    /** 工具初始化函数 */
    init: (ctx?: InitContext) => Promise<{
      /** 工具描述 */
      description: string;
      /** 参数模式 */
      parameters: {
        type: 'object';
        properties?: Record<string, unknown>;
        required?: string[];
        additionalProperties?: boolean;
      };
      /**
       * 工具执行函数
       * @param args - 工具参数
       * @param ctx - 执行上下文
       * @returns 执行结果
       */
      execute(
        args: Parameters,
        ctx: Context,
      ): Promise<{
        /** 响应标题 */
        title: string;
        /** 元数据 */
        metadata: M;
        /** 输出内容 */
        output: string;
        /** 附件文件 */
        attachments?: FilePart[];
      }>;
      /** 参数验证错误格式化函数 */
      formatValidationError?(error: { errors: Array<{ path: string; message: string }> }): string;
    }>;
  }

  /**
   * 从工具定义推断参数类型
   */
  export type InferParameters<T extends Info> = T extends Info<infer P>
    ? P
    : never;

  /**
   * 从工具定义推断元数据类型
   */
  export type InferMetadata<T extends Info> = T extends Info<any, infer M>
    ? M
    : never;

  /**
   * 输出截断配置
   */
  export interface TruncateOptions {
    maxLines?: number;
    maxBytes?: number;
    direction?: 'head' | 'tail';
  }

  /**
   * 默认截断配置
   */
  const DEFAULT_TRUNCATE_OPTIONS: Required<TruncateOptions> = {
    maxLines: 2000,
    maxBytes: 50 * 1024,
    direction: 'head',
  };

  /**
   * 截断输出内容
   * @param text - 原始文本
   * @param options - 截断选项
   * @returns 截断结果
   */
  function truncateOutput(
    text: string,
    options?: TruncateOptions,
  ): { content: string; truncated: boolean } {
    const opts = { ...DEFAULT_TRUNCATE_OPTIONS, ...options };
    const lines = text.split('\n');
    const totalBytes = Buffer.byteLength(text, 'utf-8');

    if (lines.length <= opts.maxLines && totalBytes <= opts.maxBytes) {
      return { content: text, truncated: false };
    }

    const out: string[] = [];
    let bytes = 0;
    let hitBytes = false;
    let i = 0;

    if (opts.direction === 'head') {
      for (i = 0; i < lines.length && i < opts.maxLines; i++) {
        const lineSize = Buffer.byteLength(lines[i], 'utf-8') + (i > 0 ? 1 : 0);
        if (bytes + lineSize > opts.maxBytes) {
          hitBytes = true;
          break;
        }
        out.push(lines[i]);
        bytes += lineSize;
      }
      const removed = hitBytes ? totalBytes - bytes : lines.length - out.length;
      const unit = hitBytes ? 'chars' : 'lines';
      return {
        content: `${out.join('\n')}\n\n...${removed} ${unit} truncated...`,
        truncated: true,
      };
    }

    for (i = lines.length - 1; i >= 0 && out.length < opts.maxLines; i--) {
      const lineSize = Buffer.byteLength(lines[i], 'utf-8') + (out.length > 0 ? 1 : 0);
      if (bytes + lineSize > opts.maxBytes) {
        hitBytes = true;
        break;
      }
      out.unshift(lines[i]);
      bytes += lineSize;
    }
    const removed = hitBytes ? totalBytes - bytes : lines.length - out.length;
    const unit = hitBytes ? 'chars' : 'lines';
    return {
      content: `...${removed} ${unit} truncated...\n\n${out.join('\n')}`,
      truncated: true,
    };
  }

  /**
   * 定义工具的工厂函数
   * @typeParam Parameters - 参数类型
   * @typeParam Result - 结果元数据类型
   * @param id - 工具唯一标识符
   * @param init - 工具初始化函数或已解析的工具信息
   * @returns 工具定义
   */
  export function define<
    Parameters extends Record<string, unknown>,
    Result extends Metadata,
  >(
    id: string,
    init:
      | Info<Parameters, Result>['init']
      | Awaited<ReturnType<Info<Parameters, Result>['init']>>,
  ): Info<Parameters, Result> {
    return {
      id,
      init: async (ctx) => {
        const toolInfo =
          init instanceof Function ? await init(ctx) : init;

        const originalExecute = toolInfo.execute;

        // 包装 execute 函数，添加参数验证和输出截断
        toolInfo.execute = async (args, ctx) => {
          // 参数验证
          const { properties, required = [] } = toolInfo.parameters;

          // 检查必需参数
          for (const param of required) {
            if (args[param] === undefined || args[param] === null) {
              const errorMessage = `Missing required parameter: ${param}`;
              if (toolInfo.formatValidationError) {
                throw new Error(
                  toolInfo.formatValidationError({
                    errors: [{ path: param, message: errorMessage }],
                  }),
                );
              }
              throw new Error(errorMessage);
            }
          }

          // 执行原始函数
          const result = await originalExecute(args, ctx);

          // 截断输出
          const truncated = truncateOutput(result.output);
          return {
            ...result,
            output: truncated.content,
            metadata: {
              ...result.metadata,
              truncated: truncated.truncated,
            } as Result,
          };
        };

        return toolInfo;
      },
    };
  }
}
````

## File: src/core/tool-action/ErrorHandler.ts
````typescript
/**
 * ToolErrorHandler - 工具执行错误处理器
 * 统一分类和处理工具执行错误
 */

import { logger } from "../../utils/logger";
import { ErrorClassifier } from "../../utils/error-classifier";
import type { ToolExecutionResult } from "./types";

interface ErrorContext {
  tool_name: string;
  input_params?: Record<string, any>;
  timestamp: number;
  execution_time_ms: number;
}

interface ErrorDetails {
  error_type: string;
  error_message: string;
  error_stack?: string;
  context?: ErrorContext;
}

export class ToolErrorHandler {
  /**
   * 包装执行函数，统一处理错误
   */
  async wrapExecution<T>(
    toolName: string,
    executor: () => Promise<T>,
    onSuccess?: (result: T) => ToolExecutionResult
  ): Promise<ToolExecutionResult> {
    const startTime = Date.now();

    try {
      const result = await executor();

      if (onSuccess) {
        return onSuccess(result);
      }

      return this.createSuccessResult(toolName, result, startTime);
    } catch (error) {
      return this.handleError(error, toolName, startTime);
    }
  }

  /**
   * 处理错误并返回标准化的错误结果
   */
  handleError(error: unknown, toolName: string, startTime: number): ToolExecutionResult {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const errorType = ErrorClassifier.classifyError(error);

    const errorDetails: ErrorDetails = {
      error_type: errorType,
      error_message: errorMessage,
      error_stack: error instanceof Error ? error.stack : undefined,
      context: {
        tool_name: toolName,
        timestamp: Date.now(),
        execution_time_ms: Date.now() - startTime,
      },
    };

    logger.error(`[ToolErrorHandler] Tool execution failed: ${toolName}`, {
      error_type: errorType,
      error_message: errorMessage,
      stack: error instanceof Error ? error.stack : undefined,
    });

    return {
      success: false,
      toolName,
      error: errorMessage,
      executionTime: Date.now() - startTime,
      error_details: errorDetails,
    };
  }

  /**
   * 创建成功结果
   */
  createSuccessResult(
    toolName: string,
    result: unknown,
    executionTime: number,
    inputParams?: Record<string, any>,
    metadata?: Record<string, any>
  ): ToolExecutionResult {
    const outputContent = String(result || "");
    const tokenCount = ErrorClassifier.estimateTokens(outputContent);

    return {
      success: true,
      toolName,
      result,
      executionTime,
      tool_details: {
        tool_name: toolName,
        input_params: inputParams || {},
        output_content: outputContent,
        output_metadata: {
          token_count: tokenCount,
          execution_time_ms: executionTime,
          ...metadata,
        },
      },
    };
  }

  /**
   * 创建失败结果（不带异常）
   */
  createFailureResult(
    toolName: string,
    errorMessage: string,
    executionTime: number,
    inputParams?: Record<string, any>
  ): ToolExecutionResult {
    const errorType = ErrorClassifier.classifyError(new Error(errorMessage));

    const errorDetails: ErrorDetails = {
      error_type: errorType,
      error_message: errorMessage,
      context: {
        tool_name: toolName,
        input_params: inputParams,
        timestamp: Date.now(),
        execution_time_ms: executionTime,
      },
    };

    return {
      success: false,
      toolName,
      error: errorMessage,
      executionTime,
      error_details: errorDetails,
    };
  }

  /**
   * 检查错误是否可重试
   */
  isRetryable(errorType: string): boolean {
    const retryableTypes = ["RATE_LIMIT", "TIMEOUT", "NETWORK_ERROR"];
    return retryableTypes.includes(errorType);
  }

  /**
   * 获取用户友好的错误消息
   */
  getUserMessage(errorType: string): string {
    const messages: Record<string, string> = {
      RATE_LIMIT: "请求过于频繁，请稍后再试",
      TIMEOUT: "请求超时，请稍后再试",
      NETWORK_ERROR: "网络连接问题，请检查网络",
      VALIDATION_ERROR: "输入参数有误，请检查后重试",
      PERMISSION_DENIED: "没有执行此操作的权限",
      TOOL_NOT_FOUND: "指定的工具不存在",
      UNKNOWN_ERROR: "发生未知错误，请稍后重试",
    };
    return messages[errorType] || "操作失败，请稍后重试";
  }
}
````

## File: src/core/tool-action/index.ts
````typescript
/**
 * Tool Action 模块导出
 */

// 类型导出
export type {
  ToolActionCall,
  TextSegment,
  ParseResult,
  DetectionResult,
  DispatcherConfig,
  ToolExecutionResult,
  ToolDescription
} from './types';

export { DetectorState } from './types';

// 解析器导出
export { ToolActionParser, toolActionParser } from './ToolActionParser';

// 流式检测器导出
export { StreamTagDetector } from './StreamTagDetector';

// 工具调度器导出
export { ToolDispatcher, generateToolPrompt } from './ToolDispatcher';
````

## File: src/core/tool-action/ParameterConverter.ts
````typescript
/**
 * ParameterConverter - 参数类型转换器
 * 将字符串参数转换为目标类型
 */

interface ParameterProperty {
  type: string;
  description?: string;
}

interface PropertySchema {
  properties?: Record<string, ParameterProperty>;
  required?: string[];
}

export class ParameterConverter {
  /**
   * 转换参数类型（字符串 -> 实际类型）
   */
  convert(params: Record<string, string>, schema?: PropertySchema | null): Record<string, any> {
    const result: Record<string, any> = {};

    for (const [key, value] of Object.entries(params)) {
      const propSchema = schema?.properties?.[key];

      if (!propSchema) {
        result[key] = value;
        continue;
      }

      result[key] = this.convertValue(value, propSchema.type);
    }

    return result;
  }

  /**
   * 转换单个值
   */
  private convertValue(value: string, targetType: string): any {
    switch (targetType) {
      case "number":
        return Number(value);

      case "boolean":
        return value === "true" || value === "1" || value === "yes";

      case "array":
        try {
          return JSON.parse(value);
        } catch {
          return value.split(",").map((s) => s.trim());
        }

      case "object":
        try {
          return JSON.parse(value);
        } catch {
          return value;
        }

      case "integer":
        return parseInt(value, 10);

      case "float":
        return parseFloat(value);

      default:
        return value;
    }
  }

  /**
   * 批量转换数组参数
   */
  convertArray(
    items: Record<string, string>[],
    schema?: PropertySchema | null
  ): Record<string, any>[] {
    return items.map((item) => this.convert(item, schema));
  }

  /**
   * 验证必需参数
   */
  validateRequired(
    params: Record<string, any>,
    requiredFields: string[]
  ): { valid: boolean; missing?: string[] } {
    const missing = requiredFields.filter((field) => {
      const value = params[field];
      return value === undefined || value === null || value === "";
    });

    return {
      valid: missing.length === 0,
      missing: missing.length > 0 ? missing : undefined,
    };
  }

  /**
   * 获取参数默认值
   */
  getDefaultValue(schema: ParameterProperty, defaultValue?: string): any {
    if (defaultValue !== undefined) {
      return this.convertValue(defaultValue, schema.type);
    }
    if (schema.type === "boolean") return false;
    if (schema.type === "number" || schema.type === "integer") return 0;
    if (schema.type === "array") return [];
    if (schema.type === "object") return {};
    return "";
  }
}
````

## File: src/core/tool-action/StreamTagDetector.ts
````typescript
/**
 * StreamTagDetector - 流式标签检测器
 *
 * 在流式输出中实时检测 <tool_action> 标签
 * 使用状态机模式处理跨 chunk 的标签检测
 */

import type { ToolActionCall, DetectionResult } from './types';
import { DetectorState } from './types';
import { ToolActionParser } from './ToolActionParser';

export class StreamTagDetector {
  private buffer: string = '';
  private state: DetectorState = DetectorState.NORMAL;
  private parser: ToolActionParser;

  // 标签标识符
  private static readonly OPEN_TAG_START = '<tool_action';
  private static readonly CLOSE_TAG = '</tool_action>';

  constructor() {
    this.parser = new ToolActionParser();
  }

  /**
   * 处理流式输入的文本块
   * @param chunk 输入的文本块
   * @returns 检测结果
   */
  processChunk(chunk: string): DetectionResult {
    // 将新 chunk 添加到缓冲区
    this.buffer += chunk;

    // 根据当前状态处理
    switch (this.state) {
      case DetectorState.NORMAL:
        return this.handleNormalState();

      case DetectorState.TAG_OPENING:
      case DetectorState.TAG_CONTENT:
        return this.handleTagState();

      default:
        return this.handleNormalState();
    }
  }

  /**
   * 处理正常状态（无标签检测中）
   */
  private handleNormalState(): DetectionResult {
    const openTagIndex = this.buffer.indexOf(StreamTagDetector.OPEN_TAG_START);

    // 没有检测到完整的标签开始
    if (openTagIndex === -1) {
      // 检查缓冲区末尾是否可能是标签开始的一部分
      const safeOutputEnd = this.findPotentialTagStart();

      if (safeOutputEnd < this.buffer.length) {
        // 缓冲区末尾可能是标签开始的一部分，只输出安全部分
        const textToEmit = safeOutputEnd > 0 ? this.buffer.slice(0, safeOutputEnd) : '';
        this.buffer = this.buffer.slice(safeOutputEnd);

        return {
          complete: false,
          textToEmit,
          bufferRemainder: this.buffer
        };
      }

      // 没有潜在的标签开始，安全输出全部内容
      const textToEmit = this.buffer;
      this.buffer = '';

      return {
        complete: false,
        textToEmit,
        bufferRemainder: ''
      };
    }

    // 检测到标签开始
    this.state = DetectorState.TAG_OPENING;

    // 输出标签开始前的文本
    const textToEmit = this.buffer.slice(0, openTagIndex);
    this.buffer = this.buffer.slice(openTagIndex);

    // 继续检查是否有完整标签
    return this.handleTagState(textToEmit);
  }

  /**
   * 处理标签状态（标签检测中）
   */
  private handleTagState(previousText: string = ''): DetectionResult {
    // 检查是否有完整的闭合标签
    const closeTagIndex = this.buffer.indexOf(StreamTagDetector.CLOSE_TAG);

    if (closeTagIndex === -1) {
      // 标签还未完整，继续缓冲
      this.state = DetectorState.TAG_CONTENT;

      return {
        complete: false,
        textToEmit: previousText,
        bufferRemainder: this.buffer
      };
    }

    // 找到完整标签
    const tagEndIndex = closeTagIndex + StreamTagDetector.CLOSE_TAG.length;
    const fullTagText = this.buffer.slice(0, tagEndIndex);

    // 解析标签
    const toolAction = this.parser.parseSingleTag(fullTagText);

    if (!toolAction) {
      // 解析失败，作为普通文本处理
      this.state = DetectorState.NORMAL;
      const textToEmit = previousText + this.buffer.slice(0, tagEndIndex);
      this.buffer = this.buffer.slice(tagEndIndex);

      return {
        complete: false,
        textToEmit,
        bufferRemainder: this.buffer
      };
    }

    // 解析成功
    this.state = DetectorState.NORMAL;
    const remainingText = this.buffer.slice(tagEndIndex);
    this.buffer = remainingText;

    return {
      complete: true,
      toolAction,
      textToEmit: previousText,
      bufferRemainder: remainingText
    };
  }

  /**
   * 查找缓冲区末尾可能的标签开始
   * 返回安全输出的位置（0 表示整个缓冲区都可能是标签开始）
   */
  private findPotentialTagStart(): number {
    const tag = StreamTagDetector.OPEN_TAG_START; // '<tool_action'

    // 从缓冲区末尾向前检查是否有部分匹配
    // 例如: buffer = "text<too" -> 应该返回 4 (保留 "<too")
    // 例如: buffer = "<tool_" -> 应该返回 0 (保留整个缓冲区)
    for (let matchLen = Math.min(tag.length - 1, this.buffer.length); matchLen >= 1; matchLen--) {
      const suffix = this.buffer.slice(-matchLen);
      const prefix = tag.slice(0, matchLen);
      if (suffix === prefix) {
        // 找到匹配，返回安全输出位置
        return this.buffer.length - matchLen;
      }
    }

    // 没有找到潜在的标签开始，可以输出整个缓冲区
    return this.buffer.length;
  }

  /**
   * 重置检测器状态
   */
  reset(): void {
    this.buffer = '';
    this.state = DetectorState.NORMAL;
  }

  /**
   * 强制刷新缓冲区（流结束时调用）
   * @returns 缓冲区中剩余的文本
   */
  flush(): string {
    const remaining = this.buffer;
    this.reset();
    return remaining;
  }

  /**
   * 获取当前状态
   */
  getState(): DetectorState {
    return this.state;
  }

  /**
   * 获取当前缓冲区内容
   */
  getBuffer(): string {
    return this.buffer;
  }

  /**
   * 检查是否在标签检测中
   */
  isDetecting(): boolean {
    return this.state !== DetectorState.NORMAL;
  }
}
````

## File: src/core/tools/builtin/FileWriteTool.ts
````typescript
/**
 * FileWriteTool - 文件写入内置工具
 * 提供安全、可靠的文件写入功能
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { ToolResult, BuiltInTool, ToolType } from '../../../types/tool-system';

/**
 * FileWriteTool参数接口
 */
export interface FileWriteArgs {
  /** 文件路径 */
  path: string;
  /** 文件内容 */
  content: string;
  /** 文件编码 */
  encoding?: BufferEncoding;
  /** 是否创建备份 */
  backup?: boolean;
  /** 备份文件后缀 */
  backupSuffix?: string;
  /** 是否创建目录（如果不存在） */
  createDirectory?: boolean;
  /** 写入模式 */
  mode?: 'overwrite' | 'append' | 'create';
}

/**
 * 文件写入工具
 * 安全写入文件内容，支持备份和目录创建
 */
export class FileWriteTool {
  private static readonly DEFAULT_ENCODING: BufferEncoding = 'utf8';
  private static readonly DEFAULT_MODE = 'overwrite' as const;
  private static readonly DEFAULT_BACKUP_SUFFIX = '.backup';
  private static readonly MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB
  private static readonly ALLOWED_EXTENSIONS = [
    '.txt', '.md', '.json', '.yaml', '.yml', '.xml', '.csv',
    '.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.cpp', '.c',
    '.html', '.css', '.scss', '.less', '.sql', '.sh', '.bat',
    '.dockerfile', '.gitignore', '.env', '.conf', '.config',
    '.log', '.tmp'
  ];

  /**
   * 执行文件写入
   * @param args 写入参数
   * @returns 写入结果
   */
  static async execute(args: FileWriteArgs): Promise<ToolResult> {
    const startTime = Date.now();

    try {
      // 参数验证
      this.validateArgs(args);

      // 安全路径检查
      const safePath = await this.getSafePath(args.path);

      // 检查文件大小（如果文件已存在）
      await this.checkExistingFileSize(safePath);

      // 检查文件扩展名
      this.checkFileExtension(safePath);

      // 创建目录（如果需要）
      if (args.createDirectory !== false) {
        await this.ensureDirectoryExists(path.dirname(safePath));
      }

      // 创建备份（如果需要）
      if (args.backup) {
        await this.createBackup(safePath, args.backupSuffix || this.DEFAULT_BACKUP_SUFFIX);
      }

      // 检查写入模式
      await this.checkWriteMode(safePath, args.mode || this.DEFAULT_MODE);

      // 写入文件
      await this.writeFileContent(
        safePath,
        args.content,
        args.encoding || this.DEFAULT_ENCODING,
        args.mode || this.DEFAULT_MODE
      );

      const duration = Date.now() - startTime;

      return {
        success: true,
        output: `File written successfully: ${safePath}`,
        duration,
        exitCode: 0
      };

    } catch (error) {
      const duration = Date.now() - startTime;
      return {
        success: false,
        error: this.formatError(error),
        duration,
        errorCode: 'FILE_WRITE_ERROR',
        exitCode: 1
      };
    }
  }

  /**
   * 验证参数
   */
  private static validateArgs(args: FileWriteArgs): void {
    if (!args.path || typeof args.path !== 'string') {
      throw new Error('File path is required and must be a string');
    }

    if (args.content === undefined || args.content === null) {
      throw new Error('File content is required');
    }

    if (args.encoding && !Buffer.isEncoding(args.encoding)) {
      throw new Error(`Invalid encoding: ${args.encoding}`);
    }

    if (args.mode && !['overwrite', 'append', 'create'].includes(args.mode)) {
      throw new Error(`Invalid mode: ${args.mode}. Must be 'overwrite', 'append', or 'create'`);
    }

    // 检查内容大小
    const contentSize = Buffer.byteLength(args.content, args.encoding || this.DEFAULT_ENCODING);
    if (contentSize > this.MAX_FILE_SIZE) {
      throw new Error(`Content size ${contentSize} exceeds maximum allowed size ${this.MAX_FILE_SIZE}`);
    }
  }

  /**
   * 获取安全路径（防止目录遍历攻击）
   */
  private static async getSafePath(inputPath: string): Promise<string> {
    const normalizedPath = path.normalize(inputPath);

    const absolutePath = path.isAbsolute(normalizedPath)
      ? normalizedPath
      : path.resolve(process.cwd(), normalizedPath);

    if (normalizedPath.includes('..') || absolutePath.includes('..')) {
      throw new Error('Path traversal detected');
    }

    const workDir = process.cwd();
    if (!absolutePath.startsWith(workDir)) {
      throw new Error('File path must be within the working directory');
    }

    return absolutePath;
  }

  /**
   * 检查现有文件大小
   */
  private static async checkExistingFileSize(filePath: string): Promise<void> {
    try {
      const stats = await fs.stat(filePath);
      if (stats.size > this.MAX_FILE_SIZE) {
        throw new Error(`Existing file size ${stats.size} exceeds maximum allowed size ${this.MAX_FILE_SIZE}`);
      }
    } catch (error) {
      // 文件不存在是正常的，继续执行
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
        throw error;
      }
    }
  }

  /**
   * 检查文件扩展名
   */
  private static checkFileExtension(filePath: string): void {
    const ext = path.extname(filePath).toLowerCase();

    if (!ext) {
      return; // 没有扩展名允许
    }

    if (!this.ALLOWED_EXTENSIONS.includes(ext)) {
      throw new Error(`File extension '${ext}' is not allowed for security reasons`);
    }
  }

  /**
   * 确保目录存在
   */
  private static async ensureDirectoryExists(dirPath: string): Promise<void> {
    try {
      await fs.mkdir(dirPath, { recursive: true });
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code !== 'EEXIST') {
        throw new Error(`Failed to create directory: ${dirPath}`);
      }
    }
  }

  /**
   * 创建备份
   */
  private static async createBackup(filePath: string, suffix: string): Promise<void> {
    try {
      await fs.access(filePath);
      const backupPath = `${filePath}${suffix}`;
      await fs.copyFile(filePath, backupPath);
    } catch (error) {
      // 文件不存在，不需要备份
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
        throw error;
      }
    }
  }

  /**
   * 检查写入模式
   */
  private static async checkWriteMode(filePath: string, mode: string): Promise<void> {
    if (mode === 'create') {
      try {
        await fs.access(filePath);
        throw new Error(`File already exists and mode is 'create': ${filePath}`);
      } catch (error) {
        if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
          throw error;
        }
        // 文件不存在，可以创建
      }
    }
  }

  /**
   * 写入文件内容
   */
  private static async writeFileContent(
    filePath: string,
    content: string,
    encoding: BufferEncoding,
    mode: string
  ): Promise<void> {
    const writeOptions = { encoding, flag: this.getWriteFlag(mode) };
    await fs.writeFile(filePath, content, writeOptions);
  }

  /**
   * 获取写入标志
   */
  private static getWriteFlag(mode: string): string {
    switch (mode) {
      case 'overwrite':
        return 'w'; // 覆盖写入
      case 'append':
        return 'a'; // 追加写入
      case 'create':
        return 'wx'; // 创建新文件（如果存在则失败）
      default:
        return 'w';
    }
  }

  /**
   * 格式化错误信息
   */
  private static formatError(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === 'string') {
      return error;
    }
    return 'Unknown error occurred';
  }

  /**
   * 获取工具元数据
   */
  static getMetadata() {
    return {
      name: 'file-write',
      description: '安全写入文件内容，支持备份、目录创建和多种写入模式',
      category: 'filesystem',
      level: 1,
      parameters: {
        type: 'object',
        properties: {
          path: {
            type: 'string',
            description: '要写入的文件路径'
          },
          content: {
            type: 'string',
            description: '要写入的文件内容'
          },
          encoding: {
            type: 'string',
            description: '文件编码，默认为utf8',
            default: 'utf8',
            enum: ['utf8', 'utf16le', 'latin1', 'base64', 'hex', 'ascii']
          },
          backup: {
            type: 'boolean',
            description: '是否创建备份文件',
            default: false
          },
          backupSuffix: {
            type: 'string',
            description: '备份文件后缀，默认为.backup',
            default: '.backup'
          },
          createDirectory: {
            type: 'boolean',
            description: '是否自动创建目录（如果不存在）',
            default: true
          },
          mode: {
            type: 'string',
            description: '写入模式',
            default: 'overwrite',
            enum: ['overwrite', 'append', 'create']
          }
        },
        required: ['path', 'content']
      }
    };
  }
}

/**
 * 创建FileWriteTool实例（用于注册表）
 */
export function createFileWriteTool() {
  return {
    ...FileWriteTool.getMetadata(),
    type: ToolType.BUILTIN,
    enabled: true,
    execute: async (args: Record<string, any>) => {
      return FileWriteTool.execute(args as FileWriteArgs);
    }
  } as BuiltInTool;
}
````

## File: src/core/tools/builtin/PlatformDetectorTool.ts
````typescript
/**
 * PlatformDetectorTool - 平台检测内置工具
 * 检测操作系统、Node.js版本、硬件架构等信息
 */

import { ToolResult, BuiltInTool, ToolType } from '../../../types/tool-system';
import * as os from 'os';

/**
 * PlatformDetectorTool参数接口
 */
export interface PlatformDetectorArgs {
  // 无参数，工具自动检测所有信息
}

/**
 * 平台信息接口
 */
export interface PlatformInfo {
  os: {
    platform: string;
    type: string;
    release: string;
    arch: string;
    uptime: number;
    hostname: string;
    homedir: string;
    tmpdir: string;
  };
  node: {
    version: string;
    v8Version: string;
    uvVersion: string;
    zlibVersion: string;
    aresVersion: string;
  };
  system: {
    cpus: number;
    cpuModel: string;
    memory: {
      total: number;
      free: number;
      used: number;
      usagePercent: number;
    };
    loadAverage: number[];
  };
  network: {
    interfaces: Record<string, os.NetworkInterfaceInfo[]>;
  };
}

/**
 * 平台检测工具
 * 提供详细的系统环境信息
 */
export class PlatformDetectorTool {
  /**
   * 执行平台检测
   * @param args 检测参数
   * @returns 检测结果
   */
  static async execute(args: PlatformDetectorArgs): Promise<ToolResult> {
    const startTime = Date.now();

    try {
      logger.debug('Detecting platform information...');

      // 收集平台信息
      const platformInfo = await this.collectPlatformInfo();

      const duration = Date.now() - startTime;

      // 格式化输出
      const formattedOutput = this.formatPlatformInfo(platformInfo);

      return {
        success: true,
        output: formattedOutput,
        duration,
        exitCode: 0
      };

    } catch (error) {
      const duration = Date.now() - startTime;

      logger.error('Platform detection failed:', error);

      return {
        success: false,
        error: `Platform detection failed: ${this.formatError(error)}`,
        duration,
        errorCode: 'PLATFORM_DETECTION_ERROR',
        exitCode: 1
      };
    }
  }

  /**
   * 收集平台信息
   */
  private static async collectPlatformInfo(): Promise<PlatformInfo> {
    const [totalMem, freeMem, cpus, networkInterfaces] = await Promise.all([
      Promise.resolve(os.totalmem()),
      Promise.resolve(os.freemem()),
      Promise.resolve(os.cpus()),
      Promise.resolve(os.networkInterfaces())
    ]);

    const usedMem = totalMem - freeMem;
    const memoryUsagePercent = ((usedMem / totalMem) * 100).toFixed(2);

    return {
      os: {
        platform: os.platform(),
        type: os.type(),
        release: os.release(),
        arch: os.arch(),
        uptime: os.uptime(),
        hostname: os.hostname(),
        homedir: os.homedir(),
        tmpdir: os.tmpdir()
      },
      node: {
        version: process.version,
        v8Version: process.versions.v8,
        uvVersion: process.versions.uv,
        zlibVersion: process.versions.zlib,
        aresVersion: process.versions.ares
      },
      system: {
        cpus: cpus.length,
        cpuModel: cpus[0]?.model || 'Unknown',
        memory: {
          total: totalMem,
          free: freeMem,
          used: usedMem,
          usagePercent: parseFloat(memoryUsagePercent)
        },
        loadAverage: os.loadavg()
      },
      network: {
        interfaces: networkInterfaces
      }
    };
  }

  /**
   * 格式化平台信息
   */
  private static formatPlatformInfo(info: PlatformInfo): string {
    let output = 'Platform Detection Results\n';
    output += '=' .repeat(50) + '\n\n';

    // 操作系统信息
    output += '🖥️  Operating System\n';
    output += '─'.repeat(30) + '\n';
    output += `Platform: ${info.os.platform}\n`;
    output += `Type: ${info.os.type}\n`;
    output += `Release: ${info.os.release}\n`;
    output += `Architecture: ${info.os.arch}\n`;
    output += `Uptime: ${this.formatUptime(info.os.uptime)}\n`;
    output += `Hostname: ${info.os.hostname}\n`;
    output += `Home Directory: ${info.os.homedir}\n`;
    output += `Temp Directory: ${info.os.tmpdir}\n\n`;

    // Node.js信息
    output += '⬢  Node.js Runtime\n';
    output += '─'.repeat(30) + '\n';
    output += `Node.js Version: ${info.node.version}\n`;
    output += `V8 Version: ${info.node.v8Version}\n`;
    output += `libuv Version: ${info.node.uvVersion}\n`;
    output += `zlib Version: ${info.node.zlibVersion}\n`;
    output += `c-ares Version: ${info.node.aresVersion}\n\n`;

    // 系统硬件信息
    output += '🔧  System Hardware\n';
    output += '─'.repeat(30) + '\n';
    output += `CPU Cores: ${info.system.cpus}\n`;
    output += `CPU Model: ${info.system.cpuModel}\n`;
    output += `Memory: ${this.formatBytes(info.system.memory.total)} Total\n`;
    output += `Memory: ${this.formatBytes(info.system.memory.free)} Free\n`;
    output += `Memory: ${this.formatBytes(info.system.memory.used)} Used\n`;
    output += `Memory Usage: ${info.system.memory.usagePercent}%\n`;
    output += `Load Average (1m): ${info.system.loadAverage[0]}\n`;
    output += `Load Average (5m): ${info.system.loadAverage[1]}\n`;
    output += `Load Average (15m): ${info.system.loadAverage[2]}\n\n`;

    // 网络接口信息（可选，可能包含敏感信息）
    output += '🌐  Network Interfaces\n';
    output += '─'.repeat(30) + '\n';
    output += this.formatNetworkInterfaces(info.network.interfaces);

    return output;
  }

  /**
   * 格式化正常运行时间
   */
  private static formatUptime(seconds: number): string {
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (days > 0) {
      return `${days} day${days > 1 ? 's' : ''}, ${hours} hour${hours !== 1 ? 's' : ''}`;
    }
    if (hours > 0) {
      return `${hours} hour${hours !== 1 ? 's' : ''}, ${minutes} minute${minutes !== 1 ? 's' : ''}`;
    }
    return `${minutes} minute${minutes !== 1 ? 's' : ''}`;
  }

  /**
   * 格式化字节数
   */
  private static formatBytes(bytes: number): string {
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  /**
   * 格式化网络接口
   */
  private static formatNetworkInterfaces(interfaces: Record<string, os.NetworkInterfaceInfo[]>): string {
    let output = '';
    const displayedInterfaces: string[] = [];

    for (const [name, info] of Object.entries(interfaces)) {
      // 忽略一些常见但不重要的接口
      if (name.includes('docker') || name.includes('br-') || name.includes('veth')) {
        continue;
      }

      displayedInterfaces.push(name);
      output += `${name}:\n`;

      const ipv4Info = info.find(i => i.family === 'IPv4' || i.family === (4 as any));
      const ipv6Info = info.find(i => i.family === 'IPv6' || i.family === (6 as any));

      if (ipv4Info) {
        output += `  IPv4: ${ipv4Info.address}\n`;
      }
      if (ipv6Info) {
        output += `  IPv6: ${ipv6Info.address}\n`;
      }
    }

    if (displayedInterfaces.length === 0) {
      output += 'No network interfaces detected (or only Docker/virtual interfaces)\n';
    }

    return output;
  }

  /**
   * 获取系统性能评分
   */
  private static getPerformanceScore(info: PlatformInfo): number {
    let score = 50; // 基础分

    // CPU加分
    if (info.system.cpus >= 8) score += 20;
    else if (info.system.cpus >= 4) score += 10;
    else if (info.system.cpus >= 2) score += 5;

    // 内存加分
    if (info.system.memory.total >= 16 * 1024 * 1024 * 1024) score += 20; // 16GB+
    else if (info.system.memory.total >= 8 * 1024 * 1024 * 1024) score += 10; // 8GB+
    else if (info.system.memory.total >= 4 * 1024 * 1024 * 1024) score += 5; // 4GB+

    // 负载减分
    const load1m = info.system.loadAverage[0] / info.system.cpus;
    if (load1m > 0.8) score -= 10;
    else if (load1m > 0.5) score -= 5;

    return Math.min(100, Math.max(0, score));
  }

  /**
   * 格式化错误信息
   */
  private static formatError(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === 'string') {
      return error;
    }
    return 'Unknown platform detection error';
  }

  /**
   * 获取工具元数据
   */
  static getMetadata() {
    return {
      name: 'platform-detector',
      description: 'Detect and provide detailed information about the current system platform, OS, Node.js runtime, hardware, and performance metrics. Useful for debugging environment issues or understanding system capabilities.',
      category: 'system',
      level: 2,
      parameters: {
        type: 'object',
        properties: {},
        required: []
      }
    };
  }

  /**
   * 计算搜索查询的向量嵌入（备用方法）
   */
  private static async getQueryEmbedding(query: string): Promise<number[]> {
    // 这个方法将由ToolRetrievalService实现
    // 这里只是占位符
    throw new Error('getQueryEmbedding not implemented');
  }

  /**
   * 从搜索结果中提取工具参数模式（用于动态生成工具调用）
   */
  private static extractParametersFromResults(results: any[]): string {
    if (results.length === 0) {
      return 'No tools found';
    }

    const tool = results[0].tool;
    if (!tool.parameters || !tool.parameters.properties) {
      return 'No parameters defined';
    }

    const params = Object.entries(tool.parameters.properties).map(([name, schema]: [string, any]) => {
      const required = tool.parameters.required?.includes(name) ? ' (required)' : '';
      return `    ${name}${required}: ${schema.type} - ${schema.description}`;
    });

    return params.join('\n');
  }
}

// 简单的logger占位符
const logger = {
  debug: (msg: string, ...args: any[]) => console.log(`[DEBUG] ${msg}`, ...args),
  error: (msg: string, ...args: any[]) => console.error(`[ERROR] ${msg}`, ...args)
};

/**
 * 创建PlatformDetectorTool实例（用于注册表）
 */
export function createPlatformDetectorTool() {
  return {
    ...PlatformDetectorTool.getMetadata(),
    type: ToolType.BUILTIN,
    enabled: true,
    execute: async (args: Record<string, any>) => {
      return PlatformDetectorTool.execute(args as PlatformDetectorArgs);
    }
  } as BuiltInTool;
}
````

## File: src/core/tools/builtin/ReadSkillTool.ts
````typescript
/**
 * ReadSkillTool - 读取 Skill 文档内置工具
 * 用于读取知识型 Skill 的完整文档内容
 */

import { ToolResult, BuiltInTool, ToolType } from '../../../types/tool-system';
import { getSkillManager } from '../../../services/SkillManager';
import { logger } from '../../../utils/logger';
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * ReadSkillTool 参数接口
 */
export interface ReadSkillArgs {
  /** Skill 名称 */
  skillName: string;
  /** 是否包含元数据（默认 false） */
  includeMetadata?: boolean;
}

/**
 * 读取 Skill 工具
 * 用于获取知识型 Skill 的完整文档内容
 */
export class ReadSkillTool {
  /**
   * 执行读取 Skill 文档
   * @param args 读取参数
   * @returns 读取结果
   */
  static async execute(args: ReadSkillArgs): Promise<ToolResult> {
    const startTime = Date.now();

    try {
      // 参数验证
      this.validateArgs(args);

      logger.info(`Reading Skill documentation: ${args.skillName}`);

      // 获取 SkillManager
      const skillManager = getSkillManager();

      // 查询 Skill
      const skill = await skillManager.getSkillByName(args.skillName);

      if (!skill) {
        throw new Error(`Skill not found: ${args.skillName}`);
      }

      // 读取 SKILL.md 文件
      const skillMdPath = path.join(skill.path, 'SKILL.md');
      const content = await fs.readFile(skillMdPath, 'utf8');

      const duration = Date.now() - startTime;

      // 格式化输出
      const output = this.formatSkillContent(args.skillName, content, skill, args.includeMetadata);

      logger.info(`Skill documentation read successfully in ${duration}ms`);

      return {
        success: true,
        output,
        duration,
        exitCode: 0
      };

    } catch (error) {
      const duration = Date.now() - startTime;

      logger.error(`Failed to read Skill documentation:`, error);

      return {
        success: false,
        error: this.formatError(error),
        duration,
        errorCode: 'READ_SKILL_ERROR',
        exitCode: 1
      };
    }
  }

  /**
   * 验证参数
   */
  private static validateArgs(args: ReadSkillArgs): void {
    if (!args.skillName || typeof args.skillName !== 'string') {
      throw new Error('skillName is required and must be a non-empty string');
    }

    if (args.skillName.trim().length === 0) {
      throw new Error('skillName cannot be empty or whitespace only');
    }
  }

  /**
   * 格式化 Skill 内容
   */
  private static formatSkillContent(
    skillName: string,
    content: string,
    skill: any,
    includeMetadata?: boolean
  ): string {
    let output = `# Skill Documentation: ${skillName}\n\n`;

    // 添加基本信息
    output += `**Version:** ${skill.version || 'N/A'}\n`;
    output += `**Description:** ${skill.description}\n`;

    if (skill.tags && skill.tags.length > 0) {
      output += `**Tags:** ${skill.tags.join(', ')}\n`;
    }

    if (skill.author) {
      output += `**Author:** ${skill.author}\n`;
    }

    output += `\n---\n\n`;

    // 添加完整文档内容
    output += content;

    // 可选：添加元数据
    if (includeMetadata && skill.parameters) {
      output += `\n\n---\n\n## Parameters Schema\n\n`;
      output += '```json\n';
      output += JSON.stringify(skill.parameters, null, 2);
      output += '\n```\n';
    }

    return output;
  }

  /**
   * 格式化错误信息
   */
  private static formatError(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === 'string') {
      return error;
    }
    return 'Unknown error occurred while reading Skill documentation';
  }

  /**
   * 获取工具元数据
   */
  static getMetadata() {
    return {
      name: 'read-skill',
      description: 'Read the complete documentation of a Skill. Use this to get detailed information about knowledge-based Skills or to understand how to use executable Skills.',
      category: 'skill',
      level: 1,
      parameters: {
        type: 'object',
        properties: {
          skillName: {
            type: 'string',
            description: 'The name of the Skill to read (e.g., "calculator")'
          },
          includeMetadata: {
            type: 'boolean',
            description: 'Whether to include parameter schema metadata in the output',
            default: false
          }
        },
        required: ['skillName']
      }
    };
  }
}

/**
 * 创建 ReadSkillTool 实例（用于注册表）
 */
export function createReadSkillTool() {
  return {
    ...ReadSkillTool.getMetadata(),
    type: ToolType.BUILTIN,
    enabled: true,
    execute: async (args: Record<string, any>) => {
      return ReadSkillTool.execute(args as ReadSkillArgs);
    }
  } as BuiltInTool;
}
````

## File: src/database/migrations/001_create_type_vocabulary.sql
````sql
-- Migration: Create Type Vocabulary Table
-- Description: Stores all type tags extracted from playbooks
-- Created: 2025-12-18

CREATE TABLE type_vocabulary (
  tag_name TEXT PRIMARY KEY,
  keywords TEXT NOT NULL, -- JSON array of keywords
  confidence REAL NOT NULL DEFAULT 0.0 CHECK (confidence >= 0.0 AND confidence <= 1.0),
  first_identified INTEGER NOT NULL,
  playbook_count INTEGER NOT NULL DEFAULT 0,
  discovered_from TEXT NOT NULL CHECK (discovered_from IN ('historical_clustering', 'manual_creation', 'llm_suggestion')),
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  metadata TEXT -- JSON object for additional information
);

-- Indexes for common queries
CREATE INDEX idx_type_vocabulary_confidence ON type_vocabulary(confidence DESC);
CREATE INDEX idx_type_vocabulary_playbook_count ON type_vocabulary(playbook_count DESC);
CREATE INDEX idx_type_vocabulary_created ON type_vocabulary(created_at DESC);
````

## File: src/database/migrations/002_create_type_similarity_matrix.sql
````sql
-- Migration: Create Type Similarity Matrix Table
-- Description: Stores similarity scores between type tags
-- Created: 2025-12-18

CREATE TABLE type_similarity_matrix (
  tag1 TEXT NOT NULL,
  tag2 TEXT NOT NULL,
  similarity_score REAL NOT NULL CHECK (similarity_score >= 0.0 AND similarity_score <= 1.0),
  co_occurrence_count INTEGER NOT NULL DEFAULT 0,
  last_updated INTEGER NOT NULL,
  PRIMARY KEY (tag1, tag2),
  FOREIGN KEY (tag1) REFERENCES type_vocabulary(tag_name) ON DELETE CASCADE,
  FOREIGN KEY (tag2) REFERENCES type_vocabulary(tag_name) ON DELETE CASCADE
);

-- Indexes for efficient similarity lookups
CREATE INDEX idx_similarity_score ON type_similarity_matrix(similarity_score DESC);
CREATE INDEX idx_similarity_tags ON type_similarity_matrix(tag1, tag2);

-- Ensure tag1 < tag2 to avoid duplicates (symmetric matrix)
CREATE TRIGGER ensure_tag_order
  BEFORE INSERT ON type_similarity_matrix
  FOR EACH ROW
  WHEN NEW.tag1 > NEW.tag2
BEGIN
  UPDATE type_similarity_matrix
  SET tag1 = NEW.tag2, tag2 = NEW.tag1
  WHERE rowid = NEW.rowid;
END;
````

## File: src/database/migrations/003_create_type_evolution_history.sql
````sql
-- Migration: Create Type Evolution History Table
-- Description: Tracks changes to type tags over time
-- Created: 2025-12-18

CREATE TABLE type_evolution_history (
  id TEXT PRIMARY KEY,
  event_type TEXT NOT NULL CHECK (event_type IN ('created', 'merged', 'deprecated', 'split', 'confidence_updated')),
  tag_name TEXT NOT NULL,
  previous_state TEXT, -- JSON object for previous state
  new_state TEXT, -- JSON object for new state
  reason TEXT NOT NULL,
  triggered_by TEXT NOT NULL CHECK (triggered_by IN ('automatic', 'manual', 'llm_analysis')),
  created_at INTEGER NOT NULL,
  FOREIGN KEY (tag_name) REFERENCES type_vocabulary(tag_name) ON DELETE CASCADE
);

-- Indexes for historical queries
CREATE INDEX idx_evolution_tag ON type_evolution_history(tag_name);
CREATE INDEX idx_evolution_date ON type_evolution_history(created_at DESC);
CREATE INDEX idx_evolution_type ON type_evolution_history(event_type);
````

## File: src/database/migrations/005_create_prompt_templates.sql
````sql
-- Migration: Create Prompt Templates Table
-- Description: Stores reusable prompt templates for different type tags
-- Created: 2025-12-18

CREATE TABLE prompt_templates (
  template_id TEXT PRIMARY KEY,
  template_type TEXT NOT NULL CHECK (template_type IN ('guidance', 'constraint', 'framework', 'example')),
  name TEXT NOT NULL,
  content TEXT NOT NULL,
  variables TEXT NOT NULL, -- JSON array of variable names
  applicable_tags TEXT NOT NULL, -- JSON array of applicable tag names
  guidance_level TEXT CHECK (guidance_level IN ('light', 'medium', 'intensive')),
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  usage_count INTEGER NOT NULL DEFAULT 0,
  effectiveness_score REAL CHECK (effectiveness_score >= 0.0 AND effectiveness_score <= 1.0),
  metadata TEXT -- JSON object for additional metadata
);

-- Indexes for template queries
CREATE INDEX idx_template_type ON prompt_templates(template_type);
CREATE INDEX idx_template_effectiveness ON prompt_templates(effectiveness_score DESC);
CREATE INDEX idx_template_usage_count ON prompt_templates(usage_count DESC);
````

## File: src/database/index.ts
````typescript
/**
 * Database Module Index
 * Entry point for all database-related functionality
 */

export { MigrationRunner, MigrationResult, Migration } from './MigrationRunner';
export * from './migrations';
````

## File: src/services/agent/index.ts
````typescript
export { ResourceStatsService } from "./ResourceStats";
export type {
  ResourceMetrics,
  TimeSeriesDataPoint,
  PerformanceTrend,
  HealthStatus,
  StatsSummary,
  AlertRule,
  Alert,
} from "./ResourceStats";
````

## File: src/services/agent/ResourceStats.ts
````typescript
/**
 * ResourceStats - 资源统计服务
 *
 * 提供资源使用统计、性能指标收集和监控功能
 */

import { logger } from "../../utils/logger";

/**
 * 资源统计接口
 */
export interface ResourceStats {
  provider: string;
  model: string;
  totalResources: number;
  availableResources: number;
  inUseResources: number;
  queuedRequests: number;
  averageWaitTime: number;
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  averageResponseTime: number;
}

/**
 * 资源指标接口
 */
export interface ResourceMetrics {
  timestamp: Date;
  provider: string;
  model: string;
  concurrentConnections: number;
  requestRate: number;
  errorRate: number;
  latencyP50: number;
  latencyP95: number;
  latencyP99: number;
  throughput: number;
  availability: number;
}

/**
 * 时间序列数据点
 */
export interface TimeSeriesDataPoint {
  timestamp: Date;
  value: number;
}

/**
 * 性能趋势
 */
export interface PerformanceTrend {
  provider: string;
  model: string;
  period: "1h" | "24h" | "7d" | "30d";
  requestCount: TimeSeriesDataPoint[];
  latencyP50: TimeSeriesDataPoint[];
  latencyP95: TimeSeriesDataPoint[];
  errorRate: TimeSeriesDataPoint[];
  throughput: TimeSeriesDataPoint[];
}

/**
 * 健康状态
 */
export interface HealthStatus {
  provider: string;
  model: string;
  status: "healthy" | "degraded" | "unhealthy";
  score: number;
  issues: string[];
  lastChecked: Date;
}

/**
 * 统计汇总
 */
export interface StatsSummary {
  totalProviders: number;
  totalModels: number;
  totalResources: number;
  totalRequests: number;
  averageLatency: number;
  averageErrorRate: number;
  averageAvailability: number;
  topProviders: { provider: string; requests: number }[];
  recentAlerts: string[];
}

/**
 * 告警规则
 */
export interface AlertRule {
  id: string;
  name: string;
  condition: "error_rate" | "latency" | "availability" | "queue_depth";
  threshold: number;
  severity: "info" | "warning" | "critical";
  enabled: boolean;
  provider?: string;
  model?: string;
}

/**
 * 告警
 */
export interface Alert {
  id: string;
  ruleId: string;
  ruleName: string;
  severity: "info" | "warning" | "critical";
  message: string;
  provider: string;
  model?: string;
  currentValue: number;
  threshold: number;
  timestamp: Date;
  acknowledged: boolean;
}

/**
 * 资源统计服务
 */
export class ResourceStatsService {
  private metricsHistory: Map<string, ResourceMetrics[]> = new Map();
  private requestHistory: Map<string, { timestamp: Date; latency: number; success: boolean }[]> =
    new Map();
  private alertRules: Map<string, AlertRule> = new Map();
  private activeAlerts: Map<string, Alert> = new Map();
  private readonly metricsRetention = 86400000; // 24小时
  private readonly metricsInterval = 1000;
  private collectionTimer?: NodeJS.Timeout;

  constructor() {
    this.initializeDefaultAlertRules();
    this.startMetricsCollection();
    logger.info("[ResourceStats] Resource statistics service initialized");
  }

  /**
   * 记录请求完成
   */
  public recordRequest(provider: string, model: string, latency: number, success: boolean): void {
    const key = `${provider}:${model}`;
    let history = this.requestHistory.get(key);
    if (!history) {
      history = [];
      this.requestHistory.set(key, history);
    }

    history.push({
      timestamp: new Date(),
      latency,
      success,
    });

    // 限制历史记录数量
    if (history.length > 10000) {
      history.shift();
    }
  }

  /**
   * 记录指标
   */
  public recordMetrics(metrics: ResourceMetrics): void {
    const key = `${metrics.provider}:${metrics.model}`;
    let history = this.metricsHistory.get(key);
    if (!history) {
      history = [];
      this.metricsHistory.set(key, history);
    }

    history.push(metrics);

    // 清理过期指标
    const cutoff = Date.now() - this.metricsRetention;
    while (history.length > 0 && history[0].timestamp.getTime() < cutoff) {
      history.shift();
    }

    // 检查告警规则
    this.checkAlerts(metrics);
  }

  /**
   * 获取资源统计
   */
  public getResourceStats(provider: string, model?: string): ResourceStats {
    if (model) {
      return this.calculateStats(provider, model);
    }

    // 聚合所有模型
    const allStats: ResourceStats[] = [];
    for (const [key] of this.requestHistory.entries()) {
      const [p, m] = key.split(":");
      if (p === provider) {
        allStats.push(this.calculateStats(p, m));
      }
    }

    if (allStats.length === 0) {
      return {
        provider,
        model: "",
        totalResources: 0,
        availableResources: 0,
        inUseResources: 0,
        queuedRequests: 0,
        averageWaitTime: 0,
        totalRequests: 0,
        successfulRequests: 0,
        failedRequests: 0,
        averageResponseTime: 0,
      };
    }

    return this.aggregateStats(provider, allStats);
  }

  /**
   * 获取性能趋势
   */
  public getPerformanceTrend(
    provider: string,
    model: string,
    period: "1h" | "24h" | "7d" | "30d" = "24h"
  ): PerformanceTrend {
    const key = `${provider}:${model}`;
    const history = this.requestHistory.get(key) ?? [];
    const now = Date.now();
    let duration: number;

    switch (period) {
      case "1h":
        duration = 3600000;
        break;
      case "24h":
        duration = 86400000;
        break;
      case "7d":
        duration = 604800000;
        break;
      case "30d":
        duration = 2592000000;
        break;
    }

    const cutoff = new Date(now - duration);
    const filtered = history.filter((r) => r.timestamp >= cutoff);

    // 按时间窗口聚合
    const windows = this.createTimeWindows(duration, period);
    const requestCount: TimeSeriesDataPoint[] = [];
    const latencyP50: TimeSeriesDataPoint[] = [];
    const latencyP95: TimeSeriesDataPoint[] = [];
    const errorRate: TimeSeriesDataPoint[] = [];
    const throughput: TimeSeriesDataPoint[] = [];

    for (const window of windows) {
      const windowData = filtered.filter(
        (r) => r.timestamp >= window.start && r.timestamp < window.end
      );

      if (windowData.length === 0) {
        requestCount.push({ timestamp: window.start, value: 0 });
        latencyP50.push({ timestamp: window.start, value: 0 });
        latencyP95.push({ timestamp: window.start, value: 0 });
        errorRate.push({ timestamp: window.start, value: 0 });
        throughput.push({ timestamp: window.start, value: 0 });
        continue;
      }

      const latencies = windowData.map((r) => r.latency).sort((a, b) => a - b);
      const successes = windowData.filter((r) => r.success).length;

      requestCount.push({
        timestamp: window.start,
        value: windowData.length,
      });

      latencyP50.push({
        timestamp: window.start,
        value: this.percentile(latencies, 50),
      });

      latencyP95.push({
        timestamp: window.start,
        value: this.percentile(latencies, 95),
      });

      errorRate.push({
        timestamp: window.start,
        value: ((windowData.length - successes) / windowData.length) * 100,
      });

      throughput.push({
        timestamp: window.start,
        value: windowData.length / (duration / 1000), // 每秒请求数
      });
    }

    return {
      provider,
      model,
      period,
      requestCount,
      latencyP50,
      latencyP95,
      errorRate,
      throughput,
    };
  }

  /**
   * 获取健康状态
   */
  public getHealthStatus(provider: string, model?: string): HealthStatus {
    const stats = this.getResourceStats(provider, model);
    const modelStr = model ?? "all";
    const key = `${provider}:${modelStr}`;

    const history = this.requestHistory.get(key) ?? [];
    const recentHistory = history.filter(
      (r) => Date.now() - r.timestamp.getTime() < 300000 // 最近5分钟
    );

    const issues: string[] = [];
    let score = 100;

    // 计算错误率
    const errorRate =
      recentHistory.length > 0
        ? (recentHistory.filter((r) => !r.success).length / recentHistory.length) * 100
        : 0;

    if (errorRate > 10) {
      issues.push(`High error rate: ${errorRate.toFixed(2)}%`);
      score -= 30;
    } else if (errorRate > 5) {
      issues.push(`Elevated error rate: ${errorRate.toFixed(2)}%`);
      score -= 15;
    }

    // 计算延迟
    const latencies = recentHistory.map((r) => r.latency).sort((a, b) => a - b);
    if (latencies.length > 0) {
      const p95 = this.percentile(latencies, 95);
      if (p95 > 10000) {
        issues.push(`High latency P95: ${p95}ms`);
        score -= 20;
      } else if (p95 > 5000) {
        issues.push(`Elevated latency P95: ${p95}ms`);
        score -= 10;
      }
    }

    // 检查可用资源
    if (model && stats.totalResources > 0) {
      const utilization = (stats.inUseResources / stats.totalResources) * 100;
      if (utilization > 90) {
        issues.push(`High resource utilization: ${utilization.toFixed(1)}%`);
        score -= 15;
      }
    }

    let status: "healthy" | "degraded" | "unhealthy";
    if (score >= 80) {
      status = "healthy";
    } else if (score >= 50) {
      status = "degraded";
    } else {
      status = "unhealthy";
    }

    return {
      provider,
      model: model ?? undefined,
      status,
      score: Math.max(0, score),
      issues,
      lastChecked: new Date(),
    };
  }

  /**
   * 获取统计汇总
   */
  public getStatsSummary(): StatsSummary {
    const providers = new Set<string>();
    const totalRequestsList: number[] = [];
    const avgLatencies: number[] = [];
    const avgErrorRates: number[] = [];
    const availabilities: number[] = [];

    for (const [key] of this.requestHistory.entries()) {
      const [provider] = key.split(":");
      providers.add(provider);

      const history = this.requestHistory.get(key) ?? [];
      if (history.length === 0) {
        continue;
      }

      const successes = history.filter((r) => r.success).length;
      totalRequestsList.push(history.length);
      avgLatencies.push(history.reduce((sum, r) => sum + r.latency, 0) / history.length);
      avgErrorRates.push(((history.length - successes) / history.length) * 100);
      availabilities.push((successes / history.length) * 100);
    }

    // 获取活跃告警
    const recentAlerts: string[] = [];
    for (const alert of this.activeAlerts.values()) {
      if (
        !alert.acknowledged &&
        Date.now() - alert.timestamp.getTime() < 3600000 // 最近1小时
      ) {
        recentAlerts.push(alert.message);
      }
    }

    // 获取前5个提供商
    const providerRequests = new Map<string, number>();
    for (const [key, history] of this.requestHistory.entries()) {
      const [provider] = key.split(":");
      providerRequests.set(provider, (providerRequests.get(provider) ?? 0) + history.length);
    }
    const topProviders = Array.from(providerRequests.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([provider, requests]) => ({ provider, requests }));

    return {
      totalProviders: providers.size,
      totalModels: this.requestHistory.size,
      totalResources: 0, // 需要从外部注入
      totalRequests: totalRequestsList.reduce((a, b) => a + b, 0),
      averageLatency:
        avgLatencies.length > 0 ? avgLatencies.reduce((a, b) => a + b, 0) / avgLatencies.length : 0,
      averageErrorRate:
        avgErrorRates.length > 0
          ? avgErrorRates.reduce((a, b) => a + b, 0) / avgErrorRates.length
          : 0,
      averageAvailability:
        availabilities.length > 0
          ? availabilities.reduce((a, b) => a + b, 0) / availabilities.length
          : 100,
      topProviders,
      recentAlerts: recentAlerts.slice(0, 10),
    };
  }

  /**
   * 添加告警规则
   */
  public addAlertRule(rule: AlertRule): void {
    this.alertRules.set(rule.id, rule);
    logger.info(`[ResourceStats] Added alert rule: ${rule.name}`);
  }

  /**
   * 移除告警规则
   */
  public removeAlertRule(ruleId: string): boolean {
    return this.alertRules.delete(ruleId);
  }

  /**
   * 获取告警规则
   */
  public getAlertRules(): AlertRule[] {
    return Array.from(this.alertRules.values());
  }

  /**
   * 获取活跃告警
   */
  public getActiveAlerts(): Alert[] {
    return Array.from(this.activeAlerts.values());
  }

  /**
   * 确认告警
   */
  public acknowledgeAlert(alertId: string): boolean {
    const alert = this.activeAlerts.get(alertId);
    if (alert) {
      alert.acknowledged = true;
      return true;
    }
    return false;
  }

  /**
   * 设置资源总数（用于统计）
   */
  public setTotalResources(count: number): void {
    // 可以在外部调用来更新总资源数
  }

  /**
   * 关闭统计服务
   */
  public shutdown(): void {
    if (this.collectionTimer) {
      clearInterval(this.collectionTimer);
    }
    this.metricsHistory.clear();
    this.requestHistory.clear();
    this.activeAlerts.clear();
    logger.info("[ResourceStats] Resource statistics service shutdown complete");
  }

  /**
   * 初始化默认告警规则
   */
  private initializeDefaultAlertRules(): void {
    const defaultRules: AlertRule[] = [
      {
        id: "high-error-rate",
        name: "High Error Rate",
        condition: "error_rate",
        threshold: 10,
        severity: "warning",
        enabled: true,
      },
      {
        id: "critical-error-rate",
        name: "Critical Error Rate",
        condition: "error_rate",
        threshold: 20,
        severity: "critical",
        enabled: true,
      },
      {
        id: "high-latency",
        name: "High Latency",
        condition: "latency",
        threshold: 10000,
        severity: "warning",
        enabled: true,
      },
      {
        id: "low-availability",
        name: "Low Availability",
        condition: "availability",
        threshold: 95,
        severity: "warning",
        enabled: true,
      },
      {
        id: "deep-queue",
        name: "Deep Queue",
        condition: "queue_depth",
        threshold: 100,
        severity: "info",
        enabled: true,
      },
    ];

    for (const rule of defaultRules) {
      this.alertRules.set(rule.id, rule);
    }
  }

  /**
   * 启动指标收集
   */
  private startMetricsCollection(): void {
    this.collectionTimer = setInterval(() => {
      this.collectMetrics();
    }, this.metricsInterval);
  }

  /**
   * 收集指标
   */
  private collectMetrics(): void {
    for (const [key, history] of this.requestHistory.entries()) {
      const [provider, model] = key.split(":");
      const recentHistory = history.filter(
        (r) => Date.now() - r.timestamp.getTime() < 60000 // 最近1分钟
      );

      if (recentHistory.length === 0) {
        continue;
      }

      const latencies = recentHistory.map((r) => r.latency).sort((a, b) => a - b);
      const successes = recentHistory.filter((r) => r.success).length;

      const metrics: ResourceMetrics = {
        timestamp: new Date(),
        provider,
        model,
        concurrentConnections: recentHistory.filter((r) => !r.success).length,
        requestRate: recentHistory.length / 60, // 每秒请求数
        errorRate: ((recentHistory.length - successes) / recentHistory.length) * 100,
        latencyP50: this.percentile(latencies, 50),
        latencyP95: this.percentile(latencies, 95),
        latencyP99: this.percentile(latencies, 99),
        throughput: recentHistory.length,
        availability: (successes / recentHistory.length) * 100,
      };

      this.recordMetrics(metrics);
    }
  }

  /**
   * 检查告警
   */
  private checkAlerts(metrics: ResourceMetrics): void {
    for (const rule of this.alertRules.values()) {
      if (!rule.enabled) {
        continue;
      }

      if (rule.provider && rule.provider !== metrics.provider) {
        continue;
      }

      if (rule.model && rule.model !== metrics.model) {
        continue;
      }

      let triggered = false;
      let currentValue = 0;

      switch (rule.condition) {
        case "error_rate":
          currentValue = metrics.errorRate;
          triggered = currentValue > rule.threshold;
          break;
        case "latency":
          currentValue = metrics.latencyP95;
          triggered = currentValue > rule.threshold;
          break;
        case "availability":
          currentValue = metrics.availability;
          triggered = currentValue < rule.threshold;
          break;
        case "queue_depth":
          currentValue = metrics.throughput;
          triggered = currentValue > rule.threshold;
          break;
      }

      if (triggered) {
        this.createAlert(rule, metrics, currentValue);
      } else {
        this.clearAlert(rule.id, metrics.provider, metrics.model);
      }
    }
  }

  /**
   * 创建告警
   */
  private createAlert(rule: AlertRule, metrics: ResourceMetrics, currentValue: number): void {
    const alertKey = `${rule.id}:${metrics.provider}:${metrics.model ?? "all"}`;

    if (this.activeAlerts.has(alertKey)) {
      return; // 告警已存在
    }

    const alert: Alert = {
      id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      ruleId: rule.id,
      ruleName: rule.name,
      severity: rule.severity,
      message: `${rule.name}: ${metrics.provider}${metrics.model ? `:${metrics.model}` : ""} - Current: ${currentValue.toFixed(2)}, Threshold: ${rule.threshold}`,
      provider: metrics.provider,
      model: metrics.model,
      currentValue,
      threshold: rule.threshold,
      timestamp: new Date(),
      acknowledged: false,
    };

    this.activeAlerts.set(alertKey, alert);
    logger.warn(`[ResourceStats] Alert triggered: ${alert.message}`);
  }

  /**
   * 清除告警
   */
  private clearAlert(ruleId: string, provider: string, model?: string): void {
    const alertKey = `${ruleId}:${provider}:${model ?? "all"}`;
    this.activeAlerts.delete(alertKey);
  }

  /**
   * 计算统计
   */
  private calculateStats(provider: string, model: string): ResourceStats {
    const key = `${provider}:${model}`;
    const history = this.requestHistory.get(key) ?? [];

    const successful = history.filter((r) => r.success);
    const failed = history.filter((r) => !r.success);

    const latencies = history.map((r) => r.latency).sort((a, b) => a - b);

    return {
      provider,
      model,
      totalResources: 0, // 需要从外部注入
      availableResources: 0, // 需要从外部注入
      inUseResources: successful.length,
      queuedRequests: 0, // 需要从外部注入
      averageWaitTime: 0,
      totalRequests: history.length,
      successfulRequests: successful.length,
      failedRequests: failed.length,
      averageResponseTime:
        latencies.length > 0 ? latencies.reduce((a, b) => a + b, 0) / latencies.length : 0,
    };
  }

  /**
   * 聚合统计
   */
  private aggregateStats(provider: string, stats: ResourceStats[]): ResourceStats {
    const totalRequests = stats.reduce((sum, s) => sum + s.totalRequests, 0);
    const successfulRequests = stats.reduce((sum, s) => sum + s.successfulRequests, 0);
    const failedRequests = stats.reduce((sum, s) => sum + s.failedRequests, 0);

    let avgResponseTime = 0;
    if (stats.length > 0) {
      avgResponseTime =
        stats.reduce((sum, s) => sum + s.averageResponseTime * s.totalRequests, 0) /
        (totalRequests || 1);
    }

    return {
      provider,
      model: "",
      totalResources: stats.reduce((sum, s) => sum + s.totalResources, 0),
      availableResources: stats.reduce((sum, s) => sum + s.availableResources, 0),
      inUseResources: stats.reduce((sum, s) => sum + s.inUseResources, 0),
      queuedRequests: stats.reduce((sum, s) => sum + s.queuedRequests, 0),
      averageWaitTime: 0,
      totalRequests,
      successfulRequests,
      failedRequests,
      averageResponseTime: avgResponseTime,
    };
  }

  /**
   * 创建时间窗口
   */
  private createTimeWindows(
    duration: number,
    period: "1h" | "24h" | "7d" | "30d"
  ): { start: Date; end: Date }[] {
    const windows: { start: Date; end: Date }[] = [];
    const now = new Date();
    let windowSize: number;

    switch (period) {
      case "1h":
        windowSize = 60000; // 1分钟
        break;
      case "24h":
        windowSize = 3600000; // 1小时
        break;
      case "7d":
        windowSize = 21600000; // 6小时
        break;
      case "30d":
        windowSize = 86400000; // 1天
        break;
    }

    let start = new Date(now.getTime() - duration);
    while (start < now) {
      const end = new Date(start.getTime() + windowSize);
      windows.push({ start, end });
      start = end;
    }

    return windows;
  }

  /**
   * 计算百分位数
   */
  private percentile(sorted: number[], p: number): number {
    if (sorted.length === 0) {
      return 0;
    }

    const index = (p / 100) * (sorted.length - 1);
    const lower = Math.floor(index);
    const upper = Math.ceil(index);

    if (lower === upper) {
      return sorted[lower];
    }

    return sorted[lower] * (upper - index) + sorted[upper] * (index - lower);
  }
}

export default ResourceStats;
````

## File: src/services/cache/SemanticCache.ts
````typescript
/**
 * SemanticCache - Semantic Query Caching Service
 *
 * Provides LRU caching with semantic similarity matching for repeated queries.
 * Avoids redundant embedding API calls and database queries.
 */

import LRUCache from "lru-cache";
import { createHash } from "crypto";
import { logger } from "../../utils/logger";
import type { EmbeddingVector } from "../tool-retrieval/types";

/**
 * Semantic cache configuration
 */
export interface SemanticCacheConfig {
  similarityThreshold: number;
  maxItems: number;
  ttlMs: number;
  persistToDisk: boolean;
  exactMatchThreshold?: number;
}

/**
 * Default configuration
 */
export const DEFAULT_SEMANTIC_CACHE_CONFIG: SemanticCacheConfig = {
  similarityThreshold: 0.95,
  maxItems: 10000,
  ttlMs: 3600000,
  persistToDisk: false,
  exactMatchThreshold: 0.99,
};

/**
 * Cached query entry
 */
export interface CachedQuery {
  query: string;
  embedding: number[];
  result: unknown;
  cachedAt: number;
  accessCount: number;
}

/**
 * Cache statistics
 */
export interface CacheStats {
  size: number;
  hits: number;
  misses: number;
  hitRate: number;
  exactMatches: number;
  similarMatches: number;
  averageSimilarity: number;
}

/**
 * Semantic search result
 */
export interface SemanticSearchResult {
  cachedQuery: CachedQuery;
  similarity: number;
  isExactMatch: boolean;
}

/**
 * SemanticCache implementation
 */
export class SemanticCache {
  private lruCache: LRUCache<string, CachedQuery>;
  private config: SemanticCacheConfig;
  private embeddingService: {
    generateForText: (text: string) => Promise<EmbeddingVector>;
  } | null;
  private stats: {
    hits: number;
    misses: number;
    exactMatches: number;
    similarMatches: number;
    totalSimilarity: number;
  };

  constructor(
    config?: Partial<SemanticCacheConfig>,
    embeddingService?: { generateForText: (text: string) => Promise<EmbeddingVector> }
  ) {
    this.config = { ...DEFAULT_SEMANTIC_CACHE_CONFIG, ...config };
    this.embeddingService = embeddingService || null;
    this.stats = {
      hits: 0,
      misses: 0,
      exactMatches: 0,
      similarMatches: 0,
      totalSimilarity: 0,
    };

    this.lruCache = new LRUCache<string, CachedQuery>({
      max: this.config.maxItems,
      ttl: this.config.ttlMs,
      updateAgeOnGet: true,
    });

    logger.info("[SemanticCache] Initialized with config:", {
      similarityThreshold: this.config.similarityThreshold,
      maxItems: this.config.maxItems,
      ttlMs: this.config.ttlMs,
    });
  }

  setEmbeddingService(service: {
    generateForText: (text: string) => Promise<EmbeddingVector>;
  }): void {
    this.embeddingService = service;
  }

  async findSimilar(query: string): Promise<SemanticSearchResult | null> {
    try {
      const queryEmbedding = await this._generateEmbedding(query);
      if (!queryEmbedding) {
        this.stats.misses++;
        return null;
      }

      let bestMatch: { entry: CachedQuery; similarity: number } | null = null;
      let bestSimilarity = 0;

      this.lruCache.forEach((entry: CachedQuery) => {
        if (this._isExactMatch(query, entry.query)) {
          entry.accessCount++;
          this.stats.hits++;
          this.stats.exactMatches++;
          this.stats.totalSimilarity += 1;

          bestMatch = { entry, similarity: 1 };
          bestSimilarity = 1;
        } else if (bestSimilarity < 1) {
          const similarity = this.cosineSimilarity(queryEmbedding, entry.embedding);

          if (similarity >= this.config.similarityThreshold && similarity > bestSimilarity) {
            bestSimilarity = similarity;
            bestMatch = { entry, similarity };
          }
        }
      });

      if (bestMatch) {
        if (bestSimilarity === 1) {
          logger.debug(`[SemanticCache] Cache exact match: query="${query.substring(0, 50)}..."`);
          return {
            cachedQuery: bestMatch.entry,
            similarity: 1,
            isExactMatch: true,
          };
        }

        bestMatch.entry.accessCount++;
        this.stats.hits++;
        this.stats.similarMatches++;
        this.stats.totalSimilarity += bestSimilarity;

        logger.debug(
          `[SemanticCache] Cache hit: similarity=${bestSimilarity.toFixed(4)}, query="${query.substring(0, 50)}..."`
        );

        return {
          cachedQuery: bestMatch.entry,
          similarity: bestSimilarity,
          isExactMatch: false,
        };
      }

      this.stats.misses++;
      return null;
    } catch (error) {
      logger.error("[SemanticCache] Error finding similar query:", error);
      this.stats.misses++;
      return null;
    }
  }

  async store(query: string, result: unknown): Promise<void> {
    try {
      const embedding = await this._generateEmbedding(query);
      if (!embedding) {
        logger.warn("[SemanticCache] Could not generate embedding for query, not caching");
        return;
      }

      const normalizedQuery = this._normalizeQuery(query);
      const entry: CachedQuery = {
        query: normalizedQuery,
        embedding,
        result,
        cachedAt: Date.now(),
        accessCount: 0,
      };

      this.lruCache.set(this._generateCacheKey(query), entry);

      logger.debug(`[SemanticCache] Cached query: "${query.substring(0, 50)}..."`);
    } catch (error) {
      logger.error("[SemanticCache] Error caching query:", error);
    }
  }

  get(query: string): { result: unknown; cachedAt: number } | null {
    const entry = this.lruCache.get(this._generateCacheKey(query));
    if (entry) {
      entry.accessCount++;
      this.stats.hits++;
      this.stats.exactMatches++;
      return {
        result: entry.result,
        cachedAt: entry.cachedAt,
      };
    }
    this.stats.misses++;
    return null;
  }

  has(query: string): boolean {
    return this.lruCache.has(this._generateCacheKey(query));
  }

  invalidate(query: string): boolean {
    const key = this._generateCacheKey(query);
    if (this.lruCache.has(key)) {
      this.lruCache.del(key);
      return true;
    }
    return false;
  }

  clear(): void {
    this.lruCache.reset();
    this.stats = {
      hits: 0,
      misses: 0,
      exactMatches: 0,
      similarMatches: 0,
      totalSimilarity: 0,
    };
    logger.info("[SemanticCache] Cache cleared");
  }

  getStats(): CacheStats {
    const total = this.stats.hits + this.stats.misses;
    const hitRate = total > 0 ? this.stats.hits / total : 0;
    const avgSimilarity = this.stats.hits > 0 ? this.stats.totalSimilarity / this.stats.hits : 0;

    return {
      size: this.lruCache.itemCount,
      hits: this.stats.hits,
      misses: this.stats.misses,
      hitRate,
      exactMatches: this.stats.exactMatches,
      similarMatches: this.stats.similarMatches,
      averageSimilarity: avgSimilarity,
    };
  }

  cosineSimilarity(a: number[], b: number[]): number {
    if (a.length !== b.length || a.length === 0) {
      return 0;
    }

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }

    const denominator = Math.sqrt(normA) * Math.sqrt(normB);
    if (denominator === 0) {
      return 0;
    }

    return dotProduct / denominator;
  }

  private _isExactMatch(a: string, b: string): boolean {
    const normalizedA = this._normalizeQuery(a);
    const normalizedB = this._normalizeQuery(b);
    return normalizedA === normalizedB;
  }

  /**
   * Generate a consistent cache key using MD5 hash
   * This ensures unique keys for semantically identical queries
   */
  private _generateCacheKey(query: string): string {
    const normalized = this._normalizeQuery(query);
    return createHash("md5").update(normalized).digest("hex");
  }

  /**
   * Normalize query for consistent comparison
   */
  private _normalizeQuery(query: string): string {
    return query.trim().toLowerCase();
  }

  private async _generateEmbedding(query: string): Promise<number[] | null> {
    if (!this.embeddingService) {
      logger.warn("[SemanticCache] No embedding service configured");
      return null;
    }

    try {
      const vector = await this.embeddingService.generateForText(query);
      return vector.values;
    } catch (error) {
      logger.error("[SemanticCache] Error generating embedding:", error);
      return null;
    }
  }

  getConfig(): SemanticCacheConfig {
    return { ...this.config };
  }

  updateConfig(config: Partial<SemanticCacheConfig>): void {
    this.config = { ...this.config, ...config };
    logger.info("[SemanticCache] Configuration updated:", config);
  }

  getMemoryUsage(): { itemCount: number; approximateBytes: number } {
    let totalBytes = 0;

    this.lruCache.forEach((entry: CachedQuery) => {
      totalBytes += entry.query.length * 2;
      totalBytes += entry.embedding.length * 8;
      totalBytes += JSON.stringify(entry.result).length * 2;
    });

    return {
      itemCount: this.lruCache.itemCount,
      approximateBytes: totalBytes,
    };
  }
}
````

## File: src/services/chat/ConversationSaver.ts
````typescript
/**
 * ConversationSaver - 对话历史保存器
 * 负责统一保存对话历史，包含思考过程
 */

import { Message } from "../../types";
import { logger } from "../../utils/logger";
import { ConversationHistoryService } from "../ConversationHistoryService";
import { SessionManager } from "../SessionManager";
import { parseAggregatedContent } from "../../api/utils/stream-parser";

export interface SaveMetadata {
  messageCount: number;
  totalTokens?: number;
  promptTokens?: number;
  completionTokens?: number;
}

export class ConversationSaver {
  constructor(
    private conversationHistoryService: ConversationHistoryService,
    private sessionManager: SessionManager
  ) {}

  /**
   * 保存对话历史
   */
  async save(
    conversationId: string,
    messages: Message[],
    aiContent: string,
    thinkingProcess?: string[],
    isReAct: boolean = false
  ): Promise<void> {
    try {
      // 1. 检查历史记录数量
      const count = await this.conversationHistoryService.getMessageCount(conversationId);
      const messagesToSave: Message[] = [];

      // 2. 准备要保存的消息（统一逻辑）
      if (count === 0) {
        // 新对话：保存所有非assistant、非system消息
        messagesToSave.push(
          ...messages.filter((m) => m.role !== "assistant" && m.role !== "system")
        );
      } else {
        // 已有对话：只保存最后一条非assistant、非system消息
        const lastMessage = messages[messages.length - 1];
        if (lastMessage && lastMessage.role !== "assistant" && lastMessage.role !== "system") {
          messagesToSave.push(lastMessage);
        }
      }

      // 3. 构建AI回复内容（统一格式）
      let assistantContent = this.formatAssistantContent(aiContent, thinkingProcess, isReAct);

      // 4. 添加AI回复
      messagesToSave.push({
        role: "assistant",
        content: assistantContent,
      });

      // 5. 保存到数据库
      await this.conversationHistoryService.saveMessages(conversationId, messagesToSave);
      logger.debug(`[ConversationSaver] Saved ${messagesToSave.length} messages to history`);
    } catch (err: any) {
      logger.warn(`[ConversationSaver] Failed to save conversation history: ${err.message}`);
    }
  }

  /**
   * 格式化AI回复内容
   */
  private formatAssistantContent(
    aiContent: string,
    thinkingProcess?: string[],
    isReAct: boolean = false
  ): string {
    // 先清理错误内容
    const cleanedContent = this.cleanErrorContent(aiContent);

    const parsed = parseAggregatedContent(cleanedContent);

    if (isReAct) {
      const thinkingParts = [];
      if (thinkingProcess?.length > 0) {
        const extractedThinking = this.extractThinkingContent(thinkingProcess);
        thinkingParts.push(`<thinking>${extractedThinking}</thinking>`);
      }
      thinkingParts.push(
        parsed.reasoning
          ? `<thinking>${parsed.reasoning}</thinking> ${parsed.content}`
          : parsed.content
      );
      return thinkingParts.join(" ");
    }

    // 普通模式
    return parsed.reasoning
      ? `<thinking>${parsed.reasoning}</thinking> ${parsed.content}`
      : parsed.content;
  }

  /**
   * 清理错误内容
   * 移除包含错误状态的 tool_output 标签和其他错误信息
   */
  private cleanErrorContent(content: string): string {
    if (!content || typeof content !== "string") {
      return content;
    }

    let cleaned = content;

    // 移除包含错误状态的 tool_output
    // 匹配 <tool_output ... status="error">...</tool_output>
    cleaned = cleaned.replace(
      /<tool_output[^>]*status\s*=\s*["']?error["']?[^>]*>[\s\S]*?<\/tool_output>/gi,
      ""
    );

    // 移除 [SYSTEM_FEEDBACK] 块中的错误内容
    cleaned = cleaned.replace(
      /\[SYSTEM_FEEDBACK\][\s\S]*?status\s*=\s*["']?error["']?[\s\S]*?(?=\[SYSTEM_FEEDBACK\]|$)/gi,
      ""
    );

    // 移除 MCP 错误信息
    cleaned = cleaned.replace(/MCP error[^"\n]*/gi, "");
    cleaned = cleaned.replace(/McpError:[^\n]*/gi, "");
    cleaned = cleaned.replace(/Request timed out/gi, "");

    // 移除错误堆栈相关信息
    cleaned = cleaned.replace(/at McpError\.fromError[^\n]*/gi, "");
    cleaned = cleaned.replace(/at Timeout\.timeoutHandler[^\n]*/gi, "");

    // 清理多余的空白字符
    cleaned = cleaned.replace(/\n{3,}/g, "\n\n");
    cleaned = cleaned.trim();

    return cleaned;
  }

  /**
   * 提取思考过程内容
   */
  private extractThinkingContent(thinkingProcess: string[]): string {
    const extracted: string[] = [];
    for (const chunk of thinkingProcess) {
      try {
        const cleaned = chunk.replace(/^data:\s*/, "").trim();
        if (cleaned && cleaned !== "[DONE]") {
          if (cleaned.includes("}{")) {
            const jsonObjects = cleaned.split(/\}\{/);
            for (let i = 0; i < jsonObjects.length; i++) {
              let jsonStr = jsonObjects[i];
              if (i > 0) jsonStr = "{" + jsonStr;
              if (i < jsonObjects.length - 1) jsonStr = jsonStr + "}";
              if (jsonStr) {
                const parsed = JSON.parse(jsonStr);
                if (parsed.reasoning_content) {
                  extracted.push(parsed.reasoning_content);
                }
              }
            }
          } else {
            const parsed = JSON.parse(cleaned);
            if (parsed.reasoning_content) {
              extracted.push(parsed.reasoning_content);
            }
          }
        }
      } catch {
        extracted.push(chunk);
      }
    }
    return extracted.join("");
  }

  /**
   * 更新会话元数据
   */
  async updateSessionMetadata(sessionId: string, usage: any): Promise<void> {
    await this.sessionManager.updateMetadata(sessionId, {
      total_tokens: usage.total_tokens,
      prompt_tokens: usage.prompt_tokens,
      completion_tokens: usage.completion_tokens,
    });
  }
}
````

## File: src/services/compat/AllowedToolsValidator.ts
````typescript
/**
 * AllowedToolsValidator - 工具权限验证器
 * 验证工具调用是否在允许的工具列表中，支持通配符和前缀匹配
 */

import { logger } from "../../utils/logger";

/**
 * 验证结果接口
 */
export interface ValidationResult {
  allowed: boolean;
  toolName: string;
  reason?: string;
}

/**
 * 批量验证结果接口
 */
export interface BatchValidationResult {
  allowed: boolean;
  validatedTools: ValidationResult[];
  deniedTools: string[];
  missingPermissions: string[];
}

/**
 * 权限验证器配置
 */
export interface AllowedToolsValidatorConfig {
  /** 严格模式：不允许未授权工具 */
  strictMode?: boolean;
  /** 默认允许的工具（系统级） */
  defaultAllowed?: string[];
  /** 工具前缀白名单 */
  allowedPrefixes?: string[];
  /** 是否区分大小写 */
  caseSensitive?: boolean;
  /** 是否记录详细日志 */
  logDetails?: boolean;
}

/**
 * 权限验证错误
 */
export class PermissionDeniedError extends Error {
  public readonly toolName: string;
  public readonly allowedTools: string[];
  public readonly missingPermissions: string[];

  constructor(
    toolName: string,
    allowedTools: string[],
    missingPermissions: string[],
    message?: string
  ) {
    const defaultMessage = `Permission denied: tool "${toolName}" is not in the allowed tools list`;
    super(message || defaultMessage);

    this.name = "PermissionDeniedError";
    this.toolName = toolName;
    this.allowedTools = allowedTools;
    this.missingPermissions = missingPermissions;
  }
}

/**
 * 工具权限验证器
 * 提供工具调用权限的同步验证功能，支持通配符和前缀匹配
 */
export class AllowedToolsValidator {
  private readonly config: Required<AllowedToolsValidatorConfig>;

  constructor(config: AllowedToolsValidatorConfig = {}) {
    this.config = {
      strictMode: config.strictMode ?? true,
      defaultAllowed: config.defaultAllowed ?? [],
      allowedPrefixes: config.allowedPrefixes ?? [],
      caseSensitive: config.caseSensitive ?? true,
      logDetails: config.logDetails ?? true,
    };
  }

  /**
   * 验证单个工具是否在 allowedTools 列表中
   * @param toolName 工具名称
   * @param allowedTools SKILL.md 中定义的 allowedTools 列表
   * @returns 验证结果
   */
  validate(toolName: string, allowedTools: string[]): ValidationResult {
    // 处理空工具名称
    if (!toolName || typeof toolName !== "string" || toolName.trim() === "") {
      return {
        allowed: false,
        toolName: toolName || "unknown",
        reason: "Invalid tool name",
      };
    }

    const normalizedToolName = this.config.caseSensitive ? toolName : toolName.toLowerCase();
    const normalizedAllowedTools = this.config.caseSensitive
      ? allowedTools
      : allowedTools.map((t) => t.toLowerCase());

    // 检查是否在默认允许列表中
    if (this.isInDefaultAllowed(normalizedToolName)) {
      return {
        allowed: true,
        toolName,
        reason: "Tool is in default allowed list",
      };
    }

    // 如果 allowedTools 为空且非严格模式，允许所有工具
    if (normalizedAllowedTools.length === 0 && !this.config.strictMode) {
      return {
        allowed: true,
        toolName,
        reason: "No allowedTools configured and not in strict mode",
      };
    }

    // 精确匹配检查
    if (this.hasExactMatch(normalizedToolName, normalizedAllowedTools)) {
      return {
        allowed: true,
        toolName,
        reason: "Tool found in allowedTools list",
      };
    }

    // 通配符匹配检查（如 "file:*" 匹配 "file-read"、"file-write"）
    if (this.hasWildcardMatch(normalizedToolName, normalizedAllowedTools)) {
      return {
        allowed: true,
        toolName,
        reason: "Tool matched wildcard pattern",
      };
    }

    // 前缀匹配检查（如 "file:" 前缀）
    if (this.hasPrefixMatch(normalizedToolName, normalizedAllowedTools)) {
      return {
        allowed: true,
        toolName,
        reason: "Tool matched allowed prefix",
      };
    }

    // 未找到匹配
    return {
      allowed: false,
      toolName,
      reason: `Tool "${toolName}" is not in the allowed tools list`,
    };
  }

  /**
   * 批量验证多个工具
   * @param toolNames 工具名称列表
   * @param allowedTools SKILL.md 中定义的 allowedTools 列表
   * @returns 批量验证结果
   */
  validateAll(toolNames: string[], allowedTools: string[]): BatchValidationResult {
    const validatedTools: ValidationResult[] = [];
    const deniedTools: string[] = [];
    const missingPermissions: string[] = [];

    for (const toolName of toolNames) {
      const result = this.validate(toolName, allowedTools);
      validatedTools.push(result);

      if (!result.allowed) {
        deniedTools.push(toolName);
        missingPermissions.push(toolName);
      }
    }

    const batchResult: BatchValidationResult = {
      allowed: deniedTools.length === 0,
      validatedTools,
      deniedTools,
      missingPermissions,
    };

    // 记录日志
    if (this.config.logDetails && deniedTools.length > 0) {
      logger.debug("Batch validation found denied tools", {
        requestedTools: toolNames,
        allowedTools,
        deniedTools,
        missingPermissions,
      });
    }

    return batchResult;
  }

  /**
   * 获取缺失的权限列表
   * @param requestedTools 请求的工具列表
   * @param allowedTools SKILL.md 中定义的 allowedTools 列表
   * @returns 未授权的工具列表
   */
  getMissingPermissions(requestedTools: string[], allowedTools: string[]): string[] {
    const missing: string[] = [];

    for (const toolName of requestedTools) {
      const result = this.validate(toolName, allowedTools);
      if (!result.allowed) {
        missing.push(toolName);
      }
    }

    return missing;
  }

  /**
   * 同步验证工具调用，如果被拒绝则抛出异常
   * @param toolName 工具名称
   * @param allowedTools SKILL.md 中定义的 allowedTools 列表
   * @throws PermissionDeniedError 当工具未被授权时
   */
  validateOrThrow(toolName: string, allowedTools: string[]): void {
    const result = this.validate(toolName, allowedTools);

    if (!result.allowed) {
      const missing = this.getMissingPermissions([toolName], allowedTools);

      // 记录拒绝日志
      logger.warn("Permission denied for tool", {
        toolName,
        allowedTools,
        reason: result.reason,
      });

      throw new PermissionDeniedError(
        toolName,
        allowedTools,
        missing,
        `Permission denied: tool "${toolName}" requires explicit permission`
      );
    }
  }

  /**
   * 检查工具名称是否匹配允许的前缀
   * @param toolName 工具名称
   * @param prefixes 允许的前缀列表
   * @returns 是否匹配
   */
  private hasPrefixMatch(toolName: string, allowedTools: string[]): boolean {
    // 检查工具是否匹配任何允许的前缀
    for (const prefix of this.config.allowedPrefixes) {
      if (toolName.startsWith(prefix)) {
        // 同时检查该前缀是否在 allowedTools 中
        // 如果允许前缀 "file:"，那么 "file:read" 应该是被允许的
        const prefixedTool = prefix + toolName.slice(prefix.length);
        if (allowedTools.includes(prefixedTool) || allowedTools.includes(prefix + "*")) {
          return true;
        }
      }
    }

    // 检查 allowedTools 中是否包含纯前缀（如 "file:"）
    for (const allowedTool of allowedTools) {
      if (allowedTool.endsWith(":") && toolName.startsWith(allowedTool)) {
        return true;
      }
    }

    return false;
  }

  /**
   * 检查是否在默认允许列表中
   * @param toolName 工具名称
   * @returns 是否在默认列表中
   */
  private isInDefaultAllowed(toolName: string): boolean {
    const normalizedDefaults = this.config.caseSensitive
      ? this.config.defaultAllowed
      : this.config.defaultAllowed.map((t) => t.toLowerCase());

    return normalizedDefaults.includes(toolName);
  }

  /**
   * 检查是否精确匹配
   * @param toolName 工具名称
   * @param allowedTools 允许的工具列表
   * @returns 是否精确匹配
   */
  private hasExactMatch(toolName: string, allowedTools: string[]): boolean {
    return allowedTools.includes(toolName);
  }

  /**
   * 检查是否通配符匹配
   * 支持模式如 "file:*" 匹配 "file-read"、"file-write" 等
   * @param toolName 工具名称
   * @param allowedTools 允许的工具列表
   * @returns 是否通配符匹配
   */
  private hasWildcardMatch(toolName: string, allowedTools: string[]): boolean {
    for (const allowedTool of allowedTools) {
      // 处理尾部通配符（如 "file:*"）
      if (allowedTool.endsWith("*")) {
        const prefix = allowedTool.slice(0, -1); // 移除 '*'
        // 移除前缀后的常见分隔符（如 "file:" -> "file"）
        const normalizedPrefix = prefix.replace(/[:\-\_]$/, "");
        if (toolName.startsWith(normalizedPrefix) || toolName.startsWith(prefix)) {
          return true;
        }
      }

      // 处理头部通配符（如 "*file"）
      if (allowedTool.startsWith("*")) {
        const suffix = allowedTool.slice(1); // 移除 '*'
        // 移除前缀后的常见分隔符（如 ":file" -> "file"）
        const normalizedSuffix = suffix.replace(/^[:\-\_]/, "");
        if (toolName.endsWith(suffix) || toolName.endsWith(normalizedSuffix)) {
          return true;
        }
      }

      // 处理中间通配符（如 "file-*-operation"）
      if (allowedTool.includes("*")) {
        const regexPattern = allowedTool
          .replace(/[.+?^${}()|[\]\\]/g, "\\$&") // 转义正则特殊字符
          .replace(/\*/g, ".*"); // 将 * 替换为 .* 用于正则匹配

        try {
          const regex = new RegExp(`^${regexPattern}$`);
          if (regex.test(toolName)) {
            return true;
          }
        } catch {
          // 正则表达式无效，跳过
          continue;
        }
      }
    }

    return false;
  }

  /**
   * 获取当前配置
   * @returns 当前配置
   */
  getConfig(): Readonly<Required<AllowedToolsValidatorConfig>> {
    return { ...this.config };
  }

  /**
   * 更新配置
   * @param config 新配置
   */
  updateConfig(config: Partial<AllowedToolsValidatorConfig>): void {
    Object.assign(this.config, config);
    logger.debug("AllowedToolsValidator config updated", { config: this.config });
  }
}

/**
 * 默认验证器实例
 */
let defaultValidator: AllowedToolsValidator | null = null;

/**
 * 获取默认权限验证器实例
 */
export function getAllowedToolsValidator(
  config?: AllowedToolsValidatorConfig
): AllowedToolsValidator {
  if (!defaultValidator) {
    defaultValidator = new AllowedToolsValidator(config);
  } else if (config) {
    defaultValidator.updateConfig(config);
  }
  return defaultValidator;
}

/**
 * 重置默认验证器实例（用于测试）
 */
export function resetAllowedToolsValidator(): void {
  defaultValidator = null;
}

// 默认导出
export default AllowedToolsValidator;
````

## File: src/services/compat/ClaudeCodeSkillParser.ts
````typescript
/**
 * ClaudeCodeSkillParser - Claude Code Skill 格式转换器
 * 解析 Claude Code SKILL.md 文件并转换为内部 SkillMetadata 格式
 */

import * as fs from "fs/promises";
import * as path from "path";
import matter from "gray-matter";
import { SkillMetadata } from "../../types/tool-system";
import { ClaudeCodeSkillFrontmatter, ParsedClaudeSkill, ParseError, ParseErrorCode } from "./types";
import { logger } from "../../utils/logger";

/**
 * 解析结果类型
 */
export interface ParseResult {
  success: boolean;
  metadata?: SkillMetadata;
  compatibility?: ParsedClaudeSkill["compatibility"];
  content?: string;
  errors: ParseError[];
  warnings: string[];
}

/**
 * 保留关键字列表
 */
const RESERVED_WORDS = ["claude", "anthropic", "system", "admin", "apexbridge", "builtin"];

/**
 * Claude Code Skill 格式转换器
 */
export class ClaudeCodeSkillParser {
  /**
   * 解析 SKILL.md 文件
   * @param skillPath Skill 目录路径
   * @returns 解析后的 Claude Skill 对象
   */
  async parse(skillPath: string): Promise<ParsedClaudeSkill> {
    const skillMdPath = path.join(skillPath, "SKILL.md");

    try {
      await fs.access(skillMdPath);
    } catch {
      throw new ParseError(`SKILL.md not found at ${skillMdPath}`, ParseErrorCode.FILE_NOT_FOUND);
    }

    const content = await fs.readFile(skillMdPath, "utf8");
    return this.parseContent(content);
  }

  /**
   * 直接解析 SKILL.md 内容
   * @param rawContent SKILL.md 原始内容
   * @returns 解析后的 Claude Skill 对象
   */
  parseContent(rawContent: string): ParsedClaudeSkill {
    const parsed = matter(rawContent);
    const frontmatter = parsed.data as ClaudeCodeSkillFrontmatter;

    // 验证并映射字段
    const validationResult = this.validateFrontmatter(frontmatter);
    if (!validationResult.valid) {
      const errorMessages = validationResult.errors.map((e) => e.message).join(", ");
      throw new ParseError(
        `Validation failed: ${errorMessages}`,
        ParseErrorCode.UNKNOWN_ERROR,
        "frontmatter"
      );
    }

    const metadata = this.mapToSkillMetadata(frontmatter);
    const compatibility = this.extractCompatibility(frontmatter);

    logger.debug("Parsed Claude Code Skill", {
      name: metadata.name,
      version: metadata.version,
    });

    return {
      metadata,
      compatibility,
      content: parsed.content,
    };
  }

  /**
   * 增强的 frontmatter 验证
   */
  private validateFrontmatter(frontmatter: any): {
    valid: boolean;
    errors: ParseError[];
    warnings: string[];
  } {
    const errors: ParseError[] = [];
    const warnings: string[] = [];

    // 1. 必填字段验证
    if (!frontmatter) {
      errors.push(
        new ParseError("Frontmatter is missing or empty", ParseErrorCode.FRONTMATTER_MISSING)
      );
      return { valid: false, errors, warnings };
    }

    // 2. name 验证（严格）
    if (!frontmatter.name) {
      errors.push(
        new ParseError('Field "name" is required', ParseErrorCode.MISSING_NAME, "name", [
          "Add a unique name for the skill",
        ])
      );
    } else if (typeof frontmatter.name !== "string") {
      errors.push(
        new ParseError('Field "name" must be a string', ParseErrorCode.INVALID_NAME_FORMAT, "name")
      );
    } else if (frontmatter.name.length > 64) {
      errors.push(
        new ParseError('Field "name" exceeds 64 characters', ParseErrorCode.NAME_TOO_LONG, "name", [
          `Current length: ${frontmatter.name.length}`,
          "Shorten the name to 64 characters or less",
        ])
      );
    } else if (!/^[a-z0-9-]+$/.test(frontmatter.name)) {
      errors.push(
        new ParseError(
          'Field "name" must contain only lowercase letters, numbers, and hyphens',
          ParseErrorCode.INVALID_NAME_FORMAT,
          "name",
          ["Use only lowercase letters (a-z), numbers (0-9), and hyphens (-)"]
        )
      );
    } else {
      // 检查保留字（仅当 name 有效时）
      if (RESERVED_WORDS.some((word) => frontmatter.name.toLowerCase().includes(word))) {
        errors.push(
          new ParseError(
            `name cannot contain reserved words: ${RESERVED_WORDS.join(", ")}`,
            ParseErrorCode.RESERVED_NAME,
            "name"
          )
        );
      }
    }

    // 3. description 验证
    if (!frontmatter.description) {
      errors.push(
        new ParseError(
          'Field "description" is required',
          ParseErrorCode.MISSING_DESCRIPTION,
          "description"
        )
      );
    } else if (frontmatter.description.length > 1024) {
      errors.push(
        new ParseError(
          'Field "description" must be 1024 characters or less',
          ParseErrorCode.MISSING_DESCRIPTION,
          "description"
        )
      );
    }

    // 4. version 验证（可选但格式检查）
    if (frontmatter.version !== undefined) {
      if (typeof frontmatter.version !== "string") {
        warnings.push('Field "version" should be a string');
      } else if (!/^\d+\.\d+\.\d+$/.test(frontmatter.version)) {
        warnings.push('Field "version" should follow semantic versioning (x.y.z)');
      }
    }

    // 5. context 验证（可选）
    if (frontmatter.context !== undefined) {
      if (!["fork", "inline"].includes(frontmatter.context)) {
        errors.push(
          new ParseError(
            'Field "context" must be "fork" or "inline"',
            ParseErrorCode.INVALID_CONTEXT,
            "context"
          )
        );
      }
    }

    // 6. allowedTools 验证（可选）
    if (frontmatter.allowedTools !== undefined) {
      if (!Array.isArray(frontmatter.allowedTools)) {
        errors.push(
          new ParseError(
            'Field "allowedTools" must be an array',
            ParseErrorCode.INVALID_ALLOWED_TOOLS,
            "allowedTools"
          )
        );
      } else {
        for (let i = 0; i < frontmatter.allowedTools.length; i++) {
          const tool = frontmatter.allowedTools[i];
          if (typeof tool !== "string") {
            errors.push(
              new ParseError(
                `allowedTools[${i}] must be a string`,
                ParseErrorCode.INVALID_ALLOWED_TOOLS,
                `allowedTools[${i}]`
              )
            );
          }
        }
      }
    }

    return { valid: errors.length === 0, errors, warnings };
  }

  /**
   * 解析 content 并返回包含错误和警告的结果
   */
  parseContentWithResult(rawContent: string): ParseResult {
    // 增强的 YAML 解析（容错）
    let frontmatter: any;
    let yamlErrors: ParseError[] = [];

    try {
      const parsed = matter(rawContent);
      frontmatter = parsed.data;
    } catch (error: any) {
      // YAML 解析失败
      yamlErrors.push(
        new ParseError(
          `Failed to parse YAML frontmatter: ${error.message}`,
          ParseErrorCode.INVALID_YAML,
          undefined,
          [
            "Check for syntax errors in YAML",
            "Ensure proper indentation (2 spaces)",
            "Verify quoted strings are properly closed",
          ]
        )
      );
      frontmatter = null;
    }

    // 验证并映射字段
    const validationResult = this.validateFrontmatter(frontmatter);
    const allErrors = [...yamlErrors, ...validationResult.errors];

    if (!validationResult.valid || yamlErrors.length > 0) {
      return {
        success: false,
        errors: allErrors,
        warnings: validationResult.warnings,
      };
    }

    const metadata = this.mapToSkillMetadata(frontmatter);
    const compatibility = this.extractCompatibility(frontmatter);
    const parsed = matter(rawContent);

    logger.debug("Parsed Claude Code Skill", {
      name: metadata.name,
      version: metadata.version,
    });

    return {
      success: true,
      metadata,
      compatibility,
      content: parsed.content,
      errors: allErrors,
      warnings: validationResult.warnings,
    };
  }

  /**
   * 映射到内部 SkillMetadata 格式
   */
  private mapToSkillMetadata(frontmatter: ClaudeCodeSkillFrontmatter): SkillMetadata {
    return {
      name: frontmatter.name,
      description: frontmatter.description,
      version: frontmatter.version || "0.1.0",
      tags: frontmatter.tags || [],
      author: frontmatter.author,
      // 映射 requires 到 dependencies
      dependencies: frontmatter.requires || [],
    };
  }

  /**
   * 提取兼容性字段
   */
  private extractCompatibility(
    frontmatter: ClaudeCodeSkillFrontmatter
  ): ParsedClaudeSkill["compatibility"] {
    return {
      allowedTools: frontmatter.allowedTools || [],
      model: frontmatter.model,
      context: frontmatter.context,
      agent: frontmatter.agent,
      hooks: frontmatter.hooks,
      userInvocable: frontmatter.userInvocable ?? false,
      source: "claude-code" as const,
    };
  }

  /**
   * 批量解析目录中的所有 Skills
   * @param skillsDir Skills 根目录路径
   * @returns 解析结果映射
   */
  async parseDirectory(skillsDir: string): Promise<Map<string, ParsedClaudeSkill>> {
    const result = new Map<string, ParsedClaudeSkill>();

    try {
      const entries = await fs.readdir(skillsDir, { withFileTypes: true });

      for (const entry of entries) {
        if (entry.isDirectory()) {
          const skillPath = path.join(skillsDir, entry.name);

          try {
            const parsed = await this.parse(skillPath);
            result.set(entry.name, parsed);
          } catch (error) {
            logger.warn(`Failed to parse skill at ${skillPath}:`, error);
          }
        }
      }
    } catch (error) {
      logger.error(`Failed to read skills directory: ${skillsDir}`, error);
    }

    return result;
  }
}

/**
 * 默认解析器实例
 */
let defaultParser: ClaudeCodeSkillParser | null = null;

export function getClaudeCodeSkillParser(): ClaudeCodeSkillParser {
  if (!defaultParser) {
    defaultParser = new ClaudeCodeSkillParser();
  }
  return defaultParser;
}
````

## File: src/services/compat/ContextModeExecutor.ts
````typescript
/**
 * ContextModeExecutor - Context 模式执行器
 * 支持 fork 和 inline 两种上下文隔离模式执行技能
 */

import * as fsSync from "fs";
import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";
import * as crypto from "crypto";
import { spawn, ChildProcess } from "child_process";
import {
  ContextMode,
  ContextModeConfig,
  SkillExecutionContext,
  ExecutionOptions,
  ExecutionResult,
} from "./types";
import { logger } from "../../utils/logger";

/**
 * 内部使用的执行结果类型（不含 mode）
 */
interface InternalExecutionResult {
  success: boolean;
  output: string;
  error?: string;
  exitCode?: number;
  durationMs: number;
  metadata?: Record<string, unknown>;
  stdout?: string;
  stderr?: string;
}

/**
 * 默认执行配置
 */
const DEFAULT_CONFIG: Required<ContextModeConfig> = {
  mode: "inline",
  workspacePath: path.join(os.tmpdir(), "skill-context"),
  isolated: false,
  maxMemory: 512,
  timeout: 60000,
};

/**
 * Cleanup retry configuration
 */
const CLEANUP_RETRY_CONFIG = {
  maxRetries: 3,
  initialDelayMs: 100,
  maxDelayMs: 1000,
  backoffMultiplier: 2,
};

/**
 * 最大输出大小 (10MB)
 */
const MAX_OUTPUT_SIZE = 10 * 1024 * 1024;

/**
 * Context 模式执行器
 */
export class ContextModeExecutor {
  private readonly workspacePath: string;
  private readonly activeProcesses: Map<string, ChildProcess>;

  constructor(workspacePath?: string) {
    this.workspacePath = workspacePath || DEFAULT_CONFIG.workspacePath;
    this.activeProcesses = new Map();
    this.ensureWorkspaceDirectory();
  }

  /**
   * 确保工作区目录存在
   */
  private async ensureWorkspaceDirectory(): Promise<void> {
    try {
      await fs.mkdir(this.workspacePath, { recursive: true });
    } catch (error) {
      logger.error("Failed to create workspace directory:", error);
    }
  }

  /**
   * 根据 context 模式执行技能
   */
  async execute(
    skillPath: string,
    mode: ContextMode,
    options: ExecutionOptions = {}
  ): Promise<ExecutionResult> {
    const startTime = Date.now();

    switch (mode) {
      case "fork":
        return this.executeInForkedContext(skillPath, options, startTime);
      case "inline":
        return this.executeInInlineContext(skillPath, options, startTime);
      default:
        return {
          success: false,
          output: "",
          error: `Unknown context mode: ${mode}`,
          durationMs: Date.now() - startTime,
          mode: mode as ContextMode,
        };
    }
  }

  /**
   * Fork 模式：在独立进程中执行，完全隔离
   */
  private async executeInForkedContext(
    skillPath: string,
    options: ExecutionOptions,
    startTime: number
  ): Promise<ExecutionResult> {
    let workspaceDir: string | null = null;

    try {
      // 1. 创建独立工作区
      workspaceDir = await this.createIsolatedWorkspace(skillPath);

      // 2. 复制技能文件到工作区
      await this.copySkillFiles(skillPath, workspaceDir);

      // 3. 在子进程中执行
      const result = await this.spawnInChildProcess(workspaceDir, options, startTime);

      // 4. 清理工作区
      await this.cleanupWorkspace(workspaceDir);

      return {
        ...result,
        mode: "fork",
      };
    } catch (error) {
      // 清理工作区（如果创建了工作区）
      if (workspaceDir) {
        try {
          await this.cleanupWorkspace(workspaceDir);
        } catch (cleanupError) {
          // 清理失败时，记录原始错误和清理错误
          const cleanupErrorMessage =
            cleanupError instanceof Error ? cleanupError.message : "Unknown cleanup error";
          logger.error(
            `[ContextModeExecutor] Cleanup failed after execution error: ${cleanupErrorMessage}`
          );
          // 仍然抛出原始执行错误
        }
      }

      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      logger.error("Fork mode execution failed:", error);

      return {
        success: false,
        output: "",
        error: errorMessage,
        durationMs: Date.now() - startTime,
        mode: "fork",
      };
    }
  }

  /**
   * Inline 模式：在当前进程中执行，共享上下文
   */
  private async executeInInlineContext(
    skillPath: string,
    options: ExecutionOptions,
    startTime: number
  ): Promise<ExecutionResult> {
    try {
      // 1. 加载技能到当前上下文
      const context = await this.loadSkillContext(skillPath, options);

      // 2. 执行技能逻辑（使用当前的进程上下文）
      const result = await this.executeInCurrentProcess(context, options, startTime);

      return {
        ...result,
        mode: "inline",
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      logger.error("Inline mode execution failed:", error);

      return {
        success: false,
        output: "",
        error: errorMessage,
        durationMs: Date.now() - startTime,
        mode: "inline",
      };
    }
  }

  /**
   * 创建隔离工作区
   */
  private async createIsolatedWorkspace(skillPath: string): Promise<string> {
    const workspaceId = `skill_fork_${Date.now()}_${crypto.randomBytes(4).toString("hex")}`;
    const workspaceDir = path.join(this.workspacePath, "fork", workspaceId);

    await fs.mkdir(workspaceDir, { recursive: true });
    await fs.chmod(workspaceDir, 0o700);

    logger.debug(`Created isolated workspace: ${workspaceDir}`);

    return workspaceDir;
  }

  /**
   * 复制技能文件到工作区
   */
  private async copySkillFiles(skillPath: string, workspaceDir: string): Promise<void> {
    try {
      const entries = await fs.readdir(skillPath, { withFileTypes: true });

      for (const entry of entries) {
        const srcPath = path.join(skillPath, entry.name);
        const destPath = path.join(workspaceDir, entry.name);

        if (entry.isDirectory()) {
          await fs.cp(srcPath, destPath, { recursive: true });
        } else {
          await fs.cp(srcPath, destPath);
        }
      }

      logger.debug(`Copied skill files to workspace: ${workspaceDir}`);
    } catch (error) {
      throw new Error(`Failed to copy skill files: ${error}`);
    }
  }

  /**
   * 在子进程中执行
   */
  private async spawnInChildProcess(
    workspaceDir: string,
    options: ExecutionOptions,
    startTime: number
  ): Promise<InternalExecutionResult> {
    return new Promise((resolve) => {
      // 查找主脚本文件
      const scriptPath = this.findMainScript(workspaceDir);

      if (!scriptPath) {
        resolve({
          success: false,
          output: "",
          error: "No executable script found in skill directory",
          durationMs: Date.now() - startTime,
        });
        return;
      }

      const timeout = options.timeout || DEFAULT_CONFIG.timeout;
      const memoryLimit = options.memoryLimit || DEFAULT_CONFIG.maxMemory;

      // 准备环境变量
      const env = this.prepareEnvironment(options.env, memoryLimit);

      // 设置 spawn 选项
      const spawnOptions = {
        env,
        cwd: workspaceDir,
        stdio: ["pipe", "pipe", "pipe"] as ("pipe" | "ipc" | "ignore" | "inherit")[],
        shell: false,
        detached: false,
      };

      // 确定执行命令
      const command = this.getExecuteCommand(scriptPath);
      const processArgs = this.getProcessArgs(options);

      // 启动进程
      const process = spawn(command, [scriptPath, ...processArgs], spawnOptions);

      // 生成进程 ID
      const processId = crypto.randomUUID();
      this.activeProcesses.set(processId, process);

      let stdout = "";
      let stderr = "";
      let outputSize = 0;
      let truncated = false;

      // 收集 stdout
      if (process.stdout) {
        process.stdout.on("data", (data: Buffer) => {
          const chunk = data.toString();
          outputSize += Buffer.byteLength(chunk);

          if (outputSize > MAX_OUTPUT_SIZE && !truncated) {
            truncated = true;
            stdout += "\n[TRUNCATED: Output exceeded size limit]";
            this.terminateProcess(process);
            this.activeProcesses.delete(processId);
          } else if (!truncated) {
            stdout += chunk;
          }
        });
      }

      // 收集 stderr
      if (process.stderr) {
        process.stderr.on("data", (data: Buffer) => {
          const chunk = data.toString();
          if (!truncated) {
            stderr += chunk;
          }
        });
      }

      // 设置超时
      const timeoutHandle = setTimeout(() => {
        logger.warn(`Script execution timed out after ${timeout}ms`);
        this.terminateProcess(process);
        this.activeProcesses.delete(processId);

        resolve({
          success: false,
          output: stdout,
          stderr: stderr || "Execution timed out",
          exitCode: -1,
          error: `Execution timed out after ${timeout}ms`,
          durationMs: Date.now() - startTime,
          metadata: { truncated },
        });
      }, timeout);

      // 处理进程退出
      process.on("close", (code: number | null, signal: string | null) => {
        clearTimeout(timeoutHandle);
        this.activeProcesses.delete(processId);

        if (code !== 0 && signal) {
          logger.warn(`Process exited with signal: ${signal}`);
        }

        resolve({
          success: code === 0 && !signal,
          output: stdout,
          stderr,
          exitCode: code ?? (signal ? -1 : 0),
          error: code !== 0 ? stderr.trim() || `Process exited with code ${code}` : undefined,
          durationMs: Date.now() - startTime,
          metadata: { truncated },
        });
      });

      // 处理进程错误
      process.on("error", (error: Error) => {
        clearTimeout(timeoutHandle);
        this.activeProcesses.delete(processId);

        logger.error("Process error:", error);

        resolve({
          success: false,
          output: stdout,
          stderr,
          error: error.message,
          durationMs: Date.now() - startTime,
          metadata: { truncated },
        });
      });
    });
  }

  /**
   * 加载技能上下文
   */
  private async loadSkillContext(
    skillPath: string,
    options: ExecutionOptions
  ): Promise<SkillExecutionContext> {
    const skillName = path.basename(skillPath);

    // 读取技能目录内容
    const files: string[] = [];
    try {
      const entries = await fs.readdir(skillPath, { withFileTypes: true });
      for (const entry of entries) {
        files.push(entry.name);
      }
    } catch {
      // 忽略读取错误
    }

    return {
      skillName,
      skillPath,
      mode: "inline",
      workspace: skillPath,
      env: options.env || {},
      files: options.files || files,
      metadata: {} as never,
    };
  }

  /**
   * 在当前进程中执行
   */
  private async executeInCurrentProcess(
    context: SkillExecutionContext,
    options: ExecutionOptions,
    startTime: number
  ): Promise<InternalExecutionResult> {
    // Inline 模式下，直接返回成功，因为技能逻辑由调用者处理
    // 这里只是标记执行模式，不实际执行脚本
    return {
      success: true,
      output: `Inline execution for skill: ${context.skillName}`,
      durationMs: Date.now() - startTime,
      metadata: {
        files: context.files,
        workspace: context.workspace,
      },
    };
  }

  /**
   * 查找主脚本文件
   */
  private findMainScript(workspaceDir: string): string | null {
    const priorityFiles = ["index.js", "index.mjs", "index.cjs", "index.ts", "run.js", "run.sh"];

    for (const file of priorityFiles) {
      const filePath = path.join(workspaceDir, file);
      if (this.fileExistsSync(filePath)) {
        return filePath;
      }
    }

    // 查找任意可执行文件
    return null;
  }

  /**
   * 同步检查文件是否存在
   */
  private fileExistsSync(filePath: string): boolean {
    try {
      fsSync.accessSync(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 获取执行命令
   */
  private getExecuteCommand(scriptPath: string): string {
    const ext = path.extname(scriptPath);

    switch (ext) {
      case ".js":
      case ".mjs":
      case ".cjs":
        return "node";
      case ".ts":
        return "ts-node";
      case ".py":
        return "python3";
      case ".sh":
        return "bash";
      default:
        return "node";
    }
  }

  /**
   * 获取进程参数
   */
  private getProcessArgs(options: ExecutionOptions): string[] {
    const args: Record<string, unknown> = {
      ...options.metadata,
    };

    return [JSON.stringify(args)];
  }

  /**
   * 准备环境变量
   */
  private prepareEnvironment(
    customEnv: Record<string, string> | undefined,
    memoryLimit: number
  ): NodeJS.ProcessEnv {
    const env: NodeJS.ProcessEnv = {
      ...process.env,
      ...customEnv,
      NODE_OPTIONS: `--max-old-space-size=${memoryLimit}`,
      NODE_NO_WARNINGS: "1",
    };

    return env;
  }

  /**
   * 清理工作区（带重试机制）
   */
  private async cleanupWorkspace(workspacePath: string): Promise<void> {
    let lastError: Error | undefined;
    let delay = CLEANUP_RETRY_CONFIG.initialDelayMs;

    for (let attempt = 1; attempt <= CLEANUP_RETRY_CONFIG.maxRetries; attempt++) {
      try {
        await fs.rm(workspacePath, { recursive: true, force: true });
        logger.debug(`Cleaned up workspace: ${workspacePath}`);
        return;
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));

        if (attempt < CLEANUP_RETRY_CONFIG.maxRetries) {
          logger.warn(
            `[ContextModeExecutor] Cleanup attempt ${attempt} failed for ${workspacePath}, retrying in ${delay}ms`,
            lastError
          );
          await this.sleep(delay);
          delay = Math.min(
            delay * CLEANUP_RETRY_CONFIG.backoffMultiplier,
            CLEANUP_RETRY_CONFIG.maxDelayMs
          );
        }
      }
    }

    // All retries exhausted
    logger.error(
      `[ContextModeExecutor] Failed to cleanup workspace after ${CLEANUP_RETRY_CONFIG.maxRetries} attempts: ${workspacePath}`,
      lastError
    );
    throw lastError;
  }

  /**
   * 睡眠辅助函数
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * 终止进程
   */
  private terminateProcess(process: ChildProcess, signal: string = "SIGTERM"): void {
    if (!process.killed && process.pid) {
      try {
        process.kill(signal as NodeJS.Signals);
      } catch (error) {
        logger.warn("Failed to terminate process:", error);
      }
    }
  }

  /**
   * 终止所有活跃进程
   */
  async terminateAllProcesses(): Promise<void> {
    for (const process of this.activeProcesses.values()) {
      this.terminateProcess(process, "SIGKILL");
    }
    this.activeProcesses.clear();
  }

  /**
   * 清理资源
   */
  async cleanup(): Promise<void> {
    await this.terminateAllProcesses();

    try {
      await fs.rm(this.workspacePath, { recursive: true, force: true });
    } catch (error) {
      logger.warn("Failed to cleanup workspace directory:", error);
    }
  }
}

/**
 * 默认执行器实例
 */
let defaultExecutor: ContextModeExecutor | null = null;

export function getContextModeExecutor(workspacePath?: string): ContextModeExecutor {
  if (!defaultExecutor) {
    defaultExecutor = new ContextModeExecutor(workspacePath);
  }
  return defaultExecutor;
}
````

## File: src/services/compat/index.ts
````typescript
/**
 * Compat Layer - 兼容层组件
 * 提供 Claude Code Skill 格式转换、脚本执行和生命周期管理
 */

export {
  ClaudeCodeSkillParser,
  getClaudeCodeSkillParser,
  type ParseResult,
} from "./ClaudeCodeSkillParser";
export { ParseError, ParseErrorCode } from "./types";
export { ScriptExecutor, getScriptExecutor } from "./ScriptExecutor";
export { ContextModeExecutor, getContextModeExecutor } from "./ContextModeExecutor";
export { LifecycleManager, getLifecycleManager } from "./LifecycleManager";
export {
  AllowedToolsValidator,
  PermissionDeniedError,
  type ValidationResult,
  type BatchValidationResult,
  type AllowedToolsValidatorConfig,
  getAllowedToolsValidator,
  resetAllowedToolsValidator,
  default,
} from "./AllowedToolsValidator";
export type {
  ClaudeCodeSkillFrontmatter,
  ParsedClaudeSkill,
  ScriptExecutionOptions,
  ExecutionResult,
  ScriptCapabilities,
  ValidationResult as ScriptValidationResult,
  SkillLifecycleHooks,
  SkillLifecycleContext,
  DependencyCheckResult,
  ContextMode,
  ContextModeConfig,
  SkillExecutionContext,
  ExecutionOptions,
} from "./types";
````

## File: src/services/compat/LifecycleManager.ts
````typescript
/**
 * LifecycleManager - 技能生命周期管理器
 * 处理技能的安装、更新、卸载生命周期钩子
 */

import * as fs from "fs/promises";
import * as path from "path";
import { SkillLifecycleHooks, SkillLifecycleContext, ParsedClaudeSkill } from "./types";
import { SkillMetadata } from "../../types/tool-system";
import { logger } from "../../utils/logger";

/**
 * 依赖检查结果
 */
export interface DependencyCheckResult {
  satisfied: boolean;
  missing: string[];
  installed: string[];
}

/**
 * 安装结果
 */
export interface InstallResult {
  success: boolean;
  context: SkillLifecycleContext;
  error?: string;
}

/**
 * 更新结果
 */
export interface UpdateResult {
  success: boolean;
  context: SkillLifecycleContext;
  previousVersion?: string;
  error?: string;
}

/**
 * 卸载结果
 */
export interface UninstallResult {
  success: boolean;
  skillName: string;
  error?: string;
}

/**
 * 回滚状态
 */
interface RollbackState {
  timestamp: Date;
  previousContext?: SkillLifecycleContext;
  actions: string[];
}

/**
 * 生命周期管理器
 */
export class LifecycleManager {
  private readonly hooksRegistry: Map<string, SkillLifecycleHooks>;
  private readonly hookCache: Map<string, ParsedClaudeSkill["compatibility"]>;
  private readonly rollbackStates: Map<string, RollbackState>;
  private _installHook:
    | ((skillName: string, skillPath: string, metadata: SkillMetadata) => Promise<void>)
    | null = null;
  private _updateHook:
    | ((skillName: string, skillPath: string, metadata: SkillMetadata) => Promise<void>)
    | null = null;
  private _uninstallHook: ((skillName: string, skillPath: string) => Promise<void>) | null = null;

  constructor() {
    this.hooksRegistry = new Map();
    this.hookCache = new Map();
    this.rollbackStates = new Map();
  }

  /**
   * 注册生命周期钩子
   */
  registerHooks(skillName: string, hooks: SkillLifecycleHooks): void {
    this.hooksRegistry.set(skillName, hooks);
    logger.debug(`Registered lifecycle hooks for skill: ${skillName}`);
  }

  /**
   * 注销生命周期钩子
   */
  unregisterHooks(skillName: string): void {
    this.hooksRegistry.delete(skillName);
    this.hookCache.delete(skillName);
    logger.debug(`Unregistered lifecycle hooks for skill: ${skillName}`);
  }

  /**
   * 执行预安装钩子
   */
  async preInstall(ctx: SkillLifecycleContext): Promise<void> {
    const hooks = this.hooksRegistry.get(ctx.skillName);
    if (hooks?.preInstall) {
      logger.info(`Executing preInstall hook for skill: ${ctx.skillName}`);
      await hooks.preInstall(ctx);
    }
  }

  /**
   * 执行后安装钩子
   */
  async postInstall(ctx: SkillLifecycleContext): Promise<void> {
    const hooks = this.hooksRegistry.get(ctx.skillName);
    if (hooks?.postInstall) {
      logger.info(`Executing postInstall hook for skill: ${ctx.skillName}`);
      await hooks.postInstall(ctx);
    }

    // 如果有 compatibility 信息，缓存它
    if (ctx.compatibility) {
      this.hookCache.set(ctx.skillName, ctx.compatibility as ParsedClaudeSkill["compatibility"]);
    }
  }

  /**
   * 执行预更新钩子
   */
  async preUpdate(ctx: SkillLifecycleContext): Promise<void> {
    const hooks = this.hooksRegistry.get(ctx.skillName);
    if (hooks?.preUpdate) {
      logger.info(`Executing preUpdate hook for skill: ${ctx.skillName}`);
      await hooks.preUpdate(ctx);
    }
  }

  /**
   * 执行后更新钩子
   */
  async postUpdate(ctx: SkillLifecycleContext): Promise<void> {
    const hooks = this.hooksRegistry.get(ctx.skillName);
    if (hooks?.postUpdate) {
      logger.info(`Executing postUpdate hook for skill: ${ctx.skillName}`);
      await hooks.postUpdate(ctx);
    }

    // 更新缓存的 compatibility 信息
    if (ctx.compatibility) {
      this.hookCache.set(ctx.skillName, ctx.compatibility as ParsedClaudeSkill["compatibility"]);
    }
  }

  /**
   * 执行预卸载钩子
   */
  async preUninstall(ctx: SkillLifecycleContext): Promise<void> {
    const hooks = this.hooksRegistry.get(ctx.skillName);
    if (hooks?.preUninstall) {
      logger.info(`Executing preUninstall hook for skill: ${ctx.skillName}`);
      await hooks.preUninstall(ctx);
    }
  }

  /**
   * 执行后卸载钩子
   */
  async postUninstall(ctx: SkillLifecycleContext): Promise<void> {
    const hooks = this.hooksRegistry.get(ctx.skillName);
    if (hooks?.postUninstall) {
      logger.info(`Executing postUninstall hook for skill: ${ctx.skillName}`);
      await hooks.postUninstall(ctx);
    }

    // 清理缓存
    this.hookCache.delete(ctx.skillName);
    this.hooksRegistry.delete(ctx.skillName);
  }

  /**
   * 检查依赖是否满足
   */
  async checkDependencies(
    dependencies: string[],
    installedSkills: string[]
  ): Promise<DependencyCheckResult> {
    const installed = new Set(installedSkills.map((s) => s.toLowerCase()));
    const missing: string[] = [];
    const satisfiedDeps: string[] = [];

    for (const dep of dependencies) {
      const depLower = dep.toLowerCase();
      if (installed.has(depLower)) {
        satisfiedDeps.push(dep);
      } else {
        missing.push(dep);
      }
    }

    return {
      satisfied: missing.length === 0,
      missing,
      installed: satisfiedDeps,
    };
  }

  /**
   * 安装依赖
   */
  async installDependencies(
    dependencies: string[],
    basePath: string
  ): Promise<{ success: boolean; errors: string[] }> {
    const errors: string[] = [];

    for (const dep of dependencies) {
      const depPath = path.join(basePath, "dependencies", dep);

      try {
        // 检查依赖是否存在
        await fs.access(depPath);

        // 检查是否有 install 脚本
        const installScript = path.join(depPath, "install.sh");
        const installJs = path.join(depPath, "install.js");

        if (await this.fileExists(installScript)) {
          await this.executeInstallScript(installScript, dep);
        } else if (await this.fileExists(installJs)) {
          await this.executeInstallScript(installJs, dep);
        }

        logger.info(`Installed dependency: ${dep}`);
      } catch (error) {
        const errorMsg = `Failed to install dependency: ${dep}`;
        logger.error(errorMsg, error);
        errors.push(errorMsg);
      }
    }

    return {
      success: errors.length === 0,
      errors,
    };
  }

  /**
   * 执行安装脚本
   */
  private async executeInstallScript(scriptPath: string, depName: string): Promise<void> {
    logger.info(`Executing install script for dependency: ${depName}`);

    // 注意：实际执行逻辑应该由 ScriptExecutor 处理
    // 这里只做基本的脚本验证
    await fs.access(scriptPath);
  }

  /**
   * 检查文件是否存在
   */
  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 获取技能的兼容性信息
   */
  getCompatibility(skillName: string): ParsedClaudeSkill["compatibility"] | undefined {
    return this.hookCache.get(skillName);
  }

  /**
   * 检查技能是否有特定能力
   */
  hasCapability(skillName: string, capability: keyof ParsedClaudeSkill["compatibility"]): boolean {
    const compatibility = this.hookCache.get(skillName);
    return compatibility ? capability in compatibility : false;
  }

  /**
   * 获取技能的 context 模式
   */
  getContextMode(skillName: string): "fork" | "inline" | undefined {
    const compatibility = this.hookCache.get(skillName);
    if (compatibility && "context" in compatibility) {
      return compatibility.context as "fork" | "inline" | undefined;
    }
    return undefined;
  }

  /**
   * 检查技能是否使用 fork 模式
   */
  isForkMode(skillName: string): boolean {
    return this.getContextMode(skillName) === "fork";
  }

  /**
   * 检查技能是否使用 inline 模式
   */
  isInlineMode(skillName: string): boolean {
    return this.getContextMode(skillName) === "inline";
  }

  /**
   * 获取所有已注册的技能名称
   */
  getRegisteredSkills(): string[] {
    return Array.from(this.hooksRegistry.keys());
  }

  /**
   * 清除所有钩子注册
   */
  clear(): void {
    this.hooksRegistry.clear();
    this.hookCache.clear();
    logger.debug("Cleared all lifecycle hook registrations");
  }

  /**
   * 从 compatibility 对象创建上下文
   */
  createContext(
    skillName: string,
    skillPath: string,
    metadata: SkillMetadata,
    compatibility?: ParsedClaudeSkill["compatibility"],
    validationLevel: "strict" | "basic" | "none" = "basic"
  ): SkillLifecycleContext {
    return {
      skillName,
      skillPath,
      metadata,
      compatibility,
      validationLevel,
      dependencies: metadata.dependencies,
    };
  }

  /**
   * 设置自定义安装操作
   */
  setInstallHook(
    hook: (skillName: string, skillPath: string, metadata: SkillMetadata) => Promise<void>
  ): void {
    this._installHook = hook;
  }

  /**
   * 设置自定义更新操作
   */
  setUpdateHook(
    hook: (skillName: string, skillPath: string, metadata: SkillMetadata) => Promise<void>
  ): void {
    this._updateHook = hook;
  }

  /**
   * 设置自定义卸载操作
   */
  setUninstallHook(hook: (skillName: string, skillPath: string) => Promise<void>): void {
    this._uninstallHook = hook;
  }

  /**
   * 执行实际的安装操作
   */
  private async performInstall(context: SkillLifecycleContext): Promise<void> {
    if (this._installHook) {
      await this._installHook(context.skillName, context.skillPath, context.metadata!);
    } else {
      logger.info(`Performing install for skill: ${context.skillName}`);
    }
  }

  /**
   * 执行实际的更新操作
   */
  private async performUpdate(context: SkillLifecycleContext): Promise<void> {
    if (this._updateHook) {
      await this._updateHook(context.skillName, context.skillPath, context.metadata!);
    } else {
      logger.info(`Performing update for skill: ${context.skillName}`);
    }
  }

  /**
   * 执行实际的卸载操作
   */
  private async performUninstall(context: SkillLifecycleContext): Promise<void> {
    if (this._uninstallHook) {
      await this._uninstallHook(context.skillName, context.skillPath);
    } else {
      logger.info(`Performing uninstall for skill: ${context.skillName}`);
    }
  }

  /**
   * 保存回滚状态
   */
  private saveRollbackState(skillName: string, actions: string[]): void {
    const previousCompatibility = this.hookCache.get(skillName);
    const previousContext: SkillLifecycleContext = {
      skillName,
      skillPath: "",
      compatibility: previousCompatibility,
    };

    this.rollbackStates.set(skillName, {
      timestamp: new Date(),
      previousContext,
      actions,
    });
  }

  /**
   * 执行回滚
   */
  private async performRollback(skillName: string): Promise<void> {
    const rollbackState = this.rollbackStates.get(skillName);
    if (rollbackState) {
      logger.info(`Rolling back skill: ${skillName}`);
      this.rollbackStates.delete(skillName);
    }
  }

  /**
   * 执行单个 hook
   */
  private async executeHook(
    hookType: keyof SkillLifecycleHooks,
    context: SkillLifecycleContext
  ): Promise<void> {
    const hooks = this.hooksRegistry.get(context.skillName);
    const hook = hooks?.[hookType];

    if (hook) {
      logger.debug(`Executing ${hookType} hook for ${context.skillName}`);
      await hook(context);
    }
  }

  /**
   * 执行完整的安装生命周期
   */
  async executeInstallLifecycle(
    skillName: string,
    skillPath: string,
    metadata: SkillMetadata
  ): Promise<InstallResult> {
    const context = this.createContext(skillName, skillPath, metadata);

    try {
      logger.info(`Starting install lifecycle for skill: ${skillName}`);

      // 1. 执行 preInstall hook
      await this.executeHook("preInstall", context);

      // 2. 执行安装操作
      await this.performInstall(context);

      // 3. 执行 postInstall hook
      await this.executeHook("postInstall", context);

      logger.info(`Install lifecycle completed for skill: ${skillName}`);
      return { success: true, context };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Install lifecycle failed for skill ${skillName}: ${errorMessage}`);

      // 回滚: 执行 preUninstall hook
      try {
        await this.executeHook("preUninstall", context);
      } catch (rollbackError) {
        logger.error(`Rollback preUninstall failed: ${rollbackError}`);
      }

      return { success: false, context, error: errorMessage };
    }
  }

  /**
   * 执行完整的更新生命周期
   */
  async executeUpdateLifecycle(
    skillName: string,
    skillPath: string,
    metadata: SkillMetadata
  ): Promise<UpdateResult> {
    const context = this.createContext(skillName, skillPath, metadata);
    const previousVersion = metadata.version;

    try {
      logger.info(`Starting update lifecycle for skill: ${skillName}`);

      // 保存回滚状态
      this.saveRollbackState(skillName, ["update"]);

      // 1. 执行 preUpdate hook
      await this.executeHook("preUpdate", context);

      // 2. 执行更新操作
      await this.performUpdate(context);

      // 3. 执行 postUpdate hook
      await this.executeHook("postUpdate", context);

      logger.info(`Update lifecycle completed for skill: ${skillName}`);
      return { success: true, context, previousVersion };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Update lifecycle failed for skill ${skillName}: ${errorMessage}`);

      // 回滚: 恢复到更新前状态
      await this.performRollback(skillName);

      return { success: false, context, previousVersion, error: errorMessage };
    }
  }

  /**
   * 执行完整的卸载生命周期
   */
  async executeUninstallLifecycle(
    skillName: string,
    skillPath: string,
    metadata: SkillMetadata
  ): Promise<UninstallResult> {
    const context = this.createContext(skillName, skillPath, metadata);

    try {
      logger.info(`Starting uninstall lifecycle for skill: ${skillName}`);

      // 1. 执行 preUninstall hook
      await this.executeHook("preUninstall", context);

      // 2. 执行卸载操作
      await this.performUninstall(context);

      // 3. 执行 postUninstall hook 并清理
      await this.postUninstall(context);

      logger.info(`Uninstall lifecycle completed for skill: ${skillName}`);
      return { success: true, skillName };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Uninstall lifecycle failed for skill ${skillName}: ${errorMessage}`);

      // 记录错误但不回滚（卸载失败）
      return { success: false, skillName, error: errorMessage };
    }
  }
}

/**
 * 默认生命周期管理器实例
 */
let defaultManager: LifecycleManager | null = null;

export function getLifecycleManager(): LifecycleManager {
  if (!defaultManager) {
    defaultManager = new LifecycleManager();
  }
  return defaultManager;
}
````

## File: src/services/compat/PermissionValidator.ts
````typescript
/**
 * PermissionValidator - 权限验证器
 * 验证 skill 执行时的工具调用权限
 */

import { ToolError, ToolErrorCode } from "../../types/tool-system";
import { logger } from "../../utils/logger";
import { getSkillManager } from "../SkillManager";
import { ParsedClaudeSkill } from "./types";

/**
 * 权限验证模式
 */
export type PermissionValidationMode = "strict" | "warn" | "disabled";

/**
 * 权限验证配置
 */
export interface PermissionValidationConfig {
  /** 是否启用权限验证 */
  enabled: boolean;
  /** 验证模式 */
  mode: PermissionValidationMode;
  /** 是否记录拒绝日志 */
  logDeniedRequests: boolean;
  /** 是否严格检查大小写 */
  caseSensitive: boolean;
}

/**
 * 权限验证结果
 */
export interface PermissionValidationResult {
  /** 是否允许 */
  allowed: boolean;
  /** 拒绝的工具列表 */
  deniedTools: string[];
  /** 原因 */
  reason?: string;
}

/**
 * 权限验证错误详情
 */
export interface PermissionDeniedDetails {
  skillName: string;
  requestedTools: string[];
  allowedTools: string[];
  missingTools: string[];
  mode: PermissionValidationMode;
  timestamp: string;
}

/**
 * 权限验证器
 * 验证 skill 执行时的工具调用权限
 */
export class PermissionValidator {
  private config: PermissionValidationConfig;

  constructor(config?: Partial<PermissionValidationConfig>) {
    this.config = {
      enabled: true,
      mode: "strict",
      logDeniedRequests: true,
      caseSensitive: true,
      ...config,
    };
  }

  /**
   * 验证工具调用权限
   * @param skillName skill 名称
   * @param requestedTools 请求的工具列表
   * @returns 验证结果
   */
  async validatePermissions(
    skillName: string,
    requestedTools: string[]
  ): Promise<PermissionValidationResult> {
    // 如果权限验证已禁用，直接返回允许
    if (!this.config.enabled) {
      return {
        allowed: true,
        deniedTools: [],
      };
    }

    // 如果没有请求任何工具，直接允许
    if (!requestedTools || requestedTools.length === 0) {
      return {
        allowed: true,
        deniedTools: [],
      };
    }

    try {
      // 获取 skill 兼容性信息
      const skillManager = getSkillManager();
      const skill = await skillManager.getSkillByName(skillName);

      if (!skill) {
        // Skill 不存在，根据模式决定行为
        return this.handleSkillNotFound(skillName, requestedTools);
      }

      // 获取 allowedTools 配置
      const allowedTools = this.getAllowedToolsFromSkill(skill);

      // 如果没有配置 allowedTools，允许所有工具
      if (!allowedTools || allowedTools.length === 0) {
        logger.debug(`Skill ${skillName} has no allowedTools configured, allowing all tools`, {
          requestedTools,
        });
        return {
          allowed: true,
          deniedTools: [],
        };
      }

      // 执行权限检查
      const result = this.checkPermissions(requestedTools, allowedTools);

      // 记录拒绝日志
      if (!result.allowed && this.config.logDeniedRequests) {
        this.logDeniedRequest(skillName, requestedTools, allowedTools, result.deniedTools);
      }

      // 根据模式处理拒绝情况
      if (!result.allowed) {
        return this.handlePermissionDenied(skillName, requestedTools, allowedTools);
      }

      return result;
    } catch (error) {
      logger.error(`Permission validation failed for skill ${skillName}:`, error);
      // 验证失败时，根据模式决定行为
      if (this.config.mode === "strict") {
        throw new ToolError(
          `Permission validation failed: ${this.formatError(error)}`,
          ToolErrorCode.TOOL_EXECUTION_FAILED
        );
      }
      // warn 模式下，允许执行但记录警告
      logger.warn(`Permission validation failed for skill ${skillName}, allowing execution`);
      return {
        allowed: true,
        deniedTools: [],
        reason: "Validation failed, allowing due to warn mode",
      };
    }
  }

  /**
   * 验证单个工具调用
   * @param skillName skill 名称
   * @param toolName 工具名称
   * @returns 验证结果
   */
  async validateTool(skillName: string, toolName: string): Promise<PermissionValidationResult> {
    return this.validatePermissions(skillName, [toolName]);
  }

  /**
   * 检查工具是否被允许
   * @param skillName skill 名称
   * @param toolName 工具名称
   * @returns 是否允许
   */
  async isToolAllowed(skillName: string, toolName: string): Promise<boolean> {
    const result = await this.validateTool(skillName, toolName);
    return result.allowed;
  }

  /**
   * 获取允许的工具列表
   * @param skillName skill 名称
   * @returns 允许的工具列表
   */
  async getAllowedTools(skillName: string): Promise<string[]> {
    try {
      const skillManager = getSkillManager();
      const skill = await skillManager.getSkillByName(skillName);

      if (!skill) {
        return [];
      }

      return this.getAllowedToolsFromSkill(skill);
    } catch (error) {
      logger.error(`Failed to get allowed tools for skill ${skillName}:`, error);
      return [];
    }
  }

  /**
   * 更新配置
   * @param config 新配置
   */
  updateConfig(config: Partial<PermissionValidationConfig>): void {
    this.config = {
      ...this.config,
      ...config,
    };
    logger.info("PermissionValidator config updated", { config: this.config });
  }

  /**
   * 获取当前配置
   * @returns 当前配置
   */
  getConfig(): PermissionValidationConfig {
    return { ...this.config };
  }

  /**
   * 从 skill 对象获取允许的工具列表
   */
  private getAllowedToolsFromSkill(skill: any): string[] {
    // 从兼容层获取 allowedTools
    if (skill.compatibility && skill.compatibility.allowedTools) {
      return skill.compatibility.allowedTools;
    }

    // 从 metadata 获取
    if (skill.metadata && skill.metadata.tools) {
      return skill.metadata.tools;
    }

    return [];
  }

  /**
   * 执行权限检查
   */
  private checkPermissions(
    requestedTools: string[],
    allowedTools: string[]
  ): PermissionValidationResult {
    const deniedTools: string[] = [];

    for (const tool of requestedTools) {
      const isAllowed = this.isToolInList(tool, allowedTools);
      if (!isAllowed) {
        deniedTools.push(tool);
      }
    }

    return {
      allowed: deniedTools.length === 0,
      deniedTools,
      reason:
        deniedTools.length > 0 ? `Tools not in allowed list: ${deniedTools.join(", ")}` : undefined,
    };
  }

  /**
   * 检查工具是否在列表中
   */
  private isToolInList(tool: string, list: string[]): boolean {
    if (this.config.caseSensitive) {
      return list.includes(tool);
    }

    // 不区分大小写比较
    const toolLower = tool.toLowerCase();
    return list.some((item) => item.toLowerCase() === toolLower);
  }

  /**
   * 处理 skill 不存在的情况
   */
  private handleSkillNotFound(
    skillName: string,
    requestedTools: string[]
  ): PermissionValidationResult {
    if (this.config.mode === "strict") {
      const error = new ToolError(`Skill not found: ${skillName}`, ToolErrorCode.SKILL_NOT_FOUND);
      throw error;
    }

    logger.warn(`Skill ${skillName} not found, allowing tool execution in warn mode`);
    return {
      allowed: true,
      deniedTools: [],
      reason: "Skill not found, allowing in warn mode",
    };
  }

  /**
   * 处理权限被拒绝的情况
   */
  private handlePermissionDenied(
    skillName: string,
    requestedTools: string[],
    allowedTools: string[]
  ): PermissionValidationResult {
    const missingTools = requestedTools.filter((tool) => !this.isToolInList(tool, allowedTools));

    const details: PermissionDeniedDetails = {
      skillName,
      requestedTools,
      allowedTools,
      missingTools,
      mode: this.config.mode,
      timestamp: new Date().toISOString(),
    };

    if (this.config.mode === "strict") {
      const error = new ToolError(
        `Permission denied: tools [${missingTools.join(", ")}] are not allowed for skill ${skillName}`,
        ToolErrorCode.TOOL_EXECUTION_FAILED,
        details
      );
      throw error;
    }

    // warn 模式：允许执行但记录警告
    logger.warn(`Permission denied for skill ${skillName}`, details);
    return {
      allowed: true,
      deniedTools: missingTools,
      reason: "Permission denied but allowed due to warn mode",
    };
  }

  /**
   * 记录拒绝请求日志
   */
  private logDeniedRequest(
    skillName: string,
    requestedTools: string[],
    allowedTools: string[],
    deniedTools: string[]
  ): void {
    logger.warn(`Permission denied for skill ${skillName}`, {
      skillName,
      requestedTools,
      allowedTools,
      deniedTools,
      missingTools: deniedTools,
      mode: this.config.mode,
      timestamp: new Date().toISOString(),
    });
  }

  /**
   * 格式化错误信息
   */
  private formatError(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error";
  }
}

// 默认实例
let defaultValidator: PermissionValidator | null = null;

/**
 * 获取默认权限验证器实例
 */
export function getPermissionValidator(
  config?: Partial<PermissionValidationConfig>
): PermissionValidator {
  if (!defaultValidator) {
    defaultValidator = new PermissionValidator(config);
  } else if (config) {
    defaultValidator.updateConfig(config);
  }
  return defaultValidator;
}

/**
 * 重置默认验证器实例（用于测试）
 */
export function resetPermissionValidator(): void {
  defaultValidator = null;
}
````

## File: src/services/compat/ScriptExecutor.ts
````typescript
/**
 * ScriptExecutor - 脚本执行适配器
 * 在隔离环境中执行技能脚本，支持多种隔离策略
 */

import { spawn, ChildProcess } from "child_process";
import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";
import * as crypto from "crypto";
import {
  ScriptExecutionOptions,
  ScriptExecutionResult,
  ScriptCapabilities,
  ValidationResult,
} from "./types";
import { logger } from "../../utils/logger";

/**
 * 默认执行选项
 */
const DEFAULT_OPTIONS: Required<ScriptExecutionOptions> = {
  timeoutMs: 60000,
  maxOutputSize: 10 * 1024 * 1024, // 10MB
  memoryLimitMb: 512,
  env: {},
  network: "deny",
};

/**
 * 最大参数大小 (1MB)
 */
const MAX_ARGS_SIZE = 1 * 1024 * 1024;

/**
 * 脚本执行适配器
 */
export class ScriptExecutor {
  private readonly workspacePath: string;
  private readonly activeProcesses: Map<string, ChildProcess>;

  constructor(workspacePath?: string) {
    this.workspacePath = workspacePath || path.join(os.tmpdir(), "skill-executor");
    this.activeProcesses = new Map();
    this.ensureWorkspaceDirectory();
  }

  /**
   * 确保工作区目录存在
   */
  private async ensureWorkspaceDirectory(): Promise<void> {
    try {
      await fs.mkdir(this.workspacePath, { recursive: true });
    } catch (error) {
      logger.error("Failed to create workspace directory:", error);
    }
  }

  /**
   * 执行脚本
   */
  async execute(
    scriptPath: string,
    args: Record<string, unknown>,
    options?: ScriptExecutionOptions
  ): Promise<ScriptExecutionResult> {
    const startTime = Date.now();
    const mergedOptions = { ...DEFAULT_OPTIONS, ...options };

    // 验证脚本路径
    const validation = await this.validateScript(scriptPath);
    if (!validation.valid) {
      return {
        success: false,
        output: "",
        error: `Script validation failed: ${validation.errors.join(", ")}`,
        durationMs: Date.now() - startTime,
      };
    }

    try {
      // 准备环境变量
      const env = this.prepareEnvironment(mergedOptions);

      // 创建隔离工作区
      const workspaceDir = await this.createWorkspace();

      // 执行脚本
      const result = await this.spawnProcess(scriptPath, args, workspaceDir, env, mergedOptions);

      // 清理工作区
      await this.cleanupWorkspace(workspaceDir);

      return {
        success: result.success,
        output: result.stdout,
        error: result.error,
        exitCode: result.exitCode,
        durationMs: Date.now() - startTime,
        metadata: {
          truncated: result.truncated,
        },
      };
    } catch (error) {
      logger.error("Script execution failed:", error);

      return {
        success: false,
        output: "",
        error: error instanceof Error ? error.message : "Unknown error",
        durationMs: Date.now() - startTime,
      };
    }
  }

  /**
   * 验证脚本
   */
  async validateScript(scriptPath: string): Promise<ValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    try {
      // 检查文件是否存在
      await fs.access(scriptPath);
    } catch {
      errors.push(`Script file not found: ${scriptPath}`);
      return {
        valid: false,
        errors,
        warnings,
        capabilities: {
          languages: [],
          hasNetworkAccess: false,
          hasFileSystemAccess: false,
          maxExecutionTimeMs: 0,
          maxMemoryMb: 0,
        },
      };
    }

    // 检查文件扩展名
    const ext = path.extname(scriptPath);
    const languages = this.detectLanguage(ext);

    if (languages.length === 0) {
      errors.push(`Unsupported script type: ${ext}`);
    }

    // 尝试读取脚本头部获取能力信息
    try {
      const content = await fs.readFile(scriptPath, "utf8");
      const capabilities = this.parseCapabilities(content);

      // 合并语言检测结果
      capabilities.languages = languages.length > 0 ? languages : capabilities.languages;

      return {
        valid: errors.length === 0,
        errors,
        warnings,
        capabilities,
      };
    } catch {
      return {
        valid: errors.length === 0,
        errors,
        warnings,
        capabilities: {
          languages,
          hasNetworkAccess: false,
          hasFileSystemAccess: true,
          maxExecutionTimeMs: DEFAULT_OPTIONS.timeoutMs,
          maxMemoryMb: DEFAULT_OPTIONS.memoryLimitMb,
        },
      };
    }
  }

  /**
   * 获取脚本能力
   */
  getCapabilities(scriptPath: string): ScriptCapabilities {
    const ext = path.extname(scriptPath);
    const languages = this.detectLanguage(ext);

    return {
      languages,
      hasNetworkAccess: false,
      hasFileSystemAccess: true,
      maxExecutionTimeMs: DEFAULT_OPTIONS.timeoutMs,
      maxMemoryMb: DEFAULT_OPTIONS.memoryLimitMb,
    };
  }

  /**
   * 在子进程中执行脚本
   */
  private spawnProcess(
    scriptPath: string,
    args: Record<string, unknown>,
    workspaceDir: string,
    env: NodeJS.ProcessEnv,
    options: Required<ScriptExecutionOptions>
  ): Promise<{
    success: boolean;
    stdout: string;
    stderr: string;
    exitCode?: number;
    error?: string;
    truncated: boolean;
  }> {
    const startTime = Date.now();

    return new Promise((resolve) => {
      // 序列化参数
      const serializedArgs = JSON.stringify(args);
      const argsSize = Buffer.byteLength(serializedArgs);

      if (argsSize > MAX_ARGS_SIZE) {
        resolve({
          success: false,
          stdout: "",
          stderr: "",
          error: `Arguments exceed maximum size limit (${MAX_ARGS_SIZE} bytes)`,
          truncated: false,
        });
        return;
      }

      // 确定执行命令
      const command = this.getExecuteCommand(scriptPath);
      const processArgs = this.prepareProcessArgs(args);

      // 设置 spawn 选项
      const spawnOptions = {
        env,
        cwd: workspaceDir,
        stdio: ["pipe", "pipe", "pipe"] as ("pipe" | "ipc" | "ignore" | "inherit")[],
        shell: false,
        detached: false,
      };

      // 启动进程
      const process = spawn(command, [scriptPath, ...processArgs], spawnOptions);

      // 生成进程 ID
      const processId = crypto.randomUUID();
      this.activeProcesses.set(processId, process);

      let stdout = "";
      let stderr = "";
      let outputSize = 0;
      let truncated = false;

      // 收集 stdout
      if (process.stdout) {
        process.stdout.on("data", (data: Buffer) => {
          const chunk = data.toString();
          outputSize += Buffer.byteLength(chunk);

          if (outputSize > options.maxOutputSize && !truncated) {
            truncated = true;
            stdout += "\n[TRUNCATED: Output exceeded size limit]";
            this.terminateProcess(process);
            this.activeProcesses.delete(processId);
          } else if (!truncated) {
            stdout += chunk;
          }
        });
      }

      // 收集 stderr
      if (process.stderr) {
        process.stderr.on("data", (data: Buffer) => {
          const chunk = data.toString();
          if (!truncated) {
            stderr += chunk;
          }
        });
      }

      // 收集 stderr
      process.stderr?.on("data", (data: Buffer) => {
        const chunk = data.toString();
        if (!truncated) {
          stderr += chunk;
        }
      });

      // 设置超时
      const timeout = setTimeout(() => {
        logger.warn(`Script execution timed out after ${options.timeoutMs}ms`);
        this.terminateProcess(process);
        this.activeProcesses.delete(processId);

        resolve({
          success: false,
          stdout,
          stderr: stderr || "Execution timed out",
          exitCode: -1,
          error: `Execution timed out after ${options.timeoutMs}ms`,
          truncated,
        });
      }, options.timeoutMs);

      // 处理进程退出
      process.on("close", (code: number | null, signal: string | null) => {
        clearTimeout(timeout);
        this.activeProcesses.delete(processId);

        const duration = Date.now() - startTime;

        if (code !== 0 && signal) {
          logger.warn(`Process exited with signal: ${signal}`);
        }

        resolve({
          success: code === 0 && !signal,
          stdout,
          stderr,
          exitCode: code ?? (signal ? -1 : 0),
          error: code !== 0 ? stderr.trim() || `Process exited with code ${code}` : undefined,
          truncated,
        });
      });

      // 处理进程错误
      process.on("error", (error: Error) => {
        clearTimeout(timeout);
        this.activeProcesses.delete(processId);

        logger.error("Process error:", error);

        resolve({
          success: false,
          stdout,
          stderr,
          error: error.message,
          truncated,
        });
      });
    });
  }

  /**
   * 准备环境变量
   */
  private prepareEnvironment(options: Required<ScriptExecutionOptions>): NodeJS.ProcessEnv {
    const env: NodeJS.ProcessEnv = {
      ...process.env,
      ...options.env,
      NODE_OPTIONS: `--max-old-space-size=${options.memoryLimitMb}`,
      NODE_NO_WARNINGS: "1",
    };

    // 网络策略
    if (options.network === "deny") {
      env.NODE_TLS_REJECT_UNAUTHORIZED = "1";
    }

    return env;
  }

  /**
   * 准备进程参数
   */
  private prepareProcessArgs(args: Record<string, unknown>): string[] {
    return [JSON.stringify(args)];
  }

  /**
   * 获取执行命令
   */
  private getExecuteCommand(scriptPath: string): string {
    const ext = path.extname(scriptPath);

    switch (ext) {
      case ".js":
      case ".mjs":
      case ".cjs":
        return "node";
      case ".ts":
        return "ts-node";
      case ".py":
        return "python3";
      case ".sh":
        return "bash";
      default:
        return "node";
    }
  }

  /**
   * 检测脚本语言
   */
  private detectLanguage(ext: string): string[] {
    const languageMap: Record<string, string[]> = {
      ".js": ["javascript"],
      ".mjs": ["javascript"],
      ".cjs": ["javascript"],
      ".ts": ["typescript"],
      ".py": ["python"],
      ".sh": ["bash", "shell"],
    };

    return languageMap[ext] || [];
  }

  /**
   * 解析脚本能力
   */
  private parseCapabilities(content: string): ScriptCapabilities {
    return {
      languages: [],
      hasNetworkAccess: content.includes("fetch") || content.includes("axios"),
      hasFileSystemAccess: true,
      maxExecutionTimeMs: DEFAULT_OPTIONS.timeoutMs,
      maxMemoryMb: DEFAULT_OPTIONS.memoryLimitMb,
    };
  }

  /**
   * 创建隔离工作区
   */
  private async createWorkspace(): Promise<string> {
    const workspaceId = `skill_${Date.now()}_${crypto.randomBytes(4).toString("hex")}`;
    const workspacePath = path.join(this.workspacePath, workspaceId);

    await fs.mkdir(workspacePath, { recursive: true });
    await fs.chmod(workspacePath, 0o700);

    return workspacePath;
  }

  /**
   * 清理工作区
   */
  private async cleanupWorkspace(workspacePath: string): Promise<void> {
    try {
      await fs.rm(workspacePath, { recursive: true, force: true });
    } catch (error) {
      logger.warn(`Failed to cleanup workspace: ${workspacePath}`, error);
    }
  }

  /**
   * 终止进程
   */
  private terminateProcess(process: ChildProcess, signal: string = "SIGTERM"): void {
    if (!process.killed && process.pid) {
      try {
        process.kill(signal as NodeJS.Signals);
      } catch (error) {
        logger.warn("Failed to terminate process:", error);
      }
    }
  }

  /**
   * 终止所有活跃进程
   */
  async terminateAllProcesses(): Promise<void> {
    for (const process of this.activeProcesses.values()) {
      this.terminateProcess(process, "SIGKILL");
    }
    this.activeProcesses.clear();
  }

  /**
   * 清理资源
   */
  async cleanup(): Promise<void> {
    await this.terminateAllProcesses();

    try {
      await fs.rm(this.workspacePath, { recursive: true, force: true });
    } catch (error) {
      logger.warn("Failed to cleanup workspace directory:", error);
    }
  }
}

/**
 * 默认执行器实例
 */
let defaultExecutor: ScriptExecutor | null = null;

export function getScriptExecutor(workspacePath?: string): ScriptExecutor {
  if (!defaultExecutor) {
    defaultExecutor = new ScriptExecutor(workspacePath);
  }
  return defaultExecutor;
}
````

## File: src/services/compat/types.ts
````typescript
/**
 * Compat Layer 类型定义
 */

import { SkillMetadata } from "../../types/tool-system";

/**
 * Claude Code Skill frontmatter 接口
 * 对应 Claude Code SKILL.md 文件的 YAML frontmatter
 */
export interface ClaudeCodeSkillFrontmatter {
  name: string;
  description: string;
  version?: string;
  author?: string;
  tags?: string[];
  requires?: string[];
  allowedTools?: string[];
  model?: string;
  context?: "fork" | "inline";
  agent?: string;
  hooks?: Record<string, unknown>;
  userInvocable?: boolean;
}

/**
 * 解析后的 Claude Skill 结果
 */
export interface ParsedClaudeSkill {
  metadata: SkillMetadata;
  compatibility: {
    allowedTools?: string[];
    model?: string;
    context?: "fork" | "inline";
    agent?: string;
    hooks?: Record<string, unknown>;
    userInvocable?: boolean;
    source: "claude-code";
  };
  content: string;
}

/**
 * 脚本执行选项
 */
export interface ScriptExecutionOptions {
  timeoutMs?: number;
  maxOutputSize?: number;
  memoryLimitMb?: number;
  env?: Record<string, string>;
  network?: "allow" | "deny";
}

/**
 * 脚本执行结果
 */
export interface ScriptExecutionResult {
  success: boolean;
  output: string;
  error?: string;
  exitCode?: number;
  durationMs: number;
  metadata?: Record<string, unknown>;
}

/**
 * 脚本能力描述
 */
export interface ScriptCapabilities {
  languages: string[];
  hasNetworkAccess: boolean;
  hasFileSystemAccess: boolean;
  maxExecutionTimeMs: number;
  maxMemoryMb: number;
}

/**
 * 脚本验证结果
 */
export interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
  capabilities: ScriptCapabilities;
}

/**
 * 生命周期钩子定义
 */
export interface SkillLifecycleHooks {
  preInstall?(ctx: SkillLifecycleContext): Promise<void>;
  postInstall?(ctx: SkillLifecycleContext): Promise<void>;
  preUpdate?(ctx: SkillLifecycleContext): Promise<void>;
  postUpdate?(ctx: SkillLifecycleContext): Promise<void>;
  preUninstall?(ctx: SkillLifecycleContext): Promise<void>;
  postUninstall?(ctx: SkillLifecycleContext): Promise<void>;
}

/**
 * 生命周期钩子上下文
 */
export interface SkillLifecycleContext {
  skillName: string;
  skillPath: string;
  metadata?: SkillMetadata;
  compatibility?: Record<string, unknown>;
  validationLevel?: "strict" | "basic" | "none";
  dependencies?: string[];
}

/**
 * Context 模式类型定义
 */
export type ContextMode = "fork" | "inline";

/**
 * Context 模式配置
 */
export interface ContextModeConfig {
  mode: ContextMode;
  workspacePath?: string;
  isolated?: boolean;
  maxMemory?: number;
  timeout?: number;
}

/**
 * 技能执行上下文
 */
export interface SkillExecutionContext {
  skillName: string;
  skillPath: string;
  mode: ContextMode;
  workspace: string;
  env: Record<string, string>;
  files: string[];
  metadata: SkillMetadata;
}

/**
 * 执行选项
 */
export interface ExecutionOptions {
  timeout?: number;
  memoryLimit?: number;
  env?: Record<string, string>;
  files?: string[];
  metadata?: Record<string, unknown>;
}

/**
 * 执行结果
 */
export interface ExecutionResult {
  success: boolean;
  output: string;
  error?: string;
  exitCode?: number;
  durationMs: number;
  mode: ContextMode;
  metadata?: Record<string, unknown>;
}

/**
 * 依赖检查结果
 */
export interface DependencyCheckResult {
  satisfied: boolean;
  missing: string[];
  installed: string[];
}

/**
 * 解析错误代码枚举
 */
export enum ParseErrorCode {
  FILE_NOT_FOUND = "FILE_NOT_FOUND",
  INVALID_YAML = "INVALID_YAML",
  MISSING_NAME = "MISSING_NAME",
  INVALID_NAME_FORMAT = "INVALID_NAME_FORMAT",
  NAME_TOO_LONG = "NAME_TOO_LONG",
  MISSING_DESCRIPTION = "MISSING_DESCRIPTION",
  INVALID_VERSION = "INVALID_VERSION",
  INVALID_CONTEXT = "INVALID_CONTEXT",
  INVALID_ALLOWED_TOOLS = "INVALID_ALLOWED_TOOLS",
  RESERVED_NAME = "RESERVED_NAME",
  FRONTMATTER_MISSING = "FRONTMATTER_MISSING",
  UNKNOWN_ERROR = "UNKNOWN_ERROR",
}

/**
 * 解析错误类型
 */
export class ParseError extends Error {
  constructor(
    message: string,
    public readonly code: ParseErrorCode,
    public readonly field?: string,
    public readonly suggestions?: string[]
  ) {
    super(message);
    this.name = "ParseError";
  }
}
````

## File: src/services/context-compression/strategies/HybridStrategy.ts
````typescript
/**
 * HybridStrategy - 混合压缩策略
 *
 * 组合 truncate + prune，先修剪再截断，保留更多上下文信息
 */

import { Message } from "../../../types";
import { TokenEstimator } from "../TokenEstimator";
import {
  IContextCompressionStrategy,
  CompressionResult,
  CompressionStrategyConfig,
} from "./IContextCompressionStrategy";
import { TruncateStrategy } from "./TruncateStrategy";
import { PruneStrategy } from "./PruneStrategy";

/**
 * 混合策略配置
 */
export interface HybridStrategyConfig extends CompressionStrategyConfig {
  /** 是否先修剪再截断（false 则先截断再修剪） */
  pruneFirst?: boolean;
  /** 修剪策略的配置 */
  pruneConfig?: {
    similarityThreshold?: number;
    shortMessageThreshold?: number;
    mergeConsecutiveUserMessages?: boolean;
  };
  /** 截断策略的配置 */
  truncateConfig?: {
    direction?: "head" | "tail";
  };
}

/**
 * 混合压缩策略
 *
 * 策略说明：
 * - 组合 truncate + prune 的优点
 * - 先修剪相似/短消息，再截断超出限制的内容
 * - 保留更多上下文信息
 * - 适用于需要平衡信息保留和 Token 限制的场景
 */
export class HybridStrategy implements IContextCompressionStrategy {
  /**
   * 默认配置
   */
  private readonly defaultConfig: Required<HybridStrategyConfig> = {
    maxTokens: 8000,
    preserveSystemMessage: true,
    minMessageCount: 1,
    pruneFirst: true,
    pruneConfig: {
      similarityThreshold: 0.7,
      shortMessageThreshold: 50,
      mergeConsecutiveUserMessages: true,
    },
    truncateConfig: {
      direction: "head",
    },
  };

  private readonly pruneStrategy: PruneStrategy;
  private readonly truncateStrategy: TruncateStrategy;

  constructor() {
    this.pruneStrategy = new PruneStrategy();
    this.truncateStrategy = new TruncateStrategy();
  }

  getName(): string {
    return "hybrid";
  }

  async compress(
    messages: Message[],
    config: CompressionStrategyConfig
  ): Promise<CompressionResult> {
    const finalConfig = { ...this.defaultConfig, ...config } as Required<HybridStrategyConfig>;

    const originalTokens = TokenEstimator.countMessages(messages);

    if (messages.length === 0) {
      return {
        messages: [],
        originalTokens: 0,
        compactedTokens: 0,
        removedCount: 0,
        hasSummary: false,
      };
    }

    if (originalTokens <= finalConfig.maxTokens) {
      return {
        messages: [...messages],
        originalTokens,
        compactedTokens: originalTokens,
        removedCount: 0,
        hasSummary: false,
      };
    }

    let result: CompressionResult;

    if (finalConfig.pruneFirst) {
      result = await this.pruneThenTruncate(messages, finalConfig);
    } else {
      result = await this.truncateThenPrune(messages, finalConfig);
    }

    return result;
  }

  /**
   * 先修剪再截断
   */
  private async pruneThenTruncate(
    messages: Message[],
    config: Required<HybridStrategyConfig>
  ): Promise<CompressionResult> {
    const originalTokens = TokenEstimator.countMessages(messages);

    const pruneConfig: CompressionStrategyConfig = {
      maxTokens: config.maxTokens,
      preserveSystemMessage: config.preserveSystemMessage,
      minMessageCount: config.minMessageCount,
    };

    let pruneResult = await this.pruneStrategy.compress(messages, pruneConfig);

    if (pruneResult.compactedTokens <= config.maxTokens) {
      return pruneResult;
    }

    const truncateConfig: CompressionStrategyConfig = {
      maxTokens: config.maxTokens,
      preserveSystemMessage: config.preserveSystemMessage,
      minMessageCount: config.minMessageCount,
    };

    const truncateResult = await this.truncateStrategy.compress(
      pruneResult.messages,
      truncateConfig
    );

    return {
      messages: truncateResult.messages,
      originalTokens,
      compactedTokens: truncateResult.compactedTokens,
      removedCount: pruneResult.removedCount + truncateResult.removedCount,
      hasSummary: false,
    };
  }

  /**
   * 先截断再修剪
   */
  private async truncateThenPrune(
    messages: Message[],
    config: Required<HybridStrategyConfig>
  ): Promise<CompressionResult> {
    const originalTokens = TokenEstimator.countMessages(messages);

    const truncateConfig: CompressionStrategyConfig = {
      maxTokens: config.maxTokens,
      preserveSystemMessage: config.preserveSystemMessage,
      minMessageCount: config.minMessageCount,
    };

    let truncateResult = await this.truncateStrategy.compress(messages, truncateConfig);

    const pruneConfig: CompressionStrategyConfig = {
      maxTokens: config.maxTokens,
      preserveSystemMessage: config.preserveSystemMessage,
      minMessageCount: config.minMessageCount,
    };

    const pruneResult = await this.pruneStrategy.compress(truncateResult.messages, pruneConfig);

    return {
      messages: pruneResult.messages,
      originalTokens,
      compactedTokens: pruneResult.compactedTokens,
      removedCount: truncateResult.removedCount + pruneResult.removedCount,
      hasSummary: false,
    };
  }

  needsCompression(messages: Message[], maxTokens: number): boolean {
    const currentTokens = TokenEstimator.countMessages(messages);
    return currentTokens > maxTokens;
  }
}
````

## File: src/services/context-compression/strategies/IContextCompressionStrategy.ts
````typescript
/**
 * 上下文压缩策略接口
 *
 * 定义上下文压缩的通用接口
 */

import { Message } from "../../../types";

/**
 * 压缩结果
 */
export interface CompressionResult {
  /** 压缩后的消息 */
  messages: Message[];
  /** 原始 Token 数 */
  originalTokens: number;
  /** 压缩后 Token 数 */
  compactedTokens: number;
  /** 被移除的消息数 */
  removedCount: number;
  /** 是否有摘要生成 */
  hasSummary: boolean;
}

/**
 * 压缩策略配置
 */
export interface CompressionStrategyConfig {
  /** 最大 Token 数 */
  maxTokens: number;
  /** 是否保留系统消息 */
  preserveSystemMessage?: boolean;
  /** 保留消息的最小数量 */
  minMessageCount?: number;
}

/**
 * 上下文压缩策略接口
 */
export interface IContextCompressionStrategy {
  /**
   * 获取策略名称
   */
  getName(): string;

  /**
   * 执行压缩
   *
   * @param messages 原始消息列表
   * @param config 压缩配置
   * @returns 压缩结果
   */
  compress(messages: Message[], config: CompressionStrategyConfig): Promise<CompressionResult>;

  /**
   * 检查是否需要压缩
   *
   * @param messages 消息列表
   * @param maxTokens 最大 Token 数
   * @returns 是否需要压缩
   */
  needsCompression(messages: Message[], maxTokens: number): boolean;
}
````

## File: src/services/context-compression/strategies/index.ts
````typescript
/**
 * 上下文压缩策略导出
 */

export * from "./IContextCompressionStrategy";
export * from "./TruncateStrategy";
export * from "./PruneStrategy";
export * from "./SummaryStrategy";
export * from "./HybridStrategy";
````

## File: src/services/context-compression/strategies/PruneStrategy.ts
````typescript
/**
 * PruneStrategy - 修剪压缩策略
 *
 * 移除相似/重复内容的短消息，合并连续的用户短消息，保留信息密度高的消息
 */

import { Message } from "../../../types";
import { TokenEstimator } from "../TokenEstimator";
import {
  IContextCompressionStrategy,
  CompressionResult,
  CompressionStrategyConfig,
} from "./IContextCompressionStrategy";

/**
 * 修剪策略配置
 */
export interface PruneStrategyConfig extends CompressionStrategyConfig {
  /** 相似度阈值（0-1），低于此值认为是相似消息 */
  similarityThreshold?: number;
  /** 短消息长度阈值（字符数），低于此值认为是短消息 */
  shortMessageThreshold?: number;
  /** 是否合并连续的用户短消息 */
  mergeConsecutiveUserMessages?: boolean;
}

/**
 * 消息相似度信息
 */
interface MessageSimilarityInfo {
  index: number;
  message: Message;
  tokens: number;
  isShort: boolean;
  contentLength: number;
  shouldRemove: boolean;
  removalReason?: string;
}

/**
 * 修剪压缩策略
 *
 * 策略说明：
 * - 移除与前一条消息高度相似的内容
 * - 合并连续的用户短消息
 * - 保留信息密度高的消息
 * - 适用于保留关键信息的场景
 */
export class PruneStrategy implements IContextCompressionStrategy {
  /**
   * 默认配置
   */
  private readonly defaultConfig: Required<PruneStrategyConfig> = {
    maxTokens: 8000,
    preserveSystemMessage: true,
    minMessageCount: 1,
    similarityThreshold: 0.7,
    shortMessageThreshold: 50,
    mergeConsecutiveUserMessages: true,
  };

  getName(): string {
    return "prune";
  }

  async compress(
    messages: Message[],
    config: CompressionStrategyConfig
  ): Promise<CompressionResult> {
    const finalConfig = { ...this.defaultConfig, ...config } as Required<PruneStrategyConfig>;

    const originalTokens = TokenEstimator.countMessages(messages);

    if (messages.length === 0) {
      return {
        messages: [],
        originalTokens: 0,
        compactedTokens: 0,
        removedCount: 0,
        hasSummary: false,
      };
    }

    if (originalTokens <= finalConfig.maxTokens) {
      return {
        messages: [...messages],
        originalTokens,
        compactedTokens: originalTokens,
        removedCount: 0,
        hasSummary: false,
      };
    }

    let systemMessages: Message[] = [];
    let otherMessages: Message[] = [];

    if (finalConfig.preserveSystemMessage) {
      const systemIndex = messages.findIndex((m) => m.role === "system");
      if (systemIndex >= 0) {
        systemMessages = [messages[systemIndex]];
        otherMessages = messages.filter((_, i) => i !== systemIndex);
      } else {
        otherMessages = [...messages];
      }
    } else {
      otherMessages = [...messages];
    }

    const prunedMessages = this.pruneMessages(otherMessages, finalConfig);
    let removedCount = otherMessages.length - prunedMessages.length;

    const totalMessages = systemMessages.length + prunedMessages.length;
    if (totalMessages < finalConfig.minMessageCount && otherMessages.length > totalMessages) {
      const additionalNeeded = finalConfig.minMessageCount - totalMessages;
      const availableMessages = otherMessages.filter((msg) => !prunedMessages.includes(msg));
      const toAdd = availableMessages.slice(-additionalNeeded);
      prunedMessages.unshift(...toAdd);
      removedCount = Math.max(0, removedCount - toAdd.length);
    }

    const finalMessages = finalConfig.preserveSystemMessage
      ? [...systemMessages, ...prunedMessages]
      : prunedMessages;

    const compactedTokens = TokenEstimator.countMessages(finalMessages);

    return {
      messages: finalMessages,
      originalTokens,
      compactedTokens,
      removedCount,
      hasSummary: false,
    };
  }

  /**
   * 修剪消息列表
   */
  private pruneMessages(messages: Message[], config: Required<PruneStrategyConfig>): Message[] {
    if (messages.length === 0) {
      return [];
    }

    const messagesWithInfo = this.analyzeMessages(messages, config);
    const result: Message[] = [];
    let consecutiveUserShortMessages: Message[] = [];

    for (let i = 0; i < messagesWithInfo.length; i++) {
      const current = messagesWithInfo[i];
      const previous = i > 0 ? messagesWithInfo[i - 1] : null;

      if (current.shouldRemove) {
        continue;
      }

      if (config.mergeConsecutiveUserMessages) {
        if (current.message.role === "user" && current.isShort) {
          consecutiveUserShortMessages.push(current.message);

          const nextMsg = i + 1 < messagesWithInfo.length ? messagesWithInfo[i + 1] : null;
          const isEndOfUserShortMessages =
            !nextMsg || nextMsg.message.role !== "user" || !nextMsg.isShort;

          if (isEndOfUserShortMessages && consecutiveUserShortMessages.length > 1) {
            const merged = this.mergeUserMessages(consecutiveUserShortMessages);
            if (merged) {
              result.push(merged);
            }
            consecutiveUserShortMessages = [];
          }
          continue;
        } else if (consecutiveUserShortMessages.length > 0) {
          const merged = this.mergeUserMessages(consecutiveUserShortMessages);
          if (merged) {
            result.push(merged);
          }
          consecutiveUserShortMessages = [];
        }
      }

      if (previous && !previous.shouldRemove && previous.message.role !== "system") {
        if (this.shouldRemoveSimilar(current, previous, config)) {
          continue;
        }
      }

      result.push(current.message);
    }

    if (consecutiveUserShortMessages.length > 0) {
      const merged = this.mergeUserMessages(consecutiveUserShortMessages);
      if (merged) {
        result.push(merged);
      }
    }

    return result;
  }

  /**
   * 分析消息信息
   */
  private analyzeMessages(
    messages: Message[],
    config: Required<PruneStrategyConfig>
  ): MessageSimilarityInfo[] {
    return messages.map((msg, index) => {
      const tokens = TokenEstimator.estimateMessage(msg).tokens;
      const contentLength = this.getMessageContentLength(msg);
      const isShort = contentLength < config.shortMessageThreshold;

      let shouldRemove = false;
      let removalReason: string | undefined;

      if (msg.role === "system") {
        shouldRemove = false;
      } else if (isShort && tokens < 10) {
        shouldRemove = true;
        removalReason = "very_short";
      }

      return {
        index,
        message: msg,
        tokens,
        isShort,
        contentLength,
        shouldRemove,
        removalReason,
      };
    });
  }

  /**
   * 获取消息内容长度
   */
  private getMessageContentLength(message: Message): number {
    if (typeof message.content === "string") {
      return message.content.length;
    }
    if (Array.isArray(message.content)) {
      return message.content.reduce((sum, part) => {
        if (part.type === "text" && part.text) {
          return sum + part.text.length;
        }
        return sum;
      }, 0);
    }
    return 0;
  }

  /**
   * 判断是否应该移除相似消息
   */
  private shouldRemoveSimilar(
    current: MessageSimilarityInfo,
    previous: MessageSimilarityInfo,
    config: Required<PruneStrategyConfig>
  ): boolean {
    if (current.message.role === previous.message.role) {
      return false;
    }

    if (current.isShort && previous.isShort) {
      const similarity = this.calculateSimilarity(current.contentLength, previous.contentLength);
      if (similarity > config.similarityThreshold) {
        return true;
      }
    }

    if (current.isShort && current.tokens < 20 && previous.tokens > current.tokens * 3) {
      return true;
    }

    return false;
  }

  /**
   * 计算内容相似度（基于长度的简化相似度计算）
   */
  private calculateSimilarity(len1: number, len2: number): number {
    if (len1 === 0 && len2 === 0) {
      return 1;
    }
    const maxLen = Math.max(len1, len2);
    const minLen = Math.min(len1, len2);
    return minLen / maxLen;
  }

  /**
   * 合并用户短消息
   */
  private mergeUserMessages(messages: Message[]): Message | null {
    if (messages.length === 0) {
      return null;
    }

    const combinedContent = messages
      .map((msg) => {
        const content = typeof msg.content === "string" ? msg.content : "";
        return content.trim();
      })
      .filter((c) => c.length > 0)
      .join("\n---\n");

    if (combinedContent.length === 0) {
      return null;
    }

    return {
      role: "user",
      content: combinedContent,
    };
  }

  needsCompression(messages: Message[], maxTokens: number): boolean {
    const currentTokens = TokenEstimator.countMessages(messages);
    return currentTokens > maxTokens;
  }
}
````

## File: src/services/context-compression/strategies/SummaryStrategy.ts
````typescript
/**
 * SummaryStrategy - 摘要压缩策略
 *
 * 用 AI 摘要替换旧消息，保留最近 N 条消息原文，旧消息用一句话摘要替代
 */

import { Message } from "../../../types";
import { TokenEstimator } from "../TokenEstimator";
import {
  IContextCompressionStrategy,
  CompressionResult,
  CompressionStrategyConfig,
} from "./IContextCompressionStrategy";

/**
 * 摘要策略配置
 */
export interface SummaryStrategyConfig extends CompressionStrategyConfig {
  /** 保留最近消息的数量（原文） */
  preserveRecent?: number;
  /** 摘要生成器函数 */
  summaryGenerator?: (messages: Message[]) => Promise<string>;
  /** 每个摘要的最大 Token 数 */
  maxSummaryTokens?: number;
}

/**
 * 摘要压缩策略
 *
 * 策略说明：
 * - 保留最近的 N 条消息原文
 * - 旧消息用一句话摘要替代
 * - 适用于需要保留对话历史概要的场景
 * - 需要提供 LLM 生成摘要
 */
export class SummaryStrategy implements IContextCompressionStrategy {
  /**
   * 默认配置
   */
  private readonly defaultConfig: Required<SummaryStrategyConfig> = {
    maxTokens: 8000,
    preserveSystemMessage: true,
    minMessageCount: 1,
    preserveRecent: 5,
    summaryGenerator: async (msgs: Message[]) => {
      return this.defaultSummary(msgs);
    },
    maxSummaryTokens: 200,
  };

  getName(): string {
    return "summary";
  }

  async compress(
    messages: Message[],
    config: CompressionStrategyConfig
  ): Promise<CompressionResult> {
    const finalConfig = { ...this.defaultConfig, ...config } as Required<SummaryStrategyConfig>;

    const originalTokens = TokenEstimator.countMessages(messages);

    if (messages.length === 0) {
      return {
        messages: [],
        originalTokens: 0,
        compactedTokens: 0,
        removedCount: 0,
        hasSummary: true,
      };
    }

    if (originalTokens <= finalConfig.maxTokens) {
      return {
        messages: [...messages],
        originalTokens,
        compactedTokens: originalTokens,
        removedCount: 0,
        hasSummary: false,
      };
    }

    let systemMessages: Message[] = [];
    let otherMessages: Message[] = [];

    if (finalConfig.preserveSystemMessage) {
      const systemIndex = messages.findIndex((m) => m.role === "system");
      if (systemIndex >= 0) {
        systemMessages = [messages[systemIndex]];
        otherMessages = messages.filter((_, idx) => idx !== systemIndex);
      } else {
        otherMessages = [...messages];
      }
    } else {
      otherMessages = [...messages];
    }

    const systemTokens = TokenEstimator.countMessages(systemMessages);
    const availableForRecent = finalConfig.maxTokens - systemTokens;

    if (availableForRecent <= 0) {
      const finalMessages = systemMessages.slice(0, 1);
      const compactedTokens = TokenEstimator.countMessages(finalMessages);
      return {
        messages: finalMessages,
        originalTokens,
        compactedTokens,
        removedCount: messages.length - finalMessages.length,
        hasSummary: true,
      };
    }

    const recentMessages = this.getRecentMessages(otherMessages, availableForRecent);
    const recentCount = recentMessages.length;
    const oldMessages = otherMessages.slice(0, otherMessages.length - recentCount);

    let summaryMessage: Message | null = null;
    let summaryTokens = 0;

    if (oldMessages.length > 0 && finalConfig.summaryGenerator) {
      const summaryText = await finalConfig.summaryGenerator(oldMessages);
      summaryMessage = {
        role: "system",
        content: `[对话历史摘要] ${summaryText}`,
        name: "context_summary",
      };
      summaryTokens = TokenEstimator.estimateMessage(summaryMessage).tokens;

      if (summaryTokens > finalConfig.maxSummaryTokens) {
        const truncatedSummary = this.truncateText(summaryText, finalConfig.maxSummaryTokens * 4);
        summaryMessage = {
          role: "system",
          content: `[对话历史摘要] ${truncatedSummary}`,
          name: "context_summary",
        };
        summaryTokens = TokenEstimator.estimateMessage(summaryMessage).tokens;
      }
    }

    const finalMessages: Message[] = [];
    if (finalConfig.preserveSystemMessage && systemMessages.length > 0) {
      finalMessages.push(systemMessages[0]);
    }
    if (summaryMessage) {
      finalMessages.push(summaryMessage);
    }
    finalMessages.push(...recentMessages);

    const totalMessages = finalMessages.length;
    if (totalMessages < finalConfig.minMessageCount && otherMessages.length > totalMessages) {
      const additionalNeeded = finalConfig.minMessageCount - totalMessages;
      const availableFromOld = oldMessages.slice(-additionalNeeded);
      finalMessages.splice(finalConfig.preserveSystemMessage ? 2 : 1, 0, ...availableFromOld);
    }

    const compactedTokens = TokenEstimator.countMessages(finalMessages);
    const removedCount = oldMessages.length;

    return {
      messages: finalMessages,
      originalTokens,
      compactedTokens,
      removedCount,
      hasSummary: true,
    };
  }

  /**
   * 获取在 Token 限制内的最近消息
   */
  private getRecentMessages(messages: Message[], maxTokens: number): Message[] {
    const result = TokenEstimator.keepRecentMessages(messages, maxTokens);
    return result.messages;
  }

  /**
   * 截断文本
   */
  private truncateText(text: string, maxCharacters: number): string {
    if (text.length <= maxCharacters) {
      return text;
    }
    return text.substring(0, maxCharacters - 3) + "...";
  }

  /**
   * 默认摘要生成（基于消息内容的简单摘要）
   */
  private async defaultSummary(messages: Message[]): Promise<string> {
    if (messages.length === 0) {
      return "无历史对话";
    }

    const userMessages = messages.filter((m) => m.role === "user");
    const assistantMessages = messages.filter((m) => m.role === "assistant");

    const userTopics = userMessages.map((m) => {
      const content = typeof m.content === "string" ? m.content : "";
      return content.substring(0, 50);
    });

    const summaryParts: string[] = [];

    if (userTopics.length > 0) {
      const topicCount = Math.min(3, userTopics.length);
      const topics = userTopics.slice(0, topicCount).join("; ");
      summaryParts.push(`讨论了 ${topicCount} 个主题: ${topics}`);
    }

    if (assistantMessages.length > 0) {
      summaryParts.push(`进行了 ${assistantMessages.length} 轮对话`);
    }

    return summaryParts.join("，") || "有若干对话记录";
  }

  needsCompression(messages: Message[], maxTokens: number): boolean {
    const currentTokens = TokenEstimator.countMessages(messages);
    return currentTokens > maxTokens;
  }
}
````

## File: src/services/context-compression/strategies/TruncateStrategy.ts
````typescript
/**
 * TruncateStrategy - 截断压缩策略
 *
 * 从消息列表的开头截断，保留最新的消息
 */

import { Message } from "../../../types";
import { TokenEstimator } from "../TokenEstimator";
import {
  IContextCompressionStrategy,
  CompressionResult,
  CompressionStrategyConfig,
} from "./IContextCompressionStrategy";

/**
 * 截断策略配置
 */
export interface TruncateStrategyConfig extends CompressionStrategyConfig {
  /** 截断方向：'head' 从开头截断，'tail' 从结尾截断 */
  direction?: "head" | "tail";
}

/**
 * 截断压缩策略
 *
 * 策略说明：
 * - 从头部截断消息，保留最新的消息
 * - 适用于大多数场景，简单可靠
 * - 保留对话的连续性
 */
export class TruncateStrategy implements IContextCompressionStrategy {
  /**
   * 默认配置
   */
  private readonly defaultConfig: Required<TruncateStrategyConfig> = {
    maxTokens: 8000,
    preserveSystemMessage: true,
    minMessageCount: 1,
    direction: "head",
  };

  getName(): string {
    return "truncate";
  }

  async compress(
    messages: Message[],
    config: CompressionStrategyConfig
  ): Promise<CompressionResult> {
    const finalConfig = { ...this.defaultConfig, ...config } as Required<TruncateStrategyConfig>;

    // 原始 Token 计数
    const originalTokens = TokenEstimator.countMessages(messages);

    if (messages.length === 0) {
      return {
        messages: [],
        originalTokens: 0,
        compactedTokens: 0,
        removedCount: 0,
        hasSummary: false,
      };
    }

    // 如果未超限，直接返回
    if (originalTokens <= finalConfig.maxTokens) {
      return {
        messages: [...messages],
        originalTokens,
        compactedTokens: originalTokens,
        removedCount: 0,
        hasSummary: false,
      };
    }

    // 分离系统消息
    let systemMessages: Message[] = [];
    let otherMessages: Message[] = [];

    if (finalConfig.preserveSystemMessage) {
      const systemIndex = messages.findIndex((m) => m.role === "system");
      if (systemIndex >= 0) {
        systemMessages = [messages[systemIndex]];
        otherMessages = messages.filter((_, i) => i !== systemIndex);
      } else {
        otherMessages = [...messages];
      }
    } else {
      otherMessages = [...messages];
    }

    // 截断其他消息
    let truncatedMessages: Message[];
    let removedCount = 0;

    if (finalConfig.direction === "tail") {
      // 从尾部截断（保留开头的消息）
      const result = TokenEstimator.keepRecentMessages(otherMessages, finalConfig.maxTokens);
      truncatedMessages = result.messages;
      removedCount = result.removedIds.length;
    } else {
      // 从头部截断（保留最新的消息）- 默认行为
      const keptResult = TokenEstimator.keepRecentMessages(otherMessages, finalConfig.maxTokens);
      truncatedMessages = keptResult.messages;
      removedCount = keptResult.removedIds.length;
    }

    // 确保至少保留最小消息数
    const totalMessages = systemMessages.length + truncatedMessages.length;
    if (totalMessages < finalConfig.minMessageCount && otherMessages.length > totalMessages) {
      // 需要保留更多消息
      const additionalNeeded = finalConfig.minMessageCount - totalMessages;
      const availableMessages = otherMessages.filter((msg) => !truncatedMessages.includes(msg));

      const toAdd = availableMessages.slice(-additionalNeeded);
      truncatedMessages = [...toAdd, ...truncatedMessages];
      removedCount = Math.max(0, removedCount - toAdd.length);
    }

    // 组合消息
    const finalMessages = finalConfig.preserveSystemMessage
      ? [...systemMessages, ...truncatedMessages]
      : truncatedMessages;

    // 计算压缩后的 Token 数
    const compactedTokens = TokenEstimator.countMessages(finalMessages);

    return {
      messages: finalMessages,
      originalTokens,
      compactedTokens,
      removedCount,
      hasSummary: false,
    };
  }

  needsCompression(messages: Message[], maxTokens: number): boolean {
    const currentTokens = TokenEstimator.countMessages(messages);
    return currentTokens > maxTokens;
  }
}
````

## File: src/services/context-compression/ContextCompressionService.ts
````typescript
/**
 * ContextCompressionService - 上下文压缩服务
 *
 * 提供统一的上下文压缩入口，支持多种压缩策略
 */

import { Message, ChatOptions } from "../../types";
import { TokenEstimator } from "./TokenEstimator";
import {
  IContextCompressionStrategy,
  CompressionResult,
  CompressionStrategyConfig,
} from "./strategies";
import { TruncateStrategy } from "./strategies/TruncateStrategy";
import { PruneStrategy } from "./strategies/PruneStrategy";
import { SummaryStrategy } from "./strategies/SummaryStrategy";
import { HybridStrategy } from "./strategies/HybridStrategy";
import { logger } from "../../utils/logger";
import { COMPRESSION, COMPACTION } from "../../constants/compression";

/**
 * 压缩策略类型
 */
export type CompressionStrategyType = "truncate" | "prune" | "summary" | "hybrid";

/**
 * OpenCode压缩决策配置
 *
 * 提供OpenCode风格的智能压缩决策机制：
 * - 缓存/输出考虑
 * - 受保护的修剪（保护工具输出）
 * - 严重溢出时的AI摘要生成
 * - 策略回退机制
 */
export interface OpenCodeCompactionConfig {
  /** 是否启用自动压缩（默认: true） */
  auto?: boolean;
  /** 是否启用受保护修剪（默认: true） */
  prune?: boolean;
  /** 溢出检测阈值（Tokens，默认: 4000） */
  overflowThreshold?: number;
  /** 是否保护关键工具输出（默认: true） */
  protectTools?: boolean;
  /** 严重溢出时是否生成摘要（默认: true） */
  summaryOnSevere?: boolean;
  /** 严重溢出阈值（上下文比例，默认: 0.8） */
  severeThreshold?: number;
}

/**
 * 上下文压缩配置
 */
export interface ContextCompressionConfig {
  /** 是否启用上下文压缩 */
  enabled?: boolean;
  /** 压缩策略 */
  strategy?: CompressionStrategyType;
  /** 模型上下文限制 */
  contextLimit?: number;
  /** 输出保留空间（Tokens） */
  outputReserve?: number;
  /** 是否保留系统消息 */
  preserveSystemMessage?: boolean;
  /** 最小保留消息数 */
  minMessageCount?: number;
  /** OpenCode压缩决策配置 */
  openCodeConfig?: OpenCodeCompactionConfig;
}

/**
 * 压缩统计信息
 */
export interface CompressionStats {
  /** 原始消息数 */
  originalMessageCount: number;
  /** 压缩后消息数 */
  compactedMessageCount: number;
  /** 原始 Token 数 */
  originalTokens: number;
  /** 压缩后 Token 数 */
  compactedTokens: number;
  /** 节省的 Token 数 */
  savedTokens: number;
  /** 节省比例 */
  savingsRatio: number;
  /** 使用的策略 */
  strategy: string;
  /** 是否执行了压缩 */
  wasCompressed: boolean;
  /** OpenCode决策信息 */
  openCodeDecision?: {
    /** 是否检测到溢出 */
    overflowDetected: boolean;
    /** 使用的压缩类型 */
    compactionType: "none" | "prune" | "summary" | "strategy" | "hybrid";
    /** 溢出严重程度 */
    severity: "none" | "warning" | "severe";
    /** 被保护的消息数 */
    protectedCount: number;
    /** 工具输出保护信息 */
    toolProtection?: {
      protectedTools: number;
      protectedOutputs: number;
    };
  };
}

/**
 * 上下文压缩服务
 *
 * 功能：
 * - 提供统一的压缩入口
 * - 管理压缩策略
 * - 记录压缩统计
 */
export class ContextCompressionService {
  /**
   * 策略实例缓存
   */
  private strategyCache: Map<string, IContextCompressionStrategy> = new Map();

  /**
   * OpenCode压缩决策默认配置
   */
  private readonly openCodeDefaultConfig: Required<OpenCodeCompactionConfig> = {
    auto: true,
    prune: true,
    overflowThreshold: COMPACTION.OVERFLOW_THRESHOLD,
    protectTools: true,
    summaryOnSevere: true,
    severeThreshold: COMPACTION.SEVERE_THRESHOLD,
  };

  /**
   * 默认配置
   * 注意：enabled 默认为 true，表示默认启用上下文压缩
   */
  private readonly defaultConfig: Required<ContextCompressionConfig> = {
    enabled: true,
    strategy: "truncate",
    contextLimit: COMPACTION.DEFAULT_CONTEXT_LIMIT,
    outputReserve: COMPACTION.DEFAULT_OUTPUT_RESERVE,
    preserveSystemMessage: true,
    minMessageCount: 1,
    openCodeConfig: this.openCodeDefaultConfig,
  };

  /**
   * 绝对最小 Token 限制
   * 即使压缩失败也不能超过此限制
   */
  private readonly ABSOLUTE_MIN_TOKENS = COMPACTION.ABSOLUTE_MIN_TOKENS;

  constructor() {
    logger.debug("[ContextCompressionService] Initialized");
  }

  /**
   * 压缩消息用于 LLM 调用（OpenCode决策机制版本）
   *
   * 新的压缩决策流程：
   * 1. OpenCode风格的溢出检测（考虑缓存/输出）
   * 2. 受保护的修剪（保护工具输出）
   * 3. 严重溢出时的AI摘要生成
   * 4. 策略回退（使用原有的4种策略）
   *
   * @param messages 原始消息列表
   * @param modelContextLimit 模型上下文限制
   * @param options ChatOptions（包含压缩配置）
   * @returns 压缩结果和统计信息
   */
  async compress(
    messages: Message[],
    modelContextLimit: number,
    options?: ChatOptions
  ): Promise<{ messages: Message[]; stats: CompressionStats }> {
    // 1. 解析配置
    const config = this.parseConfig(options, modelContextLimit);
    const openCodeConfig = config.openCodeConfig;

    // 2. 快速检查：是否需要压缩
    const currentTokens = TokenEstimator.countMessages(messages);
    const usableLimit = config.contextLimit - config.outputReserve;

    if (!config.enabled || currentTokens <= usableLimit) {
      return {
        messages: [...messages],
        stats: this.buildStats(messages, currentTokens, currentTokens, config.strategy, false, {
          overflowDetected: false,
          compactionType: "none",
          severity: "none",
          protectedCount: 0,
        }),
      };
    }

    // 3. OpenCode风格的溢出检测
    const overflowResult = this.isOverflowOpenCode(messages, modelContextLimit, openCodeConfig);

    // 初始化决策信息
    const openCodeDecision = {
      overflowDetected: overflowResult.isOverflow,
      compactionType: "none" as "none" | "prune" | "summary" | "strategy" | "hybrid",
      severity: overflowResult.severity,
      protectedCount: 0,
      toolProtection: {
        protectedTools: 0,
        protectedOutputs: 0,
      },
    };

    let resultMessages: Message[] = [...messages];
    let compactionType: "none" | "prune" | "summary" | "strategy" | "hybrid" = "none";

    try {
      // 4. 受保护的修剪（如果启用）
      if (openCodeConfig.auto && openCodeConfig.prune && overflowResult.isOverflow) {
        const pruneResult = await this.protectedPrune(messages, usableLimit, openCodeConfig);

        if (TokenEstimator.countMessages(pruneResult.messages) <= usableLimit) {
          resultMessages = pruneResult.messages;
          openCodeDecision.protectedCount = pruneResult.protectedCount;
          openCodeDecision.toolProtection = pruneResult.toolProtection;
          compactionType = "prune";

          logger.debug(
            `[ContextCompressionService] Protected prune: removed ${pruneResult.removedCount} messages, protected ${pruneResult.protectedCount} messages`
          );
        }
      }

      // 5. 严重溢出时的AI摘要生成
      if (
        compactionType === "none" &&
        openCodeConfig.auto &&
        openCodeConfig.summaryOnSevere &&
        overflowResult.severity === "severe"
      ) {
        const summaryResult = await this.openCodeSummary(messages, usableLimit, openCodeConfig);

        if (TokenEstimator.countMessages(summaryResult.messages) <= usableLimit) {
          resultMessages = summaryResult.messages;
          compactionType = "summary";

          logger.debug(
            `[ContextCompressionService] OpenCode summary: replaced ${summaryResult.replacedCount} messages with summary (${summaryResult.summaryTokenCount} tokens)`
          );
        }
      }

      // 6. 策略回退（如果OpenCode机制未能解决问题）
      if (compactionType === "none") {
        const strategy = this.getStrategy(config.strategy);
        const compressionConfig: CompressionStrategyConfig = {
          maxTokens: usableLimit,
          preserveSystemMessage: config.preserveSystemMessage,
          minMessageCount: config.minMessageCount,
        };

        const strategyResult = await strategy.compress(resultMessages, compressionConfig);
        resultMessages = strategyResult.messages;
        compactionType = "strategy";

        logger.debug(
          `[ContextCompressionService] Strategy fallback (${config.strategy}): removed ${strategyResult.removedCount} messages`
        );
      }

      openCodeDecision.compactionType = compactionType;
    } catch (error) {
      logger.error(`[ContextCompressionService] Error in OpenCode compression: ${error}`);

      // 回退到标准策略
      const strategy = this.getStrategy(config.strategy);
      const compressionConfig: CompressionStrategyConfig = {
        maxTokens: usableLimit,
        preserveSystemMessage: config.preserveSystemMessage,
        minMessageCount: config.minMessageCount,
      };

      const strategyResult = await strategy.compress(messages, compressionConfig);
      resultMessages = strategyResult.messages;
      compactionType = "strategy";
      openCodeDecision.compactionType = "strategy";
    }

    // 7. 边界兜底：确保不超过绝对最小限制
    const finalMessages = this.applyAbsoluteLimit(resultMessages, this.ABSOLUTE_MIN_TOKENS);

    // 8. 记录日志
    logger.debug(
      `[ContextCompressionService] OpenCode compression completed: ${currentTokens} -> ${TokenEstimator.countMessages(finalMessages)} tokens, ` +
        `compaction type: ${openCodeDecision.compactionType}, severity: ${openCodeDecision.severity}`
    );

    // 9. 构建统计信息
    const finalTokens = TokenEstimator.countMessages(finalMessages);
    const stats = this.buildStats(
      messages,
      currentTokens,
      finalTokens,
      config.strategy,
      true,
      openCodeDecision
    );

    return {
      messages: finalMessages,
      stats,
    };
  }

  /**
   * 检查消息是否需要压缩
   */
  needsCompression(messages: Message[], modelContextLimit: number, options?: ChatOptions): boolean {
    const config = this.parseConfig(options, modelContextLimit);

    if (!config.enabled) {
      return false;
    }

    const strategy = this.getStrategy(config.strategy);
    const usableLimit = config.contextLimit - config.outputReserve;

    return strategy.needsCompression(messages, usableLimit);
  }

  /**
   * 获取可用的压缩策略列表
   */
  getAvailableStrategies(): CompressionStrategyType[] {
    return ["truncate", "prune", "summary", "hybrid"];
  }

  /**
   * OpenCode风格的溢出检测
   *
   * 考虑缓存和输出空间进行溢出检测
   *
   * @param messages 消息列表
   * @param modelContextLimit 模型上下文限制
   * @param openCodeConfig OpenCode配置
   * @returns 溢出检测结果
   */
  isOverflowOpenCode(
    messages: Message[],
    modelContextLimit: number,
    openCodeConfig?: OpenCodeCompactionConfig
  ): {
    isOverflow: boolean;
    currentTokens: number;
    usableLimit: number;
    overflowAmount: number;
    severity: "none" | "warning" | "severe";
    cacheConsideration: number;
  } {
    const config = openCodeConfig ?? this.openCodeDefaultConfig;
    const currentTokens = TokenEstimator.countMessages(messages);
    const usableLimit = modelContextLimit - config.overflowThreshold;
    const overflowAmount = Math.max(0, currentTokens - usableLimit);

    // 计算严重程度
    let severity: "none" | "warning" | "severe" = "none";
    if (overflowAmount > 0) {
      const overflowRatio = overflowAmount / usableLimit;
      if (overflowRatio > config.severeThreshold) {
        severity = "severe";
      } else {
        severity = "warning";
      }
    }

    // 缓存考虑（预留空间用于缓存输出）
    const cacheConsideration = config.overflowThreshold;

    return {
      isOverflow: currentTokens > usableLimit,
      currentTokens,
      usableLimit,
      overflowAmount,
      severity,
      cacheConsideration,
    };
  }

  /**
   * 受保护的修剪
   *
   * 智能移除消息，同时保护工具输出等关键内容
   *
   * @param messages 消息列表
   * @param maxTokens 最大Token数
   * @param openCodeConfig OpenCode配置
   * @returns 修剪结果
   */
  async protectedPrune(
    messages: Message[],
    maxTokens: number,
    openCodeConfig?: OpenCodeCompactionConfig
  ): Promise<{
    messages: Message[];
    removedCount: number;
    protectedCount: number;
    toolProtection: {
      protectedTools: number;
      protectedOutputs: number;
    };
  }> {
    const config = openCodeConfig ?? this.openCodeDefaultConfig;

    if (!config.prune || !config.protectTools) {
      // 如果禁用保护修剪，使用标准的truncate策略
      const result = TokenEstimator.keepRecentMessages(messages, maxTokens);
      return {
        messages: result.messages,
        removedCount: messages.length - result.messages.length,
        protectedCount: 0,
        toolProtection: {
          protectedTools: 0,
          protectedOutputs: 0,
        },
      };
    }

    const currentTokens = TokenEstimator.countMessages(messages);

    if (currentTokens <= maxTokens) {
      return {
        messages: [...messages],
        removedCount: 0,
        protectedCount: 0,
        toolProtection: {
          protectedTools: 0,
          protectedOutputs: 0,
        },
      };
    }

    // 识别并保护工具输出消息
    const protectedMessages: Message[] = [];
    const removableMessages: Message[] = [];
    let protectedTools = 0;
    let protectedOutputs = 0;

    for (const msg of messages) {
      const isToolOutput = this.isToolOutputMessage(msg);
      const isToolCall = this.isToolCallMessage(msg);

      if (isToolOutput || isToolCall) {
        protectedMessages.push(msg);
        if (isToolCall) {
          protectedTools++;
        } else {
          protectedOutputs++;
        }
      } else {
        removableMessages.push(msg);
      }
    }

    // 从后向前遍历可移除消息，保护最新内容
    const keptMessages: Message[] = [...protectedMessages];
    let removedCount = 0;

    for (let i = removableMessages.length - 1; i >= 0; i--) {
      const msg = removableMessages[i];
      const msgTokens = TokenEstimator.estimateMessage(msg).tokens;
      const currentKeptTokens = TokenEstimator.countMessages(keptMessages);

      if (currentKeptTokens + msgTokens <= maxTokens) {
        keptMessages.unshift(msg);
      } else {
        removedCount++;
      }
    }

    // 如果仍然超出限制，截断可移除消息
    const finalMessages = TokenEstimator.keepRecentMessages(keptMessages, maxTokens);
    const finalRemovedCount = removedCount + (keptMessages.length - finalMessages.messages.length);

    return {
      messages: finalMessages.messages,
      removedCount: finalRemovedCount,
      protectedCount: protectedMessages.length,
      toolProtection: {
        protectedTools,
        protectedOutputs,
      },
    };
  }

  /**
   * 生成OpenCode风格的摘要
   *
   * 当发生严重溢出时，使用AI生成摘要替代旧消息
   *
   * @param messages 消息列表
   * @param maxTokens 最大Token数
   * @param openCodeConfig OpenCode配置
   * @returns 摘要结果
   */
  async openCodeSummary(
    messages: Message[],
    maxTokens: number,
    openCodeConfig?: OpenCodeCompactionConfig
  ): Promise<{
    messages: Message[];
    summaryTokenCount: number;
    originalCount: number;
    replacedCount: number;
  }> {
    const config = openCodeConfig ?? this.openCodeDefaultConfig;

    if (!config.summaryOnSevere) {
      // 如果禁用摘要，使用标准策略
      const result = TokenEstimator.keepRecentMessages(messages, maxTokens);
      return {
        messages: result.messages,
        summaryTokenCount: 0,
        originalCount: messages.length,
        replacedCount: 0,
      };
    }

    // 保留系统消息和最近的N条消息
    const systemMessage = messages.find((msg) => msg.role === "system");
    const recentMessages: Message[] = [];
    const oldMessages: Message[] = [];

    // 找到系统消息的位置
    let systemIndex = -1;
    for (let i = 0; i < messages.length; i++) {
      if (messages[i].role === "system" && systemIndex === -1) {
        systemIndex = i;
      }
    }

    // 分离新消息和旧消息
    const keepRecentCount = COMPRESSION.KEEP_RECENT_MESSAGES;
    let recentCount = 0;

    for (let i = messages.length - 1; i >= 0; i--) {
      if (recentCount < keepRecentCount) {
        recentMessages.unshift(messages[i]);
        recentCount++;
      } else {
        // 如果是系统消息之前的消息，加入旧消息列表
        if (systemIndex === -1 || i < systemIndex) {
          oldMessages.unshift(messages[i]);
        } else if (systemIndex !== -1 && i === systemIndex) {
          // 系统消息单独处理
        }
      }
    }

    // 生成摘要
    const summaryText = this.generateSummaryText(oldMessages);
    const summaryTokens = TokenEstimator.estimateText(summaryText).tokens;

    // 确保摘要不会超出限制
    const availableTokens =
      maxTokens -
      TokenEstimator.countMessages(recentMessages) -
      (systemMessage ? TokenEstimator.estimateMessage(systemMessage).tokens : 0);

    if (summaryTokens > availableTokens) {
      // 摘要太长，截断它
      const truncatedSummary = this.truncateText(
        summaryText,
        availableTokens * this.openCodeDefaultConfig.severeThreshold
      );
      return {
        messages: systemMessage ? [systemMessage, ...recentMessages] : recentMessages,
        summaryTokenCount: TokenEstimator.estimateText(truncatedSummary).tokens,
        originalCount: messages.length,
        replacedCount: oldMessages.length,
      };
    }

    // 创建摘要消息
    const summaryMessage: Message = {
      role: "assistant",
      content: `[对话历史摘要] ${summaryText}`,
    };

    return {
      messages: systemMessage
        ? [systemMessage, summaryMessage, ...recentMessages]
        : [summaryMessage, ...recentMessages],
      summaryTokenCount: summaryTokens,
      originalCount: messages.length,
      replacedCount: oldMessages.length,
    };
  }

  /**
   * 检测消息是否为工具调用消息
   */
  private isToolCallMessage(message: Message): boolean {
    if (typeof message.content === "string") {
      const content = message.content;
      // 检查常见的工具调用标记
      const toolCallPatterns = [
        /<tool_action\s+type=["']?skill["']?/i,
        /<tool_action\s+type=["']?mcp["']?/i,
        /function\s+call/i,
        /工具调用/i,
      ];

      return toolCallPatterns.some((pattern) => pattern.test(content));
    }
    return false;
  }

  /**
   * 检测消息是否为工具输出消息
   */
  private isToolOutputMessage(message: Message): boolean {
    if (typeof message.content === "string") {
      const content = message.content;
      // 检查常见的工具输出标记
      const toolOutputPatterns = [
        /<tool_action\s+result/i,
        /工具输出/i,
        /执行结果/i,
        /\[工具调用结束\]/i,
        /<observation>/i,
      ];

      return toolOutputPatterns.some((pattern) => pattern.test(content));
    }
    return false;
  }

  /**
   * 生成对话摘要文本
   */
  private generateSummaryText(messages: Message[]): string {
    if (messages.length === 0) {
      return "无早期对话记录";
    }

    // 统计对话信息
    const userMessages = messages.filter((m) => m.role === "user");
    const assistantMessages = messages.filter((m) => m.role === "assistant");
    const toolCalls = messages.filter((m) => this.isToolCallMessage(m));

    // 提取用户请求的主要话题
    const topics: string[] = [];
    for (const msg of userMessages.slice(0, 3)) {
      // 提取消息中的关键内容（取前50个字符）
      const content = typeof msg.content === "string" ? msg.content : JSON.stringify(msg.content);
      const truncated = content.substring(0, 50);
      if (truncated) {
        topics.push(truncated);
      }
    }

    return `对话共 ${messages.length} 条消息，其中用户消息 ${userMessages.length} 条，助手消息 ${assistantMessages.length} 条，工具调用 ${toolCalls.length} 次。主要讨论话题：${topics.join("; ")}...`;
  }

  /**
   * 截断文本以适应Token限制
   */
  private truncateText(text: string, maxTokens: number): string {
    const maxChars = maxTokens * 4; // 估算：4字符/token
    if (text.length <= maxChars) {
      return text;
    }
    return text.substring(0, maxChars - 3) + "...";
  }

  /**
   * 解析OpenCode配置
   *
   * @param config 原始配置
   * @returns 标准化后的配置
   */
  parseOpenCodeConfig(config?: OpenCodeCompactionConfig): Required<OpenCodeCompactionConfig> {
    return {
      auto: config?.auto ?? this.openCodeDefaultConfig.auto,
      prune: config?.prune ?? this.openCodeDefaultConfig.prune,
      overflowThreshold: config?.overflowThreshold ?? this.openCodeDefaultConfig.overflowThreshold,
      protectTools: config?.protectTools ?? this.openCodeDefaultConfig.protectTools,
      summaryOnSevere: config?.summaryOnSevere ?? this.openCodeDefaultConfig.summaryOnSevere,
      severeThreshold: config?.severeThreshold ?? this.openCodeDefaultConfig.severeThreshold,
    };
  }

  /**
   * 解析配置
   */
  private parseConfig(
    options: ChatOptions | undefined,
    modelContextLimit: number
  ): Required<ContextCompressionConfig> {
    // 从 ChatOptions 中提取压缩配置
    const compressionConfig = options?.contextCompression;

    return {
      enabled: compressionConfig?.enabled ?? this.defaultConfig.enabled,
      strategy:
        (compressionConfig?.strategy as CompressionStrategyType) ?? this.defaultConfig.strategy,
      contextLimit: modelContextLimit,
      outputReserve: compressionConfig?.outputReserve ?? this.defaultConfig.outputReserve,
      preserveSystemMessage:
        compressionConfig?.preserveSystemMessage ?? this.defaultConfig.preserveSystemMessage,
      minMessageCount: compressionConfig?.minMessageCount ?? this.defaultConfig.minMessageCount,
      openCodeConfig: this.parseOpenCodeConfig(compressionConfig?.openCodeConfig),
    };
  }

  /**
   * 获取策略实例（带缓存）
   */
  private getStrategy(type: CompressionStrategyType): IContextCompressionStrategy {
    let strategy = this.strategyCache.get(type);

    if (!strategy) {
      switch (type) {
        case "truncate":
          strategy = new TruncateStrategy();
          break;
        case "prune":
          strategy = new PruneStrategy();
          break;
        case "summary":
          strategy = new SummaryStrategy();
          break;
        case "hybrid":
          strategy = new HybridStrategy();
          break;
        default:
          logger.warn(`[ContextCompressionService] Unknown strategy '${type}', using 'truncate'`);
          strategy = new TruncateStrategy();
      }
      this.strategyCache.set(type, strategy);
    }

    return strategy;
  }

  /**
   * 应用绝对限制兜底
   */
  private applyAbsoluteLimit(messages: Message[], maxTokens: number): Message[] {
    if (maxTokens <= 0) {
      return [];
    }

    const result = TokenEstimator.keepRecentMessages(messages, maxTokens);
    return result.messages;
  }

  /**
   * 构建压缩统计信息
   */
  private buildStats(
    messages: Message[],
    originalTokens: number,
    compactedTokens: number,
    strategy: string,
    wasCompressed: boolean,
    openCodeDecision?: {
      overflowDetected: boolean;
      compactionType: "none" | "prune" | "summary" | "strategy" | "hybrid";
      severity: "none" | "warning" | "severe";
      protectedCount: number;
      toolProtection?: {
        protectedTools: number;
        protectedOutputs: number;
      };
    }
  ): CompressionStats {
    const savedTokens = originalTokens - compactedTokens;
    const savingsRatio = originalTokens > 0 ? savedTokens / originalTokens : 0;

    return {
      originalMessageCount: messages.length,
      compactedMessageCount: messages.length,
      originalTokens,
      compactedTokens,
      savedTokens,
      savingsRatio,
      strategy,
      wasCompressed,
      openCodeDecision,
    };
  }
}

/**
 * 压缩服务单例
 */
let serviceInstance: ContextCompressionService | null = null;

export function getContextCompressionService(): ContextCompressionService {
  if (!serviceInstance) {
    serviceInstance = new ContextCompressionService();
  }
  return serviceInstance;
}
````

## File: src/services/context-compression/index.ts
````typescript
/**
 * 上下文压缩模块导出
 */

export * from "./TokenEstimator";
export * from "./ContextCompressionService";
export * from "./strategies";
````

## File: src/services/context-compression/TokenEstimator.ts
````typescript
/**
 * TokenEstimator - Token 估算工具
 *
 * 提供消息和文本的 Token 数量估算功能
 *
 * 估算规则：
 * - 平均 4 个字符 ≈ 1 Token（适用于英文）
 * - 中文约 1-2 字符/Token
 * - 消息角色标记额外 +4 Tokens
 */

import { Message, ContentPart } from "../../types";

/**
 * Token 估算结果
 */
export interface TokenEstimationResult {
  /** 估算的 Token 数量 */
  tokens: number;
  /** 字符数量 */
  characters: number;
  /** 消息角色（如果是消息估算） */
  role?: string;
}

/**
 * 消息保留结果
 */
export interface KeepRecentResult {
  /** 保留的消息列表 */
  messages: Message[];
  /** 原始 Token 数 */
  originalTokens: number;
  /** 压缩后 Token 数 */
  compactedTokens: number;
  /** 被移除的消息 ID 列表 */
  removedIds: string[];
}

/**
 * Token 估算器
 */
export class TokenEstimator {
  /**
   * 默认字符/Toke 比率
   * 参考: OpenAI 估算方式，平均 4 字符/token
   */
  private static readonly CHARS_PER_TOKEN = 4;

  /**
   * 角色标记的开销（Tokens）
   * 格式: "<|im_start|>{role}<|im_end|>\n"
   */
  private static readonly ROLE_TOKEN_OVERHEAD = 4;

  /**
   * 估算文本的 Token 数量
   *
   * @param text 输入文本
   * @returns 估算结果
   */
  static estimateText(text: string): TokenEstimationResult {
    if (!text || typeof text !== "string") {
      return { tokens: 0, characters: 0 };
    }

    const characters = text.length;
    const tokens = this.calculateTokens(characters);

    return { tokens, characters };
  }

  /**
   * 估算 ContentPart 的 Token 数量
   *
   * @param part ContentPart
   * @returns 估算结果
   */
  static estimateContentPart(part: ContentPart): TokenEstimationResult {
    if (part.type === "text" && part.text) {
      return this.estimateText(part.text);
    }

    if (part.type === "image_url") {
      // 图片 URL 估算
      const url = typeof part.image_url === "string" ? part.image_url : part.image_url?.url || "";
      const characters = url.length;
      const tokens = Math.ceil(characters / this.CHARS_PER_TOKEN) + 10; // +10 考虑 JSON 开销

      return { tokens, characters };
    }

    return { tokens: 0, characters: 0 };
  }

  /**
   * 估算单条消息的 Token 数量
   *
   * @param message Message 对象
   * @returns 估算结果
   */
  static estimateMessage(message: Message): TokenEstimationResult {
    if (!message) {
      return { tokens: 0, characters: 0, role: undefined };
    }

    let totalTokens = this.ROLE_TOKEN_OVERHEAD; // 角色标记开销
    let totalCharacters = 0;

    if (typeof message.content === "string") {
      // 纯文本消息
      const result = this.estimateText(message.content);
      totalTokens += result.tokens;
      totalCharacters += result.characters;
    } else if (Array.isArray(message.content)) {
      // 多模态消息（包含文本和图片）
      for (const part of message.content) {
        const result = this.estimateContentPart(part);
        totalTokens += result.tokens;
        totalCharacters += result.characters;
      }
    }

    return {
      tokens: totalTokens,
      characters: totalCharacters,
      role: message.role,
    };
  }

  /**
   * 估算多条消息的 Token 数量
   *
   * @param messages Message 数组
   * @returns 总 Token 数
   */
  static countMessages(messages: Message[]): number {
    if (!messages || messages.length === 0) {
      return 0;
    }

    return messages.reduce((sum, msg) => {
      const result = this.estimateMessage(msg);
      return sum + result.tokens;
    }, 0);
  }

  /**
   * 保留最近的 N 条消息（在 Token 限制内）
   *
   * 从后向前遍历，保留最新的消息，直到 Token 达到限制
   *
   * @param messages 消息列表
   * @param maxTokens 最大 Token 数
   * @returns 保留结果
   */
  static keepRecentMessages(messages: Message[], maxTokens: number): KeepRecentResult {
    if (!messages || messages.length === 0) {
      return {
        messages: [],
        originalTokens: 0,
        compactedTokens: 0,
        removedIds: [],
      };
    }

    const originalTokens = this.countMessages(messages);
    const kept: Message[] = [];
    const removedIds: string[] = [];

    // 从后向前遍历，保留最新的消息
    for (let i = messages.length - 1; i >= 0; i--) {
      const msg = messages[i];
      const msgTokens = this.estimateMessage(msg).tokens;
      const currentTokens = this.countMessages(kept);

      if (currentTokens + msgTokens <= maxTokens) {
        // 可以保留，将消息插入到开头
        kept.unshift(msg);
      } else {
        // 不能保留，记录被移除的消息 ID
        const msgId = (msg as any).id || `msg_${i}`;
        removedIds.push(msgId);
      }
    }

    return {
      messages: kept,
      originalTokens,
      compactedTokens: this.countMessages(kept),
      removedIds,
    };
  }

  /**
   * 估算对话历史的 Token 使用情况
   *
   * @param messages 消息列表
   * @param systemPrompt 系统提示词
   * @returns 总 Token 数
   */
  static countConversation(messages: Message[], systemPrompt?: string): number {
    let total = this.countMessages(messages);

    if (systemPrompt) {
      total += this.estimateText(systemPrompt).tokens;
    }

    return total;
  }

  /**
   * 计算字符对应的 Token 数量
   *
   * @param characters 字符数
   * @returns Token 数
   */
  private static calculateTokens(characters: number): number {
    if (characters <= 0) {
      return 0;
    }
    // 使用 ceil 确保不会低估 Token 数量
    return Math.ceil(characters / this.CHARS_PER_TOKEN);
  }

  /**
   * 估算压缩后可以节省的 Token 数量
   *
   * @param originalMessages 原始消息
   * @param maxTokens 最大 Token 数
   * @returns 可节省的 Token 数量估算
   */
  static estimateSavings(originalMessages: Message[], maxTokens: number): number {
    const original = this.countMessages(originalMessages);

    if (original <= maxTokens) {
      return 0;
    }

    return original - maxTokens;
  }

  /**
   * 计算消息是否可以容纳在限制内
   *
   * @param message 单条消息
   * @param maxTokens 最大 Token 数
   * @returns 是否可以容纳
   */
  static canFitMessage(message: Message, maxTokens: number): boolean {
    const tokens = this.estimateMessage(message).tokens;
    return tokens <= maxTokens;
  }

  /**
   * 估算需要保留多少条消息才能在限制内
   *
   * @param messages 消息列表
   * @param maxTokens 最大 Token 数
   * @returns 需要保留的消息数量
   */
  static countNeededMessages(messages: Message[], maxTokens: number): number {
    const result = this.keepRecentMessages(messages, maxTokens);
    return result.messages.length;
  }
}
````

## File: src/services/embedding/BatchEmbeddingService.ts
````typescript
/**
 * BatchEmbeddingService - 批量嵌入生成服务
 *
 * 提供高性能的并行/批量嵌入生成，支持：
 * - 真正的批量 API 调用（不是顺序循环）
 * - 并发控制（避免超过 API 限制）
 * - 智能分批（基于 token 限制）
 * - 错误重试与恢复
 *
 * 预期性能提升：10-50x（相比顺序生成）
 */

import { logger } from "../../utils/logger";
import { EmbeddingConfig, EmbeddingVector } from "../tool-retrieval/types";

// LLMManager lazy import to avoid circular dependency
let llmManagerInstance: unknown = null;

/**
 * 批量嵌入配置
 */
export interface BatchEmbeddingConfig {
  /** 单批最大文本数 */
  batchSize: number;
  /** 最大并发数 */
  maxConcurrency: number;
  /** Token 限制（默认 7000，留 buffer） */
  tokenLimit: number;
  /** 重试次数 */
  maxRetries: number;
  /** 重试间隔（ms） */
  retryDelay: number;
  /** 是否启用智能分批 */
  smartBatching: boolean;
  /** 嵌入模型名称 */
  model?: string;
}

/**
 * 批量嵌入结果
 */
export interface BatchEmbeddingResult {
  embeddings: EmbeddingVector[];
  totalTime: number;
  batchesProcessed: number;
  successCount: number;
  errorCount: number;
}

/**
 * 默认配置
 */
const DEFAULT_CONFIG: BatchEmbeddingConfig = {
  batchSize: 100,
  maxConcurrency: 10,
  tokenLimit: 7000,
  maxRetries: 3,
  retryDelay: 1000,
  smartBatching: true,
};

/**
 * BatchEmbeddingService - 高性能批量嵌入生成
 */
export class BatchEmbeddingService {
  private config: BatchEmbeddingConfig;
  private llmConfigService: unknown = null;
  private dimensionsCache: number | null = null;

  constructor(config?: Partial<BatchEmbeddingConfig>) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    logger.info("[BatchEmbeddingService] Initialized with config:", {
      batchSize: this.config.batchSize,
      maxConcurrency: this.config.maxConcurrency,
      tokenLimit: this.config.tokenLimit,
      smartBatching: this.config.smartBatching,
    });
  }

  /**
   * 生成批量嵌入（并行+批量优化）
   */
  async generateBatch(texts: string[]): Promise<BatchEmbeddingResult> {
    const startTime = Date.now();

    if (texts.length === 0) {
      return {
        embeddings: [],
        totalTime: 0,
        batchesProcessed: 0,
        successCount: 0,
        errorCount: 0,
      };
    }

    logger.debug(`[BatchEmbeddingService] Starting batch generation for ${texts.length} texts`);

    // 智能分批（基于 token 限制）
    const batches = this.config.smartBatching
      ? this.splitIntoTokenBatches(texts, this.config.tokenLimit)
      : this.splitIntoFixedBatches(texts, this.config.batchSize);

    const allEmbeddings: EmbeddingVector[] = [];
    let successCount = 0;
    let errorCount = 0;

    // 并发处理各批次（控制并发数）
    for (let i = 0; i < batches.length; i += this.config.maxConcurrency) {
      const concurrentBatches = batches.slice(i, i + this.config.maxConcurrency);

      const batchResults = await Promise.all(
        concurrentBatches.map((batch, batchIndex) =>
          this.processBatchWithRetry(batch, i + batchIndex)
        )
      );

      // 汇总结果
      for (const result of batchResults) {
        allEmbeddings.push(...result.embeddings);
        successCount += result.successCount;
        errorCount += result.errorCount;
      }

      logger.debug(
        `[BatchEmbeddingService] Processed ${Math.min(i + concurrentBatches.length, batches.length)}/${batches.length} batches`
      );
    }

    const totalTime = Date.now() - startTime;

    logger.info(
      `[BatchEmbeddingService] Batch generation completed: ${successCount} succeeded, ${errorCount} failed, ${totalTime}ms total`
    );

    return {
      embeddings: allEmbeddings,
      totalTime,
      batchesProcessed: batches.length,
      successCount,
      errorCount,
    };
  }

  /**
   * 生成单个嵌入（使用批量 API）
   */
  async generateSingle(text: string): Promise<EmbeddingVector> {
    const result = await this.generateBatch([text]);

    if (result.errorCount > 0 || result.embeddings.length === 0) {
      throw new Error("Failed to generate single embedding");
    }

    return result.embeddings[0];
  }

  /**
   * 并发生成多个嵌入（高并发场景）
   */
  async generateConcurrent(texts: string[], maxConcurrency?: number): Promise<EmbeddingVector[]> {
    const concurrency = maxConcurrency || this.config.maxConcurrency;
    const results: EmbeddingVector[] = [];

    for (let i = 0; i < texts.length; i += concurrency) {
      const batch = texts.slice(i, i + concurrency);
      const batchResults = await Promise.all(
        batch.map((text) => this.generateSingleWithRetry(text))
      );

      for (const result of batchResults) {
        if (result) {
          results.push(result);
        }
      }

      logger.debug(
        `[BatchEmbeddingService] Concurrent progress: ${Math.min(i + concurrency, texts.length)}/${texts.length}`
      );
    }

    return results;
  }

  /**
   * 处理单个批次（使用 LLMManager.embed 批量 API）
   */
  private async processBatch(
    texts: string[]
  ): Promise<{ embeddings: EmbeddingVector[]; successCount: number; errorCount: number }> {
    try {
      // Lazy import LLMManager
      if (!llmManagerInstance) {
        const { LLMManager } = await import("../../core/LLMManager");
        llmManagerInstance = new LLMManager();
      }

      // 调用批量 API（LLMManager.embed 支持数组输入）
      const embeddings = await (
        llmManagerInstance as { embed(texts: string[]): Promise<number[][]> }
      ).embed(texts);

      if (!embeddings || embeddings.length === 0) {
        throw new Error("Empty embedding result from batch API");
      }

      // 转换为 EmbeddingVector 格式
      const vectors: EmbeddingVector[] = embeddings.map((vector, index) => ({
        values: vector,
        dimensions: vector.length,
        model: this.config.model || "unknown",
      }));

      return {
        embeddings: vectors,
        successCount: texts.length,
        errorCount: 0,
      };
    } catch (error) {
      logger.error(`[BatchEmbeddingService] Batch processing failed:`, error);
      return {
        embeddings: [],
        successCount: 0,
        errorCount: texts.length,
      };
    }
  }

  /**
   * 处理批次（带重试）
   */
  private async processBatchWithRetry(
    texts: string[],
    batchIndex: number
  ): Promise<{ embeddings: EmbeddingVector[]; successCount: number; errorCount: number }> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {
      try {
        const result = await this.processBatch(texts);

        if (result.errorCount === 0) {
          return result;
        }

        // 部分失败，记录并继续
        if (attempt < this.config.maxRetries) {
          logger.warn(
            `[BatchEmbeddingService] Batch ${batchIndex} partial failure, attempt ${attempt + 1}/${this.config.maxRetries + 1}`
          );
        }

        return result;
      } catch (error) {
        lastError = error as Error;

        if (attempt < this.config.maxRetries) {
          const delay = this.config.retryDelay * Math.pow(2, attempt);
          logger.warn(
            `[BatchEmbeddingService] Batch ${batchIndex} failed, retrying in ${delay}ms...`,
            lastError.message
          );
          await this.sleep(delay);
        }
      }
    }

    logger.error(
      `[BatchEmbeddingService] Batch ${batchIndex} failed after all retries:`,
      lastError
    );

    return {
      embeddings: [],
      successCount: 0,
      errorCount: texts.length,
    };
  }

  /**
   * 生成单个嵌入（带重试）
   */
  private async generateSingleWithRetry(text: string): Promise<EmbeddingVector | null> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {
      try {
        const result = await this.processBatch([text]);

        if (result.embeddings.length > 0) {
          return result.embeddings[0];
        }
      } catch (error) {
        lastError = error as Error;

        if (attempt < this.config.maxRetries) {
          const delay = this.config.retryDelay * Math.pow(2, attempt);
          await this.sleep(delay);
        }
      }
    }

    logger.error(`[BatchEmbeddingService] Single embedding failed after retries:`, lastError);
    return null;
  }

  /**
   * 智能分批（基于 token 限制）
   */
  private splitIntoTokenBatches(texts: string[], tokenLimit: number): string[][] {
    const batches: string[][] = [];
    let currentBatch: string[] = [];
    let currentTokens = 0;

    for (const text of texts) {
      const textTokens = this.estimateTokens(text);

      // 如果单个文本超过限制，强制添加并继续
      if (textTokens > tokenLimit && currentBatch.length > 0) {
        batches.push([...currentBatch]);
        currentBatch = [];
        currentTokens = 0;
      }

      // 如果当前批次加上此文本超过限制，开始新批次
      if (currentTokens + textTokens > tokenLimit && currentBatch.length > 0) {
        batches.push([...currentBatch]);
        currentBatch = [];
        currentTokens = 0;
      }

      currentBatch.push(text);
      currentTokens += textTokens;
    }

    // 添加最后一个批次
    if (currentBatch.length > 0) {
      batches.push(currentBatch);
    }

    logger.debug(
      `[BatchEmbeddingService] Smart batching: ${texts.length} texts → ${batches.length} batches`
    );

    return batches;
  }

  /**
   * 固定大小分批
   */
  private splitIntoFixedBatches(texts: string[], batchSize: number): string[][] {
    const batches: string[][] = [];

    for (let i = 0; i < texts.length; i += batchSize) {
      batches.push(texts.slice(i, i + batchSize));
    }

    return batches;
  }

  /**
   * 估算 token 数量（简单估算：4 字符 ≈ 1 token）
   */
  private estimateTokens(text: string): number {
    // 考虑中文字符（通常 1 字 ≈ 1 token）
    const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
    const otherChars = text.length - chineseChars;

    // 中文按字计，英文按 4 字符 ≈ 1 token
    return chineseChars + Math.ceil(otherChars / 4);
  }

  /**
   * 休眠辅助函数
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * 获取实际维度
   */
  async getActualDimensions(): Promise<number> {
    if (this.dimensionsCache !== null) {
      return this.dimensionsCache;
    }

    try {
      if (!this.llmConfigService) {
        const { LLMConfigService } = await import("../../services/LLMConfigService");
        this.llmConfigService = LLMConfigService.getInstance();
      }

      const embeddingModel = (
        this.llmConfigService as { getDefaultModel(type: string): unknown }
      ).getDefaultModel("embedding");

      if (embeddingModel && typeof embeddingModel === "object") {
        const modelConfig = (embeddingModel as { modelConfig?: { dimensions?: number } })
          .modelConfig;
        this.dimensionsCache = modelConfig?.dimensions || 1536;
        return this.dimensionsCache;
      }
    } catch (error) {
      logger.warn("[BatchEmbeddingService] Failed to get actual dimensions:", error);
    }

    return 1536; // 默认维度
  }

  /**
   * 获取服务统计
   */
  getStats(): {
    config: BatchEmbeddingConfig;
    dimensions: number | null;
  } {
    return {
      config: this.config,
      dimensions: this.dimensionsCache,
    };
  }
}

/**
 * 获取 LLMManager 实例（用于嵌入）
 */
export function getEmbeddingLLMManager(): unknown {
  return llmManagerInstance;
}

/**
 * 重置 LLMManager 实例（用于测试）
 */
export function resetEmbeddingLLMManager(): void {
  llmManagerInstance = null;
}
````

## File: src/services/tool-retrieval/BatchEmbeddingService.ts
````typescript
/**
 * BatchEmbeddingService - 批量嵌入生成服务
 *
 * 提供高性能的批量嵌入生成，支持：
 * - 智能分批处理
 * - 并发控制
 * - 错误重试（指数退避）
 * - 进度追踪
 * - 性能统计
 */

import { logger } from "../../utils/logger";
import { createHash } from "crypto";

/**
 * 批量嵌入配置
 */
export interface BatchEmbeddingConfig {
  /** 每批数量，默认 100 */
  batchSize?: number;
  /** 最大并发数，默认 5 */
  maxConcurrency?: number;
  /** 超时时间（毫秒），默认 60000 */
  timeoutMs?: number;
  /** 重试次数，默认 3 */
  retryAttempts?: number;
  /** 最小重试延迟（毫秒），默认 1000 */
  minRetryDelayMs?: number;
  /** 最大重试延迟（毫秒），默认 10000 */
  maxRetryDelayMs?: number;
  /** 启用进度回调 */
  enableProgressCallback?: boolean;
}

/**
 * 批量嵌入结果
 */
export interface BatchEmbeddingResult {
  /** 嵌入向量数组 */
  embeddings: number[][];
  /** 总处理数量 */
  totalProcessed: number;
  /** 失败数量 */
  failedCount: number;
  /** 总耗时（毫秒） */
  duration: number;
  /** 每批详情 */
  batches: BatchInfo[];
}

/**
 * 单批信息
 */
export interface BatchInfo {
  /** 批索引 */
  batchIndex: number;
  /** 批大小 */
  batchSize: number;
  /** 开始时间 */
  startTime: number;
  /** 结束时间 */
  endTime: number;
  /** 是否成功 */
  success: boolean;
  /** 错误信息（如果有） */
  error?: string;
}

/**
 * 进度回调函数类型
 */
export type ProgressCallback = (progress: EmbeddingProgress) => void;

/**
 * 错误回调函数类型
 */
export type ErrorCallback = (error: BatchEmbeddingError) => void;

/**
 * 批量嵌入错误信息
 */
export interface BatchEmbeddingError {
  /** 失败的批次索引 */
  batchIndex: number;
  /** 错误信息 */
  message: string;
  /** 失败数量 */
  failedCount: number;
  /** 是否可重试 */
  retryable: boolean;
  /** 时间戳 */
  timestamp: number;
}

/**
 * 嵌入进度信息
 */
export interface EmbeddingProgress {
  /** 已处理数量 */
  processed: number;
  /** 总数量 */
  total: number;
  /** 当前批次索引 */
  currentBatch: number;
  /** 总批次数 */
  totalBatches: number;
  /** 已失败数量 */
  failed: number;
  /** 耗时（毫秒） */
  elapsedMs: number;
  /** 预估剩余时间（毫秒） */
  estimatedRemainingMs: number;
}

/**
 * 批量嵌入服务
 */
export class BatchEmbeddingService {
  private config: Required<BatchEmbeddingConfig>;
  private progressCallback: ProgressCallback | null = null;
  private errorCallback: ErrorCallback | null = null;

  constructor(config: BatchEmbeddingConfig = {}) {
    this.config = {
      batchSize: config.batchSize ?? 100,
      maxConcurrency: config.maxConcurrency ?? 5,
      timeoutMs: config.timeoutMs ?? 60000,
      retryAttempts: config.retryAttempts ?? 3,
      minRetryDelayMs: config.minRetryDelayMs ?? 1000,
      maxRetryDelayMs: config.maxRetryDelayMs ?? 10000,
      enableProgressCallback: config.enableProgressCallback ?? false,
    };
  }

  /**
   * 设置进度回调
   */
  setProgressCallback(callback: ProgressCallback | null): void {
    this.progressCallback = callback;
  }

  /**
   * 设置错误回调
   */
  setErrorCallback(callback: ErrorCallback | null): void {
    this.errorCallback = callback;
  }

  /**
   * 生成批量嵌入向量
   *
   * @param texts 文本列表
   * @param embedFn 嵌入函数 (texts) => Promise<number[][]>
   * @returns 批量结果
   */
  async generateBatch(
    texts: string[],
    embedFn: (texts: string[]) => Promise<number[][]>
  ): Promise<BatchEmbeddingResult> {
    const startTime = Date.now();
    const totalTexts = texts.length;

    if (totalTexts === 0) {
      return {
        embeddings: [],
        totalProcessed: 0,
        failedCount: 0,
        duration: 0,
        batches: [],
      };
    }

    logger.info(`[BatchEmbeddingService] Starting batch embedding for ${totalTexts} texts`);

    // 分批
    const batches = this.createBatches(texts);
    const totalBatches = batches.length;
    const results: (number[] | null)[] = new Array(totalTexts).fill(null);
    const batchInfos: BatchInfo[] = [];
    let processedCount = 0;
    let failedCount = 0;

    // 使用信号量控制并发
    const semaphore = new Semaphore(this.config.maxConcurrency);

    // 处理所有批次
    const batchPromises = batches.map(async (batch, batchIndex) => {
      const batchStartIndex = batchIndex * this.config.batchSize;

      return semaphore.acquire(async () => {
        const batchStartTime = Date.now();
        let success = true;
        let errorMessage: string | undefined;

        try {
          // 执行嵌入（带重试）
          const embeddings = await this.executeWithRetry(
            () => embedFn(batch),
            `Batch ${batchIndex + 1}/${totalBatches}`
          );

          // 验证结果
          if (embeddings.length !== batch.length) {
            throw new Error(
              `Embedding count mismatch: expected ${batch.length}, got ${embeddings.length}`
            );
          }

          // 填充结果（使用预计算的起始索引）
          for (let i = 0; i < batch.length; i++) {
            const globalIndex = batchStartIndex + i;
            if (embeddings[i] && embeddings[i].length > 0) {
              results[globalIndex] = embeddings[i];
            } else {
              success = false;
              failedCount++;
              logger.warn(
                `[BatchEmbeddingService] Empty embedding at index ${globalIndex} in batch ${batchIndex + 1}`
              );
              // 报告部分失败
              this.reportError(batchIndex, `Empty embedding at index ${globalIndex}`, failedCount);
            }
          }
        } catch (err) {
          success = false;
          errorMessage = err instanceof Error ? err.message : "Unknown error";
          failedCount += batch.length;
          logger.error(`[BatchEmbeddingService] Batch ${batchIndex + 1} failed:`, errorMessage);

          // 报告错误到回调
          this.reportError(batchIndex, errorMessage, failedCount);
        }

        const batchEndTime = Date.now();
        const batchInfo: BatchInfo = {
          batchIndex,
          batchSize: batch.length,
          startTime: batchStartTime,
          endTime: batchEndTime,
          success,
          error: errorMessage,
        };
        batchInfos.push(batchInfo);

        processedCount += batch.length;

        // 报告进度
        this.reportProgress(
          processedCount,
          totalTexts,
          batchIndex,
          totalBatches,
          failedCount,
          startTime
        );
      });
    });

    await Promise.all(batchPromises);

    const duration = Date.now() - startTime;

    // 过滤掉空结果
    const validEmbeddings = results.filter((e): e is number[] => e !== null && e.length > 0);

    logger.info(
      `[BatchEmbeddingService] Completed: ${validEmbeddings.length}/${totalTexts} embeddings in ${duration}ms`
    );

    return {
      embeddings: validEmbeddings,
      totalProcessed: validEmbeddings.length,
      failedCount,
      duration,
      batches: batchInfos,
    };
  }

  /**
   * 创建文本批次
   */
  private createBatches(texts: string[]): string[][] {
    const batches: string[][] = [];
    const batchSize = this.config.batchSize;

    for (let i = 0; i < texts.length; i += batchSize) {
      batches.push(texts.slice(i, i + batchSize));
    }

    return batches;
  }

  /**
   * 带重试的执行
   */
  private async executeWithRetry<T>(fn: () => Promise<T>, operationName: string): Promise<T> {
    let lastError: Error | undefined;
    const { retryAttempts, minRetryDelayMs, maxRetryDelayMs } = this.config;

    for (let attempt = 1; attempt <= retryAttempts; attempt++) {
      try {
        return await this.withTimeout(fn(), operationName);
      } catch (err) {
        lastError = err instanceof Error ? err : new Error(String(err));

        if (attempt < retryAttempts) {
          // 指数退避
          const delay = this.calculateExponentialBackoff(attempt, minRetryDelayMs, maxRetryDelayMs);
          logger.warn(
            `[BatchEmbeddingService] ${operationName} failed (attempt ${attempt}/${retryAttempts}), retrying in ${delay}ms: ${lastError.message}`
          );
          await this.sleep(delay);
        } else {
          logger.error(
            `[BatchEmbeddingService] ${operationName} failed after ${retryAttempts} attempts:`,
            lastError.message
          );
        }
      }
    }

    throw lastError!;
  }

  /**
   * 计算指数退避延迟
   */
  private calculateExponentialBackoff(attempt: number, minDelay: number, maxDelay: number): number {
    const delay = Math.min(minDelay * Math.pow(2, attempt - 1), maxDelay);
    // 添加随机抖动（±25%）
    const jitter = delay * 0.25 * (Math.random() - 0.5) * 2;
    return Math.max(minDelay, Math.min(maxDelay, delay + jitter));
  }

  /**
   * 带超时的执行
   */
  private async withTimeout<T>(promise: Promise<T>, operationName: string): Promise<T> {
    return Promise.race([
      promise,
      new Promise<T>((_, reject) => {
        setTimeout(() => {
          reject(
            new Error(`Operation "${operationName}" timed out after ${this.config.timeoutMs}ms`)
          );
        }, this.config.timeoutMs);
      }),
    ]);
  }

  /**
   * 睡眠
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * 报告进度
   */
  private reportProgress(
    processed: number,
    total: number,
    currentBatch: number,
    totalBatches: number,
    failed: number,
    startTime: number
  ): void {
    if (!this.progressCallback && !this.config.enableProgressCallback) {
      return;
    }

    const elapsedMs = Date.now() - startTime;
    const progressPercent = total > 0 ? (processed / total) * 100 : 0;
    const estimatedRemainingMs =
      progressPercent > 0 ? (elapsedMs / processed) * (total - processed) : 0;

    const progress: EmbeddingProgress = {
      processed,
      total,
      currentBatch: currentBatch + 1,
      totalBatches,
      failed,
      elapsedMs,
      estimatedRemainingMs,
    };

    if (processed % 100 === 0 || processed === total) {
      logger.debug(
        `[BatchEmbeddingService] Progress: ${progressPercent.toFixed(1)}% (${processed}/${total}), ` +
          `failed: ${failed}, elapsed: ${(elapsedMs / 1000).toFixed(1)}s`
      );
    }

    if (this.progressCallback) {
      try {
        this.progressCallback(progress);
      } catch (err) {
        logger.warn("[BatchEmbeddingService] Progress callback error:", err);
      }
    }
  }

  /**
   * 报告错误
   */
  private reportError(batchIndex: number, message: string, failedCount: number): void {
    if (!this.errorCallback) {
      return;
    }

    const error: BatchEmbeddingError = {
      batchIndex,
      message,
      failedCount,
      retryable: failedCount < this.config.retryAttempts * this.config.batchSize,
      timestamp: Date.now(),
    };

    try {
      this.errorCallback(error);
    } catch (err) {
      logger.warn("[BatchEmbeddingService] Error callback error:", err);
    }
  }

  /**
   * 生成批次键（用于缓存）
   */
  static generateBatchKey(texts: string[]): string {
    const content = texts.join("|||");
    return createHash("md5").update(content).digest("hex");
  }

  /**
   * 估算处理时间
   */
  static estimateDuration(textCount: number, avgProcessingTimeMs: number = 100): number {
    // 考虑并发和批次开销
    const batchOverhead = Math.ceil(textCount / 100) * 50;
    const concurrencyFactor = Math.ceil(textCount / 1000);
    return (textCount * avgProcessingTimeMs) / concurrencyFactor + batchOverhead;
  }
}

/**
 * 信号量实现（用于并发控制）
 */
class Semaphore {
  private permits: number;
  private waitQueue: Array<() => void> = [];

  constructor(private readonly maxPermits: number) {
    this.permits = maxPermits;
  }

  async acquire<T>(fn: () => Promise<T>): Promise<T> {
    // 获取许可
    await this.acquirePermit();

    try {
      return await fn();
    } finally {
      this.releasePermit();
    }
  }

  private acquirePermit(): Promise<void> {
    if (this.permits > 0) {
      this.permits--;
      return Promise.resolve();
    }

    return new Promise((resolve) => {
      this.waitQueue.push(resolve);
    });
  }

  private releasePermit(): void {
    this.permits++;

    if (this.waitQueue.length > 0) {
      const next = this.waitQueue.shift();
      if (next) {
        this.permits--;
        next();
      }
    }
  }
}

export { Semaphore };
````

## File: src/services/tool-retrieval/DisclosureManager.ts
````typescript
/**
 * DisclosureManager - Result Disclosure Management
 *
 * Phase 1d: 披露管理器实现
 * Handles three-tier disclosure mechanism: METADATA, CONTENT, RESOURCES
 *
 * Phase 2: 三层披露机制增强
 * - DisclosureDecisionManager: 阈值决策层
 * - DisclosureCache: 专用缓存层（TTL+LRU）
 * - DisclosureMetrics: 性能指标采集
 */

import { logger } from "../../utils/logger";
import {
  DisclosureLevel,
  DisclosureStrategy,
  DisclosureContent,
  HybridRetrievalError,
  HybridRetrievalErrorCode,
} from "../../types/enhanced-skill";
import { UnifiedRetrievalResult } from "../../types/enhanced-skill";

// ==================== Phase 2: New Interfaces ====================

/**
 * 决策输入
 */
export interface DisclosureDecisionInput {
  result: UnifiedRetrievalResult;
  score: number;
  maxTokens: number;
}

/**
 * 决策输出
 */
export interface DisclosureDecisionOutput {
  level: DisclosureLevel;
  reason: "always" | "threshold" | "tokenBudget";
}

/**
 * 决策管理器接口
 */
export interface IDisclosureDecisionManager {
  decide(input: DisclosureDecisionInput): DisclosureDecisionOutput;
}

/**
 * 缓存键
 */
export interface DisclosureCacheKey {
  id: string;
  level: DisclosureLevel;
  version?: string;
  hash?: string;
}

/**
 * 缓存接口
 */
export interface IDisclosureCache {
  get(key: DisclosureCacheKey): DisclosureContent | null;
  set(key: DisclosureCacheKey, value: DisclosureContent, ttlMs?: number): void;
  invalidate(id: string): void;
  stats(): { size: number; hits: number; misses: number };
  dispose(): Promise<void>;
}

/**
 * 性能指标
 */
export interface DisclosureMetrics {
  l1Ms: number;
  l2Ms: number;
  l3Ms: number;
  cacheHit: boolean;
  disclosureLevel: DisclosureLevel;
}

/**
 * Phase 2 增强配置
 */
export interface DisclosureManagerConfigV2 extends DisclosureManagerConfig {
  enabled: boolean;
  thresholds: { l2: number; l3: number };
  l1MaxTokens: number;
  l2MaxTokens: number;
  cache: {
    enabled: boolean;
    l1TtlMs: number;
    l2TtlMs: number;
    maxSize: number;
    cleanupIntervalMs: number;
  };
  parallelLoad: { enabled: boolean; maxConcurrency: number };
  metrics: { enabled: boolean; sampleRate: number };
}

/**
 * 决策管理器实现
 * 基于阈值和 Token 预算自动选择披露级别
 */
export class DisclosureDecisionManager implements IDisclosureDecisionManager {
  private readonly config: DisclosureManagerConfigV2["thresholds"];

  constructor(config: DisclosureManagerConfigV2["thresholds"]) {
    this.config = config;
  }

  /**
   * 决策方法
   */
  decide(input: DisclosureDecisionInput): DisclosureDecisionOutput {
    const { score, maxTokens } = input;

    // L1: 始终 - Token 预算极低时
    if (maxTokens < 500) {
      return { level: DisclosureLevel.METADATA, reason: "always" };
    }

    // L3: 阈值触发 - score >= 0.85 (先检查最高阈值)
    if (score >= this.config.l3) {
      return { level: DisclosureLevel.RESOURCES, reason: "threshold" };
    }

    // L2: 阈值触发 - score >= 0.7
    if (score >= this.config.l2) {
      return { level: DisclosureLevel.CONTENT, reason: "threshold" };
    }

    // 回退: 自适应 Token 预算
    return { level: DisclosureLevel.CONTENT, reason: "tokenBudget" };
  }
}

// ==================== Phase 2: Cache Implementation ====================

/**
 * 披露缓存实现
 * 支持 TTL 过期和 LRU 淘汰
 */
export class DisclosureCache implements IDisclosureCache {
  private readonly cache: Map<string, { value: DisclosureContent; expiresAt: number }>;
  private readonly config: DisclosureManagerConfigV2["cache"];
  private hits: number = 0;
  private misses: number = 0;
  private cleanupTimer: NodeJS.Timeout | null = null;

  constructor(config: DisclosureManagerConfigV2["cache"]) {
    this.config = config;
    this.cache = new Map();

    // 定期清理过期项
    if (config.cleanupIntervalMs > 0) {
      this.cleanupTimer = setInterval(() => this.cleanup(), config.cleanupIntervalMs);
    }
  }

  /**
   * 获取缓存
   */
  get(key: DisclosureCacheKey): DisclosureContent | null {
    if (!this.config.enabled) {
      return null;
    }

    const cacheKey = this.generateKey(key);
    const item = this.cache.get(cacheKey);

    if (!item) {
      this.misses++;
      return null;
    }

    if (Date.now() > item.expiresAt) {
      this.cache.delete(cacheKey);
      this.misses++;
      return null;
    }

    // 更新访问时间戳以支持 LRU
    item.expiresAt = Date.now() + this.config.l1TtlMs;

    this.hits++;
    return item.value;
  }

  /**
   * 设置缓存
   */
  set(key: DisclosureCacheKey, value: DisclosureContent, ttlMs?: number): void {
    if (!this.config.enabled) {
      return;
    }

    const cacheKey = this.generateKey(key);
    const ttl = ttlMs || this.config.l1TtlMs;

    // LRU 淘汰
    if (this.cache.size >= this.config.maxSize) {
      this.evictOldest();
    }

    this.cache.set(cacheKey, {
      value,
      expiresAt: Date.now() + ttl,
    });
  }

  /**
   * 使缓存失效
   */
  invalidate(id: string): void {
    for (const key of this.cache.keys()) {
      if (key.startsWith(`${id}:`)) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * 获取缓存统计
   */
  stats(): { size: number; hits: number; misses: number } {
    return {
      size: this.cache.size,
      hits: this.hits,
      misses: this.misses,
    };
  }

  /**
   * 生成缓存键
   */
  private generateKey(key: DisclosureCacheKey): string {
    return `${key.id}:${key.level}:${key.hash || "default"}`;
  }

  /**
   * 淘汰最旧的缓存项
   */
  private evictOldest(): void {
    let oldestKey: string | null = null;
    let oldestTime = Infinity;

    for (const [key, item] of this.cache) {
      if (item.expiresAt < oldestTime) {
        oldestTime = item.expiresAt;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  /**
   * 清理过期缓存项
   */
  private cleanup(): void {
    const now = Date.now();
    for (const [key, item] of this.cache) {
      if (now > item.expiresAt) {
        this.cache.delete(key);
      }
    }
  }

  /**
   * Dispose of resources - stop cleanup timer and clear cache
   */
  async dispose(): Promise<void> {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
    }
    this.cache.clear();
  }
}

/**
 * Disclosure manager interface
 */
export interface IDisclosureManager {
  applyDisclosure(
    results: UnifiedRetrievalResult[],
    level: DisclosureLevel
  ): UnifiedRetrievalResult[];
  applyAdaptiveDisclosure(
    results: UnifiedRetrievalResult[],
    maxTokens: number
  ): UnifiedRetrievalResult[];
  getDisclosureContent(result: UnifiedRetrievalResult, level: DisclosureLevel): DisclosureContent;
}

/**
 * Disclosure manager configuration
 */
export interface DisclosureManagerConfig {
  /** Disclosure strategy */
  strategy: DisclosureStrategy;
  /** Max tokens for adaptive disclosure */
  adaptiveMaxTokens: number;
  /** Prefer metadata below token threshold */
  preferMetadataBelow: number;
}

/**
 * Default disclosure manager configuration
 */
export const DEFAULT_DISCLOSURE_CONFIG: DisclosureManagerConfig = {
  strategy: DisclosureStrategy.METADATA,
  adaptiveMaxTokens: 3000,
  preferMetadataBelow: 500,
};

/**
 * Default Phase 2 disclosure manager configuration
 */
export const DEFAULT_DISCLOSURE_CONFIG_V2: DisclosureManagerConfigV2 = {
  ...DEFAULT_DISCLOSURE_CONFIG,
  enabled: true,
  thresholds: { l2: 0.7, l3: 0.85 },
  l1MaxTokens: 120,
  l2MaxTokens: 5000,
  cache: {
    enabled: true,
    maxSize: 2000,
    l1TtlMs: 300000,
    l2TtlMs: 300000,
    cleanupIntervalMs: 300000,
  },
  parallelLoad: { enabled: true, maxConcurrency: 8 },
  metrics: { enabled: true, sampleRate: 1.0 },
};

/**
 * Get disclosure options for getDisclosure method
 */
export interface GetDisclosureOptions {
  score: number;
  maxTokens: number;
}

/**
 * Disclosure manager implementation
 * Manages three-tier disclosure mechanism
 */
export class DisclosureManager implements IDisclosureManager {
  private readonly _logger = logger;
  private readonly config: DisclosureManagerConfigV2;
  private readonly _decisionManager: IDisclosureDecisionManager;
  private readonly _cache: IDisclosureCache;

  constructor(config?: Partial<DisclosureManagerConfigV2>) {
    this.config = { ...DEFAULT_DISCLOSURE_CONFIG_V2, ...config };
    this._decisionManager = new DisclosureDecisionManager(this.config.thresholds);
    this._cache = new DisclosureCache(this.config.cache);

    this._logger.info("[DisclosureManager] Initialized with config:", {
      enabled: this.config.enabled,
      strategy: this.config.strategy,
      thresholds: this.config.thresholds,
      l1MaxTokens: this.config.l1MaxTokens,
      l2MaxTokens: this.config.l2MaxTokens,
      cacheEnabled: this.config.cache.enabled,
    });
  }

  /**
   * Get disclosure content for a tool by ID
   * This is the main entry point used by tests
   */
  async getDisclosure(id: string, options: GetDisclosureOptions): Promise<DisclosureContent> {
    const { score, maxTokens } = options;

    // Check cache first
    const cacheKey: DisclosureCacheKey = {
      id,
      level: DisclosureLevel.METADATA,
      hash: String(score),
    };

    const cached = this._cache.get(cacheKey);
    if (cached) {
      return cached;
    }

    // Use decision manager to determine appropriate level
    const decisionInput: DisclosureDecisionInput = {
      result: {
        id,
        name: id,
        description: "",
        unifiedScore: score,
        scores: { vector: score, keyword: score, semantic: score, tag: score },
        ranks: { vector: 1, keyword: 1, semantic: 1, tag: 1 },
        tags: [],
        toolType: "skill",
        disclosure: {
          level: DisclosureLevel.METADATA,
          name: id,
          description: "",
          tokenCount: 0,
        },
      },
      score,
      maxTokens,
    };

    const decision = this._decisionManager.decide(decisionInput);

    // Get disclosure content based on decision
    const result: UnifiedRetrievalResult = {
      id,
      name: id,
      description: "",
      unifiedScore: score,
      scores: { vector: score, keyword: score, semantic: score, tag: score },
      ranks: { vector: 1, keyword: 1, semantic: 1, tag: 1 },
      tags: [],
      toolType: "skill",
      disclosure: {
        level: DisclosureLevel.METADATA,
        name: id,
        description: "",
        tokenCount: 0,
      },
    };

    const content = this.getDisclosureContent(result, decision.level);

    // Cache the result
    const contentCacheKey: DisclosureCacheKey = {
      id,
      level: decision.level,
      hash: String(score),
    };
    this._cache.set(contentCacheKey, content);

    return content;
  }

  /**
   * Get the cache instance
   */
  getCache(): IDisclosureCache {
    return this._cache;
  }

  /**
   * Apply disclosure level to results
   */
  applyDisclosure(
    results: UnifiedRetrievalResult[],
    level: DisclosureLevel
  ): UnifiedRetrievalResult[] {
    try {
      this._logger.debug(`[DisclosureManager] Applying disclosure level: ${level}`, {
        resultCount: results.length,
      });

      return results.map((result) => ({
        ...result,
        disclosure: this.getDisclosureContent(result, level),
      }));
    } catch (error) {
      this._logger.error("[DisclosureManager] Failed to apply disclosure:", error);
      throw new HybridRetrievalError(
        `Disclosure application failed: ${this.formatError(error)}`,
        HybridRetrievalErrorCode.DISCLOSURE_ERROR
      );
    }
  }

  /**
   * Apply adaptive disclosure based on token limit
   */
  applyAdaptiveDisclosure(
    results: UnifiedRetrievalResult[],
    maxTokens: number
  ): UnifiedRetrievalResult[] {
    try {
      this._logger.debug(
        `[DisclosureManager] Applying adaptive disclosure with maxTokens: ${maxTokens}`,
        {
          resultCount: results.length,
        }
      );

      // Calculate total tokens and determine appropriate disclosure level
      let totalTokens = 0;
      const tokenEstimates: number[] = [];

      for (const result of results) {
        const metadataTokens =
          this.estimateTokens(result.name) + this.estimateTokens(result.description);
        tokenEstimates.push(metadataTokens);
        totalTokens += metadataTokens;

        if (totalTokens > maxTokens) {
          break;
        }
      }

      // Apply appropriate disclosure level based on token budget
      if (totalTokens <= this.config.preferMetadataBelow) {
        return this.applyDisclosure(results, DisclosureLevel.METADATA);
      } else if (totalTokens <= maxTokens * 0.7) {
        return this.applyDisclosure(results, DisclosureLevel.CONTENT);
      } else {
        return this.applyDisclosure(results, DisclosureLevel.RESOURCES);
      }
    } catch (error) {
      this._logger.error("[DisclosureManager] Failed to apply adaptive disclosure:", error);
      throw new HybridRetrievalError(
        `Adaptive disclosure failed: ${this.formatError(error)}`,
        HybridRetrievalErrorCode.DISCLOSURE_ERROR
      );
    }
  }

  /**
   * Get disclosure content for a result
   */
  getDisclosureContent(result: UnifiedRetrievalResult, level: DisclosureLevel): DisclosureContent {
    const baseContent: DisclosureContent = {
      level,
      name: result.name,
      description: result.description,
      tokenCount: this.estimateTokens(result.name) + this.estimateTokens(result.description),
    };

    switch (level) {
      case DisclosureLevel.METADATA:
        return baseContent;

      case DisclosureLevel.CONTENT:
        return {
          ...baseContent,
          inputSchema: this.extractInputSchema(result),
          outputSchema: this.extractOutputSchema(result),
          examples: this.extractExamples(result),
          tokenCount:
            baseContent.tokenCount +
            this.estimateTokens(JSON.stringify(baseContent.inputSchema || {})),
        };

      case DisclosureLevel.RESOURCES:
        return {
          ...baseContent,
          inputSchema: this.extractInputSchema(result),
          outputSchema: this.extractOutputSchema(result),
          resources: this.extractResources(result),
          examples: this.extractExamples(result),
          tokenCount:
            baseContent.tokenCount +
            this.estimateTokens(JSON.stringify(baseContent.inputSchema || {})) +
            this.estimateTokens(JSON.stringify(baseContent.outputSchema || {})) +
            this.estimateTokens((baseContent.resources || []).join(", ")),
        };

      default:
        return baseContent;
    }
  }

  /**
   * Extract input schema from result metadata
   */
  private extractInputSchema(result: UnifiedRetrievalResult): Record<string, unknown> | undefined {
    if (result.metadata && typeof result.metadata === "object") {
      const metadata = result.metadata as Record<string, unknown>;
      if (metadata.inputSchema) {
        return metadata.inputSchema as Record<string, unknown>;
      }
      if (metadata.parameters) {
        return metadata.parameters as Record<string, unknown>;
      }
      if (metadata.input) {
        return metadata.input as Record<string, unknown>;
      }
    }
    return undefined;
  }

  /**
   * Extract output schema from result metadata
   */
  private extractOutputSchema(result: UnifiedRetrievalResult): Record<string, unknown> | undefined {
    if (result.metadata && typeof result.metadata === "object") {
      const metadata = result.metadata as Record<string, unknown>;
      if (metadata.outputSchema) {
        return metadata.outputSchema as Record<string, unknown>;
      }
      if (metadata.output) {
        return metadata.output as Record<string, unknown>;
      }
    }
    return undefined;
  }

  /**
   * Extract examples from result metadata
   */
  private extractExamples(
    result: UnifiedRetrievalResult
  ): Array<{ input: string; output: string }> {
    if (result.metadata && typeof result.metadata === "object") {
      const metadata = result.metadata as Record<string, unknown>;
      if (Array.isArray(metadata.examples)) {
        const examples = metadata.examples as string[];
        return examples.map((ex, idx) => ({
          input: `Example ${idx + 1} input`,
          output: ex,
        }));
      }
      if (Array.isArray(metadata.example)) {
        const examples = metadata.example as string[];
        return examples.map((ex, idx) => ({
          input: `Example ${idx + 1} input`,
          output: ex,
        }));
      }
    }
    return [];
  }

  /**
   * Extract resources from result metadata
   */
  private extractResources(
    result: UnifiedRetrievalResult
  ): Array<{ type: string; path: string; description: string }> {
    if (result.metadata && typeof result.metadata === "object") {
      const metadata = result.metadata as Record<string, unknown>;
      if (Array.isArray(metadata.resources)) {
        const resources = metadata.resources as string[];
        return resources.map((res, idx) => ({
          type: "file",
          path: res,
          description: `Resource ${idx + 1}`,
        }));
      }
      if (Array.isArray(metadata.relatedFiles)) {
        const files = metadata.relatedFiles as string[];
        return files.map((file, idx) => ({
          type: "file",
          path: file,
          description: `Related file ${idx + 1}`,
        }));
      }
      if (Array.isArray(metadata.dependencies)) {
        const deps = metadata.dependencies as string[];
        return deps.map((dep, idx) => ({
          type: "dependency",
          path: dep,
          description: `Dependency ${idx + 1}`,
        }));
      }
    }
    return [];
  }

  /**
   * Estimate token count for text
   */
  private estimateTokens(text: string): number {
    // Rough estimate: ~4 characters per token for English
    if (!text) {
      return 0;
    }
    return Math.ceil(text.length / 4);
  }

  /**
   * Format error message
   */
  private formatError(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error occurred in DisclosureManager";
  }
}
````

## File: src/services/tool-retrieval/HybridRetrievalEngine.ts
````typescript
/**
 * HybridRetrievalEngine - Main Retrieval Engine
 *
 * Phase 1c: 混合检索引擎实现
 * Coordinates all retrieval methods and returns unified results
 */

import { logger } from "../../utils/logger";
import {
  HybridRetrievalConfig,
  UnifiedRetrievalResult,
  RetrievalResult,
  RetrievalMetrics,
  DisclosureStrategy,
  DisclosureLevel,
  DisclosureContent,
  HybridRetrievalError,
  HybridRetrievalErrorCode,
  DEFAULT_HYBRID_RETRIEVAL_CONFIG,
} from "../../types/enhanced-skill";
import { ToolRetrievalResult, ToolsTable } from "./types";
import { TagMatchingEngine, ITagMatchingEngine } from "./TagMatchingEngine";
import { UnifiedScoringEngine, IUnifiedScoringEngine } from "./UnifiedScoringEngine";
import {
  DisclosureManager,
  IDisclosureManager,
  DisclosureDecisionManager,
  IDisclosureDecisionManager,
  DisclosureCache,
  IDisclosureCache,
  DisclosureDecisionInput,
  DisclosureCacheKey,
  DisclosureManagerConfigV2,
  DisclosureMetrics,
} from "./DisclosureManager";
import { DisclosureConfigLoader } from "../../utils/config/disclosure-config";
import { ISearchEngine } from "./SearchEngine";
import { ILanceDBConnection } from "./LanceDBConnection";
import { IEmbeddingGenerator } from "./EmbeddingGenerator";

// ==================== Phase 2: New Interfaces ====================

/**
 * Disclosed result with disclosure content and metrics
 */
export interface DisclosedResult extends UnifiedRetrievalResult {
  /** Disclosure level applied */
  disclosureLevel: DisclosureLevel;
  /** Full disclosure content */
  disclosureContent: DisclosureContent;
  /** Performance metrics */
  metrics: DisclosureMetrics;
}

/**
 * Search result with disclosure decisions
 */
export interface DisclosureSearchResult {
  /** Disclosed results */
  results: DisclosedResult[];
  /** Total latency in milliseconds */
  totalLatencyMs: number;
  /** Cache statistics */
  cacheStats: { size: number; hits: number; misses: number };
}

/**
 * Search options for disclosure-aware search
 */
export interface SearchOptions {
  /** Maximum results */
  limit?: number;
  /** Minimum score threshold */
  minScore?: number;
  /** Maximum tokens for content */
  maxTokens?: number;
  /** Force disclosure level */
  forceLevel?: DisclosureLevel;
  /** Whether to use cache */
  useCache?: boolean;
}

/**
 * Hybrid retrieval query
 */
export interface HybridRetrievalQuery {
  /** Query text for vector/keyword/semantic search */
  query: string;
  /** Query tags for tag matching */
  tags?: string[];
  /** Maximum results */
  limit?: number;
  /** Minimum score threshold */
  minScore?: number;
  /** Disclosure level */
  disclosureLevel?: DisclosureLevel;
  /** Whether to use cache */
  useCache?: boolean;
}

/**
 * Hybrid retrieval engine interface
 */
export interface IHybridRetrievalEngine {
  search(query: HybridRetrievalQuery): Promise<UnifiedRetrievalResult[]>;
  searchWithCache(query: HybridRetrievalQuery): Promise<UnifiedRetrievalResult[]>;
  getMetrics(): RetrievalMetrics;
  clearCache(): void;
}

/**
 * Hybrid retrieval engine configuration
 */
export interface HybridRetrievalEngineConfig {
  /** Base hybrid retrieval configuration */
  hybridConfig: HybridRetrievalConfig;
  /** Search engine instance */
  searchEngine: ISearchEngine;
  /** Database connection */
  connection: ILanceDBConnection;
  /** Embedding generator */
  embeddingGenerator: IEmbeddingGenerator;
}

/**
 * HybridRetrievalEngine implementation
 * Coordinates vector, keyword, semantic, and tag-based retrieval
 */
export class HybridRetrievalEngine implements IHybridRetrievalEngine {
  private readonly _logger = logger;
  private readonly config: HybridRetrievalEngineConfig;
  private readonly tagMatchingEngine: ITagMatchingEngine;
  private readonly scoringEngine: IUnifiedScoringEngine;
  private readonly disclosureManager: IDisclosureManager;
  // Phase 2: New disclosure components
  private readonly decisionManager: IDisclosureDecisionManager;
  private readonly disclosureCache: IDisclosureCache;
  private readonly disclosureConfig: DisclosureManagerConfigV2;
  private readonly _cache: Map<string, { result: UnifiedRetrievalResult[]; expiresAt: number }> =
    new Map();
  private metrics: RetrievalMetrics;

  constructor(config: HybridRetrievalEngineConfig) {
    this.config = config;
    this.tagMatchingEngine = new TagMatchingEngine({
      hierarchy: config.hybridConfig.tagHierarchy,
      minScore: config.hybridConfig.minScore,
      maxDepth: 3,
      enableAliases: true,
    });
    this.scoringEngine = new UnifiedScoringEngine({
      rrfK: config.hybridConfig.rrfK,
      defaultWeights: {
        vector: config.hybridConfig.vectorWeight,
        keyword: config.hybridConfig.keywordWeight,
        semantic: config.hybridConfig.semanticWeight,
        tag: config.hybridConfig.tagWeight,
      },
      minScore: config.hybridConfig.minScore,
      maxResults: config.hybridConfig.maxResults,
    });
    this.disclosureManager = new DisclosureManager({
      strategy: config.hybridConfig.disclosureStrategy,
    });

    // Phase 2: Initialize disclosure config, decision manager, and cache
    this.disclosureConfig = DisclosureConfigLoader.getInstance().loadSync();
    this.decisionManager = new DisclosureDecisionManager(this.disclosureConfig.thresholds);
    this.disclosureCache = new DisclosureCache(this.disclosureConfig.cache);

    this.metrics = {
      totalTime: 0,
      vectorTime: 0,
      keywordTime: 0,
      semanticTime: 0,
      tagTime: 0,
      fusionTime: 0,
      resultCount: 0,
      cacheHit: false,
      cacheHits: 0,
      cacheMisses: 0,
    };

    this._logger.info("[HybridRetrievalEngine] Initialized", {
      vectorWeight: config.hybridConfig.vectorWeight,
      keywordWeight: config.hybridConfig.keywordWeight,
      semanticWeight: config.hybridConfig.semanticWeight,
      tagWeight: config.hybridConfig.tagWeight,
      rrfK: config.hybridConfig.rrfK,
    });
  }

  /**
   * Search for relevant tools using hybrid retrieval
   */
  async search(query: HybridRetrievalQuery): Promise<UnifiedRetrievalResult[]> {
    const startTime = Date.now();
    let cacheHit = false;

    try {
      // Check cache if enabled
      if (query.useCache !== false) {
        const cacheKey = this.getCacheKey(query);
        const cached = this.getFromCache(cacheKey);
        if (cached) {
          this._logger.debug(`[HybridRetrievalEngine] Cache hit for query: "${query.query}"`);
          cacheHit = true;
          return cached;
        }
      }

      this._logger.info(`[HybridRetrievalEngine] Searching for: "${query.query}"`, {
        limit: query.limit || this.config.hybridConfig.maxResults,
        tags: query.tags,
      });

      // Execute parallel searches
      const [vectorResults, keywordResults, semanticResults] = await Promise.all([
        this.vectorSearch(query.query, query.limit),
        this.keywordSearch(query.query, query.limit),
        this.semanticSearch(query.query, query.limit),
      ]);

      // Execute tag search if tags provided
      let tagResults: RetrievalResult[] = [];
      if (query.tags && query.tags.length > 0 && this.config.hybridConfig.enableTagMatching) {
        const tagStartTime = Date.now();
        tagResults = await this.tagSearch(query.query, query.tags, query.limit);
        this.metrics.tagTime = Date.now() - tagStartTime;
      }

      // Fuse results using RRF
      const fusionResult = this.scoringEngine.fuseResults(
        vectorResults,
        keywordResults,
        semanticResults,
        tagResults
      );

      // Apply disclosure
      const disclosureLevel = query.disclosureLevel || DisclosureLevel.METADATA;
      const resultsWithDisclosure = this.disclosureManager.applyDisclosure(
        fusionResult.results,
        disclosureLevel
      );

      // Cache results if caching enabled
      if (query.useCache !== false) {
        const cacheKey = this.getCacheKey(query);
        this.addToCache(cacheKey, resultsWithDisclosure);
      }

      // Update metrics
      this.metrics.totalTime = Date.now() - startTime;
      this.metrics.fusionTime = fusionResult.duration;
      this.metrics.resultCount = resultsWithDisclosure.length;
      this.metrics.cacheHit = cacheHit;

      this._logger.debug(
        `[HybridRetrievalEngine] Search completed in ${this.metrics.totalTime}ms`,
        {
          resultCount: resultsWithDisclosure.length,
          cacheHit,
        }
      );

      return resultsWithDisclosure;
    } catch (error) {
      this._logger.error(`[HybridRetrievalEngine] Search failed for "${query.query}":`, error);
      throw new HybridRetrievalError(
        `Hybrid search failed: ${this.formatError(error)}`,
        HybridRetrievalErrorCode.CONFIG_ERROR,
        { query: query.query }
      );
    }
  }

  /**
   * Search with caching enabled (always uses cache)
   */
  async searchWithCache(query: HybridRetrievalQuery): Promise<UnifiedRetrievalResult[]> {
    return this.search({ ...query, useCache: true });
  }

  /**
   * Search with disclosure decision making (Phase 2)
   * Uses threshold-based disclosure and caching for optimal performance
   */
  async searchWithDisclosure(
    query: HybridRetrievalQuery,
    options?: SearchOptions
  ): Promise<DisclosureSearchResult> {
    const startTime = Date.now();

    try {
      this._logger.info(`[HybridRetrievalEngine] Searching with disclosure: "${query.query}"`, {
        limit: options?.limit || this.config.hybridConfig.maxResults,
        forceLevel: options?.forceLevel,
      });

      // Execute hybrid search
      const results = await this.performHybridSearch(query, options);

      // Process each result with disclosure decision
      const disclosedResults: DisclosedResult[] = [];
      const maxTokens = options?.maxTokens || this.disclosureConfig.l2MaxTokens;

      for (const result of results) {
        const resultStartTime = Date.now();

        // Make disclosure decision
        const decision = options?.forceLevel
          ? { level: options.forceLevel, reason: "always" as const }
          : this.decisionManager.decide({
              result,
              score: result.unifiedScore,
              maxTokens,
            });

        // Build cache key
        const cacheKey: DisclosureCacheKey = {
          id: result.id,
          level: decision.level,
          version: result.version,
          hash: this.generateContentHash(result),
        };

        // Check cache
        let content = this.disclosureCache.get(cacheKey);
        let fromCache = true;

        // Cache miss - load content
        if (!content) {
          fromCache = false;
          content = await this.loadDisclosureContent(result, decision.level);
          this.disclosureCache.set(cacheKey, content);
        }

        // Calculate latency
        const latency = Date.now() - resultStartTime;

        // Build metrics based on disclosure level
        const metrics: DisclosureMetrics = {
          l1Ms: decision.level === DisclosureLevel.METADATA ? latency : 0,
          l2Ms: decision.level === DisclosureLevel.CONTENT ? latency : 0,
          l3Ms: decision.level === DisclosureLevel.RESOURCES ? latency : 0,
          cacheHit: fromCache,
          disclosureLevel: decision.level,
        };

        disclosedResults.push({
          ...result,
          disclosureLevel: decision.level,
          disclosureContent: content,
          metrics,
        });
      }

      const totalLatency = Date.now() - startTime;

      this._logger.debug(
        `[HybridRetrievalEngine] Disclosure search completed in ${totalLatency}ms`,
        {
          resultCount: disclosedResults.length,
          cacheStats: this.disclosureCache.stats(),
        }
      );

      return {
        results: disclosedResults,
        totalLatencyMs: totalLatency,
        cacheStats: this.disclosureCache.stats(),
      };
    } catch (error) {
      this._logger.error(`[HybridRetrievalEngine] Disclosure search failed:`, error);
      throw new HybridRetrievalError(
        `Disclosure search failed: ${this.formatError(error)}`,
        HybridRetrievalErrorCode.DISCLOSURE_ERROR,
        { query: query.query }
      );
    }
  }

  /**
   * Perform hybrid search and return unified results
   */
  private async performHybridSearch(
    query: HybridRetrievalQuery,
    options?: SearchOptions
  ): Promise<UnifiedRetrievalResult[]> {
    // Check cache if enabled
    if (options?.useCache !== false) {
      const cacheKey = this.getDisclosureCacheKey(query, options);
      const cached = this.getFromDisclosureCache(cacheKey);
      if (cached) {
        this._logger.debug(
          `[HybridRetrievalEngine] Disclosure cache hit for query: "${query.query}"`
        );
        return cached;
      }
    }

    // Execute parallel searches
    const [vectorResults, keywordResults, semanticResults] = await Promise.all([
      this.vectorSearch(query.query, options?.limit),
      this.keywordSearch(query.query, options?.limit),
      this.semanticSearch(query.query, options?.limit),
    ]);

    // Execute tag search if tags provided
    let tagResults: RetrievalResult[] = [];
    if (query.tags && query.tags.length > 0 && this.config.hybridConfig.enableTagMatching) {
      tagResults = await this.tagSearch(query.query, query.tags, options?.limit);
    }

    // Fuse results using RRF
    const fusionResult = this.scoringEngine.fuseResults(
      vectorResults,
      keywordResults,
      semanticResults,
      tagResults
    );

    // Apply minimum score filter
    const minScore = options?.minScore || this.config.hybridConfig.minScore;
    const filteredResults = fusionResult.results.filter((r) => r.unifiedScore >= minScore);

    // Cache results if caching enabled
    if (options?.useCache !== false) {
      const cacheKey = this.getDisclosureCacheKey(query, options);
      this.addToDisclosureCache(cacheKey, filteredResults);
    }

    return filteredResults;
  }

  /**
   * Load disclosure content based on level
   */
  private async loadDisclosureContent(
    result: UnifiedRetrievalResult,
    level: DisclosureLevel
  ): Promise<DisclosureContent> {
    const baseContent: DisclosureContent = {
      level,
      name: result.name,
      description: result.description,
      tokenCount: this.estimateTokens(result.name) + this.estimateTokens(result.description),
    };

    switch (level) {
      case DisclosureLevel.METADATA:
        return baseContent;

      case DisclosureLevel.CONTENT:
        return {
          ...baseContent,
          inputSchema: this.extractInputSchema(result),
          outputSchema: this.extractOutputSchema(result),
          examples: this.extractExamples(result),
          tokenCount:
            baseContent.tokenCount +
            this.estimateTokens(JSON.stringify(baseContent.inputSchema || {})),
        };

      case DisclosureLevel.RESOURCES:
        return {
          ...baseContent,
          inputSchema: this.extractInputSchema(result),
          outputSchema: this.extractOutputSchema(result),
          resources: this.extractResources(result),
          examples: this.extractExamples(result),
          tokenCount:
            baseContent.tokenCount +
            this.estimateTokens(JSON.stringify(baseContent.inputSchema || {})) +
            this.estimateTokens(JSON.stringify(baseContent.outputSchema || {})) +
            this.estimateTokens((baseContent.resources || []).join(", ")),
        };

      default:
        return baseContent;
    }
  }

  /**
   * Generate content hash for cache key
   */
  private generateContentHash(result: UnifiedRetrievalResult): string {
    const content = `${result.id}:${result.name}:${result.description}:${result.version || ""}`;
    return require("crypto").createHash("md5").update(content).digest("hex");
  }

  /**
   * Generate cache key for disclosure search
   */
  private getDisclosureCacheKey(query: HybridRetrievalQuery, options?: SearchOptions): string {
    const parts = [
      query.query,
      query.tags?.join(",") || "",
      String(options?.limit || this.config.hybridConfig.maxResults),
      String(options?.minScore || this.config.hybridConfig.minScore),
      String(options?.forceLevel || "auto"),
    ];
    return require("crypto").createHash("md5").update(parts.join("|")).digest("hex");
  }

  /**
   * Get results from disclosure cache
   */
  private getFromDisclosureCache(cacheKey: string): UnifiedRetrievalResult[] | null {
    const entry = this._cache.get(cacheKey);
    if (entry && entry.expiresAt > Date.now()) {
      return entry.result;
    }
    return null;
  }

  /**
   * Add results to disclosure cache
   */
  private addToDisclosureCache(cacheKey: string, results: UnifiedRetrievalResult[]): void {
    if (this._cache.size >= 1000) {
      const oldestKey = this._cache.keys().next().value;
      this._cache.delete(oldestKey);
    }

    const expiresAt = Date.now() + this.config.hybridConfig.cacheTTL * 1000;
    this._cache.set(cacheKey, { result: results, expiresAt });
  }

  /**
   * Extract input schema from result metadata
   */
  private extractInputSchema(result: UnifiedRetrievalResult): Record<string, unknown> | undefined {
    if (result.metadata && typeof result.metadata === "object") {
      const metadata = result.metadata as Record<string, unknown>;
      if (metadata.inputSchema) {
        return metadata.inputSchema as Record<string, unknown>;
      }
      if (metadata.parameters) {
        return metadata.parameters as Record<string, unknown>;
      }
      if (metadata.input) {
        return metadata.input as Record<string, unknown>;
      }
    }
    return undefined;
  }

  /**
   * Extract output schema from result metadata
   */
  private extractOutputSchema(result: UnifiedRetrievalResult): Record<string, unknown> | undefined {
    if (result.metadata && typeof result.metadata === "object") {
      const metadata = result.metadata as Record<string, unknown>;
      if (metadata.outputSchema) {
        return metadata.outputSchema as Record<string, unknown>;
      }
      if (metadata.output) {
        return metadata.output as Record<string, unknown>;
      }
    }
    return undefined;
  }

  /**
   * Extract examples from result metadata
   */
  private extractExamples(
    result: UnifiedRetrievalResult
  ): Array<{ input: string; output: string }> {
    if (result.metadata && typeof result.metadata === "object") {
      const metadata = result.metadata as Record<string, unknown>;
      if (Array.isArray(metadata.examples)) {
        const examples = metadata.examples as string[];
        return examples.map((ex, idx) => ({
          input: `Example ${idx + 1} input`,
          output: ex,
        }));
      }
      if (Array.isArray(metadata.example)) {
        const examples = metadata.example as string[];
        return examples.map((ex, idx) => ({
          input: `Example ${idx + 1} input`,
          output: ex,
        }));
      }
    }
    return [];
  }

  /**
   * Extract resources from result metadata
   */
  private extractResources(
    result: UnifiedRetrievalResult
  ): Array<{ type: string; path: string; description: string }> {
    if (result.metadata && typeof result.metadata === "object") {
      const metadata = result.metadata as Record<string, unknown>;
      if (Array.isArray(metadata.resources)) {
        const resources = metadata.resources as string[];
        return resources.map((res, idx) => ({
          type: "file",
          path: res,
          description: `Resource ${idx + 1}`,
        }));
      }
      if (Array.isArray(metadata.relatedFiles)) {
        const files = metadata.relatedFiles as string[];
        return files.map((file, idx) => ({
          type: "file",
          path: file,
          description: `Related file ${idx + 1}`,
        }));
      }
      if (Array.isArray(metadata.dependencies)) {
        const deps = metadata.dependencies as string[];
        return deps.map((dep, idx) => ({
          type: "dependency",
          path: dep,
          description: `Dependency ${idx + 1}`,
        }));
      }
    }
    return result.path ? [{ type: "file", path: result.path, description: "Main resource" }] : [];
  }

  /**
   * Estimate token count for text
   */
  private estimateTokens(text: string): number {
    if (!text) {
      return 0;
    }
    return Math.ceil(text.length / 4);
  }

  /**
   * Get retrieval metrics
   */
  getMetrics(): RetrievalMetrics {
    return { ...this.metrics };
  }

  /**
   * Clear the cache
   */
  clearCache(): void {
    this._cache.clear();
    this._logger.info("[HybridRetrievalEngine] Cache cleared");
  }

  /**
   * Perform vector search
   */
  private async vectorSearch(query: string, limit?: number): Promise<RetrievalResult[]> {
    const startTime = Date.now();

    try {
      const results = await this.config.searchEngine.search(query, {
        limit: limit || this.config.hybridConfig.maxResults,
        minScore: this.config.hybridConfig.minScore,
      });

      this.metrics.vectorTime = Date.now() - startTime;

      return results.map((r) => ({
        id: r.id,
        score: r.score,
        method: "vector" as const,
        metadata: {
          name: r.name,
          description: r.description,
          tags: r.tags,
          toolType: r.toolType,
          path: (r as any).path,
          version: (r as any).version,
        },
      }));
    } catch (error) {
      this._logger.error("[HybridRetrievalEngine] Vector search failed:", error);
      this.metrics.vectorTime = Date.now() - startTime;
      return [];
    }
  }

  /**
   * Perform keyword search
   */
  private async keywordSearch(query: string, limit?: number): Promise<RetrievalResult[]> {
    const startTime = Date.now();

    try {
      // Simple keyword matching - can be enhanced with full-text search
      const searchTerms = query.toLowerCase().split(/\s+/);
      const allTools = await this.getAllTools();

      const results = allTools
        .filter((tool) => {
          const searchableText =
            `${tool.name} ${tool.description} ${tool.tags?.join(" ")}`.toLowerCase();
          return searchTerms.some((term) => searchableText.includes(term));
        })
        .map((tool) => {
          // Calculate keyword match score
          const matchCount = searchTerms.filter((term) =>
            `${tool.name} ${tool.description}`.toLowerCase().includes(term)
          ).length;
          const score = matchCount / searchTerms.length;

          return {
            id: tool.id,
            score: Math.min(score, 1),
            method: "keyword" as const,
            metadata: {
              name: tool.name,
              description: tool.description,
              tags: tool.tags,
              toolType: tool.toolType,
              path: tool.path,
              version: tool.version,
            },
          };
        })
        .sort((a, b) => b.score - a.score)
        .slice(0, limit || this.config.hybridConfig.maxResults);

      this.metrics.keywordTime = Date.now() - startTime;

      return results;
    } catch (error) {
      this._logger.error("[HybridRetrievalEngine] Keyword search failed:", error);
      this.metrics.keywordTime = Date.now() - startTime;
      return [];
    }
  }

  /**
   * Perform semantic search
   */
  private async semanticSearch(query: string, limit?: number): Promise<RetrievalResult[]> {
    const startTime = Date.now();

    try {
      // Semantic search is essentially vector search with query embedding
      // Reuse vector search but mark as semantic
      const vectorResults = await this.vectorSearch(query, limit);

      this.metrics.semanticTime = Date.now() - startTime;

      return vectorResults.map((r) => ({
        ...r,
        method: "semantic" as const,
      }));
    } catch (error) {
      this._logger.error("[HybridRetrievalEngine] Semantic search failed:", error);
      this.metrics.semanticTime = Date.now() - startTime;
      return [];
    }
  }

  /**
   * Perform tag-based search
   */
  private async tagSearch(
    query: string,
    tags: string[],
    limit?: number
  ): Promise<RetrievalResult[]> {
    try {
      // Get candidates from vector search first
      const candidates = await this.config.searchEngine.search(query, {
        limit: (limit || this.config.hybridConfig.maxResults) * 2,
        minScore: 0.1, // Lower threshold for tag matching
      });

      // Match tags
      const tagMatchResults = await this.tagMatchingEngine.matchTags(
        tags,
        candidates as ToolRetrievalResult[]
      );

      // Convert to retrieval results
      return tagMatchResults
        .filter((match) => match.matched && match.score >= this.config.hybridConfig.minScore)
        .map((match) => {
          const candidate = candidates.find((c) => c.id === match.tag);
          return {
            id: match.tag || candidate?.id || "",
            score: match.score,
            method: "tag" as const,
            metadata: {
              name: candidate?.name,
              description: candidate?.description,
              tags: candidate?.tags,
              toolType: candidate?.toolType,
              path: (candidate as any)?.path,
              version: (candidate as any)?.version,
            },
          };
        })
        .sort((a, b) => b.score - a.score)
        .slice(0, limit || this.config.hybridConfig.maxResults);
    } catch (error) {
      this._logger.error("[HybridRetrievalEngine] Tag search failed:", error);
      return [];
    }
  }

  /**
   * Get all tools from database
   */
  private async getAllTools(): Promise<ToolsTable[]> {
    try {
      // This would typically query the database
      // For now, return empty array as placeholder
      return [];
    } catch (error) {
      this._logger.error("[HybridRetrievalEngine] Failed to get all tools:", error);
      return [];
    }
  }

  /**
   * Generate cache key for query
   */
  private getCacheKey(query: HybridRetrievalQuery): string {
    const parts = [
      query.query,
      query.tags?.join(",") || "",
      String(query.limit || this.config.hybridConfig.maxResults),
      String(query.disclosureLevel || DisclosureLevel.METADATA),
    ];
    return require("crypto").createHash("md5").update(parts.join("|")).digest("hex");
  }

  /**
   * Get results from cache
   */
  private getFromCache(cacheKey: string): UnifiedRetrievalResult[] | null {
    const entry = this._cache.get(cacheKey);
    if (entry && entry.expiresAt > Date.now()) {
      return entry.result;
    }
    return null;
  }

  /**
   * Add results to cache
   */
  private addToCache(cacheKey: string, results: UnifiedRetrievalResult[]): void {
    // Check cache size limit
    if (this._cache.size >= 1000) {
      // Remove oldest entry
      const oldestKey = this._cache.keys().next().value;
      this._cache.delete(oldestKey);
    }

    const expiresAt = Date.now() + this.config.hybridConfig.cacheTTL * 1000;
    this._cache.set(cacheKey, { result: results, expiresAt });
  }

  /**
   * Format error message
   */
  private formatError(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error occurred in HybridRetrievalEngine";
  }

  /**
   * Dispose of resources - cleanup disclosure cache
   */
  async dispose(): Promise<void> {
    if (this.disclosureCache && "dispose" in this.disclosureCache) {
      await this.disclosureCache.dispose();
    }
  }
}
````

## File: src/services/tool-retrieval/IndexConfigOptimizer.ts
````typescript
/**
 * IndexConfigOptimizer - IVF_PQ Index Configuration Optimizer
 *
 * Dynamically calculates optimal IVF_PQ index parameters based on data scale.
 * Improves vector search performance and recall rate.
 */

import { logger } from "../../utils/logger";

/**
 * IVF_PQ index configuration interface
 */
export interface IndexConfig {
  /** Number of IVF partitions */
  numPartitions: number;
  /** Number of sub-vectors for PQ */
  numSubVectors: number;
  /** Number of bits for PQ encoding (4 or 8) */
  numBits: 4 | 8;
  /** Maximum iterations for k-means clustering */
  maxIterations: number;
  /** Distance type for similarity search */
  distanceType: "l2" | "cosine" | "dot";
}

/**
 * Optimization result with estimated metrics
 */
export interface OptimizationResult {
  /** Calculated index configuration */
  config: IndexConfig;
  /** Estimated recall rate (0-1) */
  estimatedRecall: number;
  /** Estimated search latency in milliseconds */
  estimatedLatency: number;
  /** Reasoning for the calculated configuration */
  reasoning: string;
}

/**
 * Data scale category
 */
export type DataScale = "small" | "medium" | "large" | "xlarge";

/**
 * Preset configurations for different data scales
 */
export const INDEX_PRESETS: Record<
  DataScale,
  {
    numPartitions: number;
    numSubVectors: number;
    numBits: 4 | 8;
    expectedRecall: number;
    expectedLatency: string;
    rowRange: { min: number; max: number };
  }
> = {
  small: {
    numPartitions: 100,
    numSubVectors: 32,
    numBits: 8,
    expectedRecall: 0.95,
    expectedLatency: "1-2ms",
    rowRange: { min: 0, max: 10000 },
  },
  medium: {
    numPartitions: 500,
    numSubVectors: 64,
    numBits: 8,
    expectedRecall: 0.92,
    expectedLatency: "2-5ms",
    rowRange: { min: 10000, max: 100000 },
  },
  large: {
    numPartitions: 1000,
    numSubVectors: 96,
    numBits: 8,
    expectedRecall: 0.9,
    expectedLatency: "3-8ms",
    rowRange: { min: 100000, max: 1000000 },
  },
  xlarge: {
    numPartitions: 2000,
    numSubVectors: 128,
    numBits: 8,
    expectedRecall: 0.85,
    expectedLatency: "8-15ms",
    rowRange: { min: 1000000, max: Infinity },
  },
};

/**
 * IndexConfigOptimizer - Calculates optimal IVF_PQ index parameters
 *
 * Uses data-driven formulas to determine optimal partition count,
 * sub-vector count, and other parameters based on dataset size and
 * embedding dimension.
 */
export class IndexConfigOptimizer {
  /**
   * Calculate the optimal index configuration based on data scale
   *
   * @param rowCount - Number of vectors in the dataset
   * @param dimension - Embedding vector dimension
   * @param targetRecall - Target recall rate (default: 0.95)
   * @param preferSpeed - Whether to prioritize speed over recall (default: false)
   * @returns OptimizationResult with config and estimated metrics
   */
  calculateOptimalConfig(
    rowCount: number,
    dimension: number,
    targetRecall: number = 0.95,
    preferSpeed: boolean = false
  ): OptimizationResult {
    const scale = this.getDataScale(rowCount);
    const preset = INDEX_PRESETS[scale];

    // Calculate optimal parameters
    const numPartitions = this.calculateNumPartitions(rowCount);
    const numSubVectors = this.calculateNumSubVectors(dimension);
    const numBits = this.calculateNumBits(targetRecall);
    const maxIterations = this.calculateMaxIterations(targetRecall);
    const distanceType = this.determineDistanceType(dimension);

    // Adjust for speed preference
    const adjustedRecall = preferSpeed
      ? Math.min(targetRecall, preset.expectedRecall - 0.05)
      : targetRecall;

    // Calculate estimated metrics
    const estimatedRecall = this.estimateRecall(
      rowCount,
      numPartitions,
      numSubVectors,
      numBits,
      adjustedRecall
    );
    const estimatedLatency = this.estimateLatency(rowCount, numPartitions, preferSpeed);

    // Generate reasoning
    const reasoning = this.generateReasoning(
      scale,
      rowCount,
      dimension,
      numPartitions,
      numSubVectors,
      numBits,
      estimatedRecall,
      estimatedLatency
    );

    return {
      config: {
        numPartitions,
        numSubVectors,
        numBits,
        maxIterations,
        distanceType,
      },
      estimatedRecall,
      estimatedLatency,
      reasoning,
    };
  }

  /**
   * Calculate optimal number of partitions based on row count
   *
   * Formula:
   * - < 10K: sqrt(rowCount) * 2 (smaller but efficient)
   * - 10K - 100K: rowCount / 100 (balanced)
   * - 100K - 1M: sqrt(rowCount) * 5 (for larger datasets)
   * - > 1M: rowCount / 500 (scales with data)
   *
   * @param rowCount - Number of vectors
   * @returns Optimal partition count
   */
  calculateNumPartitions(rowCount: number): number {
    if (rowCount < 10000) {
      // Small dataset: use sqrt with minimum
      const partitions = Math.max(32, Math.round(Math.sqrt(rowCount) * 2));
      logger.debug(
        `[IndexConfigOptimizer] Small dataset (${rowCount} rows): ${partitions} partitions`
      );
      return partitions;
    }

    if (rowCount < 100000) {
      // Medium dataset: balanced approach
      const partitions = Math.round(rowCount / 100);
      logger.debug(
        `[IndexConfigOptimizer] Medium dataset (${rowCount} rows): ${partitions} partitions`
      );
      return Math.min(partitions, 512);
    }

    if (rowCount < 1000000) {
      // Large dataset: optimized for search speed
      const partitions = Math.round(Math.sqrt(rowCount) * 5);
      logger.debug(
        `[IndexConfigOptimizer] Large dataset (${rowCount} rows): ${partitions} partitions`
      );
      return Math.min(partitions, 1024);
    }

    // XLarge dataset: scales with data
    const partitions = Math.round(rowCount / 500);
    logger.debug(
      `[IndexConfigOptimizer] XLarge dataset (${rowCount} rows): ${partitions} partitions`
    );
    return Math.min(partitions, 2048);
  }

  /**
   * Calculate optimal number of sub-vectors based on dimension
   *
   * Sub-vectors should divide the original vector for PQ encoding.
   * Range: dimension/8 to dimension/4, with reasonable bounds.
   *
   * @param dimension - Embedding vector dimension
   * @returns Optimal sub-vector count
   */
  calculateNumSubVectors(dimension: number): number {
    // Minimum: dimension / 8, Maximum: dimension / 4
    const minSubVectors = Math.max(8, Math.floor(dimension / 8));
    const maxSubVectors = Math.min(256, Math.floor(dimension / 4));

    // Use dimension / 6 as a balanced choice
    const subVectors = Math.round(dimension / 6);

    const clampedSubVectors = Math.max(minSubVectors, Math.min(maxSubVectors, subVectors));
    logger.debug(
      `[IndexConfigOptimizer] Dimension ${dimension}: ${clampedSubVectors} sub-vectors (range: ${minSubVectors}-${maxSubVectors})`
    );

    return clampedSubVectors;
  }

  /**
   * Calculate optimal number of bits for PQ encoding
   *
   * - High recall (> 0.9): use 8 bits for better accuracy
   * - Lower recall: use 4 bits for faster encoding
   *
   * @param targetRecall - Target recall rate
   * @returns Number of bits (4 or 8)
   */
  calculateNumBits(targetRecall: number): 4 | 8 {
    return targetRecall >= 0.9 ? 8 : 4;
  }

  /**
   * Calculate maximum iterations for k-means clustering
   *
   * Higher recall requires more iterations for better centroids.
   *
   * @param targetRecall - Target recall rate
   * @returns Maximum iterations
   */
  calculateMaxIterations(targetRecall: number): number {
    if (targetRecall >= 0.95) {
      return 50;
    }
    if (targetRecall >= 0.9) {
      return 35;
    }
    return 20;
  }

  /**
   * Determine optimal distance type based on dimension
   *
   * - Cosine similarity works well for most embeddings
   * - L2 distance is good for normalized vectors
   * - Dot product is fastest but requires normalized vectors
   *
   * @param dimension - Embedding vector dimension
   * @returns Distance type
   */
  determineDistanceType(dimension: number): "l2" | "cosine" | "dot" {
    // Cosine is generally best for semantic search
    return "cosine";
  }

  /**
   * Get the data scale category based on row count
   *
   * @param rowCount - Number of vectors
   * @returns Data scale category
   */
  getDataScale(rowCount: number): DataScale {
    if (rowCount < 10000) {
      return "small";
    }
    if (rowCount < 100000) {
      return "medium";
    }
    if (rowCount < 1000000) {
      return "large";
    }
    return "xlarge";
  }

  /**
   * Get refine factor based on target recall
   *
   * Refine factor is used for re-ranking results to improve recall.
   *
   * @param targetRecall - Target recall rate
   * @returns Refine factor for LanceDB index
   */
  getRefineFactor(targetRecall: number): number {
    if (targetRecall >= 0.95) {
      return 30;
    }
    if (targetRecall >= 0.9) {
      return 20;
    }
    return 10;
  }

  /**
   * Estimate recall rate based on configuration
   *
   * This is a simplified model based on research findings.
   * Actual recall depends on data distribution and query characteristics.
   *
   * @param rowCount - Number of vectors
   * @param numPartitions - Number of partitions
   * @param numSubVectors - Number of sub-vectors
   * @param numBits - Number of bits for PQ
   * @param targetRecall - Target recall
   * @returns Estimated recall rate
   */
  private estimateRecall(
    rowCount: number,
    numPartitions: number,
    numSubVectors: number,
    numBits: 4 | 8,
    targetRecall: number
  ): number {
    // Base recall based on numBits (8 bits = better recall)
    const bitFactor = numBits === 8 ? 1.0 : 0.92;

    // Partition factor (more partitions = better recall up to a point)
    const partitionFactor = Math.min(1.0, (numPartitions / Math.sqrt(rowCount)) * 2);

    // Sub-vector factor (more sub-vectors = better recall)
    const subVectorFactor = Math.min(1.0, numSubVectors / 64);

    // Combined estimate (weighted average)
    const estimated =
      (bitFactor * 0.4 + partitionFactor * 0.35 + subVectorFactor * 0.25) * targetRecall;

    // Clamp between 0.7 and 0.99
    return Math.min(0.99, Math.max(0.7, estimated));
  }

  /**
   * Estimate search latency based on configuration
   *
   * @param rowCount - Number of vectors
   * @param numPartitions - Number of partitions
   * @param preferSpeed - Whether speed is prioritized
   * @returns Estimated latency in milliseconds
   */
  private estimateLatency(rowCount: number, numPartitions: number, preferSpeed: boolean): number {
    // Base latency proportional to log of row count
    const baseLatency = Math.log10(rowCount) * 0.5;

    // Adjust for partitions (more partitions = slightly slower but more accurate)
    const partitionFactor = Math.log2(numPartitions) * 0.3;

    // Speed preference reduces latency
    const speedFactor = preferSpeed ? 0.7 : 1.0;

    const estimated = (baseLatency + partitionFactor) * speedFactor;

    // Clamp between 1ms and 50ms
    return Math.min(50, Math.max(1, estimated));
  }

  /**
   * Generate human-readable reasoning for the configuration
   *
   * @param scale - Data scale category
   * @param rowCount - Number of vectors
   * @param dimension - Embedding dimension
   * @param numPartitions - Calculated partitions
   * @param numSubVectors - Calculated sub-vectors
   * @param numBits - Calculated bits
   * @param estimatedRecall - Estimated recall rate
   * @param estimatedLatency - Estimated latency
   * @returns Reasoning string
   */
  private generateReasoning(
    scale: DataScale,
    rowCount: number,
    dimension: number,
    numPartitions: number,
    numSubVectors: number,
    numBits: 4 | 8,
    estimatedRecall: number,
    estimatedLatency: number
  ): string {
    const scaleEmoji = {
      small: "🟢",
      medium: "🔵",
      large: "🟠",
      xlarge: "🔴",
    };

    return (
      `${scaleEmoji[scale]} ${scale.toUpperCase()} dataset optimization\n` +
      `  • Row count: ${rowCount.toLocaleString()} vectors\n` +
      `  • Dimension: ${dimension}\n` +
      `  • Partitions: ${numPartitions} (${(numPartitions / Math.sqrt(rowCount)).toFixed(2)}x sqrt(n))\n` +
      `  • Sub-vectors: ${numSubVectors} (${dimension / numSubVectors} dims per sub-vector)\n` +
      `  • PQ bits: ${numBits} (${numBits === 8 ? "higher accuracy" : "faster encoding"})\n` +
      `  • Expected recall: ${(estimatedRecall * 100).toFixed(1)}%\n` +
      `  • Expected latency: ~${estimatedLatency.toFixed(1)}ms`
    );
  }

  /**
   * Get a preset configuration for quick setup
   *
   * @param scale - Data scale category
   * @returns Preset configuration
   */
  getPreset(scale: DataScale): IndexConfig {
    const preset = INDEX_PRESETS[scale];
    return {
      numPartitions: preset.numPartitions,
      numSubVectors: preset.numSubVectors,
      numBits: preset.numBits,
      maxIterations: 30,
      distanceType: "cosine",
    };
  }

  /**
   * Get all available preset names
   *
   * @returns Array of preset names
   */
  getAvailablePresets(): DataScale[] {
    return ["small", "medium", "large", "xlarge"];
  }
}
````

## File: src/services/tool-retrieval/LanceDBConnectionPool.ts
````typescript
/**
 * LanceDBConnectionPool - Connection Pool Management
 *
 * Manages a pool of LanceDB connections for improved concurrency
 * and system stability. Replaces the single-connection pattern.
 */

import * as lancedb from "@lancedb/lancedb";
import * as fs from "fs/promises";
import { logger } from "../../utils/logger";

/**
 * Pool configuration interface
 */
export interface PoolConfig {
  maxInstances: number;
  instanceTTL: number;
  healthCheckInterval: number;
  minIdle: number;
  leakDetectionThreshold: number;
}

/**
 * Default pool configuration
 */
export const DEFAULT_POOL_CONFIG: PoolConfig = {
  maxInstances: 4,
  instanceTTL: 300000,
  healthCheckInterval: 60000,
  minIdle: 1,
  leakDetectionThreshold: 300000,
};

/**
 * Pooled connection interface
 */
export interface PooledConnection {
  connection: lancedb.Connection;
  dbPath: string;
  createdAt: number;
  lastAccess: number;
  accessCount: number;
  healthy: boolean;
  borrowedAt?: number;
}

/**
 * Pool statistics interface
 */
export interface PoolStats {
  size: number;
  maxSize: number;
  totalAccess: number;
  hitRate: number;
  healthyCount: number;
  idleCount: number;
  borrowedCount: number;
  potentialLeaks: number;
}

/**
 * LanceDBConnectionPool class
 */
export class LanceDBConnectionPool {
  private pool: Map<string, PooledConnection> = new Map();
  private config: PoolConfig;
  private healthCheckTimer: NodeJS.Timeout | null = null;
  private totalAccess: number = 0;
  private cacheHits: number = 0;
  private disposed: boolean = false;

  /**
   * Create a new connection pool
   */
  constructor(config: Partial<PoolConfig> = {}) {
    this.config = { ...DEFAULT_POOL_CONFIG, ...config };
    this.startHealthCheck();
    logger.info("[LanceDBConnectionPool] Pool initialized with config:", this.config);
  }

  /**
   * Get a connection from the pool
   */
  async getConnection(dbPath: string): Promise<lancedb.Connection> {
    const normalizedPath = this.normalizePath(dbPath);
    this.totalAccess++;

    // Check for existing connection
    const existing = this.pool.get(normalizedPath);
    if (existing) {
      if (existing.healthy) {
        existing.lastAccess = Date.now();
        existing.accessCount++;
        this.cacheHits++;
        logger.debug(`[LanceDBConnectionPool] Reusing existing connection for: ${normalizedPath}`);
        return existing.connection;
      } else {
        // Remove unhealthy connection
        await this.removeConnection(normalizedPath);
      }
    }

    // Check pool size limit
    if (this.pool.size >= this.config.maxInstances) {
      logger.warn(
        `[LanceDBConnectionPool] Pool at max capacity (${this.config.maxInstances}), attempting to evict expired connections`
      );
      await this.evictExpired();

      // If still at capacity, remove the least recently used connection
      if (this.pool.size >= this.config.maxInstances) {
        const lruPath = this.findLeastRecentlyUsed();
        if (lruPath) {
          logger.info(`[LanceDBConnectionPool] Evicting LRU connection: ${lruPath}`);
          await this.removeConnection(lruPath);
        }
      }
    }

    // Create new connection
    const connection = await this.createConnection(normalizedPath);
    const pooledConnection: PooledConnection = {
      connection,
      dbPath: normalizedPath,
      createdAt: Date.now(),
      lastAccess: Date.now(),
      accessCount: 1,
      healthy: true,
    };

    this.pool.set(normalizedPath, pooledConnection);
    logger.info(
      `[LanceDBConnectionPool] Created new connection for: ${normalizedPath}, pool size: ${this.pool.size}`
    );

    return connection;
  }

  /**
   * Release a connection back to the pool
   */
  async releaseConnection(dbPath: string): Promise<void> {
    const normalizedPath = this.normalizePath(dbPath);
    const connection = this.pool.get(normalizedPath);

    if (connection) {
      connection.lastAccess = Date.now();
      logger.debug(`[LanceDBConnectionPool] Released connection for: ${normalizedPath}`);
    }
  }

  /**
   * Close a specific connection
   */
  async closeConnection(dbPath: string): Promise<void> {
    const normalizedPath = this.normalizePath(dbPath);
    await this.removeConnection(normalizedPath);
  }

  /**
   * Close all connections in the pool
   */
  async closeAll(): Promise<void> {
    // Stop health check timer
    this.stopHealthCheck();

    // Close all connections
    for (const [dbPath, pooledConnection] of this.pool) {
      try {
        await this.closeSingleConnection(pooledConnection);
        logger.info(`[LanceDBConnectionPool] Closed connection for: ${dbPath}`);
      } catch (error) {
        logger.error(`[LanceDBConnectionPool] Error closing connection for ${dbPath}:`, error);
      }
    }

    this.pool.clear();
    logger.info("[LanceDBConnectionPool] All connections closed");
  }

  /**
   * Dispose of the pool and cleanup resources
   * Implements IDisposable pattern for proper resource cleanup
   */
  async dispose(): Promise<void> {
    if (this.disposed) {
      return;
    }
    this.disposed = true;

    logger.info("[LanceDBConnectionPool] Disposing connection pool...");

    // Stop health check
    this.stopHealthCheck();

    // Close all connections
    await this.closeAll();

    // Reset statistics
    this.totalAccess = 0;
    this.cacheHits = 0;

    logger.info("[LanceDBConnectionPool] Connection pool disposed");
  }

  /**
   * Stop the health check timer
   */
  private stopHealthCheck(): void {
    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
      this.healthCheckTimer = null;
      logger.debug("[LanceDBConnectionPool] Health check timer stopped");
    }
  }

  /**
   * Get pool statistics
   */
  getStats(): PoolStats {
    const hitRate = this.totalAccess > 0 ? this.cacheHits / this.totalAccess : 0;
    let healthyCount = 0;
    let idleCount = 0;
    let borrowedCount = 0;
    let potentialLeaks = 0;
    const now = Date.now();

    for (const connection of this.pool.values()) {
      if (connection.healthy) {
        healthyCount++;
        // Consider idle if not accessed in the last 30 seconds
        if (Date.now() - connection.lastAccess > 30000) {
          idleCount++;
        }
      }
      // Track borrowed connections (if we implement lease tracking)
      if (connection.borrowedAt) {
        borrowedCount++;
        // Check for potential leaks
        if (now - connection.borrowedAt > this.config.leakDetectionThreshold) {
          potentialLeaks++;
        }
      }
    }

    return {
      size: this.pool.size,
      maxSize: this.config.maxInstances,
      totalAccess: this.totalAccess,
      hitRate: Math.round(hitRate * 100) / 100,
      healthyCount,
      idleCount,
      borrowedCount,
      potentialLeaks,
    };
  }

  /**
   * Check if a connection is healthy
   */
  async isHealthy(dbPath: string): Promise<boolean> {
    const normalizedPath = this.normalizePath(dbPath);
    const connection = this.pool.get(normalizedPath);

    if (!connection || !connection.healthy) {
      return false;
    }

    try {
      // Simple health check - try to get table names
      const tableNames = await connection.connection.tableNames();
      return Array.isArray(tableNames);
    } catch (error) {
      logger.warn(`[LanceDBConnectionPool] Connection health check failed for ${dbPath}:`, error);
      return false;
    }
  }

  /**
   * Force refresh a connection
   */
  async refreshConnection(dbPath: string): Promise<lancedb.Connection> {
    const normalizedPath = this.normalizePath(dbPath);
    await this.removeConnection(normalizedPath);
    return this.getConnection(normalizedPath);
  }

  /**
   * Get the number of active connections
   */
  getSize(): number {
    return this.pool.size;
  }

  /**
   * Start periodic health check
   */
  private startHealthCheck(): void {
    if (this.disposed) {
      logger.debug("[LanceDBConnectionPool] Skipping health check start - pool already disposed");
      return;
    }

    if (this.healthCheckTimer) {
      clearInterval(this.healthCheckTimer);
    }

    this.healthCheckTimer = setInterval(async () => {
      if (!this.disposed) {
        await this.performHealthCheck();
      }
    }, this.config.healthCheckInterval);

    logger.info(
      `[LanceDBConnectionPool] Health check started (interval: ${this.config.healthCheckInterval}ms)`
    );
  }

  /**
   * Perform health check on all connections
   */
  private async performHealthCheck(): Promise<void> {
    logger.debug(
      `[LanceDBConnectionPool] Performing health check on ${this.pool.size} connections`
    );

    for (const [dbPath, connection] of this.pool) {
      try {
        const isHealthy = await this.checkConnectionHealth(connection);
        connection.healthy = isHealthy;

        if (!isHealthy) {
          logger.warn(`[LanceDBConnectionPool] Connection marked unhealthy: ${dbPath}`);
        }
      } catch (error) {
        logger.error(`[LanceDBConnectionPool] Health check error for ${dbPath}:`, error);
        connection.healthy = false;
      }
    }

    // Evict unhealthy connections
    await this.evictUnhealthy();
  }

  /**
   * Check individual connection health
   */
  private async checkConnectionHealth(pooledConnection: PooledConnection): Promise<boolean> {
    try {
      // Try to get table names as a simple health check
      await pooledConnection.connection.tableNames();
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Evict expired connections based on TTL
   */
  private async evictExpired(): Promise<void> {
    const now = Date.now();
    const expiredPaths: string[] = [];

    for (const [dbPath, connection] of this.pool) {
      const age = now - connection.createdAt;
      const idleTime = now - connection.lastAccess;

      // Remove if past TTL and idle, or extremely old (over 2x TTL)
      if (
        (age > this.config.instanceTTL && idleTime > 60000) ||
        age > this.config.instanceTTL * 2
      ) {
        expiredPaths.push(dbPath);
      }
    }

    for (const dbPath of expiredPaths) {
      logger.info(`[LanceDBConnectionPool] Evicting expired connection: ${dbPath}`);
      await this.removeConnection(dbPath);
    }

    if (expiredPaths.length > 0) {
      logger.info(`[LanceDBConnectionPool] Evicted ${expiredPaths.length} expired connections`);
    }
  }

  /**
   * Evict unhealthy connections
   */
  private async evictUnhealthy(): Promise<void> {
    const unhealthyPaths: string[] = [];

    for (const [dbPath, connection] of this.pool) {
      if (!connection.healthy) {
        unhealthyPaths.push(dbPath);
      }
    }

    for (const dbPath of unhealthyPaths) {
      logger.info(`[LanceDBConnectionPool] Removing unhealthy connection: ${dbPath}`);
      await this.removeConnection(dbPath);
    }
  }

  /**
   * Find the least recently used connection
   */
  private findLeastRecentlyUsed(): string | null {
    let oldestAccess = Infinity;
    let lruPath: string | null = null;

    for (const [dbPath, connection] of this.pool) {
      if (connection.lastAccess < oldestAccess) {
        oldestAccess = connection.lastAccess;
        lruPath = dbPath;
      }
    }

    return lruPath;
  }

  /**
   * Create a new LanceDB connection
   */
  private async createConnection(dbPath: string): Promise<lancedb.Connection> {
    try {
      // Ensure database directory exists
      await fs.mkdir(dbPath, { recursive: true });

      // Connect to LanceDB
      const connection = await lancedb.connect(dbPath);
      logger.debug(`[LanceDBConnectionPool] Created connection for: ${dbPath}`);

      return connection;
    } catch (error) {
      logger.error(`[LanceDBConnectionPool] Failed to create connection for ${dbPath}:`, error);
      throw error;
    }
  }

  /**
   * Close a single connection
   */
  private async closeSingleConnection(pooledConnection: PooledConnection): Promise<void> {
    try {
      // LanceDB doesn't have an explicit close method in the Connection interface
      // The connection will be garbage collected when the object is destroyed
      pooledConnection.connection = null as any;
      pooledConnection.healthy = false;
    } catch (error) {
      logger.error("[LanceDBConnectionPool] Error closing connection:", error);
    }
  }

  /**
   * Remove a connection from the pool
   */
  private async removeConnection(dbPath: string): Promise<void> {
    const pooledConnection = this.pool.get(dbPath);
    if (pooledConnection) {
      await this.closeSingleConnection(pooledConnection);
      this.pool.delete(dbPath);
      logger.debug(`[LanceDBConnectionPool] Removed connection for: ${dbPath}`);
    }
  }

  /**
   * Normalize database path
   */
  private normalizePath(dbPath: string): string {
    return path.normalize(dbPath);
  }
}

// Import path module at the end to avoid circular dependencies
import * as path from "path";
````

## File: src/services/tool-retrieval/MCPToolSupport.ts
````typescript
/**
 * MCPToolSupport - MCP Tool Support
 *
 * Handles MCP tool indexing, embedding generation, and search.
 */

import { createHash } from 'crypto';
import { logger } from '../../utils/logger';
import {
  MCPTool,
  MCPToolRetrievalResult,
  EmbeddingVector,
  ToolsTable
} from './types';
import { IEmbeddingGenerator } from './EmbeddingGenerator';
import { ILanceDBConnection } from './LanceDBConnection';

/**
 * MCPToolSupport interface
 */
export interface IMCPToolSupport {
  indexTools(tools: MCPTool[]): Promise<void>;
  getEmbeddingForTool(tool: MCPTool): Promise<EmbeddingVector>;
  removeTool(toolName: string): Promise<void>;
  searchTools(query: string, limit?: number): Promise<MCPToolRetrievalResult[]>;
}

/**
 * MCPToolSupport implementation
 */
export class MCPToolSupport implements IMCPToolSupport {
  private readonly embeddingGenerator: IEmbeddingGenerator;
  private readonly connection: ILanceDBConnection;
  private readonly defaultLimit: number;

  constructor(
    embeddingGenerator: IEmbeddingGenerator,
    connection: ILanceDBConnection,
    defaultLimit: number = 5
  ) {
    this.embeddingGenerator = embeddingGenerator;
    this.connection = connection;
    this.defaultLimit = defaultLimit;
  }

  /**
   * Index MCP tools
   */
  async indexTools(tools: MCPTool[]): Promise<void> {
    try {
      logger.info(`[MCPToolSupport] Indexing ${tools.length} MCP tools...`);

      const records: ToolsTable[] = [];

      for (const tool of tools) {
        try {
          // Generate unique ID
          const toolId = this.generateToolId(tool);

          // Generate vector embedding
          const vector = await this.getEmbeddingForTool(tool);

          // Prepare record
          const record: ToolsTable = {
            id: toolId,
            name: tool.name,
            description: tool.description,
            tags: this.extractToolTags(tool),
            path: null,
            version: null,
            source: tool.metadata?.source as string || tool.name,
            toolType: 'mcp',
            metadata: JSON.stringify(tool.metadata || {}),
            vector: vector.values,
            indexedAt: new Date()
          };

          records.push(record);
        } catch (error) {
          logger.error(`[MCPToolSupport] Failed to index tool ${tool.name}:`, error);
        }
      }

      if (records.length > 0) {
        // Remove existing records
        for (const record of records) {
          await this.removeToolById(record.id);
        }

        // Batch insert
        await this.connection.addRecords(records);
        logger.info(`[MCPToolSupport] Successfully indexed ${records.length} MCP tools`);
      } else {
        logger.warn('[MCPToolSupport] No tools were indexed');
      }

    } catch (error) {
      logger.error('[MCPToolSupport] Failed to index tools:', error);
      throw error;
    }
  }

  /**
   * Get embedding for an MCP tool
   */
  async getEmbeddingForTool(tool: MCPTool): Promise<EmbeddingVector> {
    return this.embeddingGenerator.generateForTool(tool);
  }

  /**
   * Remove a tool from the index
   */
  async removeTool(toolName: string): Promise<void> {
    const toolId = this.generateToolId({ name: toolName, description: '', inputSchema: { schema: {} } });
    await this.removeToolById(toolId);
  }

  /**
   * Remove tool by ID
   */
  private async removeToolById(toolId: string): Promise<void> {
    try {
      await this.connection.deleteById(toolId);
      logger.debug(`[MCPToolSupport] Removed tool: ${toolId}`);
    } catch (error) {
      logger.error(`[MCPToolSupport] Failed to remove tool ${toolId}:`, error);
    }
  }

  /**
   * Search MCP tools
   */
  async searchTools(query: string, limit?: number): Promise<MCPToolRetrievalResult[]> {
    const effectiveLimit = limit ?? this.defaultLimit;

    try {
      logger.info(`[MCPToolSupport] Searching MCP tools for: "${query}"`);

      // Generate query embedding
      const vector = await this.embeddingGenerator.generateForText(query);

      // Get table and search
      const table = await this.connection.getTable();
      if (!table) {
        logger.warn('[MCPToolSupport] Table not initialized');
        return [];
      }

      // Execute search
      const queryBuilder = table.query()
        .nearestTo(vector.values)
        .distanceType('cosine')
        .limit(effectiveLimit * 2);

      // Filter by MCP tools
      const results = await queryBuilder.toArray();

      // Format results
      const formatted: MCPToolRetrievalResult[] = [];

      for (const result of results.slice(0, effectiveLimit)) {
        try {
          const data = this.extractResultData(result);
          const score = this.calculateScore(result);

          // Only include MCP tools
          if (data.toolType === 'mcp') {
            formatted.push({
              name: data.name,
              score,
              description: data.description,
              parameters: this.extractParameters(data.metadata)
            });
          }
        } catch (error) {
          logger.warn('[MCPToolSupport] Failed to format search result:', error);
        }
      }

      logger.info(`[MCPToolSupport] Found ${formatted.length} MCP tool(s)`);
      return formatted;

    } catch (error) {
      logger.error(`[MCPToolSupport] Search failed for query "${query}":`, error);
      throw error;
    }
  }

  /**
   * Generate unique tool ID
   */
  private generateToolId(tool: MCPTool): string {
    const source = tool.metadata?.source as string || tool.name;
    return createHash('md5')
      .update(`mcp:${source}:${tool.name}`)
      .digest('hex');
  }

  /**
   * Extract tags from tool
   */
  private extractTags(tool: MCPTool): string[] {
    return tool.metadata?.tags as string[] || [];
  }

  /**
   * Extract tool tags (internal)
   */
  private extractToolTags(tool: MCPTool): string[] {
    const tags: string[] = [];

    if (tool.metadata) {
      if (Array.isArray(tool.metadata.tags)) {
        tags.push(...(tool.metadata.tags as string[]));
      }
      if (tool.metadata.source) {
        tags.push(`mcp:${tool.metadata.source}`);
      }
    }

    return tags;
  }

  /**
   * Extract parameters from metadata
   */
  private extractParameters(metadata: string): Record<string, unknown> {
    try {
      if (typeof metadata === 'string') {
        const parsed = JSON.parse(metadata);
        return parsed.inputSchema?.properties || {};
      }
      return {};
    } catch {
      return {};
    }
  }

  /**
   * Extract result data
   */
  private extractResultData(result: unknown): ToolsTable {
    if (result && typeof result === 'object') {
      const r = result as Record<string, unknown>;
      if ('item' in r) {
        return r.item as ToolsTable;
      }
    }
    return result as ToolsTable;
  }

  /**
   * Calculate similarity score
   */
  private calculateScore(result: unknown): number {
    if (result && typeof result === 'object') {
      const r = result as Record<string, number>;
      if (r._distance !== undefined) {
        return Math.max(0, 1 - r._distance);
      }
      if (r.score !== undefined) {
        return r.score;
      }
    }
    return 0;
  }
}
````

## File: src/services/tool-retrieval/SkillIndexer.ts
````typescript
/**
 * SkillIndexer - Skill Indexing
 *
 * Handles skill indexing operations: add, remove, update, and scan.
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { createHash } from 'crypto';
import matter from 'gray-matter';
import { logger } from '../../utils/logger';
import {
  SkillData,
  ToolsTable,
  VectorizedFileData,
  ToolError,
  ToolErrorCode
} from './types';
import { ILanceDBConnection } from './LanceDBConnection';
import { IEmbeddingGenerator } from './EmbeddingGenerator';

/**
 * SkillIndexer interface
 */
export interface ISkillIndexer {
  addSkill(skill: SkillData): Promise<void>;
  removeSkill(skillId: string): Promise<void>;
  updateSkill(skill: SkillData): Promise<void>;
  addSkillsBatch(skills: SkillData[]): Promise<void>;
  scanAndIndex(dirPath: string): Promise<number>;
  checkReindexRequired(skillPath: string, vectorizedFile: string): Promise<boolean>;
  readSkillMetadata(filePath: string): Promise<SkillData | null>;
  forceReindexAll(skillsDir?: string): Promise<void>;
}

/**
 * SkillIndexer implementation
 */
export class SkillIndexer implements ISkillIndexer {
  private readonly connection: ILanceDBConnection;
  private readonly embeddingGenerator: IEmbeddingGenerator;
  private readonly defaultSkillsDir: string;

  constructor(
    connection: ILanceDBConnection,
    embeddingGenerator: IEmbeddingGenerator,
    defaultSkillsDir: string = './.data/skills'
  ) {
    this.connection = connection;
    this.embeddingGenerator = embeddingGenerator;
    this.defaultSkillsDir = defaultSkillsDir;
  }

  /**
   * Add a skill to the index
   */
  async addSkill(skill: SkillData): Promise<void> {
    try {
      logger.info(`[SkillIndexer] Adding skill: ${skill.name}`);

      // Generate skill ID
      const skillId = this.generateSkillId(skill.name);

      // Generate vector embedding
      const vector = await this.embeddingGenerator.generateForSkill(skill);

      // Prepare record data
      const record = this.prepareSkillRecord(skill, skillId, vector.values);

      // Remove existing skill (update mode)
      await this.removeSkill(skillId);

      // Add to table
      const table = await this.connection.getTable();
      if (table) {
        await table.add([record as unknown as Record<string, unknown>]);
        logger.info(`[SkillIndexer] Skill indexed: ${skill.name} (${vector.values.length} dimensions)`);
      }

    } catch (error) {
      logger.error(`[SkillIndexer] Failed to add skill ${skill.name}:`, error);
      throw error;
    }
  }

  /**
   * Remove a skill from the index
   */
  async removeSkill(skillId: string): Promise<void> {
    try {
      logger.debug(`[SkillIndexer] Removing skill: ${skillId}`);
      await this.connection.deleteById(skillId);
    } catch (error) {
      logger.warn(`[SkillIndexer] Failed to remove skill ${skillId}:`, error);
    }
  }

  /**
   * Update a skill in the index
   */
  async updateSkill(skill: SkillData): Promise<void> {
    await this.addSkill(skill);
  }

  /**
   * Batch add skills
   */
  async addSkillsBatch(skills: SkillData[]): Promise<void> {
    const records: ToolsTable[] = [];

    for (const skill of skills) {
      try {
        const skillId = this.generateSkillId(skill.name);
        const vector = await this.embeddingGenerator.generateForSkill(skill);
        const record = this.prepareSkillRecord(skill, skillId, vector.values);
        records.push(record);
      } catch (error) {
        logger.warn(`[SkillIndexer] Failed to index skill ${skill.name}:`, error);
      }
    }

    if (records.length > 0) {
      await this.connection.addRecords(records);
      logger.info(`[SkillIndexer] Batch indexed ${records.length} skills`);
    }
  }

  /**
   * Scan directory and index all skills
   */
  async scanAndIndex(dirPath: string): Promise<number> {
    try {
      logger.info(`[SkillIndexer] Scanning skills directory: ${dirPath}`);

      // Check if directory exists
      try {
        await fs.access(dirPath);
      } catch {
        logger.warn(`[SkillIndexer] Skills directory does not exist: ${dirPath}`);
        return 0;
      }

      // Get all skill directories
      const entries = await fs.readdir(dirPath, { withFileTypes: true });
      const skillDirs = entries
        .filter(entry => entry.isDirectory())
        .map(entry => entry.name);

      logger.info(`[SkillIndexer] Found ${skillDirs.length} skill directories`);

      // Index each skill
      let indexedCount = 0;
      let skippedCount = 0;

      for (const skillName of skillDirs) {
        try {
          const skillPath = path.join(dirPath, skillName);
          const vectorizedFile = path.join(skillPath, '.vectorized');

          // Check if reindexing is needed
          let needReindex = true;
          if (await this.fileExists(vectorizedFile)) {
            needReindex = await this.checkReindexRequired(skillPath, vectorizedFile);
          }

          if (needReindex) {
            // Read skill metadata
            const skillData = await this.readSkillMetadata(skillPath);

            if (skillData) {
              // Index skill
              await this.addSkill({
                ...skillData,
                filePath: skillPath,
                id: this.generateSkillId(skillData.name)
              });

              // Update .vectorized file
              await this.updateVectorizedFile(vectorizedFile, skillPath);
            }

            indexedCount++;
            logger.debug(`[SkillIndexer] Indexed skill: ${skillName}`);
          } else {
            skippedCount++;
            logger.debug(`[SkillIndexer] Skipped unchanged skill: ${skillName}`);
          }

        } catch (error) {
          logger.warn(`[SkillIndexer] Failed to index skill ${skillName}:`, error);
        }
      }

      logger.info(`[SkillIndexer] Scan completed: ${indexedCount} indexed, ${skippedCount} skipped`);
      return indexedCount;

    } catch (error) {
      logger.error('[SkillIndexer] Failed to scan and index skills:', error);
      throw error;
    }
  }

  /**
   * Check if reindexing is required
   */
  async checkReindexRequired(skillPath: string, vectorizedFile: string): Promise<boolean> {
    try {
      // Read .vectorized file
      const vectorizedContent = await fs.readFile(vectorizedFile, 'utf8');
      const vectorizedData: VectorizedFileData = JSON.parse(vectorizedContent);

      // Calculate current SKILL.md hash
      const skillMdPath = path.join(skillPath, 'SKILL.md');
      const skillContent = await fs.readFile(skillMdPath, 'utf8');
      const currentHash = createHash('md5').update(skillContent).digest('hex');
      const currentSize = Buffer.byteLength(skillContent);

      // Compare hash and size
      return currentHash !== vectorizedData.skillHash || currentSize !== vectorizedData.skillSize;

    } catch {
      // File doesn't exist or parse failed, need to index
      return true;
    }
  }

  /**
   * Read skill metadata from SKILL.md
   */
  async readSkillMetadata(filePath: string): Promise<SkillData | null> {
    try {
      const skillMdPath = path.join(filePath, 'SKILL.md');

      // Read file
      const content = await fs.readFile(skillMdPath, 'utf8');

      // Parse YAML Frontmatter
      const parsed = matter(content);

      if (!parsed.data.name || !parsed.data.description) {
        throw new Error('SKILL.md must contain name and description');
      }

      return {
        id: '',
        name: parsed.data.name,
        description: parsed.data.description,
        tags: Array.isArray(parsed.data.tags) ? parsed.data.tags : [],
        version: parsed.data.version || '1.0.0',
        metadata: {
          tools: parsed.data.tools || []
        }
      };

    } catch (error) {
      logger.error(`[SkillIndexer] Failed to read skill metadata from ${filePath}:`, error);
      return null;
    }
  }

  /**
   * Generate skill ID
   */
  private generateSkillId(name: string): string {
    return createHash('md5')
      .update(name)
      .digest('hex');
  }

  /**
   * Prepare skill record for database
   */
  private prepareSkillRecord(
    skill: SkillData,
    skillId: string,
    vector: number[]
  ): ToolsTable {
    // Convert tools to parameters format
    const tools = (skill.metadata?.tools as unknown[]) || [];
    const parameters = tools.length > 0 ? {
      type: 'object',
      properties: tools.reduce((acc: Record<string, unknown>, tool: unknown) => {
        const t = tool as { name?: string; description?: string; input_schema?: { properties?: Record<string, unknown>; required?: string[] } };
        if (t.name) {
          acc[t.name] = {
            type: 'object',
            description: t.description || '',
            properties: t.input_schema?.properties || {},
            required: t.input_schema?.required || []
          };
        }
        return acc;
      }, {}),
      required: tools
        .filter((t: unknown) => (t as { input_schema?: { required?: string[] } }).input_schema?.required?.length > 0)
        .map((t: unknown) => (t as { name?: string }).name)
        .filter((n: unknown): n is string => typeof n === 'string')
    } : { type: 'object', properties: {}, required: [] };

    return {
      id: skillId,
      name: skill.name,
      description: skill.description,
      tags: skill.tags || [],
      path: skill.filePath,
      version: skill.version || '1.0.0',
      source: skill.name,
      toolType: 'skill',
      metadata: JSON.stringify({
        ...skill.metadata,
        tools: skill.metadata?.tools || [],
        parameters
      }),
      vector,
      indexedAt: new Date()
    };
  }

  /**
   * Update .vectorized file
   */
  private async updateVectorizedFile(vectorizedFile: string, skillPath: string): Promise<void> {
    try {
      const skillMdPath = path.join(skillPath, 'SKILL.md');
      const skillContent = await fs.readFile(skillMdPath, 'utf8');
      const skillHash = createHash('md5').update(skillContent).digest('hex');
      const skillSize = Buffer.byteLength(skillContent);

      const vectorizedData: VectorizedFileData = {
        indexedAt: Date.now(),
        skillSize,
        skillHash
      };

      await fs.writeFile(vectorizedFile, JSON.stringify(vectorizedData, null, 2));
      logger.debug(`[SkillIndexer] Updated .vectorized file: ${vectorizedFile}`);

    } catch (error) {
      logger.warn(`[SkillIndexer] Failed to update .vectorized file:`, error);
    }
  }

  /**
   * Check if file exists
   */
  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Force reindex all skills (delete all .vectorized files)
   */
  async forceReindexAll(skillsDir: string = this.defaultSkillsDir): Promise<void> {
    try {
      const entries = await fs.readdir(skillsDir, { withFileTypes: true });
      const skillDirs = entries
        .filter(entry => entry.isDirectory())
        .map(entry => entry.name);

      logger.info(`[SkillIndexer] Force reindexing ${skillDirs.length} skills...`);

      // Delete each skill's .vectorized file
      for (const skillName of skillDirs) {
        const skillPath = path.join(skillsDir, skillName);
        const vectorizedFile = path.join(skillPath, '.vectorized');

        try {
          await fs.unlink(vectorizedFile);
          logger.debug(`[SkillIndexer] Deleted .vectorized file for skill: ${skillName}`);
        } catch (error: any) {
          if (error.code !== 'ENOENT') {
            logger.warn(`[SkillIndexer] Failed to delete .vectorized file for ${skillName}:`, error);
          }
        }
      }

      logger.info('[SkillIndexer] Force reindex preparation completed');

    } catch (error) {
      logger.warn('[SkillIndexer] Failed to force reindex skills:', error);
    }
  }
}
````

## File: src/services/tool-retrieval/TagMatchingEngine.ts
````typescript
/**
 * TagMatchingEngine - Tag-based Matching Engine
 *
 * Phase 1b: 标签匹配引擎实现
 * Supports tag hierarchy, alias expansion, and batch matching
 */

import { logger } from "../../utils/logger";
import {
  TagMatchResult,
  TagHierarchy,
  TagMatchingOptions,
  HybridRetrievalError,
  HybridRetrievalErrorCode,
} from "../../types/enhanced-skill";
import { ToolRetrievalResult } from "./types";

/**
 * Tag matching engine interface
 */
export interface ITagMatchingEngine {
  matchTags(queryTags: string[], candidates: ToolRetrievalResult[]): Promise<TagMatchResult[]>;
  matchSingleTool(tool: ToolRetrievalResult, queryTags: string[]): Promise<TagMatchResult>;
  calculateTagScore(toolTags: string[], queryTags: string[], hierarchy: TagHierarchy): number;
  expandAliases(tag: string, hierarchy: TagHierarchy): string[];
}

/**
 * Tag matching engine configuration
 */
export interface TagMatchingEngineConfig {
  /** Tag hierarchy configuration */
  hierarchy: TagHierarchy;
  /** Minimum match score threshold */
  minScore: number;
  /** Maximum hierarchy depth */
  maxDepth: number;
  /** Enable alias expansion */
  enableAliases: boolean;
}

/**
 * Default tag matching engine configuration
 */
export const DEFAULT_TAG_MATCHING_CONFIG: TagMatchingEngineConfig = {
  hierarchy: {
    levels: ["category", "subcategory", "tag"],
    aliases: {
      cat: "category",
      sub: "subcategory",
      t: "tag",
      c: "category",
      s: "subcategory",
    },
  },
  minScore: 0.5,
  maxDepth: 3,
  enableAliases: true,
};

/**
 * TagMatchingEngine implementation
 * Handles tag-based matching with hierarchy support
 */
export class TagMatchingEngine implements ITagMatchingEngine {
  private readonly _logger = logger;
  private readonly config: TagMatchingEngineConfig;

  constructor(config?: Partial<TagMatchingEngineConfig>) {
    this.config = { ...DEFAULT_TAG_MATCHING_CONFIG, ...config };
    this._logger.info("[TagMatchingEngine] Initialized with config:", {
      minScore: this.config.minScore,
      maxDepth: this.config.maxDepth,
      enableAliases: this.config.enableAliases,
      hierarchyLevels: this.config.hierarchy.levels,
    });
  }

  /**
   * Match tags against multiple candidate tools
   */
  async matchTags(
    queryTags: string[],
    candidates: ToolRetrievalResult[]
  ): Promise<TagMatchResult[]> {
    const startTime = Date.now();

    try {
      this._logger.info(
        `[TagMatchingEngine] Matching ${candidates.length} tools by ${queryTags.length} query tags`
      );

      // Return empty array if query tags are empty
      if (queryTags.length === 0) {
        return [];
      }

      const results: TagMatchResult[] = [];

      for (const candidate of candidates) {
        const matchResult = await this.matchSingleTool(candidate, queryTags);
        results.push(matchResult);
      }

      const duration = Date.now() - startTime;
      this._logger.debug(`[TagMatchingEngine] Tag matching completed in ${duration}ms`, {
        resultCount: results.length,
      });

      return results;
    } catch (error) {
      this._logger.error("[TagMatchingEngine] Tag matching failed:", error);
      throw new HybridRetrievalError(
        `Tag matching failed: ${this.formatError(error)}`,
        HybridRetrievalErrorCode.TAG_MATCH_ERROR,
        { queryTags, candidateCount: candidates.length }
      );
    }
  }

  /**
   * Match tags for a single tool
   */
  async matchSingleTool(tool: ToolRetrievalResult, queryTags: string[]): Promise<TagMatchResult> {
    try {
      const toolTags = tool.tags || [];
      const matchScore = this.calculateTagScore(toolTags, queryTags, this.config.hierarchy);

      // Find the best matching tag
      const matchedTag = this.findBestMatchingTag(toolTags, queryTags, this.config.hierarchy);

      const expandedFrom = this.isExpandedFromAlias(matchedTag, queryTags, this.config.hierarchy);

      return {
        matched: matchScore >= this.config.minScore,
        tag: matchedTag || "",
        level: this.getTagLevel(matchedTag, this.config.hierarchy),
        score: matchScore,
        expandedFrom,
      };
    } catch (error) {
      this._logger.error(`[TagMatchingEngine] Failed to match tool ${tool.name}:`, error);
      throw new HybridRetrievalError(
        `Single tool matching failed: ${this.formatError(error)}`,
        HybridRetrievalErrorCode.TAG_MATCH_ERROR,
        { toolId: tool.id, toolName: tool.name }
      );
    }
  }

  /**
   * Calculate tag matching score between tool tags and query tags
   */
  calculateTagScore(toolTags: string[], queryTags: string[], hierarchy: TagHierarchy): number {
    if (queryTags.length === 0) {
      return 0;
    }

    let totalScore = 0;
    let matchCount = 0;

    for (const queryTag of queryTags) {
      const expandedQueryTags = this.config.enableAliases
        ? this.expandAliases(queryTag, hierarchy)
        : [queryTag];

      let bestMatchScore = 0;

      for (const toolTag of toolTags) {
        const expandedToolTags = this.config.enableAliases
          ? this.expandAliases(toolTag, hierarchy)
          : [toolTag];

        // Check for exact match or alias match
        for (const et of expandedToolTags) {
          for (const eq of expandedQueryTags) {
            if (et === eq) {
              // Exact match - highest score
              bestMatchScore = Math.max(bestMatchScore, 1.0);
              break;
            }

            // Check hierarchy level match
            const etLevel = this.getTagLevel(et, hierarchy);
            const eqLevel = this.getTagLevel(eq, hierarchy);

            if (
              etLevel === eqLevel &&
              etLevel !== "unknown" &&
              et.toLowerCase() === eq.toLowerCase()
            ) {
              // Same level partial match (only if the tag names are similar, not just same level)
              bestMatchScore = Math.max(bestMatchScore, 0.8);
            }

            // Check if one tag is a prefix/suffix of another
            if (et.startsWith(eq) || eq.startsWith(et)) {
              bestMatchScore = Math.max(bestMatchScore, 0.6);
            }
          }
        }
      }

      if (bestMatchScore > 0) {
        totalScore += bestMatchScore;
        matchCount++;
      }
    }

    // Return weighted average score
    return matchCount > 0 ? totalScore / queryTags.length : 0;
  }

  /**
   * Expand a tag to all its aliases
   */
  expandAliases(tag: string, hierarchy: TagHierarchy): string[] {
    const expanded = [tag];

    // Check if tag is in format "level:value"
    const colonIndex = tag.indexOf(":");
    if (colonIndex > 0) {
      const levelPart = tag.substring(0, colonIndex);
      const valuePart = tag.substring(colonIndex + 1);

      // Check if levelPart is an alias
      for (const [alias, canonical] of Object.entries(hierarchy.aliases)) {
        if (levelPart === alias) {
          // Expand to canonical level
          expanded.push(`${canonical}:${valuePart}`);
        }
      }

      // Also check if levelPart is a canonical level name
      for (const level of hierarchy.levels) {
        if (levelPart === level) {
          // Add all aliases for this level
          for (const [alias, canonical] of Object.entries(hierarchy.aliases)) {
            if (canonical === level) {
              expanded.push(`${alias}:${valuePart}`);
            }
          }
        }
      }
    } else {
      // Original logic for simple tags
      for (const [alias, canonical] of Object.entries(hierarchy.aliases)) {
        if (tag === alias) {
          expanded.push(canonical);
        } else if (tag === canonical) {
          // Find all aliases for this canonical
          for (const [a, c] of Object.entries(hierarchy.aliases)) {
            if (c === canonical) {
              expanded.push(a);
            }
          }
        }
      }
    }

    return [...new Set(expanded)];
  }

  /**
   * Find the best matching tag from tool tags
   */
  private findBestMatchingTag(
    toolTags: string[],
    queryTags: string[],
    hierarchy: TagHierarchy
  ): string {
    let bestMatch = "";
    let bestScore = 0;

    for (const toolTag of toolTags) {
      for (const queryTag of queryTags) {
        const expandedQueryTags = this.config.enableAliases
          ? this.expandAliases(queryTag, hierarchy)
          : [queryTag];

        for (const eq of expandedQueryTags) {
          if (toolTag === eq) {
            if (1.0 > bestScore) {
              bestScore = 1.0;
              bestMatch = toolTag;
            }
          } else if (
            toolTag.toLowerCase().includes(eq.toLowerCase()) ||
            eq.toLowerCase().includes(toolTag.toLowerCase())
          ) {
            if (0.7 > bestScore) {
              bestScore = 0.7;
              bestMatch = toolTag;
            }
          }
        }
      }
    }

    return bestMatch;
  }

  /**
   * Check if match was expanded from an alias
   */
  private isExpandedFromAlias(
    matchedTag: string,
    queryTags: string[],
    hierarchy: TagHierarchy
  ): string | undefined {
    if (!this.config.enableAliases) {
      return undefined;
    }

    for (const queryTag of queryTags) {
      if (queryTag !== matchedTag) {
        // Check if queryTag is an alias of matchedTag
        for (const [alias, canonical] of Object.entries(hierarchy.aliases)) {
          if (alias === queryTag && canonical === matchedTag) {
            return queryTag;
          }
        }
      }
    }

    return undefined;
  }

  /**
   * Get the hierarchy level of a tag
   */
  private getTagLevel(tag: string, hierarchy: TagHierarchy): string {
    if (!tag) {
      return "unknown";
    }

    // Check if tag is in format "level:value" (e.g., "category:file")
    const colonIndex = tag.indexOf(":");
    if (colonIndex > 0) {
      const levelPart = tag.substring(0, colonIndex).toLowerCase();
      // Check if it's a valid level name or alias
      for (const level of hierarchy.levels) {
        if (levelPart === level.toLowerCase()) {
          return level;
        }
      }
      // Check if it's an alias
      for (const [alias, canonical] of Object.entries(hierarchy.aliases)) {
        if (levelPart === alias.toLowerCase()) {
          return canonical;
        }
      }
    }

    // Check if tag is a canonical level name
    for (const level of hierarchy.levels) {
      if (tag.toLowerCase() === level.toLowerCase()) {
        return level;
      }
    }

    // Check if tag is an alias
    for (const [alias, canonical] of Object.entries(hierarchy.aliases)) {
      if (tag.toLowerCase() === alias.toLowerCase()) {
        return canonical;
      }
    }

    return "tag"; // Default to lowest level
  }

  /**
   * Format error message
   */
  private formatError(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error occurred in TagMatchingEngine";
  }
}
````

## File: src/services/tool-retrieval/UnifiedScoringEngine.ts
````typescript
/**
 * UnifiedScoringEngine - RRF Fusion & Score Normalization
 *
 * Phase 1c: 统一评分引擎实现
 * Implements RRF fusion algorithm and weighted score combination
 */

import { logger } from "../../utils/logger";
import {
  UnifiedRetrievalResult,
  RetrievalResult,
  RetrievalMethod,
  FusionResult,
  HybridRetrievalError,
  HybridRetrievalErrorCode,
  DEFAULT_HYBRID_RETRIEVAL_CONFIG,
} from "../../types/enhanced-skill";

/**
 * Unified scoring engine interface
 */
export interface IUnifiedScoringEngine {
  fuseResults(
    vectorResults: RetrievalResult[],
    keywordResults: RetrievalResult[],
    semanticResults: RetrievalResult[],
    tagResults: RetrievalResult[]
  ): FusionResult;
  normalizeScores(results: RetrievalResult[]): RetrievalResult[];
  blendScores(result: RetrievalResult, weights: Record<RetrievalMethod, number>): number;
  deduplicateResults(results: UnifiedRetrievalResult[]): UnifiedRetrievalResult[];
  rerankResults(results: UnifiedRetrievalResult[], limit: number): UnifiedRetrievalResult[];
}

/**
 * Unified scoring engine configuration
 */
export interface UnifiedScoringEngineConfig {
  /** RRF constant k */
  rrfK: number;
  /** Score normalization method */
  normalizationMethod: "minmax" | "zscore" | "percentile";
  /** Default weights for each retrieval method */
  defaultWeights: Record<RetrievalMethod, number>;
  /** Minimum score threshold */
  minScore: number;
  /** Maximum results */
  maxResults: number;
}

/**
 * Default unified scoring engine configuration
 */
export const DEFAULT_SCORING_CONFIG: UnifiedScoringEngineConfig = {
  rrfK: DEFAULT_HYBRID_RETRIEVAL_CONFIG.rrfK,
  normalizationMethod: "minmax",
  defaultWeights: {
    vector: DEFAULT_HYBRID_RETRIEVAL_CONFIG.vectorWeight,
    keyword: DEFAULT_HYBRID_RETRIEVAL_CONFIG.keywordWeight,
    semantic: DEFAULT_HYBRID_RETRIEVAL_CONFIG.semanticWeight,
    tag: DEFAULT_HYBRID_RETRIEVAL_CONFIG.tagWeight,
  },
  minScore: DEFAULT_HYBRID_RETRIEVAL_CONFIG.minScore,
  maxResults: DEFAULT_HYBRID_RETRIEVAL_CONFIG.maxResults,
};

/**
 * UnifiedScoringEngine implementation
 * Handles RRF fusion, score normalization, and result deduplication
 */
export class UnifiedScoringEngine implements IUnifiedScoringEngine {
  private readonly _logger = logger;
  private readonly config: UnifiedScoringEngineConfig;

  constructor(config?: Partial<UnifiedScoringEngineConfig>) {
    this.config = { ...DEFAULT_SCORING_CONFIG, ...config };
    this._logger.info("[UnifiedScoringEngine] Initialized with config:", {
      rrfK: this.config.rrfK,
      normalizationMethod: this.config.normalizationMethod,
      defaultWeights: this.config.defaultWeights,
    });
  }

  /**
   * Fuse results from multiple retrieval methods using RRF
   */
  fuseResults(
    vectorResults: RetrievalResult[],
    keywordResults: RetrievalResult[],
    semanticResults: RetrievalResult[],
    tagResults: RetrievalResult[]
  ): FusionResult {
    const startTime = Date.now();

    try {
      this._logger.info("[UnifiedScoringEngine] Fusing results from 4 retrieval methods", {
        vectorCount: vectorResults.length,
        keywordCount: keywordResults.length,
        semanticCount: semanticResults.length,
        tagCount: tagResults.length,
      });

      // Create result maps for each method
      const resultMaps: Map<string, RetrievalResult[]> = new Map();
      resultMaps.set("vector", vectorResults);
      resultMaps.set("keyword", keywordResults);
      resultMaps.set("semantic", semanticResults);
      resultMaps.set("tag", tagResults);

      // Collect all unique result IDs
      const allIds: Set<string> = new Set();
      for (const results of resultMaps.values()) {
        for (const result of results) {
          allIds.add(result.id);
        }
      }

      // Normalize scores for each method to 0-1 range
      const normalizedMaps: Map<string, RetrievalResult[]> = new Map();
      for (const [method, results] of resultMaps) {
        normalizedMaps.set(method, this.normalizeScores(results));
      }

      // Count active methods (methods with results)
      const activeMethods = Array.from(resultMaps.entries()).filter(
        ([, results]) => results.length > 0
      ).length;

      // Calculate RRF scores for each result
      const unifiedResults: UnifiedRetrievalResult[] = [];

      for (const id of allIds) {
        const ranks: { vector: number; keyword: number; semantic: number; tag: number } = {
          vector: 0,
          keyword: 0,
          semantic: 0,
          tag: 0,
        };
        const scores: { vector: number; keyword: number; semantic: number; tag: number } = {
          vector: 0,
          keyword: 0,
          semantic: 0,
          tag: 0,
        };

        // Get rank, original score, and normalized score from each method
        for (const [method, results] of resultMaps) {
          const rank = results.findIndex((r) => r.id === id) + 1;
          const normalizedResults = normalizedMaps.get(method) || [];
          const normalizedResult = normalizedResults.find((r) => r.id === id);

          if (rank > 0) {
            (ranks as Record<string, number>)[method] = rank;
            (scores as Record<string, number>)[method] = normalizedResult?.score || 0;
          }
        }

        // Calculate RRF score for each method
        const rrfScores: Record<RetrievalMethod, number> = {
          vector: ranks.vector > 0 ? 1 / (this.config.rrfK + ranks.vector) : 0,
          keyword: ranks.keyword > 0 ? 1 / (this.config.rrfK + ranks.keyword) : 0,
          semantic: ranks.semantic > 0 ? 1 / (this.config.rrfK + ranks.semantic) : 0,
          tag: ranks.tag > 0 ? 1 / (this.config.rrfK + ranks.tag) : 0,
        };

        // Calculate unified score combining normalized scores and RRF scores
        const unifiedScore = this.calculateHybridScore(scores, rrfScores, activeMethods);

        // Get tool info from any result that has it
        const toolInfo = this.getToolInfo(id, resultMaps);

        // Include all results
        unifiedResults.push({
          id,
          name: toolInfo.name || "",
          description: toolInfo.description || "",
          unifiedScore,
          scores,
          ranks,
          tags: toolInfo.tags || [],
          toolType: toolInfo.toolType || "skill",
          disclosure: {
            level: 0 as any,
            name: toolInfo.name || "",
            description: toolInfo.description || "",
            tokenCount: 0,
          },
          path: toolInfo.path,
          version: toolInfo.version,
          metadata: toolInfo.metadata,
        });
      }

      // Sort by unified score
      unifiedResults.sort((a, b) => b.unifiedScore - a.unifiedScore);

      // Apply intelligent filtering based on score distribution
      let filteredResults = unifiedResults;
      if (activeMethods > 1 && unifiedResults.length > 1) {
        const scores = unifiedResults.map((r) => r.unifiedScore);

        // Calculate score gap between consecutive results
        let maxGap = 0;
        for (let i = 0; i < scores.length - 1; i++) {
          const gap = scores[i] - scores[i + 1];
          if (gap > maxGap) {
            maxGap = gap;
          }
        }

        // If there's a large gap between top results and lower results, filter out the lower ones
        if (maxGap > 0.3) {
          // Find the cutoff point (where the large gap occurs)
          let cutoffIndex = 0;
          for (let i = 0; i < scores.length - 1; i++) {
            if (scores[i] - scores[i + 1] === maxGap) {
              cutoffIndex = i;
              break;
            }
          }
          filteredResults = unifiedResults.slice(0, cutoffIndex + 1);
        } else {
          // No large gap, keep all results
          filteredResults = unifiedResults;
        }
      } else if (activeMethods === 1 && unifiedResults.length > 1) {
        // For single method, use adaptive filtering based on original score range
        // Get the original scores directly from resultMaps
        let originalScores: number[] = [];
        for (const [method, results] of resultMaps) {
          if (results.length > 0) {
            originalScores = results.map((r) => r.score);
            break;
          }
        }
        const maxOriginalScore = Math.max(...originalScores);
        const minOriginalScore = Math.min(...originalScores);

        // If score range is large (max > 10x min), apply stricter filtering
        if (
          maxOriginalScore > 0 &&
          minOriginalScore > 0 &&
          maxOriginalScore / minOriginalScore > 10
        ) {
          // Apply minScore threshold
          filteredResults = unifiedResults.filter((r) => r.unifiedScore >= this.config.minScore);
        } else {
          // Score range is small, keep all results
          filteredResults = unifiedResults;
        }
      }

      // Apply deduplication
      const deduplicatedResults = this.deduplicateResults(filteredResults);

      // Apply reranking
      const rerankedResults = this.rerankResults(deduplicatedResults, this.config.maxResults);

      const duration = Date.now() - startTime;
      this._logger.debug(`[UnifiedScoringEngine] Fusion completed in ${duration}ms`, {
        inputCount: allIds.size,
        outputCount: rerankedResults.length,
      });

      return {
        results: rerankedResults,
        config: {
          k: this.config.rrfK,
          weights: this.config.defaultWeights,
          normalization: this.config.normalizationMethod,
        },
        duration,
        deduplicatedCount: allIds.size - deduplicatedResults.length,
      };
    } catch (error) {
      this._logger.error("[UnifiedScoringEngine] Fusion failed:", error);
      throw new HybridRetrievalError(
        `Score fusion failed: ${this.formatError(error)}`,
        HybridRetrievalErrorCode.FUSION_ERROR
      );
    }
  }

  /**
   * Normalize scores using min-max normalization
   */
  normalizeScores(results: RetrievalResult[]): RetrievalResult[] {
    if (results.length === 0) {
      return results;
    }

    // Find min and max scores
    const scores = results.map((r) => r.score);
    const minScore = Math.min(...scores);
    const maxScore = Math.max(...scores);
    const scoreRange = maxScore - minScore;

    // Apply min-max normalization
    if (scoreRange === 0) {
      // All scores are the same, set to 1
      return results.map((r) => ({ ...r, score: 1 }));
    }

    return results.map((r) => ({
      ...r,
      score: (r.score - minScore) / scoreRange,
    }));
  }

  /**
   * Blend multiple scores using weighted combination
   */
  blendScores(result: RetrievalResult, weights: Record<RetrievalMethod, number>): number {
    // This is a placeholder - actual blending happens in fuseResults
    return result.score;
  }

  /**
   * Deduplicate results by ID
   */
  deduplicateResults(results: UnifiedRetrievalResult[]): UnifiedRetrievalResult[] {
    const seen: Set<string> = new Set();
    const deduplicated: UnifiedRetrievalResult[] = [];

    for (const result of results) {
      if (!seen.has(result.id)) {
        seen.add(result.id);
        deduplicated.push(result);
      }
    }

    return deduplicated;
  }

  /**
   * Rerank results with diversity consideration
   */
  rerankResults(results: UnifiedRetrievalResult[], limit: number): UnifiedRetrievalResult[] {
    // Take top results with diversity consideration
    const selected: UnifiedRetrievalResult[] = [];
    const selectedTypes: Set<string> = new Set();

    for (const result of results) {
      if (selected.length >= limit) {
        break;
      }

      // Prefer results with different tool types for diversity
      if (!selectedTypes.has(result.toolType) || selected.length < limit / 2) {
        selected.push(result);
        selectedTypes.add(result.toolType);
      } else if (selected.length < limit) {
        selected.push(result);
      }
    }

    // Re-sort by unified score
    selected.sort((a, b) => b.unifiedScore - a.unifiedScore);

    return selected;
  }

  /**
   * Calculate unified score from RRF scores
   */
  private calculateUnifiedScore(
    rrfScores: Record<RetrievalMethod, number>,
    weights: Record<RetrievalMethod, number>
  ): number {
    let totalWeight = 0;
    let weightedSum = 0;

    for (const method of Object.keys(rrfScores) as RetrievalMethod[]) {
      weightedSum += rrfScores[method] * weights[method];
      totalWeight += weights[method];
    }

    // Normalize by total weight
    return totalWeight > 0 ? weightedSum / totalWeight : 0;
  }

  /**
   * Calculate hybrid score combining normalized scores and RRF scores
   * For single-method results: use normalized scores directly
   * For multi-method results: combine normalized scores with RRF-based fusion
   */
  private calculateHybridScore(
    normalizedScores: Record<RetrievalMethod, number>,
    rrfScores: Record<RetrievalMethod, number>,
    activeMethodCount: number
  ): number {
    if (activeMethodCount === 1) {
      // For single method, use the highest normalized score
      let maxScore = 0;
      for (const method of Object.keys(normalizedScores) as RetrievalMethod[]) {
        maxScore = Math.max(maxScore, normalizedScores[method]);
      }
      return maxScore;
    }

    // For multiple methods, combine normalized scores using weights
    let weightedScore = 0;
    let totalWeight = 0;

    for (const method of Object.keys(normalizedScores) as RetrievalMethod[]) {
      const weight = this.config.defaultWeights[method];
      weightedScore += normalizedScores[method] * weight;
      totalWeight += weight;
    }

    return totalWeight > 0 ? weightedScore / totalWeight : 0;
  }

  /**
   * Get tool info from result maps
   */
  private getToolInfo(
    id: string,
    resultMaps: Map<string, RetrievalResult[]>
  ): {
    name?: string;
    description?: string;
    tags?: string[];
    toolType?: "skill" | "mcp" | "builtin";
    path?: string;
    version?: string;
    metadata?: Record<string, unknown>;
  } {
    for (const results of resultMaps.values()) {
      const result = results.find((r) => r.id === id);
      if (result && result.metadata) {
        return result.metadata as any;
      }
    }

    return {};
  }

  /**
   * Format error message
   */
  private formatError(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error occurred in UnifiedScoringEngine";
  }
}
````

## File: src/services/warmup/ApplicationWarmupService.ts
````typescript
/**
 * ApplicationWarmupService - 应用启动预热服务
 *
 * 提供完整的应用预热功能：
 * - 数据库连接预热
 * - 向量索引预热加载
 * - 嵌入缓存预热
 * - 搜索缓存预热
 *
 * 预期效果：首次查询延迟从 500-1000ms 降低到 50-100ms
 */

import { logger } from "../../utils/logger";
import { IndexPrewarmService } from "./IndexPrewarmService";
import { CacheWarmupManager } from "./CacheWarmupManager";
import { LLMConfigService } from "../LLMConfigService";

/**
 * 预热配置
 */
export interface WarmupConfig {
  enabled: boolean;
  timeoutMs: number;
  databaseWarmup: {
    enabled: boolean;
    priority: string[];
  };
  indexWarmup: {
    enabled: boolean;
    queryCount: number;
  };
  embeddingCacheWarmup: {
    enabled: boolean;
    sampleCount: number;
  };
  searchCacheWarmup: {
    enabled: boolean;
    queryCount: number;
  };
}

/**
 * 预热状态
 */
export interface WarmupStatus {
  isComplete: boolean;
  startTime: Date | null;
  endTime: Date | null;
  totalDuration: number;
  phases: {
    database: { status: string; duration: number };
    index: { status: string; duration: number };
    embedding: { status: string; duration: number };
    search: { status: string; duration: number };
  };
  errors: string[];
}

/**
 * 默认配置
 */
const DEFAULT_CONFIG: WarmupConfig = {
  enabled: true,
  timeoutMs: 60000,
  databaseWarmup: {
    enabled: true,
    priority: ["sqlite"],
  },
  indexWarmup: {
    enabled: true,
    queryCount: 100,
  },
  embeddingCacheWarmup: {
    enabled: true,
    sampleCount: 100,
  },
  searchCacheWarmup: {
    enabled: true,
    queryCount: 100,
  },
};

/**
 * ApplicationWarmupService - 应用启动预热管理
 */
export class ApplicationWarmupService {
  private config: WarmupConfig;
  private status: WarmupStatus;
  private indexPrewarmService: IndexPrewarmService;
  private cacheWarmupManager: CacheWarmupManager;
  private isRunning = false;

  constructor(config?: Partial<WarmupConfig>) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.status = {
      isComplete: false,
      startTime: null,
      endTime: null,
      totalDuration: 0,
      phases: {
        database: { status: "pending", duration: 0 },
        index: { status: "pending", duration: 0 },
        embedding: { status: "pending", duration: 0 },
        search: { status: "pending", duration: 0 },
      },
      errors: [],
    };
    this.indexPrewarmService = new IndexPrewarmService();
    this.cacheWarmupManager = new CacheWarmupManager();

    logger.info("[ApplicationWarmupService] Initialized with config:", {
      enabled: this.config.enabled,
      timeoutMs: this.config.timeoutMs,
    });
  }

  /**
   * 执行完整预热流程
   */
  async warmup(): Promise<WarmupStatus> {
    if (!this.config.enabled) {
      logger.info("[ApplicationWarmupService] Warmup disabled, skipping");
      return this.status;
    }

    if (this.isRunning) {
      logger.warn("[ApplicationWarmupService] Warmup already in progress");
      return this.status;
    }

    this.isRunning = true;
    this.status.startTime = new Date();

    try {
      logger.info("[ApplicationWarmupService] Starting application warmup...");

      // 设置超时
      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error("Warmup timeout")), this.config.timeoutMs);
      });

      const warmupPromise = this.executeWarmup();

      await Promise.race([warmupPromise, timeoutPromise]);

      this.status.isComplete = true;
      logger.info("[ApplicationWarmupService] Warmup completed successfully");
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      this.status.errors.push(errorMessage);
      logger.error("[ApplicationWarmupService] Warmup failed:", error);
    } finally {
      this.status.endTime = new Date();
      this.status.totalDuration = this.status.endTime.getTime() - this.status.startTime!.getTime();
      this.isRunning = false;
    }

    return this.status;
  }

  /**
   * 执行预热步骤
   */
  private async executeWarmup(): Promise<void> {
    if (this.config.databaseWarmup.enabled) {
      await this.warmupDatabase();
    }

    if (this.config.indexWarmup.enabled) {
      await this.warmupIndex();
    }

    if (this.config.embeddingCacheWarmup.enabled) {
      await this.warmupEmbeddingCache();
    }

    if (this.config.searchCacheWarmup.enabled) {
      await this.warmupSearchCache();
    }
  }

  /**
   * 数据库连接预热
   */
  private async warmupDatabase(): Promise<void> {
    const startTime = Date.now();

    try {
      logger.info("[ApplicationWarmupService] Warming up database connections...");

      if (this.config.databaseWarmup.priority.includes("sqlite")) {
        const llmConfigService = LLMConfigService.getInstance();
        const providers = llmConfigService.listProviders();
        logger.debug(
          `[ApplicationWarmupService] SQLite connection warmed up (${providers.length} providers)`
        );
      }

      this.status.phases.database = {
        status: "complete",
        duration: Date.now() - startTime,
      };

      logger.info(
        `[ApplicationWarmupService] Database warmup completed in ${this.status.phases.database.duration}ms`
      );
    } catch (error) {
      this.status.phases.database = {
        status: "failed",
        duration: Date.now() - startTime,
      };
      throw error;
    }
  }

  /**
   * 向量索引预热
   */
  private async warmupIndex(): Promise<void> {
    const startTime = Date.now();

    try {
      logger.info("[ApplicationWarmupService] Warming up vector indexes...");

      await this.indexPrewarmService.prewarm({
        queryCount: this.config.indexWarmup.queryCount,
      });

      this.status.phases.index = {
        status: "complete",
        duration: Date.now() - startTime,
      };

      logger.info(
        `[ApplicationWarmupService] Index warmup completed in ${this.status.phases.index.duration}ms`
      );
    } catch (error) {
      this.status.phases.index = {
        status: "failed",
        duration: Date.now() - startTime,
      };
      throw error;
    }
  }

  /**
   * 嵌入缓存预热
   */
  private async warmupEmbeddingCache(): Promise<void> {
    const startTime = Date.now();

    try {
      logger.info("[ApplicationWarmupService] Warming up embedding cache...");

      await this.cacheWarmupManager.warmupEmbeddingCache({
        sampleCount: this.config.embeddingCacheWarmup.sampleCount,
      });

      this.status.phases.embedding = {
        status: "complete",
        duration: Date.now() - startTime,
      };

      logger.info(
        `[ApplicationWarmupService] Embedding cache warmup completed in ${this.status.phases.embedding.duration}ms`
      );
    } catch (error) {
      this.status.phases.embedding = {
        status: "failed",
        duration: Date.now() - startTime,
      };
      throw error;
    }
  }

  /**
   * 搜索缓存预热
   */
  private async warmupSearchCache(): Promise<void> {
    const startTime = Date.now();

    try {
      logger.info("[ApplicationWarmupService] Warming up search cache...");

      await this.cacheWarmupManager.warmupSearchCache({
        queryCount: this.config.searchCacheWarmup.queryCount,
      });

      this.status.phases.search = {
        status: "complete",
        duration: Date.now() - startTime,
      };

      logger.info(
        `[ApplicationWarmupService] Search cache warmup completed in ${this.status.phases.search.duration}ms`
      );
    } catch (error) {
      this.status.phases.search = {
        status: "failed",
        duration: Date.now() - startTime,
      };
      throw error;
    }
  }

  /**
   * 获取预热状态
   */
  getStatus(): WarmupStatus {
    return { ...this.status };
  }

  /**
   * 检查是否完成预热
   */
  isReady(): boolean {
    return this.status.isComplete;
  }

  /**
   * 获取配置
   */
  getConfig(): WarmupConfig {
    return { ...this.config };
  }

  /**
   * 更新配置
   */
  updateConfig(config: Partial<WarmupConfig>): void {
    this.config = { ...this.config, ...config };
  }
}

// 单例实例
let warmupServiceInstance: ApplicationWarmupService | null = null;

export function getWarmupService(): ApplicationWarmupService {
  if (!warmupServiceInstance) {
    warmupServiceInstance = new ApplicationWarmupService();
  }
  return warmupServiceInstance;
}

export function resetWarmupService(): void {
  warmupServiceInstance = null;
}
````

## File: src/services/warmup/CacheWarmupManager.ts
````typescript
/**
 * CacheWarmupManager - 缓存预热管理器
 *
 * 负责预热各种缓存：
 * - 嵌入缓存
 * - 搜索结果缓存
 */

import { logger } from "../../utils/logger";
import { EmbeddingGenerator } from "../tool-retrieval/EmbeddingGenerator";
import { ToolRetrievalService } from "../tool-retrieval/ToolRetrievalService";
import { ToolRetrievalConfig, EmbeddingConfig } from "../tool-retrieval/types";

/**
 * 嵌入缓存预热配置
 */
export interface EmbeddingCacheWarmupConfig {
  sampleCount: number;
  timeoutMs: number;
}

/**
 * 搜索缓存预热配置
 */
export interface SearchCacheWarmupConfig {
  queryCount: number;
  timeoutMs: number;
}

/**
 * 预热结果
 */
export interface CacheWarmupResult {
  success: boolean;
  itemsWarmed: number;
  errors: string[];
  duration: number;
}

/**
 * 预热查询样例
 */
const SAMPLE_SEARCH_QUERIES = [
  "file operations",
  "text processing",
  "data analysis",
  "api calls",
  "database queries",
  "user authentication",
  "error handling",
  "logging",
  "configuration",
  "testing",
];

/**
 * CacheWarmupManager - 缓存预热管理
 */
export class CacheWarmupManager {
  private embeddingConfig: EmbeddingConfig | null = null;
  private embeddingGenerator: EmbeddingGenerator | null = null;
  private toolRetrievalService: ToolRetrievalService | null = null;

  constructor() {
    logger.info("[CacheWarmupManager] Initialized");
  }

  /**
   * 预热嵌入缓存
   */
  async warmupEmbeddingCache(
    options?: Partial<EmbeddingCacheWarmupConfig>
  ): Promise<CacheWarmupResult> {
    const config = {
      sampleCount: options?.sampleCount || 50,
      timeoutMs: options?.timeoutMs || 30000,
    };

    const startTime = Date.now();
    const errors: string[] = [];
    let itemsWarmed = 0;

    try {
      logger.info(
        `[CacheWarmupManager] Starting embedding cache warmup with ${config.sampleCount} samples...`
      );

      // 初始化 EmbeddingGenerator
      if (!this.embeddingGenerator) {
        const embeddingConfig: EmbeddingConfig = {
          provider: "openai",
          model: "text-embedding-3-small",
          dimensions: 1536,
        };
        this.embeddingGenerator = new EmbeddingGenerator(embeddingConfig);
      }

      // 生成预热文本
      const warmupTexts = this.generateWarmupTexts(config.sampleCount);

      // 分批生成嵌入
      const batchSize = 10;
      for (let i = 0; i < warmupTexts.length; i += batchSize) {
        const batch = warmupTexts.slice(i, i + batchSize);

        try {
          const result = await this.generateBatchWithTimeout(batch, config.timeoutMs);
          if (result) {
            itemsWarmed += batch.length;
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          errors.push(`Batch ${Math.floor(i / batchSize) + 1} failed: ${errorMessage}`);
        }
      }

      logger.info(
        `[CacheWarmupManager] Embedding cache warmup completed: ${itemsWarmed} items warmed, ${errors.length} failures`
      );

      return {
        success: errors.length === 0,
        itemsWarmed,
        errors,
        duration: Date.now() - startTime,
      };
    } catch (error) {
      logger.error("[CacheWarmupManager] Embedding cache warmup failed:", error);

      return {
        success: false,
        itemsWarmed,
        errors: [error instanceof Error ? error.message : "Unknown error"],
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * 预热搜索缓存
   */
  async warmupSearchCache(options?: Partial<SearchCacheWarmupConfig>): Promise<CacheWarmupResult> {
    const config = {
      queryCount: options?.queryCount || 50,
      timeoutMs: options?.timeoutMs || 5000,
    };

    const startTime = Date.now();
    const errors: string[] = [];
    let itemsWarmed = 0;

    try {
      logger.info(
        `[CacheWarmupManager] Starting search cache warmup with ${config.queryCount} queries...`
      );

      // 初始化 ToolRetrievalService
      if (!this.toolRetrievalService) {
        const retrievalConfig: ToolRetrievalConfig = {
          vectorDbPath: "./.data/tools.lance",
          model: "text-embedding-3-small",
          dimensions: 1536,
          similarityThreshold: 0.4,
          maxResults: 10,
          cacheSize: 1000,
        };
        this.toolRetrievalService = new ToolRetrievalService(retrievalConfig);
        await this.toolRetrievalService.initialize();
      }

      // 生成预热查询
      const queries = this.generateWarmupQueries(config.queryCount);

      // 执行预热查询
      for (const query of queries) {
        try {
          const result = await this.executeSearchWithTimeout(
            this.toolRetrievalService,
            query,
            config.timeoutMs
          );
          if (result) {
            itemsWarmed++;
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          errors.push(`Query "${query.substring(0, 30)}..." failed: ${errorMessage}`);
        }
      }

      logger.info(
        `[CacheWarmupManager] Search cache warmup completed: ${itemsWarmed} queries warmed, ${errors.length} failures`
      );

      return {
        success: errors.length === 0,
        itemsWarmed,
        errors,
        duration: Date.now() - startTime,
      };
    } catch (error) {
      logger.error("[CacheWarmupManager] Search cache warmup failed:", error);

      return {
        success: false,
        itemsWarmed,
        errors: [error instanceof Error ? error.message : "Unknown error"],
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * 生成预热文本
   */
  private generateWarmupTexts(count: number): string[] {
    const texts: string[] = [];
    const categories = [
      "function",
      "tool",
      "skill",
      "api",
      "service",
      "module",
      "utility",
      "handler",
      "manager",
      "service",
    ];

    for (let i = 0; i < count; i++) {
      const category = categories[i % categories.length];
      const name = `${category}-${i}`;
      const description = `This is a ${category} that provides ${category} functionality for the system`;
      const tags = [category, "warmup", "sample"];

      texts.push(`${name} ${description} ${tags.join(" ")}`);
    }

    return texts;
  }

  /**
   * 生成预热查询
   */
  private generateWarmupQueries(count: number): string[] {
    const queries: string[] = [];

    for (let i = 0; i < count; i++) {
      const baseQuery = SAMPLE_SEARCH_QUERIES[i % SAMPLE_SEARCH_QUERIES.length];
      queries.push(`${baseQuery} ${i}`);
    }

    return queries;
  }

  /**
   * 批量生成嵌入（带超时）
   */
  private async generateBatchWithTimeout(texts: string[], timeoutMs: number): Promise<boolean> {
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        logger.warn(`[CacheWarmupManager] Batch generation timeout for ${texts.length} texts`);
        resolve(false);
      }, timeoutMs);

      if (this.embeddingGenerator) {
        this.embeddingGenerator
          .generateBatch(texts)
          .then(() => {
            clearTimeout(timeout);
            resolve(true);
          })
          .catch(() => {
            clearTimeout(timeout);
            resolve(false);
          });
      } else {
        clearTimeout(timeout);
        resolve(false);
      }
    });
  }

  /**
   * 执行搜索（带超时）
   */
  private async executeSearchWithTimeout(
    service: ToolRetrievalService,
    query: string,
    timeoutMs: number
  ): Promise<boolean> {
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        logger.warn(
          `[CacheWarmupManager] Search timeout for query: "${query.substring(0, 30)}..."`
        );
        resolve(false);
      }, timeoutMs);

      service
        .findRelevantSkills(query, 5)
        .then(() => {
          clearTimeout(timeout);
          resolve(true);
        })
        .catch(() => {
          clearTimeout(timeout);
          resolve(false);
        });
    });
  }
}
````

## File: src/services/warmup/index.ts
````typescript
/**
 * Warmup Services - 应用启动预热模块
 *
 * 提供完整的应用预热功能：
 * - 数据库连接预热
 * - 向量索引预热
 * - 嵌入缓存预热
 * - 搜索缓存预热
 */

// 导出主预热服务
export {
  ApplicationWarmupService,
  getWarmupService,
  resetWarmupService,
  type WarmupConfig,
  type WarmupStatus,
} from "./ApplicationWarmupService";

// 导出索引预热服务
export {
  IndexPrewarmService,
  type IndexPrewarmConfig,
  type IndexPrewarmResult,
} from "./IndexPrewarmService";

// 导出缓存预热管理器
export {
  CacheWarmupManager,
  type EmbeddingCacheWarmupConfig,
  type SearchCacheWarmupConfig,
  type CacheWarmupResult,
} from "./CacheWarmupManager";
````

## File: src/services/warmup/IndexPrewarmService.ts
````typescript
/**
 * IndexPrewarmService - 向量索引预热服务
 *
 * 负责预热 LanceDB 向量索引，减少首次查询延迟
 */

import { logger } from "../../utils/logger";
import { ToolRetrievalService } from "../tool-retrieval/ToolRetrievalService";
import { ToolRetrievalConfig } from "../tool-retrieval/types";

/**
 * 预热配置
 */
export interface IndexPrewarmConfig {
  queryCount: number;
  queryTimeoutMs: number;
}

/**
 * 预热结果
 */
export interface IndexPrewarmResult {
  success: boolean;
  queriesExecuted: number;
  errors: string[];
  duration: number;
}

/**
 * 预热查询样例
 */
const SAMPLE_QUERIES = [
  "search tools",
  "find skills",
  "retrieve functions",
  "get capabilities",
  "query assistants",
  "list functions",
  "search agents",
  "find executors",
  "get tools",
  "retrieve skills",
  "query plugins",
  "list agents",
  "search capabilities",
  "find helpers",
  "get functions",
  "retrieve executors",
  "query assistants",
  "list tools",
  "search skills",
  "find plugins",
];

/**
 * IndexPrewarmService - 向量索引预热
 */
export class IndexPrewarmService {
  private config: IndexPrewarmConfig;
  private hasWarmed = false;
  private toolRetrievalService: ToolRetrievalService | null = null;

  constructor(config?: Partial<IndexPrewarmConfig>) {
    this.config = {
      queryCount: 100,
      queryTimeoutMs: 5000,
      ...config,
    };
    logger.info("[IndexPrewarmService] Initialized");
  }

  /**
   * 预热向量索引
   */
  async prewarm(options?: Partial<IndexPrewarmConfig>): Promise<IndexPrewarmResult> {
    const config = { ...this.config, ...options };
    const startTime = Date.now();
    const errors: string[] = [];
    let queriesExecuted = 0;

    if (this.hasWarmed) {
      logger.debug("[IndexPrewarmService] Already warmed up, skipping");
      return {
        success: true,
        queriesExecuted: 0,
        errors: [],
        duration: Date.now() - startTime,
      };
    }

    try {
      logger.info(
        `[IndexPrewarmService] Starting index prewarm with ${config.queryCount} queries...`
      );

      // 初始化 ToolRetrievalService
      if (!this.toolRetrievalService) {
        const retrievalConfig: ToolRetrievalConfig = {
          vectorDbPath: "./.data/tools.lance",
          model: "text-embedding-3-small",
          dimensions: 1536,
          similarityThreshold: 0.4,
          maxResults: 10,
          cacheSize: 1000,
        };
        this.toolRetrievalService = new ToolRetrievalService(retrievalConfig);
      }

      // 初始化服务
      await this.toolRetrievalService.initialize();

      // 执行预热查询
      const queries = this.generateQueries(config.queryCount);

      for (const query of queries) {
        try {
          const result = await this.executeQueryWithTimeout(
            this.toolRetrievalService,
            query,
            config.queryTimeoutMs
          );
          if (result) {
            queriesExecuted++;
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          errors.push(`Query "${query.substring(0, 30)}..." failed: ${errorMessage}`);
        }
      }

      this.hasWarmed = true;

      logger.info(
        `[IndexPrewarmService] Index prewarm completed: ${queriesExecuted} queries successful, ${errors.length} failed`
      );

      return {
        success: errors.length === 0,
        queriesExecuted,
        errors,
        duration: Date.now() - startTime,
      };
    } catch (error) {
      logger.error("[IndexPrewarmService] Index prewarm failed:", error);

      return {
        success: false,
        queriesExecuted,
        errors: [error instanceof Error ? error.message : "Unknown error"],
        duration: Date.now() - startTime,
      };
    }
  }

  /**
   * 生成预热查询
   */
  private generateQueries(count: number): string[] {
    const queries: string[] = [];

    for (let i = 0; i < count; i++) {
      const baseQuery = SAMPLE_QUERIES[i % SAMPLE_QUERIES.length];
      const variant = `${baseQuery} ${i}`;
      queries.push(variant);
    }

    return queries;
  }

  /**
   * 带超时的查询执行
   */
  private async executeQueryWithTimeout(
    service: ToolRetrievalService,
    query: string,
    timeoutMs: number
  ): Promise<boolean> {
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        logger.warn(`[IndexPrewarmService] Query timeout: "${query.substring(0, 30)}..."`);
        resolve(false);
      }, timeoutMs);

      service
        .findRelevantSkills(query, 5)
        .then(() => {
          clearTimeout(timeout);
          resolve(true);
        })
        .catch(() => {
          clearTimeout(timeout);
          resolve(false);
        });
    });
  }

  /**
   * 检查是否已预热
   */
  isReady(): boolean {
    return this.hasWarmed;
  }

  /**
   * 重置预热状态（用于测试）
   */
  reset(): void {
    this.hasWarmed = false;
  }
}
````

## File: src/services/DatabaseManager.ts
````typescript
/**
 * DatabaseManager - 数据库连接管理器
 * 统一管理所有 SQLite 数据库连接
 */

import Database from "better-sqlite3";
import { logger } from "../utils/logger";
import { PathService } from "./PathService";

export interface DatabaseConfig {
  name: string;
  path: string;
  options?: {
    wal?: boolean;
    foreignKeys?: boolean;
  };
}

export class DatabaseManager {
  private static _instance: DatabaseManager | null = null;
  private connections: Map<string, Database.Database> = new Map();
  private configs: Map<string, DatabaseConfig> = new Map();

  private constructor() {
    this.initializeDefaultDatabases();
  }

  static getInstance(): DatabaseManager {
    if (!DatabaseManager._instance) {
      DatabaseManager._instance = new DatabaseManager();
    }
    return DatabaseManager._instance;
  }

  /**
   * 初始化默认数据库配置
   */
  private initializeDefaultDatabases(): void {
    const pathService = PathService.getInstance();
    const dataPath = pathService.getDataDir();

    this.register({
      name: "llm_config",
      path: `${dataPath}/llm_config.db`,
      options: { wal: true, foreignKeys: true },
    });

    this.register({
      name: "conversations",
      path: `${dataPath}/conversations.db`,
      options: { wal: true, foreignKeys: true },
    });

    this.register({
      name: "mcp_servers",
      path: `${dataPath}/mcp_servers.db`,
      options: { wal: true, foreignKeys: true },
    });

    this.register({
      name: "trajectory",
      path: `${dataPath}/trajectory.db`,
      options: { wal: true, foreignKeys: true },
    });

    logger.debug("[DatabaseManager] Initialized default database configurations");
  }

  /**
   * 注册数据库配置
   */
  register(config: DatabaseConfig): void {
    this.configs.set(config.name, config);
    logger.debug(`[DatabaseManager] Registered database: ${config.name}`);
  }

  /**
   * 获取数据库连接
   */
  getConnection(name: string): Database.Database {
    if (!this.connections.has(name)) {
      const config = this.configs.get(name);
      if (!config) {
        throw new Error(`Database not registered: ${name}`);
      }
      this.connections.set(name, this.createConnection(config));
    }
    return this.connections.get(name)!;
  }

  /**
   * 创建数据库连接
   */
  private createConnection(config: DatabaseConfig): Database.Database {
    const db = new Database(config.path);

    if (config.options?.wal !== false) {
      db.pragma("journal_mode = WAL");
    }

    if (config.options?.foreignKeys !== false) {
      db.pragma("foreign_keys = ON");
    }

    logger.debug(`[DatabaseManager] Connected to ${config.name}: ${config.path}`);
    return db;
  }

  /**
   * 检查数据库连接是否存在
   */
  hasConnection(name: string): boolean {
    return this.connections.has(name);
  }

  /**
   * 关闭指定数据库连接
   */
  async close(name: string): Promise<void> {
    const connection = this.connections.get(name);
    if (connection) {
      connection.close();
      this.connections.delete(name);
      logger.debug(`[DatabaseManager] Closed connection: ${name}`);
    }
  }

  /**
   * 关闭所有数据库连接
   */
  async closeAll(): Promise<void> {
    for (const [name, connection] of this.connections) {
      connection.close();
      logger.debug(`[DatabaseManager] Closed connection: ${name}`);
    }
    this.connections.clear();
  }

  /**
   * 获取所有已注册的数据库名称
   */
  getDatabaseNames(): string[] {
    return Array.from(this.configs.keys());
  }

  /**
   * 获取所有活动连接数量
   */
  getActiveConnectionCount(): number {
    return this.connections.size;
  }
}
````

## File: src/services/MCPConfigService.ts
````typescript
/**
 * MCPConfigService - MCP 配置管理服务
 *
 * 负责MCP服务器配置的持久化存储和管理
 */

import Database from 'better-sqlite3';
import * as fs from 'fs';
import * as path from 'path';
import { logger } from '../utils/logger';
import { PathService } from './PathService';
import type { MCPServerConfig } from '../types/mcp';

export interface MCPServerRecord {
  id: string;
  config: MCPServerConfig;
  created_at: number;
  updated_at: number;
}

/**
 * MCP 配置服务
 */
export class MCPConfigService {
  private static instance: MCPConfigService;
  private db: Database.Database;
  private dbPath: string;

  private constructor() {
    const pathService = PathService.getInstance();
    const dataDir = pathService.getDataDir();

    // 确保数据目录存在
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }

    this.dbPath = path.join(dataDir, 'mcp_servers.db');
    this.db = new Database(this.dbPath);

    // 启用 WAL 模式提升性能
    this.db.pragma('journal_mode = WAL');
    // 启用外键约束
    this.db.pragma('foreign_keys = ON');

    this.initializeDatabase();
    logger.debug(`MCPConfigService initialized (database: ${this.dbPath})`);
  }

  /**
   * 获取单例实例
   */
  public static getInstance(): MCPConfigService {
    if (!MCPConfigService.instance) {
      MCPConfigService.instance = new MCPConfigService();
    }
    return MCPConfigService.instance;
  }

  /**
   * 初始化数据库表结构
   */
  private initializeDatabase(): void {
    this.db.exec(`
      -- MCP 服务器配置表
      CREATE TABLE IF NOT EXISTS mcp_servers (
        id TEXT PRIMARY KEY,
        config TEXT NOT NULL,
        enabled INTEGER DEFAULT 1,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        CHECK(enabled IN (0, 1))
      );

      -- 创建索引
      CREATE INDEX IF NOT EXISTS idx_mcp_servers_enabled ON mcp_servers(enabled);
      CREATE INDEX IF NOT EXISTS idx_mcp_servers_updated ON mcp_servers(updated_at);
    `);

    logger.debug('[MCPConfigService] Database tables initialized');
  }

  /**
   * 保存 MCP 服务器配置
   */
  saveServer(config: MCPServerConfig): void {
    try {
      const now = Date.now();
      const configJson = JSON.stringify(config);

      const stmt = this.db.prepare(`
        INSERT INTO mcp_servers (id, config, enabled, created_at, updated_at)
        VALUES (@id, @config, 1, @now, @now)
        ON CONFLICT(id) DO UPDATE SET
          config = @config,
          updated_at = @now
      `);

      stmt.run({
        id: config.id,
        config: configJson,
        now
      });

      logger.debug(`[MCPConfigService] Server ${config.id} saved`);
    } catch (error: any) {
      logger.error(`[MCPConfigService] Failed to save server ${config.id}:`, error);
      throw error;
    }
  }

  /**
   * 删除 MCP 服务器配置
   */
  deleteServer(serverId: string): void {
    try {
      const stmt = this.db.prepare('DELETE FROM mcp_servers WHERE id = ?');
      const result = stmt.run(serverId);

      if (result.changes > 0) {
        logger.debug(`[MCPConfigService] Server ${serverId} deleted`);
      } else {
        logger.warn(`[MCPConfigService] Server ${serverId} not found in database`);
      }
    } catch (error: any) {
      logger.error(`[MCPConfigService] Failed to delete server ${serverId}:`, error);
      throw error;
    }
  }

  /**
   * 获取所有启用的服务器配置
   */
  getAllServers(): MCPServerRecord[] {
    try {
      const stmt = this.db.prepare(`
        SELECT id, config, created_at, updated_at
        FROM mcp_servers
        WHERE enabled = 1
        ORDER BY updated_at DESC
      `);

      const rows = stmt.all() as Array<{
        id: string;
        config: string;
        created_at: number;
        updated_at: number;
      }>;

      return rows.map(row => ({
        id: row.id,
        config: JSON.parse(row.config),
        created_at: row.created_at,
        updated_at: row.updated_at
      }));
    } catch (error: any) {
      logger.error('[MCPConfigService] Failed to get all servers:', error);
      throw error;
    }
  }

  /**
   * 获取特定服务器配置
   */
  getServer(serverId: string): MCPServerRecord | undefined {
    try {
      const stmt = this.db.prepare(`
        SELECT id, config, created_at, updated_at
        FROM mcp_servers
        WHERE id = ? AND enabled = 1
      `);

      const row = stmt.get(serverId) as {
        id: string;
        config: string;
        created_at: number;
        updated_at: number;
      } | undefined;

      if (!row) {
        return undefined;
      }

      return {
        id: row.id,
        config: JSON.parse(row.config),
        created_at: row.created_at,
        updated_at: row.updated_at
      };
    } catch (error: any) {
      logger.error(`[MCPConfigService] Failed to get server ${serverId}:`, error);
      throw error;
    }
  }

  /**
   * 检查服务器是否存在
   */
  exists(serverId: string): boolean {
    try {
      const stmt = this.db.prepare('SELECT 1 FROM mcp_servers WHERE id = ? AND enabled = 1');
      const row = stmt.get(serverId);
      return !!row;
    } catch (error: any) {
      logger.error(`[MCPConfigService] Failed to check server ${serverId}:`, error);
      return false;
    }
  }

  /**
   * 关闭数据库连接
   */
  close(): void {
    if (this.db) {
      this.db.close();
      logger.debug('[MCPConfigService] Database connection closed');
    }
  }
}
````

## File: src/services/TrajectoryStore.ts
````typescript
/**
 * Trajectory 存储服务
 * 负责 Trajectory 的 SQLite 数据库操作
 */

import Database from 'better-sqlite3';
import * as fs from 'fs';
import * as path from 'path';
import { Trajectory } from '../types/trajectory';
import { PathService } from './PathService';
import { logger } from '../utils/logger';

export class TrajectoryStore {
  private static instance: TrajectoryStore;
  private db: Database.Database;
  private dbPath: string;

  private constructor() {
    const pathService = PathService.getInstance();
    const dataDir = pathService.getDataDir();

    // 确保数据目录存在
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }

    this.dbPath = path.join(dataDir, 'trajectories.db');
    this.db = new Database(this.dbPath);

    // 启用 WAL 模式提升性能
    this.db.pragma('journal_mode = WAL');
    // 启用外键约束
    this.db.pragma('foreign_keys = ON');

    this.initializeDatabase();
    logger.debug(`TrajectoryStore initialized (database: ${this.dbPath})`);
  }

  /**
   * 获取单例实例
   */
  public static getInstance(): TrajectoryStore {
    if (!TrajectoryStore.instance) {
      TrajectoryStore.instance = new TrajectoryStore();
    }
    return TrajectoryStore.instance;
  }

  /**
   * 初始化数据库表结构
   */
  private initializeDatabase(): void {
    this.db.exec(`
      -- Trajectory 表
      CREATE TABLE IF NOT EXISTS trajectories (
        task_id TEXT PRIMARY KEY,
        session_id TEXT,
        user_input TEXT NOT NULL,
        steps TEXT NOT NULL,
        final_result TEXT,
        outcome TEXT NOT NULL CHECK(outcome IN ('SUCCESS', 'FAILURE')),
        environment_feedback TEXT,
        used_rule_ids TEXT,
        timestamp INTEGER NOT NULL,
        duration_ms INTEGER NOT NULL,
        evolution_status TEXT NOT NULL CHECK(evolution_status IN ('PENDING', 'COMPLETED', 'FAILED'))
      );

      -- 创建索引以提升查询性能
      CREATE INDEX IF NOT EXISTS idx_trajectories_outcome ON trajectories(outcome);
      CREATE INDEX IF NOT EXISTS idx_trajectories_timestamp ON trajectories(timestamp);
      CREATE INDEX IF NOT EXISTS idx_trajectories_session_id ON trajectories(session_id);
    `);

    logger.debug('[TrajectoryStore] Database tables initialized');
  }

  /**
   * 根据 ID 获取 Trajectory
   */
  async getById(taskId: string): Promise<Trajectory | null> {
    const stmt = this.db.prepare(`
      SELECT * FROM trajectories WHERE task_id = ?
    `);
    const row = stmt.get(taskId) as any;

    return row ? this.mapRowToTrajectory(row) : null;
  }

  /**
   * 获取最近的成功 Trajectory
   */
  async getRecentSuccess(limit: number = 10): Promise<Trajectory[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM trajectories
      WHERE outcome = 'SUCCESS'
      ORDER BY timestamp DESC
      LIMIT ?
    `);
    const rows = stmt.all(limit) as any[];

    return rows.map(row => this.mapRowToTrajectory(row));
  }

  /**
   * 获取最近的失败 Trajectory
   */
  async getRecentFailures(limit: number = 10): Promise<Trajectory[]> {
    const stmt = this.db.prepare(`
      SELECT * FROM trajectories
      WHERE outcome = 'FAILURE'
      ORDER BY timestamp DESC
      LIMIT ?
    `);
    const rows = stmt.all(limit) as any[];

    return rows.map(row => this.mapRowToTrajectory(row));
  }

  /**
   * 保存 Trajectory
   */
  async save(trajectory: Trajectory): Promise<void> {
    const stmt = this.db.prepare(`
      INSERT OR REPLACE INTO trajectories (
        task_id, session_id, user_input, steps, final_result,
        outcome, environment_feedback, used_rule_ids, timestamp,
        duration_ms, evolution_status
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(
      trajectory.task_id,
      trajectory.session_id,
      trajectory.user_input,
      JSON.stringify(trajectory.steps),
      trajectory.final_result,
      trajectory.outcome,
      trajectory.environment_feedback,
      JSON.stringify(trajectory.used_rule_ids),
      trajectory.timestamp,
      trajectory.duration_ms,
      trajectory.evolution_status
    );

    logger.debug(`[TrajectoryStore] Saved trajectory: ${trajectory.task_id}`);
  }

  /**
   * 批量保存 Trajectory
   */
  async saveBatch(trajectories: Trajectory[]): Promise<void> {
    const transaction = this.db.transaction((trajs: Trajectory[]) => {
      for (const trajectory of trajs) {
        this.save(trajectory);
      }
    });

    transaction(trajectories);
    logger.debug(`[TrajectoryStore] Batch saved ${trajectories.length} trajectories`);
  }

  /**
   * 删除 Trajectory
   */
  async delete(taskId: string): Promise<void> {
    const stmt = this.db.prepare(`
      DELETE FROM trajectories WHERE task_id = ?
    `);
    stmt.run(taskId);

    logger.debug(`[TrajectoryStore] Deleted trajectory: ${taskId}`);
  }

  /**
   * 获取轨迹统计信息
   */
  getStats(): {
    total: number;
    success: number;
    failure: number;
    pending: number;
    completed: number;
    failed: number;
  } {
    const totalStmt = this.db.prepare('SELECT COUNT(*) as count FROM trajectories');
    const successStmt = this.db.prepare("SELECT COUNT(*) as count FROM trajectories WHERE outcome = 'SUCCESS'");
    const failureStmt = this.db.prepare("SELECT COUNT(*) as count FROM trajectories WHERE outcome = 'FAILURE'");
    const pendingStmt = this.db.prepare("SELECT COUNT(*) as count FROM trajectories WHERE evolution_status = 'PENDING'");
    const completedStmt = this.db.prepare("SELECT COUNT(*) as count FROM trajectories WHERE evolution_status = 'COMPLETED'");
    const failedStmt = this.db.prepare("SELECT COUNT(*) as count FROM trajectories WHERE evolution_status = 'FAILED'");

    const total = totalStmt.get() as any;
    const success = successStmt.get() as any;
    const failure = failureStmt.get() as any;
    const pending = pendingStmt.get() as any;
    const completed = completedStmt.get() as any;
    const failed = failedStmt.get() as any;

    return {
      total: total.count,
      success: success.count,
      failure: failure.count,
      pending: pending.count,
      completed: completed.count,
      failed: failed.count
    };
  }

  /**
   * 映射数据库行到 Trajectory 对象
   */
  private mapRowToTrajectory(row: any): Trajectory {
    return {
      task_id: row.task_id,
      session_id: row.session_id,
      user_input: row.user_input,
      steps: JSON.parse(row.steps),
      final_result: row.final_result,
      outcome: row.outcome,
      environment_feedback: row.environment_feedback,
      used_rule_ids: JSON.parse(row.used_rule_ids || '[]'),
      timestamp: row.timestamp,
      duration_ms: row.duration_ms,
      evolution_status: row.evolution_status
    };
  }

  /**
   * 清理过期数据
   */
  async cleanup(olderThanDays: number = 30): Promise<number> {
    const cutoffTime = Date.now() - (olderThanDays * 24 * 60 * 60 * 1000);
    const stmt = this.db.prepare(`
      DELETE FROM trajectories WHERE timestamp < ?
    `);
    const result = stmt.run(cutoffTime);

    logger.info(`[TrajectoryStore] Cleaned up ${result.changes} trajectories older than ${olderThanDays} days`);
    return result.changes;
  }
}
````

## File: src/services/UnifiedToolManager.ts
````typescript
/**
 * Unified Tool Manager
 * 统一工具管理器
 * 整合 Skills 和 MCP 工具，提供统一的工具发现和调用接口
 */

import { EventEmitter } from 'events';
import { logger } from '../utils/logger';
import type { SkillTool } from '../types/tool-system';
import type { MCPTool } from '../types/mcp';
import type { VectorToolResult, VectorSearchResult } from '../types/vector';

export interface UnifiedTool {
  id: string;
  name: string;
  type: 'skill' | 'mcp';
  source: string; // skill name or mcp server id
  description: string;
  category?: string;
  tags?: string[];
  parameters?: any;
  embedding?: number[];
  metadata?: {
    version?: string;
    author?: string;
    [key: string]: any;
  };
}

export interface UnifiedToolResult {
  success: boolean;
  content: Array<{
    type: 'text' | 'image' | 'resource' | 'image_data';
    text?: string;
    mimeType?: string;
    data?: string | number[];
    [key: string]: any;
  }>;
  duration: number;
  error?: {
    code: string;
    message: string;
  };
  metadata?: {
    toolType: 'skill' | 'mcp';
    source: string;
    toolName: string;
  };
}

export interface ToolSearchOptions {
  query?: string;
  type?: 'skill' | 'mcp' | 'all';
  category?: string;
  tags?: string[];
  limit?: number;
  minScore?: number;
}

export interface ToolSearchResult extends VectorSearchResult {
  tool: UnifiedTool;
  score: number;
  reason?: string;
}

export class UnifiedToolManager extends EventEmitter {
  private skillManager: any; // SkillManager 实例
  private mcpIntegration: any; // MCPIntegrationService 实例
  private vectorDBService: any; // VectorDBService 实例
  private toolCache: Map<string, UnifiedTool> = new Map();
  private cacheTimestamp: Map<string, number> = new Map();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5分钟缓存

  constructor(
    skillManager: any,
    mcpIntegration: any,
    vectorDBService: any
  ) {
    super();
    this.skillManager = skillManager;
    this.mcpIntegration = mcpIntegration;
    this.vectorDBService = vectorDBService;

    // 监听事件
    this.setupEventListeners();
  }

  private setupEventListeners(): void {
    // 监听 Skill 变化
    this.skillManager?.on('skill-installed', (skill: SkillTool) => {
      this.addSkillToCache(skill);
      this.refreshToolIndex();
    });

    this.skillManager?.on('skill-uninstalled', (skillName: string) => {
      this.removeSkillFromCache(skillName);
      this.refreshToolIndex();
    });

    // 监听 MCP 工具变化
    this.mcpIntegration?.on('tools-changed', (data: { serverId: string; tools: MCPTool[] }) => {
      this.addMCPToolsToCache(data.serverId, data.tools);
      this.refreshToolIndex();
    });

    // 监听 MCP 服务器状态变化
    this.mcpIntegration?.on('server-status-changed', (data: { serverId: string; status: any }) => {
      if (data.status.phase !== 'running') {
        this.removeMCPServerFromCache(data.serverId);
        this.refreshToolIndex();
      }
    });
  }

  /**
   * 初始化统一工具管理器
   */
  async initialize(): Promise<void> {
    try {
      logger.info('[UnifiedTool] Initializing...');

      // 加载所有工具到缓存
      await this.loadAllTools();

      // 刷新向量索引
      await this.refreshToolIndex();

      logger.info(`[UnifiedTool] Initialized with ${this.toolCache.size} tools`);
    } catch (error: any) {
      logger.error('[UnifiedTool] Failed to initialize:', error);
      throw error;
    }
  }

  /**
   * 加载所有工具到缓存
   */
  private async loadAllTools(): Promise<void> {
    // 加载 Skills
    try {
      const skills = this.skillManager?.getSkills?.() || [];
      logger.debug(`[UnifiedTool] Loading ${skills.length} skills`);

      for (const skill of skills) {
        this.addSkillToCache(skill);
      }
    } catch (error) {
      logger.error('[UnifiedTool] Failed to load skills:', error);
    }

    // 加载 MCP 工具
    try {
      const mcpToolsList = this.mcpIntegration?.getAllTools?.() || [];
      logger.debug(`[UnifiedTool] Loading MCP tools from ${mcpToolsList.length} servers`);

      for (const { serverId, tools } of mcpToolsList) {
        this.addMCPToolsToCache(serverId, tools);
      }
    } catch (error) {
      logger.error('[UnifiedTool] Failed to load MCP tools:', error);
    }
  }

  /**
   * 将 Skill 添加到缓存
   */
  private addSkillToCache(skill: SkillTool): void {
    const tool: UnifiedTool = {
      id: `skill:${skill.name}`,
      name: skill.name,
      type: 'skill',
      source: skill.name,
      description: skill.description,
      category: skill.tags?.[0] || 'uncategorized',
      tags: skill.tags || [],
      parameters: skill.parameters,
      metadata: {
        version: skill.version,
        author: skill.author,
        level: skill.level
      }
    };

    this.toolCache.set(tool.id, tool);
    this.cacheTimestamp.set(tool.id, Date.now());

    logger.debug(`[UnifiedTool] Added skill to cache: ${skill.name}`);
  }

  /**
   * 从缓存中移除 Skill
   */
  private removeSkillFromCache(skillName: string): void {
    const id = `skill:${skillName}`;
    this.toolCache.delete(id);
    this.cacheTimestamp.delete(id);

    logger.debug(`[UnifiedTool] Removed skill from cache: ${skillName}`);
  }

  /**
   * 将 MCP 工具添加到缓存
   */
  private addMCPToolsToCache(serverId: string, tools: MCPTool[]): void {
    for (const tool of tools) {
      const unifiedTool: UnifiedTool = {
        id: `mcp:${serverId}:${tool.name}`,
        name: tool.name,
        type: 'mcp',
        source: serverId,
        description: tool.description,
        tags: [`mcp`, `server:${serverId}`],
        parameters: tool.inputSchema,
        metadata: {
          mcpServerId: serverId,
          mcpToolName: tool.name
        }
      };

      this.toolCache.set(unifiedTool.id, unifiedTool);
      this.cacheTimestamp.set(unifiedTool.id, Date.now());
    }

    logger.debug(`[UnifiedTool] Added ${tools.length} MCP tools from server ${serverId}`);
  }

  /**
   * 从缓存中移除 MCP 服务器
   */
  private removeMCPServerFromCache(serverId: string): void {
    const toRemove: string[] = [];

    for (const [id, tool] of this.toolCache.entries()) {
      if (tool.type === 'mcp' && tool.source === serverId) {
        toRemove.push(id);
      }
    }

    toRemove.forEach(id => {
      this.toolCache.delete(id);
      this.cacheTimestamp.delete(id);
    });

    logger.debug(`[UnifiedTool] Removed ${toRemove.length} MCP tools for server ${serverId}`);
  }

  /**
   * 搜索工具
   */
  async searchTools(options: ToolSearchOptions): Promise<ToolSearchResult[]> {
    try {
      const {
        query,
        type = 'all',
        category,
        tags,
        limit = 10,
        minScore = 0.3
      } = options;

      let results: ToolSearchResult[] = [];

      if (query) {
        // 向量搜索
        results = await this.vectorSearch(query, { type, limit, minScore });
      } else {
        // 列表搜索
        results = this.listSearch({ type, category, tags, limit });
      }

      // 按分数排序
      results.sort((a, b) => b.score - a.score);

      return results.slice(0, limit);
    } catch (error: any) {
      logger.error('[UnifiedTool] Tool search failed:', error);
      return [];
    }
  }

  /**
   * 向量搜索
   */
  private async vectorSearch(
    query: string,
    options: { type?: string; limit?: number; minScore?: number }
  ): Promise<ToolSearchResult[]> {
    try {
      const searchResult = await this.vectorDBService.searchTools(query, {
        limit: options.limit || 10,
        minScore: options.minScore || 0.3
      });

      return searchResult.map((result: VectorToolResult) => ({
        id: result.id,
        tool: result.tool as UnifiedTool,
        score: result.score,
        metadata: result.metadata
      }));
    } catch (error: any) {
      logger.error('[UnifiedTool] Vector search failed:', error);
      return [];
    }
  }

  /**
   * 列表搜索
   */
  private listSearch(options: {
    type?: string;
    category?: string;
    tags?: string[];
    limit?: number;
  }): ToolSearchResult[] {
    const { type, category, tags, limit = 10 } = options;

    let tools = Array.from(this.toolCache.values());

    // 类型过滤
    if (type !== 'all') {
      tools = tools.filter(t => t.type === type);
    }

    // 分类过滤
    if (category) {
      tools = tools.filter(t => t.category === category);
    }

    // 标签过滤
    if (tags && tags.length > 0) {
      tools = tools.filter(t =>
        tags.every(tag => t.tags?.includes(tag))
      );
    }

    // 转换为搜索结果
    return tools.slice(0, limit).map(tool => ({
      id: tool.id,
      tool,
      score: 1.0,
      reason: 'Direct match'
    }));
  }

  /**
   * 获取所有工具
   */
  getAllTools(type?: 'skill' | 'mcp'): UnifiedTool[] {
    let tools = Array.from(this.toolCache.values());

    if (type) {
      tools = tools.filter(t => t.type === type);
    }

    return tools;
  }

  /**
   * 根据 ID 获取工具
   */
  getToolById(id: string): UnifiedTool | undefined {
    return this.toolCache.get(id);
  }

  /**
   * 根据名称获取工具
   */
  getToolByName(name: string): UnifiedTool | undefined {
    // 先尝试精确匹配
    for (const tool of this.toolCache.values()) {
      if (tool.name === name) {
        return tool;
      }
    }

    // 如果没找到，尝试模糊匹配
    for (const tool of this.toolCache.values()) {
      if (tool.name.toLowerCase().includes(name.toLowerCase())) {
        return tool;
      }
    }

    return undefined;
  }

  /**
   * 调用工具
   */
  async callTool(
    toolNameOrId: string,
    arguments_: Record<string, any>,
    options?: { toolId?: string }
  ): Promise<UnifiedToolResult> {
    const startTime = Date.now();

    try {
      // 解析工具
      const tool = options?.toolId
        ? this.getToolById(options.toolId)
        : this.getToolByName(toolNameOrId);

      if (!tool) {
        throw new Error(`Tool not found: ${toolNameOrId}`);
      }

      let result: UnifiedToolResult;

      if (tool.type === 'skill') {
        // 调用 Skill
        result = await this.callSkill(tool, arguments_);
      } else {
        // 调用 MCP 工具
        result = await this.callMCPTool(tool, arguments_);
      }

      const duration = Date.now() - startTime;

      return {
        ...result,
        duration,
        metadata: {
          ...result.metadata,
          toolType: tool.type,
          source: tool.source,
          toolName: tool.name
        }
      };
    } catch (error: any) {
      const duration = Date.now() - startTime;

      logger.error(`[UnifiedTool] Tool call failed:`, error);

      return {
        success: false,
        content: [],
        duration,
        error: {
          code: 'TOOL_CALL_ERROR',
          message: error.message || 'Unknown error'
        },
        metadata: {
          toolType: 'skill' as const,
          source: 'unknown',
          toolName: toolNameOrId
        }
      };
    }
  }

  /**
   * 调用 Skill
   */
  private async callSkill(tool: UnifiedTool, args: Record<string, any>): Promise<UnifiedToolResult> {
    try {
      const skillResult = await this.skillManager.executeSkill(tool.name, args);

      return {
        success: skillResult.success,
        content: [
          {
            type: 'text',
            text: skillResult.output || skillResult.error || ''
          }
        ],
        duration: skillResult.duration,
        metadata: {
          toolType: 'skill',
          source: tool.source,
          toolName: tool.name
        }
      };
    } catch (error: any) {
      return {
        success: false,
        content: [],
        duration: 0,
        error: {
          code: 'SKILL_EXECUTION_ERROR',
          message: error.message || 'Unknown error'
        }
      };
    }
  }

  /**
   * 调用 MCP 工具
   */
  private async callMCPTool(tool: UnifiedTool, args: Record<string, any>): Promise<UnifiedToolResult> {
    try {
      const mcpResult = await this.mcpIntegration.callTool({
        toolName: tool.metadata?.mcpToolName || tool.name,
        arguments: args,
        serverId: tool.source
      });

      return {
        success: mcpResult.success,
        content: mcpResult.content || [],
        duration: mcpResult.duration,
        metadata: {
          toolType: 'mcp',
          source: tool.source,
          toolName: tool.name
        }
      };
    } catch (error: any) {
      return {
        success: false,
        content: [],
        duration: 0,
        error: {
          code: 'MCP_EXECUTION_ERROR',
          message: error.message || 'Unknown error'
        }
      };
    }
  }

  /**
   * 刷新工具索引
   */
  async refreshToolIndex(): Promise<void> {
    try {
      logger.debug('[UnifiedTool] Refreshing tool index...');

      const tools = Array.from(this.toolCache.values());

      await this.vectorDBService.indexTools(tools);

      logger.info(`[UnifiedTool] Tool index refreshed: ${tools.length} tools indexed`);
    } catch (error: any) {
      logger.error('[UnifiedTool] Failed to refresh tool index:', error);
    }
  }

  /**
   * 获取统计信息
   */
  getStatistics() {
    const tools = Array.from(this.toolCache.values());

    const stats = {
      totalTools: tools.length,
      skillsCount: tools.filter(t => t.type === 'skill').length,
      mcpToolsCount: tools.filter(t => t.type === 'mcp').length,
      byCategory: {} as Record<string, number>,
      byTags: {} as Record<string, number>,
      cacheSize: this.toolCache.size,
      cacheTTL: this.CACHE_TTL
    };

    for (const tool of tools) {
      if (tool.category) {
        stats.byCategory[tool.category] = (stats.byCategory[tool.category] || 0) + 1;
      }

      for (const tag of tool.tags || []) {
        stats.byTags[tag] = (stats.byTags[tag] || 0) + 1;
      }
    }

    return stats;
  }

  /**
   * 清理缓存
   */
  clearCache(): void {
    this.toolCache.clear();
    this.cacheTimestamp.clear();

    logger.info('[UnifiedTool] Cache cleared');
  }

  /**
   * 优雅关闭
   */
  async shutdown(): Promise<void> {
    logger.info('[UnifiedTool] Shutting down...');

    this.clearCache();

    logger.info('[UnifiedTool] Shut down complete');
  }
}
````

## File: src/types/config/api-key.ts
````typescript
/**
 * API Key 信息结构
 */
export interface ApiKeyInfo {
  /** 唯一标识 */
  id: string;
  /** 名称（如 "默认项目"、"cherry"） */
  name: string;
  /** 完整的 API Key */
  key: string;
  /** 创建时间戳 */
  createdAt: number;
  /** 上次使用时间戳（可选） */
  lastUsedAt?: number;
  /** 所属人ID（可选） */
  ownerId?: string;
}
````

## File: src/types/config/rate-limit.ts
````typescript
/**
 * 速率限制策略类型
 */
export type RateLimitStrategyType = 'ip' | 'apiKey' | 'user' | 'header';

/**
 * 速率限制策略配置
 */
export interface RateLimitStrategyConfig {
  /** 策略类型 */
  type: RateLimitStrategyType | string;
  /** Header 名称（当 type='header' 时使用） */
  headerName?: string;
  /** 策略描述 */
  description?: string;
}

/**
 * 速率限制匹配器配置
 */
export interface RateLimitMatcherConfig {
  /** 路径匹配 */
  path?: string;
  /** 路径前缀 */
  prefix?: string;
  /** 正则表达式 */
  regex?: string;
  /** HTTP 方法 */
  methods?: string[];
}

/**
 * 速率限制规则配置
 */
export interface RateLimitRuleConfig {
  /** 规则唯一标识 */
  id: string;
  /** 规则名称 */
  name?: string;
  /** 规则描述 */
  description?: string;
  /** 优先级（数值越大优先级越高） */
  priority?: number;
  /** 时间窗口（毫秒） */
  windowMs: number;
  /** 窗口内最大请求数 */
  maxRequests: number;
  /** 匹配策略 */
  strategy: RateLimitStrategyConfig;
  /** 主匹配器 */
  matcher: RateLimitMatcherConfig;
  /** 附加匹配器列表 */
  matchers?: RateLimitMatcherConfig[];
  /** 窗口模式 */
  mode?: 'sliding' | 'fixed';
  /** 策略执行顺序 */
  strategyOrder?: RateLimitStrategyType[];
  /** 是否返回响应头 */
  responseHeaders?: boolean;
  /** 是否跳过成功请求 */
  skipSuccessfulRequests?: boolean;
  /** 是否跳过失败请求 */
  skipFailedRequests?: boolean;
  /** 是否启用 */
  enabled?: boolean;
}

/**
 * 速率限制响应头配置
 */
export interface RateLimitHeadersConfig {
  /** 限制数量头 */
  limit?: string;
  /** 剩余数量头 */
  remaining?: string;
  /** 重置时间头 */
  reset?: string;
  /** 重试后时间头 */
  retryAfter?: string;
}

/**
 * 速率限制设置
 */
export interface RateLimitSettings {
  /** 是否启用 */
  enabled: boolean;
  /** 默认时间窗口（毫秒） */
  windowMs: number;
  /** 默认最大请求数 */
  max: number;
  /** 超出限制时的消息 */
  message?: string;
  /** 是否使用标准响应头 */
  standardHeaders?: boolean;
  /** 是否使用传统响应头 */
  legacyHeaders?: boolean;
  /** 是否信任代理 */
  trustProxy?: boolean;
  /** 速率限制规则 */
  rules?: RateLimitRuleConfig[];
  /** 响应头配置 */
  headers?: RateLimitHeadersConfig;
  /** 默认策略顺序 */
  defaultStrategyOrder?: RateLimitStrategyType[];
  /** 提供商类型 */
  provider?: 'auto' | 'redis' | 'memory';
  /** 键前缀 */
  keyPrefix?: string;
}
````

## File: src/types/config/redis.ts
````typescript
/**
 * Redis 配置
 */
export interface RedisConfig {
  /** 是否启用 */
  enabled: boolean;
  /** Redis 主机地址 */
  host?: string;
  /** Redis 端口 */
  port?: number;
  /** 密码 */
  password?: string;
  /** 数据库编号 */
  db?: number;
  /** 键前缀 */
  keyPrefix?: string;
  /** 连接 URL */
  url?: string;
  /** Socket 配置 */
  socket?: {
    host?: string;
    port?: number;
  };
  /** 连接超时（毫秒） */
  connectTimeout?: number;
  /** 连接超时（毫秒，兼容旧名称） */
  connectTimeoutMs?: number;
  /** 延迟连接 */
  lazyConnect?: boolean;
  /** 每个请求最大重试次数 */
  maxRetriesPerRequest?: number;
  /** 故障转移重试延迟（毫秒） */
  retryDelayOnFailover?: number;
  /** 用户名 */
  username?: string;
  /** TLS 配置：true 启用TLS，对象传递证书配置 */
  tls?: boolean | Record<string, unknown>;
}
````

## File: src/types/enhanced-skill.ts
````typescript
/**
 * Enhanced Skill Types - Hybrid Retrieval & Disclosure
 *
 * Phase 1: 混合检索框架和基础披露机制的类型定义
 */

// ==================== Hybrid Retrieval Types ====================

/**
 * Hybrid retrieval configuration
 */
export interface HybridRetrievalConfig {
  /** Weight for vector similarity (0-1) */
  vectorWeight: number;
  /** Weight for keyword matching (0-1) */
  keywordWeight: number;
  /** Weight for semantic matching (0-1) */
  semanticWeight: number;
  /** Weight for tag matching (0-1) */
  tagWeight: number;
  /** RRF fusion constant */
  rrfK: number;
  /** Minimum score threshold */
  minScore: number;
  /** Maximum results */
  maxResults: number;
  /** Enable tag matching */
  enableTagMatching: boolean;
  /** Enable keyword matching */
  enableKeywordMatching: boolean;
  /** Enable semantic matching */
  enableSemanticMatching: boolean;
  /** Cache TTL in seconds */
  cacheTTL: number;
  /** Disclosure strategy */
  disclosureStrategy: DisclosureStrategy;
  /** Tag hierarchy */
  tagHierarchy: TagHierarchy;
}

/**
 * Disclosure strategy
 */
export enum DisclosureStrategy {
  METADATA = "metadata",
  CONTENT = "content",
  RESOURCES = "resources",
  ADAPTIVE = "adaptive",
}

/**
 * Default hybrid retrieval configuration
 */
export const DEFAULT_HYBRID_RETRIEVAL_CONFIG: HybridRetrievalConfig = {
  vectorWeight: 0.5,
  keywordWeight: 0.3,
  semanticWeight: 0.2,
  tagWeight: 0.1,
  rrfK: 60,
  minScore: 0.1,
  maxResults: 10,
  enableTagMatching: true,
  enableKeywordMatching: true,
  enableSemanticMatching: true,
  cacheTTL: 300,
  disclosureStrategy: DisclosureStrategy.METADATA,
  tagHierarchy: {
    levels: ["category", "subcategory", "tag"],
    aliases: {
      cat: "category",
      sub: "subcategory",
      t: "tag",
    },
  },
};

/**
 * Unified retrieval result combining multiple retrieval methods
 */
export interface UnifiedRetrievalResult {
  /** Unique result ID */
  id: string;
  /** Tool/skill name */
  name: string;
  /** Tool description */
  description: string;
  /** Combined score from all methods */
  unifiedScore: number;
  /** Individual scores from each method */
  scores: {
    vector: number;
    keyword: number;
    semantic: number;
    tag: number;
  };
  /** RRF ranks from each method */
  ranks: {
    vector: number;
    keyword: number;
    semantic: number;
    tag: number;
  };
  /** Type tags */
  tags: string[];
  /** Tool type */
  toolType: "skill" | "mcp" | "builtin";
  /** Disclosure content */
  disclosure: DisclosureContent;
  /** Metadata */
  metadata?: Record<string, unknown>;
  /** Source path */
  path?: string;
  /** Version */
  version?: string;
}

/**
 * Individual retrieval result from a single method
 */
export interface RetrievalResult {
  /** Result ID */
  id: string;
  /** Score (0-1 for normalized, rank for RRF) */
  score: number;
  /** Retrieval method */
  method: RetrievalMethod;
  /** Metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Retrieval method enumeration
 */
export type RetrievalMethod = "vector" | "keyword" | "semantic" | "tag";

// ==================== Tag Matching Types ====================

/**
 * Tag match result
 */
export interface TagMatchResult {
  /** Whether tag matched */
  matched: boolean;
  /** Matched tag */
  tag: string;
  /** Matched tag hierarchy level */
  level: string;
  /** Match score (0-1) */
  score: number;
  /** Alias expansion applied */
  expandedFrom?: string;
}

/**
 * Tag hierarchy configuration
 */
export interface TagHierarchy {
  /** Hierarchy levels from general to specific */
  levels: string[];
  /** Tag aliases for matching */
  aliases: Record<string, string>;
  /** Inherited tags per level */
  inheritTags?: boolean;
}

/**
 * Tag matching options
 */
export interface TagMatchingOptions {
  /** Query tags to match */
  queryTags: string[];
  /** Maximum hierarchy depth */
  maxDepth?: number;
  /** Enable alias expansion */
  enableAliases?: boolean;
  /** Minimum match score */
  minScore?: number;
}

// ==================== Disclosure Types ====================

/**
 * Disclosure level enumeration
 */
export enum DisclosureLevel {
  /** Only metadata (name, description) */
  METADATA = "metadata",
  /** Include input/output schema */
  CONTENT = "content",
  /** Include resources and references */
  RESOURCES = "resources",
}

/**
 * Disclosure content
 */
export interface DisclosureContent {
  /** Disclosure level */
  level: DisclosureLevel;
  /** Name */
  name: string;
  /** Description */
  description: string;
  /** Version */
  version?: string;
  /** Author */
  author?: string;
  /** Tags */
  tags?: string[];
  /** Input schema */
  inputSchema?: Record<string, unknown>;
  /** Output schema */
  outputSchema?: Record<string, unknown>;
  /** Parameters (for CONTENT level) */
  parameters?: Array<{ name: string; type: string; required?: boolean; description?: string }>;
  /** Examples (for CONTENT/RESOURCES level) */
  examples?: Array<{ input: string; output: string }>;
  /** Scripts (for RESOURCES level) */
  scripts?: Array<{ name: string; language: string; content: string }>;
  /** Dependencies (for RESOURCES level) */
  dependencies?: Array<{ name: string; version: string }>;
  /** Resources (for RESOURCES level) */
  resources?: Array<{ type: string; path: string; description: string }>;
  /** Token count estimate */
  tokenCount: number;
}

/**
 * Disclosure options
 */
export interface DisclosureOptions {
  /** Target disclosure level */
  level: DisclosureLevel;
  /** Include examples */
  includeExamples?: boolean;
  /** Include resources */
  includeResources?: boolean;
  /** Max token limit */
  maxTokens?: number;
  /** Adaptive strategy config */
  adaptiveConfig?: {
    minTokens: number;
    maxTokens: number;
    preferMetadataBelow: number;
  };
}

// ==================== Performance & Metrics ====================

/**
 * Retrieval performance metrics
 */
export interface RetrievalMetrics {
  /** Total retrieval time in ms */
  totalTime: number;
  /** Vector search time in ms */
  vectorTime: number;
  /** Keyword search time in ms */
  keywordTime: number;
  /** Semantic matching time in ms */
  semanticTime: number;
  /** Tag matching time in ms */
  tagTime: number;
  /** Fusion time in ms */
  fusionTime: number;
  /** Number of results retrieved */
  resultCount: number;
  /** Cache hit status */
  cacheHit: boolean;
  /** Number of cache hits */
  cacheHits: number;
  /** Number of cache misses */
  cacheMisses: number;
}

/**
 * Engine performance metrics
 */
export interface EngineMetrics {
  /** Operation name */
  operation: string;
  /** Duration in ms */
  duration: number;
  /** Success status */
  success: boolean;
  /** Error message if failed */
  error?: string;
  /** Additional metrics */
  details?: Record<string, unknown>;
}

// ==================== Error Types ====================

/**
 * Hybrid retrieval error codes
 */
export enum HybridRetrievalErrorCode {
  CONFIG_ERROR = "CONFIG_ERROR",
  VECTOR_SEARCH_ERROR = "VECTOR_SEARCH_ERROR",
  KEYWORD_SEARCH_ERROR = "KEYWORD_SEARCH_ERROR",
  SEMANTIC_MATCH_ERROR = "SEMANTIC_MATCH_ERROR",
  TAG_MATCH_ERROR = "TAG_MATCH_ERROR",
  FUSION_ERROR = "FUSION_ERROR",
  DISCLOSURE_ERROR = "DISCLOSURE_ERROR",
  CACHE_ERROR = "CACHE_ERROR",
}

/**
 * Hybrid retrieval error
 */
export class HybridRetrievalError extends Error {
  code: HybridRetrievalErrorCode;
  details?: Record<string, unknown>;

  constructor(message: string, code: HybridRetrievalErrorCode, details?: Record<string, unknown>) {
    super(message);
    this.name = "HybridRetrievalError";
    this.code = code;
    this.details = details;
  }
}

// ==================== Cache Types ====================

/**
 * Cache entry
 */
export interface CacheEntry<T> {
  /** Cached data */
  data: T;
  /** Creation timestamp */
  createdAt: number;
  /** Expiration timestamp */
  expiresAt: number;
  /** Access count */
  accessCount: number;
}

/**
 * Cache statistics
 */
export interface CacheStats {
  /** Total entries */
  size: number;
  /** Hit count */
  hits: number;
  /** Miss count */
  misses: number;
  /** Hit rate */
  hitRate: number;
  /** Memory usage estimate */
  memoryUsage: number;
}

// ==================== Fusion Types ====================

/**
 * RRF (Reciprocal Rank Fusion) configuration
 */
export interface RRFConfig {
  /** RRF constant k */
  k: number;
  /** Weights for each method */
  weights: Record<RetrievalMethod, number>;
  /** Normalization method */
  normalization: "minmax" | "zscore" | "percentile";
}

/**
 * Fusion result
 */
export interface FusionResult {
  /** Fused results */
  results: UnifiedRetrievalResult[];
  /** Applied fusion config */
  config: RRFConfig;
  /** Total fusion time */
  duration: number;
  /** Number of deduplicated items */
  deduplicatedCount: number;
}
````

## File: src/types/errors.ts
````typescript
/**
 * ApexBridge 统一错误类型定义
 *
 * 提供标准化的错误码、错误类和工具函数
 * 错误码格式: ERR_{MODULE}_{ACTION}
 */

import { ErrorType } from "./trajectory";

/**
 * 错误码枚举
 * 格式: ERR_{MODULE}_{ACTION}
 */
export enum ErrorCode {
  // ========== Tool 相关错误 ==========
  /** 工具执行超时 */
  ERR_TOOL_EXECUTE_TIMEOUT = "ERR_TOOL_EXECUTE_TIMEOUT",
  /** 工具未找到 */
  ERR_TOOL_NOT_FOUND = "ERR_TOOL_NOT_FOUND",
  /** 工具执行失败 */
  ERR_TOOL_EXECUTE_FAILED = "ERR_TOOL_EXECUTE_FAILED",
  /** 工具注册失败 */
  ERR_TOOL_REGISTER_FAILED = "ERR_TOOL_REGISTER_FAILED",
  /** 工具注销失败 */
  ERR_TOOL_UNREGISTER_FAILED = "ERR_TOOL_UNREGISTER_FAILED",

  // ========== LLM 相关错误 ==========
  /** LLM API 错误 */
  ERR_LLM_API_ERROR = "ERR_LLM_API_ERROR",
  /** LLM 模型未配置 */
  ERR_LLM_MODEL_NOT_CONFIGURED = "ERR_LLM_MODEL_NOT_CONFIGURED",
  /** LLM 请求超时 */
  ERR_LLM_REQUEST_TIMEOUT = "ERR_LLM_REQUEST_TIMEOUT",
  /** LLM 速率限制 */
  ERR_LLM_RATE_LIMIT = "ERR_LLM_RATE_LIMIT",

  // ========== Database 相关错误 ==========
  /** 数据库连接失败 */
  ERR_DB_CONNECTION_FAILED = "ERR_DB_CONNECTION_FAILED",
  /** 数据库查询错误 */
  ERR_DB_QUERY_FAILED = "ERR_DB_QUERY_FAILED",
  /** 数据库迁移错误 */
  ERR_DB_MIGRATION_FAILED = "ERR_DB_MIGRATION_FAILED",

  // ========== MCP 相关错误 ==========
  /** MCP 服务器连接失败 */
  ERR_MCP_SERVER_CONNECTION_FAILED = "ERR_MCP_SERVER_CONNECTION_FAILED",
  /** MCP 工具调用失败 */
  ERR_MCP_TOOL_CALL_FAILED = "ERR_MCP_TOOL_CALL_FAILED",
  /** MCP 服务器已存在 */
  ERR_MCP_SERVER_EXISTS = "ERR_MCP_SERVER_EXISTS",

  // ========== Authentication 相关错误 ==========
  /** 未授权访问 */
  ERR_AUTH_UNAUTHORIZED = "ERR_AUTH_UNAUTHORIZED",
  /** 认证失败 */
  ERR_AUTH_FAILED = "ERR_AUTH_FAILED",
  /** 权限不足 */
  ERR_AUTH_FORBIDDEN = "ERR_AUTH_FORBIDDEN",

  // ========== Validation 相关错误 ==========
  /** 输入参数错误 */
  ERR_VALIDATION_INVALID_INPUT = "ERR_VALIDATION_INVALID_INPUT",
  /** 请求参数缺失 */
  ERR_VALIDATION_MISSING_PARAM = "ERR_VALIDATION_MISSING_PARAM",
  /** 请求格式错误 */
  ERR_VALIDATION_MALFORMED_REQUEST = "ERR_VALIDATION_MALFORMED_REQUEST",

  // ========== Internal 相关错误 ==========
  /** 内部服务器错误 */
  ERR_INTERNAL_SERVER_ERROR = "ERR_INTERNAL_SERVER_ERROR",
  /** 配置错误 */
  ERR_INTERNAL_CONFIG_ERROR = "ERR_INTERNAL_CONFIG_ERROR",
  /** 状态错误 */
  ERR_INTERNAL_STATE_ERROR = "ERR_INTERNAL_STATE_ERROR",

  // ========== Vector Search 相关错误 ==========
  /** 向量数据库连接失败 */
  ERR_VECTOR_DB_CONNECTION_FAILED = "ERR_VECTOR_DB_CONNECTION_FAILED",
  /** 向量索引错误 */
  ERR_VECTOR_INDEX_ERROR = "ERR_VECTOR_INDEX_ERROR",
  /** 嵌入模型错误 */
  ERR_EMBEDDING_MODEL_ERROR = "ERR_EMBEDDING_MODEL_ERROR",
}

/**
 * 应用错误类
 * 提供标准化的错误响应格式
 */
export class AppError extends Error {
  /**
   * @param code - 错误码
   * @param message - 错误消息
   * @param statusCode - HTTP 状态码 (默认 500)
   * @param details - 错误详情
   */
  constructor(
    public readonly code: ErrorCode,
    public readonly message: string,
    public readonly statusCode: number = 500,
    public readonly details?: unknown
  ) {
    super(message);
    this.name = "AppError";
    // 确保 Error 堆栈被正确捕获
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, AppError);
    }
  }

  /**
   * 转换为 JSON 格式
   */
  toJSON(): Record<string, unknown> {
    const json: Record<string, unknown> = {
      error: {
        code: this.code,
        message: this.message,
      },
    };

    if (this.statusCode) {
      (json.error as Record<string, unknown>).statusCode = this.statusCode;
    }

    if (this.details) {
      (json.error as Record<string, unknown>).details = this.details;
    }

    return json;
  }

  /**
   * 获取 HTTP 状态码
   */
  getStatusCode(): number {
    return this.statusCode;
  }

  /**
   * 转换为 ErrorType (用于 trajectory 追踪)
   */
  toErrorType(): ErrorType {
    // 根据错误码映射到 ErrorType
    if (this.code.includes("TIMEOUT")) {
      return ErrorType.TIMEOUT;
    }
    if (this.code.includes("RATE_LIMIT")) {
      return ErrorType.RATE_LIMIT;
    }
    if (this.code.includes("PERMISSION") || this.code.includes("AUTH")) {
      return ErrorType.PERMISSION_DENIED;
    }
    if (this.code.includes("INVALID") || this.code.includes("VALIDATION")) {
      return ErrorType.INVALID_INPUT;
    }
    if (this.code.includes("NETWORK") || this.code.includes("CONNECTION")) {
      return ErrorType.NETWORK_ERROR;
    }
    if (
      this.code.includes("RESOURCE") ||
      this.code.includes("MEMORY") ||
      this.code.includes("DISK")
    ) {
      return ErrorType.RESOURCE_EXHAUSTED;
    }
    return ErrorType.UNKNOWN;
  }
}

/**
 * 函数式结果类型
 * 用于安全的错误处理
 */
export type Result<T> = { success: true; data: T } | { success: false; error: AppError };

/**
 * 错误创建工具函数
 */

// ========== Tool 错误 ==========

/**
 * 创建工具执行超时错误
 */
export function toolExecuteTimeout(toolName: string, timeout: number): AppError {
  return new AppError(
    ErrorCode.ERR_TOOL_EXECUTE_TIMEOUT,
    `Tool execution timeout: ${toolName} exceeded ${timeout}ms`,
    504,
    { toolName, timeout }
  );
}

/**
 * 创建工具未找到错误
 */
export function toolNotFound(toolName: string): AppError {
  return new AppError(ErrorCode.ERR_TOOL_NOT_FOUND, `Tool not found: ${toolName}`, 404, {
    toolName,
  });
}

/**
 * 创建工具执行失败错误
 */
export function toolExecuteFailed(toolName: string, reason: string): AppError {
  return new AppError(
    ErrorCode.ERR_TOOL_EXECUTE_FAILED,
    `Tool execution failed: ${toolName} - ${reason}`,
    500,
    { toolName, reason }
  );
}

// ========== LLM 错误 ==========

/**
 * 创建 LLM API 错误
 */
export function llmApiError(provider: string, message: string): AppError {
  return new AppError(ErrorCode.ERR_LLM_API_ERROR, `LLM API error (${provider}): ${message}`, 502, {
    provider,
    message,
  });
}

/**
 * 创建 LLM 模型未配置错误
 */
export function llmModelNotConfigured(modelType: string): AppError {
  return new AppError(
    ErrorCode.ERR_LLM_MODEL_NOT_CONFIGURED,
    `LLM model not configured for type: ${modelType}`,
    500,
    { modelType }
  );
}

// ========== Database 错误 ==========

/**
 * 创建数据库连接失败错误
 */
export function dbConnectionFailed(database: string, reason: string): AppError {
  return new AppError(
    ErrorCode.ERR_DB_CONNECTION_FAILED,
    `Database connection failed: ${database} - ${reason}`,
    503,
    { database, reason }
  );
}

/**
 * 创建数据库查询错误
 */
export function dbQueryFailed(query: string, reason: string): AppError {
  return new AppError(ErrorCode.ERR_DB_QUERY_FAILED, `Database query failed: ${reason}`, 500, {
    query: query.substring(0, 100),
    reason,
  });
}

// ========== MCP 错误 ==========

/**
 * 创建 MCP 服务器连接失败错误
 */
export function mcpServerConnectionFailed(serverId: string, reason: string): AppError {
  return new AppError(
    ErrorCode.ERR_MCP_SERVER_CONNECTION_FAILED,
    `MCP server connection failed: ${serverId} - ${reason}`,
    502,
    { serverId, reason }
  );
}

/**
 * 创建 MCP 工具调用失败错误
 */
export function mcpToolCallFailed(toolName: string, reason: string): AppError {
  return new AppError(
    ErrorCode.ERR_MCP_TOOL_CALL_FAILED,
    `MCP tool call failed: ${toolName} - ${reason}`,
    500,
    { toolName, reason }
  );
}

// ========== Validation 错误 ==========

/**
 * 创建输入参数错误
 */
export function validationInvalidInput(field: string, reason: string): AppError {
  return new AppError(
    ErrorCode.ERR_VALIDATION_INVALID_INPUT,
    `Invalid input for field '${field}': ${reason}`,
    400,
    { field, reason }
  );
}

/**
 * 创建请求参数缺失错误
 */
export function validationMissingParam(param: string): AppError {
  return new AppError(
    ErrorCode.ERR_VALIDATION_MISSING_PARAM,
    `Missing required parameter: ${param}`,
    400,
    { param }
  );
}

// ========== Internal 错误 ==========

/**
 * 创建内部配置错误
 */
export function internalConfigError(setting: string, reason: string): AppError {
  return new AppError(
    ErrorCode.ERR_INTERNAL_CONFIG_ERROR,
    `Configuration error for '${setting}': ${reason}`,
    500,
    { setting, reason }
  );
}

/**
 * 创建内部状态错误
 */
export function internalStateError(state: string, reason: string): AppError {
  return new AppError(
    ErrorCode.ERR_INTERNAL_STATE_ERROR,
    `State error in '${state}': ${reason}`,
    500,
    { state, reason }
  );
}

/**
 * 错误规范化函数
 * 将任意错误转换为 AppError
 */
export function normalizeError(error: unknown): AppError {
  if (error instanceof AppError) {
    return error;
  }

  if (error instanceof Error) {
    return new AppError(ErrorCode.ERR_INTERNAL_SERVER_ERROR, error.message, 500, {
      originalError: error.name,
    });
  }

  return new AppError(ErrorCode.ERR_INTERNAL_SERVER_ERROR, String(error) || "Unknown error", 500);
}

/**
 * 检查是否为 AppError
 */
export function isAppError(error: unknown): error is AppError {
  return error instanceof AppError;
}

/**
 * 错误码到 HTTP 状态码的映射
 */
export function getStatusCodeForErrorCode(code: ErrorCode): number {
  switch (code) {
    case ErrorCode.ERR_TOOL_NOT_FOUND:
    case ErrorCode.ERR_VALIDATION_MISSING_PARAM:
      return 404;
    case ErrorCode.ERR_VALIDATION_INVALID_INPUT:
    case ErrorCode.ERR_VALIDATION_MALFORMED_REQUEST:
      return 400;
    case ErrorCode.ERR_AUTH_UNAUTHORIZED:
      return 401;
    case ErrorCode.ERR_AUTH_FORBIDDEN:
      return 403;
    case ErrorCode.ERR_LLM_RATE_LIMIT:
      return 429;
    case ErrorCode.ERR_LLM_API_ERROR:
    case ErrorCode.ERR_MCP_SERVER_CONNECTION_FAILED:
    case ErrorCode.ERR_MCP_TOOL_CALL_FAILED:
    case ErrorCode.ERR_VECTOR_DB_CONNECTION_FAILED:
      return 502;
    default:
      return 500;
  }
}
````

## File: src/types/mcp.ts
````typescript
/**
 * MCP (Model Context Protocol) 相关类型定义
 */

export interface MCPServerConfig {
  id: string;
  type: 'stdio' | 'sse' | 'websocket';
  command: string;
  args: string[];
  env?: Record<string, string>;
  cwd?: string;
  transportOptions?: Record<string, any>;
}

export interface MCPServerStatus {
  phase: 'not-started' | 'initializing' | 'starting' | 'running' | 'stopping' | 'stopped' | 'error' | 'shutting-down';
  message: string;
  uptime: number;
  startTime?: Date;
  error?: string;
}

export interface MCPTool {
  name: string;
  description: string;
  inputSchema?: {
    type: 'object';
    properties?: Record<string, any>;
    required?: string[];
  };
}

export interface MCPToolCall {
  tool: string;
  arguments: Record<string, any>;
}

export interface MCPToolContent {
  type: 'text' | 'image' | 'resource';
  text?: string;
  mimeType?: string;
  data?: string | Uint8Array;
}

export interface MCPToolResult {
  success: boolean;
  content: MCPToolContent[];
  duration: number;
  metadata?: {
    toolType: 'mcp';
    source?: string;
    toolName?: string;
  };
  error?: {
    code: string;
    message: string;
    details?: any;
  };
}

export interface MCPInitializeParams {
  protocolVersion: string;
  capabilities: Record<string, any>;
  clientInfo: {
    name: string;
    version: string;
  };
}

export interface MCPJSONRPCRequest {
  jsonrpc: '2.0';
  id: string | number;
  method: string;
  params?: any;
}

export interface MCPJSONRPCResponse {
  jsonrpc: '2.0';
  id: string | number;
  result?: any;
  error?: {
    code: number;
    message: string;
    data?: any;
  };
}
````

## File: src/types/message-v2.ts
````typescript
/**
 * Message V2 Types - 基于 opencode 的消息 Part 抽象体系
 */

// ==================== Part 基类 ====================

export interface PartBase {
  id: string;
  sessionID: string;
  messageID: string;
}

// ==================== Part 类型定义 ====================

export interface TextPart extends PartBase {
  type: 'text';
  text: string;
  synthetic?: boolean;
  ignored?: boolean;
  time?: { start: number; end?: number };
  metadata?: Record<string, unknown>;
}

export interface ReasoningPart extends PartBase {
  type: 'reasoning';
  text: string;
  metadata?: Record<string, unknown>;
  time: { start: number; end?: number };
}

export interface ToolPart extends PartBase {
  type: 'tool';
  callID: string;
  tool: string;
  state: ToolState;
  metadata?: Record<string, unknown>;
}

export interface StepStartPart extends PartBase {
  type: 'step-start';
  snapshot?: string;
}

export interface StepFinishPart extends PartBase {
  type: 'step-finish';
  reason: string;
  snapshot?: string;
  cost: number;
  tokens: TokenStats;
}

export interface FilePart extends PartBase {
  type: 'file';
  mime: string;
  filename?: string;
  url: string;
  source?: FileSource | SymbolSource | ResourceSource;
}

export interface SubtaskPart extends PartBase {
  type: 'subtask';
  prompt: string;
  description: string;
  agent: string;
  command?: string;
}

export interface AgentPart extends PartBase {
  type: 'agent';
  name: string;
  source?: { value: string; start: number; end: number };
}

export interface CompactionPart extends PartBase {
  type: 'compaction';
  auto: boolean;
}

export interface RetryPart extends PartBase {
  type: 'retry';
  attempt: number;
  error: APIError;
  time: { created: number };
}

export interface SnapshotPart extends PartBase {
  type: 'snapshot';
  snapshot: string;
}

export interface PatchPart extends PartBase {
  type: 'patch';
  hash: string;
  files: string[];
}

// ==================== Part 联合类型 ====================

export type Part =
  | TextPart
  | ReasoningPart
  | ToolPart
  | StepStartPart
  | StepFinishPart
  | FilePart
  | SubtaskPart
  | AgentPart
  | CompactionPart
  | RetryPart
  | SnapshotPart
  | PatchPart;

// ==================== File Part Source ====================

export interface FileSource {
  type: 'file';
  path: string;
  text: { value: string; start: number; end: number };
}

export interface SymbolSource {
  type: 'symbol';
  path: string;
  range: { start: { line: number; character: number }; end: { line: number; character: number } };
  name: string;
  kind: number;
  text: { value: string; start: number; end: number };
}

export interface ResourceSource {
  type: 'resource';
  clientName: string;
  uri: string;
  text: { value: string; start: number; end: number };
}

// ==================== Message Info ====================

export interface UserMessage {
  id: string;
  sessionID: string;
  role: 'user';
  time: { created: number };
  summary?: { title?: string; body?: string; diffs?: unknown[] };
  agent: string;
  model: { providerID: string; modelID: string };
  system?: string;
  tools?: Record<string, boolean>;
  variant?: string;
}

export interface AssistantMessage {
  id: string;
  sessionID: string;
  role: 'assistant';
  time: { created: number; completed?: number };
  parentID: string;
  modelID: string;
  providerID: string;
  agent: string;
  path: { cwd: string; root: string };
  summary?: boolean;
  cost: number;
  tokens: TokenStats;
  finish?: string;
  error?: APIError;
}

export type MessageInfo = UserMessage | AssistantMessage;

// ==================== WithParts ====================

export interface WithParts {
  info: MessageInfo;
  parts: Part[];
}

// ==================== Token Stats ====================

export interface TokenStats {
  input: number;
  output: number;
  reasoning: number;
  cache: { read: number; write: number };
}

// ==================== API Error ====================

export interface APIError {
  message: string;
  statusCode?: number;
  isRetryable: boolean;
  responseHeaders?: Record<string, string>;
  responseBody?: string;
  metadata?: Record<string, string>;
}

// ==================== Tool State (前置声明) ====================
// ToolState 使用前置类型声明避免循环引用
export type ToolState = ToolStatePending | ToolStateRunning | ToolStateCompleted | ToolStateError;

export type ToolStatePending = {
  status: 'pending';
  input: Record<string, unknown>;
  raw: string;
};

export type ToolStateRunning = {
  status: 'running';
  input: Record<string, unknown>;
  title?: string;
  metadata?: Record<string, unknown>;
  time: { start: number };
};

export type ToolStateCompleted = {
  status: 'completed';
  input: Record<string, unknown>;
  output: string;
  title: string;
  metadata: Record<string, unknown>;
  time: { start: number; end: number; compacted?: number };
  attachments?: FilePart[];
};

export type ToolStateError = {
  status: 'error';
  input: Record<string, unknown>;
  error: string;
  metadata?: Record<string, unknown>;
  time: { start: number; end: number };
};

// 重新导出以保持 API 一致性
export type {
  ToolState as IToolState,
  ToolStatePending as IToolStatePending,
  ToolStateRunning as IToolStateRunning,
  ToolStateCompleted as IToolStateCompleted,
  ToolStateError as IToolStateError
};

// ==================== ID 生成器 ====================

/**
 * 生成唯一的消息 ID
 */
export function generateMessageId(): string {
  return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
}

/**
 * 生成唯一的 Part ID
 */
export function generatePartId(): string {
  return `part_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
}

// ==================== Part 工厂函数 ====================

export interface CreateTextPartOptions {
  id?: string;
  sessionID: string;
  messageID: string;
  text: string;
  synthetic?: boolean;
  ignored?: boolean;
  time?: { start: number; end?: number };
  metadata?: Record<string, unknown>;
}

export interface CreateReasoningPartOptions {
  id?: string;
  sessionID: string;
  messageID: string;
  text: string;
  time: { start: number; end?: number };
  metadata?: Record<string, unknown>;
}

export interface CreateStepStartPartOptions {
  id?: string;
  sessionID: string;
  messageID: string;
  snapshot?: string;
}

export interface CreateStepFinishPartOptions {
  id?: string;
  sessionID: string;
  messageID: string;
  reason: string;
  snapshot?: string;
  cost: number;
  tokens: TokenStats;
}

/**
 * 创建 TextPart
 */
export function createTextPart(options: CreateTextPartOptions): TextPart {
  return {
    id: options.id || generatePartId(),
    sessionID: options.sessionID,
    messageID: options.messageID,
    type: 'text',
    text: options.text,
    synthetic: options.synthetic,
    ignored: options.ignored,
    time: options.time,
    metadata: options.metadata,
  };
}

/**
 * 创建 ReasoningPart
 */
export function createReasoningPart(options: CreateReasoningPartOptions): ReasoningPart {
  return {
    id: options.id || generatePartId(),
    sessionID: options.sessionID,
    messageID: options.messageID,
    type: 'reasoning',
    text: options.text,
    time: options.time,
    metadata: options.metadata,
  };
}

/**
 * 创建 StepStartPart
 */
export function createStepStartPart(options: CreateStepStartPartOptions): StepStartPart {
  return {
    id: options.id || generatePartId(),
    sessionID: options.sessionID,
    messageID: options.messageID,
    type: 'step-start',
    snapshot: options.snapshot,
  };
}

/**
 * 创建 StepFinishPart
 */
export function createStepFinishPart(options: CreateStepFinishPartOptions): StepFinishPart {
  return {
    id: options.id || generatePartId(),
    sessionID: options.sessionID,
    messageID: options.messageID,
    type: 'step-finish',
    reason: options.reason,
    snapshot: options.snapshot,
    cost: options.cost,
    tokens: options.tokens,
  };
}

/**
 * 创建 ToolPart
 */
export interface CreateToolPartOptions {
  id?: string;
  sessionID: string;
  messageID: string;
  callID: string;
  tool: string;
  state: ToolState;
  metadata?: Record<string, unknown>;
}

export function createToolPart(options: CreateToolPartOptions): ToolPart {
  return {
    id: options.id || generatePartId(),
    sessionID: options.sessionID,
    messageID: options.messageID,
    type: 'tool',
    callID: options.callID,
    tool: options.tool,
    state: options.state,
    metadata: options.metadata,
  };
}

/**
 * 创建 FilePart
 */
export interface CreateFilePartOptions {
  id?: string;
  sessionID: string;
  messageID: string;
  mime: string;
  filename?: string;
  url: string;
  source?: FileSource | SymbolSource | ResourceSource;
}

export function createFilePart(options: CreateFilePartOptions): FilePart {
  return {
    id: options.id || generatePartId(),
    sessionID: options.sessionID,
    messageID: options.messageID,
    type: 'file',
    mime: options.mime,
    filename: options.filename,
    url: options.url,
    source: options.source,
  };
}

/**
 * 创建 SubtaskPart
 */
export interface CreateSubtaskPartOptions {
  id?: string;
  sessionID: string;
  messageID: string;
  prompt: string;
  description: string;
  agent: string;
  command?: string;
}

export function createSubtaskPart(options: CreateSubtaskPartOptions): SubtaskPart {
  return {
    id: options.id || generatePartId(),
    sessionID: options.sessionID,
    messageID: options.messageID,
    type: 'subtask',
    prompt: options.prompt,
    description: options.description,
    agent: options.agent,
    command: options.command,
  };
}

/**
 * 创建 AgentPart
 */
export interface CreateAgentPartOptions {
  id?: string;
  sessionID: string;
  messageID: string;
  name: string;
  source?: { value: string; start: number; end: number };
}

export function createAgentPart(options: CreateAgentPartOptions): AgentPart {
  return {
    id: options.id || generatePartId(),
    sessionID: options.sessionID,
    messageID: options.messageID,
    type: 'agent',
    name: options.name,
    source: options.source,
  };
}

/**
 * 创建 CompactionPart
 */
export interface CreateCompactionPartOptions {
  id?: string;
  sessionID: string;
  messageID: string;
  auto: boolean;
}

export function createCompactionPart(options: CreateCompactionPartOptions): CompactionPart {
  return {
    id: options.id || generatePartId(),
    sessionID: options.sessionID,
    messageID: options.messageID,
    type: 'compaction',
    auto: options.auto,
  };
}

/**
 * 创建 RetryPart
 */
export interface CreateRetryPartOptions {
  id?: string;
  sessionID: string;
  messageID: string;
  attempt: number;
  error: APIError;
  created?: number;
}

export function createRetryPart(options: CreateRetryPartOptions): RetryPart {
  return {
    id: options.id || generatePartId(),
    sessionID: options.sessionID,
    messageID: options.messageID,
    type: 'retry',
    attempt: options.attempt,
    error: options.error,
    time: { created: options.created || Date.now() },
  };
}

// ==================== Message 工厂函数 ====================

export interface CreateUserMessageOptions {
  id?: string;
  sessionID: string;
  agent: string;
  providerID: string;
  modelID: string;
  system?: string;
  tools?: Record<string, boolean>;
  variant?: string;
  summary?: { title?: string; body?: string; diffs?: unknown[] };
}

export function createUserMessage(options: CreateUserMessageOptions): UserMessage {
  return {
    id: options.id || generateMessageId(),
    sessionID: options.sessionID,
    role: 'user',
    time: { created: Date.now() },
    agent: options.agent,
    model: { providerID: options.providerID, modelID: options.modelID },
    system: options.system,
    tools: options.tools,
    variant: options.variant,
    summary: options.summary,
  };
}

export interface CreateAssistantMessageOptions {
  id?: string;
  sessionID: string;
  parentID: string;
  modelID: string;
  providerID: string;
  agent: string;
  cwd: string;
  root: string;
  summary?: boolean;
}

export function createAssistantMessage(options: CreateAssistantMessageOptions): AssistantMessage {
  return {
    id: options.id || generateMessageId(),
    sessionID: options.sessionID,
    role: 'assistant',
    time: { created: Date.now() },
    parentID: options.parentID,
    modelID: options.modelID,
    providerID: options.providerID,
    agent: options.agent,
    path: { cwd: options.cwd, root: options.root },
    summary: options.summary,
    cost: 0,
    tokens: {
      input: 0,
      output: 0,
      reasoning: 0,
      cache: { read: 0, write: 0 },
    },
  };
}

// ==================== UI Message 类型（用于 toModelMessage） ====================

/**
 * UI 消息部分类型
 */
export type UIPart =
  | { type: 'text'; text: string; providerMetadata?: Record<string, unknown> }
  | { type: 'reasoning'; text: string; providerMetadata?: Record<string, unknown> }
  | ({ type: `tool-${string}`; state: 'output-available'; toolCallId: string; input: Record<string, unknown>; output: string; callProviderMetadata?: Record<string, unknown> })
  | ({ type: `tool-${string}`; state: 'output-error'; toolCallId: string; input: Record<string, unknown>; errorText: string; callProviderMetadata?: Record<string, unknown> })
  | { type: 'file'; url: string; mediaType: string; filename?: string };

/**
 * UI 消息接口
 */
export interface UIMessage {
  id: string;
  role: 'user' | 'assistant';
  parts: UIPart[];
}

// ==================== toModelMessage 消息格式转换 ====================

/**
 * 将 WithParts[] 转换为 AI SDK 兼容的格式
 * @param input WithParts 数组
 * @returns UIMessage 数组（可直接传递给 AI SDK）
 */
export function toModelMessage(input: WithParts[]): UIMessage[] {
  const result: UIMessage[] = [];

  for (const msg of input) {
    if (msg.parts.length === 0) continue;

    // 处理 User 消息
    if (msg.info.role === 'user') {
      const userMessage: UIMessage = {
        id: msg.info.id,
        role: 'user',
        parts: [],
      };
      result.push(userMessage);

      for (const part of msg.parts) {
        if (part.type === 'text' && !part.ignored) {
          userMessage.parts.push({
            type: 'text',
            text: part.text,
          });
        }
        if (part.type === 'file' && part.mime !== 'text/plain' && part.mime !== 'application/x-directory') {
          userMessage.parts.push({
            type: 'file',
            url: part.url,
            mediaType: part.mime,
            filename: part.filename,
          });
        }
        if (part.type === 'compaction') {
          userMessage.parts.push({
            type: 'text',
            text: 'What did we do so far?',
          });
        }
        if (part.type === 'subtask') {
          userMessage.parts.push({
            type: 'text',
            text: 'The following tool was executed by the user',
          });
        }
      }
    }

    // 处理 Assistant 消息
    if (msg.info.role === 'assistant') {
      // 过滤掉错误消息（除非有非 step-start/reasoning 的 parts）
      if (
        'error' in msg.info &&
        msg.info.error &&
        !msg.parts.some((part) => part.type !== 'step-start' && part.type !== 'reasoning')
      ) {
        continue;
      }

      const assistantMessage: UIMessage = {
        id: msg.info.id,
        role: 'assistant',
        parts: [],
      };

      for (const part of msg.parts) {
        if (part.type === 'text') {
          assistantMessage.parts.push({
            type: 'text',
            text: part.text,
            providerMetadata: part.metadata,
          });
        }
        if (part.type === 'tool') {
          if (part.state.status === 'completed') {
            // 如果有附件，添加到结果中
            if ('attachments' in part.state && part.state.attachments && part.state.attachments.length > 0) {
              result.push({
                id: `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
                role: 'user',
                parts: [
                  {
                    type: 'text',
                    text: `Tool ${part.tool} returned an attachment:`,
                  },
                  ...part.state.attachments.map((attachment) => ({
                    type: 'file' as const,
                    url: attachment.url,
                    mediaType: attachment.mime,
                    filename: attachment.filename,
                  })),
                ],
              });
            }
            assistantMessage.parts.push({
              type: `tool-${part.tool}` as const,
              state: 'output-available' as const,
              toolCallId: part.callID,
              input: part.state.input,
              output: 'time' in part.state && part.state.time && 'compacted' in part.state.time ? '[Old tool result content cleared]' : part.state.output,
              callProviderMetadata: part.metadata,
            });
          }
          if (part.state.status === 'error') {
            assistantMessage.parts.push({
              type: `tool-${part.tool}` as const,
              state: 'output-error' as const,
              toolCallId: part.callID,
              input: part.state.input,
              errorText: part.state.error,
              callProviderMetadata: part.metadata,
            });
          }
        }
        if (part.type === 'reasoning') {
          assistantMessage.parts.push({
            type: 'reasoning',
            text: part.text,
            providerMetadata: part.metadata,
          });
        }
      }

      if (assistantMessage.parts.length > 0) {
        result.push(assistantMessage);
      }
    }
  }

  return result;
}
````

## File: src/types/reflector.ts
````typescript
/**
 * Reflector 相关类型定义
 * Stage 1: Reflector MVP - 规则引擎版
 */

import { ErrorType } from './trajectory';

/**
 * 错误模式规则
 * 定义常见错误类型的识别规则和解决方案
 */
export interface ErrorPatternRule {
  error_type: ErrorType;
  keywords: string[];
  anti_pattern: string;
  solution: string;
  tags: string[];
}

/**
 * 失败模式分析结果
 * 从失败 Trajectory 中提取的反模式信息
 */
export interface FailurePattern {
  error_type: ErrorType;
  occurrences: number;
  failed_trajectories: string[];
  anti_pattern: string;
  solution: string;
  tags: string[];
  confidence: number;
}
````

## File: src/types/task-queue.ts
````typescript
/**
 * Task Queue Types - Playbook 反思任务队列类型定义
 *
 * 用于支持 Stage 0.5: 任务队列基础设施
 * - 事件驱动 + SQLite 持久化任务队列 + 闲时调度模式
 */

/**
 * 任务类型枚举
 */
export enum TaskType {
  /** 生成 Playbook（从成功 Trajectory） */
  GENERATE = 'GENERATE',

  /** 反思失败模式（从失败 Trajectory） */
  REFLECT = 'REFLECT',

  /** 维护知识库（去重/归档） */
  CURATE = 'CURATE'
}

/**
 * 任务状态枚举
 */
export enum TaskStatus {
  /** 待处理 */
  PENDING = 'PENDING',

  /** 处理中 */
  PROCESSING = 'PROCESSING',

  /** 已完成 */
  COMPLETED = 'COMPLETED',

  /** 失败 */
  FAILED = 'FAILED'
}

/**
 * 任务优先级
 */
export enum TaskPriority {
  /** 普通优先级 */
  NORMAL = 0,

  /** 高优先级（失败任务反思） */
  HIGH = 1,

  /** 紧急（手动触发） */
  URGENT = 2
}

/**
 * 反思任务实体
 */
export interface ReflectionTask {
  id: string;
  task_type: TaskType;
  trajectory_id?: string;
  status: TaskStatus;
  priority: TaskPriority;
  payload?: Record<string, unknown>;
  error_message?: string;
  retry_count: number;
  created_at: Date;
  updated_at: Date;
  scheduled_at?: Date;
  completed_at?: Date;
}

/**
 * 任务统计信息
 */
export interface TaskQueueStats {
  total: number;
  pending: number;
  processing: number;
  completed: number;
  failed: number;
  by_type: {
    [key in TaskType]: number;
  };
}

/**
 * 入队任务参数
 */
export interface EnqueueTaskParams {
  task_type: TaskType;
  trajectory_id?: string;
  priority?: TaskPriority;
  payload?: Record<string, unknown>;
  scheduled_at?: Date;
}

/**
 * 任务处理器函数类型
 */
export type TaskHandler = (task: ReflectionTask) => Promise<void>;

/**
 * 闲时调度器配置
 */
export interface IdleSchedulerOptions {
  /** CPU 使用率阈值（默认 0.3 即 30%） */
  cpuThreshold?: number;
  /** 检查间隔（毫秒，默认 30000） */
  checkIntervalMs?: number;
}

/**
 * SQLite 数据库行映射类型
 */
export interface ReflectionQueueRow {
  id: string;
  task_type: string;
  trajectory_id: string | null;
  status: string;
  priority: number;
  payload: string | null;
  error_message: string | null;
  retry_count: number;
  created_at: string;
  updated_at: string;
  scheduled_at: string | null;
  completed_at: string | null;
}
````

## File: src/types/tool-state.ts
````typescript
/**
 * Tool State - ToolState 状态机定义
 */

import type { FilePart, ToolState, ToolStatePending, ToolStateRunning, ToolStateCompleted, ToolStateError } from './message-v2';

// ==================== Tool State 类型守卫 ====================

export function isToolStatePending(state: ToolState): state is ToolStatePending {
  return state.status === 'pending';
}

export function isToolStateRunning(state: ToolState): state is ToolStateRunning {
  return state.status === 'running';
}

export function isToolStateCompleted(state: ToolState): state is ToolStateCompleted {
  return state.status === 'completed';
}

export function isToolStateError(state: ToolState): state is ToolStateError {
  return state.status === 'error';
}

// ==================== Tool State 工厂函数 ====================

export interface CreateToolStatePendingOptions {
  input: Record<string, unknown>;
  raw: string;
}

export function createToolStatePending(options: CreateToolStatePendingOptions): ToolStatePending {
  return {
    status: 'pending',
    input: options.input,
    raw: options.raw,
  };
}

export interface CreateToolStateRunningOptions {
  input: Record<string, unknown>;
  title?: string;
  metadata?: Record<string, unknown>;
  startTime?: number;
}

export function createToolStateRunning(options: CreateToolStateRunningOptions): ToolStateRunning {
  return {
    status: 'running',
    input: options.input,
    title: options.title,
    metadata: options.metadata,
    time: { start: options.startTime || Date.now() },
  };
}

export interface CreateToolStateCompletedOptions {
  input: Record<string, unknown>;
  output: string;
  title: string;
  metadata?: Record<string, unknown>;
  attachments?: FilePart[];
  startTime?: number;
  endTime?: number;
}

export function createToolStateCompleted(options: CreateToolStateCompletedOptions): ToolStateCompleted {
  const startTime = options.startTime || Date.now();
  return {
    status: 'completed',
    input: options.input,
    output: options.output,
    title: options.title,
    metadata: options.metadata || {},
    time: {
      start: startTime,
      end: options.endTime || Date.now(),
    },
    attachments: options.attachments,
  };
}

export interface CreateToolStateErrorOptions {
  input: Record<string, unknown>;
  error: string;
  metadata?: Record<string, unknown>;
  startTime?: number;
  endTime?: number;
}

export function createToolStateError(options: CreateToolStateErrorOptions): ToolStateError {
  const startTime = options.startTime || Date.now();
  return {
    status: 'error',
    input: options.input,
    error: options.error,
    metadata: options.metadata,
    time: {
      start: startTime,
      end: options.endTime || Date.now(),
    },
  };
}

// ==================== Tool State 转换函数 ====================

export function pendingToRunning(pending: ToolStatePending, title?: string): ToolStateRunning {
  return {
    status: 'running',
    input: pending.input,
    title,
    time: { start: Date.now() },
  };
}

export function runningToCompleted(
  running: ToolStateRunning,
  output: string,
  title: string,
  attachments?: FilePart[]
): ToolStateCompleted {
  return {
    status: 'completed',
    input: running.input,
    output,
    title,
    metadata: running.metadata || {},
    time: {
      start: running.time.start,
      end: Date.now(),
    },
    attachments,
  };
}

export function runningToError(running: ToolStateRunning, error: string, metadata?: Record<string, unknown>): ToolStateError {
  return {
    status: 'error',
    input: running.input,
    error,
    metadata: metadata || running.metadata,
    time: {
      start: running.time.start,
      end: Date.now(),
    },
  };
}

// ==================== Tool State 工具函数 ====================

/**
 * 检查 Tool 是否已完成（成功或失败）
 */
export function isToolCompleted(state: ToolState): boolean {
  return state.status === 'completed' || state.status === 'error';
}

/**
 * 获取 Tool 执行的持续时间（毫秒）
 */
export function getToolDuration(state: ToolState): number | null {
  if (state.status === 'pending' || state.status === 'running') return null;
  return state.time.end - state.time.start;
}

/**
 * 标记 Tool 为已完成（压缩状态）
 */
export function compactToolState(completed: ToolStateCompleted): ToolStateCompleted {
  return {
    ...completed,
    time: {
      ...completed.time,
      compacted: Date.now(),
    },
    output: '[Old tool result content cleared]',
  };
}
````

## File: src/types/tool-system.ts
````typescript
/**
 * 工具系统类型定义
 * 基于OpenSpec提案：内置工具与Skills外置工具融合架构
 */

/**
 * 工具类型枚举
 */
export enum ToolType {
  BUILTIN = 'builtin',
  SKILL = 'skill'
}

/**
 * 工具执行选项
 */
export interface ToolExecuteOptions {
  /** 工具名称 */
  name: string;
  /** 工具参数 */
  args: Record<string, any>;
  /** 执行超时时间（毫秒） */
  timeout?: number;
  /** 最大输出大小（字节） */
  maxOutputSize?: number;
  /** 并发限制 */
  concurrency?: number;
}

/**
 * 工具执行结果
 */
export interface ToolResult {
  /** 执行是否成功 */
  success: boolean;
  /** 输出内容 */
  output?: string;
  /** 标准错误输出 */
  stderr?: string;
  /** 退出码 */
  exitCode?: number;
  /** 执行耗时（毫秒） */
  duration: number;
  /** 错误信息 */
  error?: string;
  /** 错误代码 */
  errorCode?: string;
}

/**
 * 内置工具定义
 */
export interface BuiltInTool {
  /** 工具名称 */
  name: string;
  /** 工具描述 */
  description: string;
  /** 工具类型 */
  type: ToolType.BUILTIN;
  /** 工具分类 */
  category: string;
  /** 工具级别（用于排序） */
  level: number;
  /** 工具参数模式 */
  parameters: ToolParameterSchema;
  /** 工具执行函数 */
  execute: (args: Record<string, any>) => Promise<ToolResult>;
  /** 是否启用 */
  enabled: boolean;
}

/**
 * Skills工具定义
 */
export interface SkillTool {
  /** 工具名称 */
  name: string;
  /** 工具描述 */
  description: string;
  /** 工具类型 */
  type: ToolType.SKILL;
  /** 工具标签 */
  tags: string[];
  /** Skills版本 */
  version: string;
  /** Skills安装路径 */
  path: string;
  /** 工具参数模式 */
  parameters: ToolParameterSchema;
  /** 作者信息 */
  author?: string;
  /** 是否启用 */
  enabled: boolean;
  /** 工具等级 */
  level: number;
}

/**
 * 工具参数模式
 */
export interface ToolParameterSchema {
  /** 参数类型 */
  type: 'object';
  /** 参数属性 */
  properties: Record<string, ToolParameterProperty>;
  /** 必需参数 */
  required?: string[];
  /** 额外属性是否允许 */
  additionalProperties?: boolean;
}

/**
 * 工具参数属性
 */
export interface ToolParameterProperty {
  /** 参数类型 */
  type: string;
  /** 参数描述 */
  description: string;
  /** 默认值 */
  default?: any;
  /** 枚举值 */
  enum?: any[];
  /** 最小值（数字类型） */
  minimum?: number;
  /** 最大值（数字类型） */
  maximum?: number;
  /** 最小长度（字符串类型） */
  minLength?: number;
  /** 最大长度（字符串类型） */
  maxLength?: number;
  /** 模式匹配（字符串类型） */
  pattern?: string;
}

/**
 * 工具执行器接口
 */
export interface ToolExecutor {
  /** 执行工具 */
  execute(options: ToolExecuteOptions): Promise<ToolResult>;
  /** 获取支持的工具列表 */
  listTools(): (BuiltInTool | SkillTool)[];
  /** 检查工具是否存在 */
  hasTool(name: string): boolean;
  /** 获取工具详情 */
  getTool(name: string): BuiltInTool | SkillTool | undefined;
}

/**
 * 工具检索结果
 */
export interface ToolRetrievalResult {
  /** 匹配的工具 */
  tool: BuiltInTool | SkillTool;
  /** 相似度分数 */
  score: number;
  /** 匹配原因 */
  reason?: string;
}

/**
 * Skills元数据
 */
export interface SkillMetadata {
  /** Skills名称 */
  name: string;
  /** Skills描述 */
  description: string;
  /** Skills版本 */
  version: string;
  /** Skills标签 */
  tags: string[];
  /** 作者信息 */
  author?: string;
  /** 依赖项 */
  dependencies?: string[];
  /** 参数模式 */
  parameters?: ToolParameterSchema;
  /** Skills分类 */
  category?: string;
  /** 工具列表 */
  tools?: string[];
}

/**
 * Skills安装选项
 */
export interface SkillInstallOptions {
  /** 是否覆盖已存在的Skills */
  overwrite?: boolean;
  /** 是否跳过向量化 */
  skipVectorization?: boolean;
  /** 验证级别 */
  validationLevel?: 'strict' | 'basic' | 'none';
}

/**
 * Skills列表查询选项
 */
export interface SkillListOptions {
  /** 名称过滤 */
  name?: string;
  /** 标签过滤 */
  tags?: string[];
  /** 分页页码 */
  page?: number;
  /** 每页限制 */
  limit?: number;
  /** 排序字段 */
  sortBy?: 'name' | 'installedAt' | 'updatedAt';
  /** 排序方向 */
  sortOrder?: 'asc' | 'desc';
}

/**
 * Skills列表结果
 */
export interface SkillListResult {
  /** Skills列表 */
  skills: SkillTool[];
  /** 总数 */
  total: number;
  /** 当前页码 */
  page: number;
  /** 每页数量 */
  limit: number;
  /** 总页数 */
  totalPages: number;
}

/**
 * Skills统计信息
 */
export interface SkillStatistics {
  /** 总数 */
  total: number;
  /** 按标签统计 */
  byTag?: Record<string, number>;
  /** 按分类统计 */
  byCategory?: Record<string, number>;
  /** 安装趋势 */
  growth?: Array<{
    date: string;
    count: number;
  }>;
}

/**
 * 沙箱执行选项
 */
export interface SandboxExecutionOptions {
  /** 执行超时时间（毫秒） */
  timeout?: number;
  /** 最大输出大小（字节） */
  maxOutputSize?: number;
  /** 内存限制（MB） */
  memoryLimit?: number;
  /** 并发限制 */
  maxConcurrency?: number;
  /** 环境变量白名单 */
  allowedEnvVars?: string[];
  /** 工作区路径 */
  workspacePath?: string;
}

/**
 * 沙箱执行结果
 */
export interface SandboxExecutionResult {
  /** 执行是否成功 */
  success: boolean;
  /** 标准输出 */
  stdout: string;
  /** 标准错误 */
  stderr: string;
  /** 退出码 */
  exitCode: number;
  /** 执行耗时（毫秒） */
  duration: number;
  /** 错误信息 */
  error?: string;
  /** 是否被截断 */
  truncated?: boolean;
}

/**
 * 工具检索服务配置
 */
export interface ToolRetrievalConfig {
  /** 向量数据库路径 */
  vectorDbPath: string;
  /** 嵌入模型名称 */
  model: string;
  /** 向量维度 */
  dimensions: number;
  /** 相似度阈值 */
  similarityThreshold: number;
  /** 缓存大小 */
  cacheSize: number;
  /** 最大返回结果数 */
  maxResults?: number;
}

/**
 * Skills配置
 */
export interface SkillsConfig {
  /** 存储配置 */
  storage: {
    /** Skills存储路径 */
    path: string;
    /** 向量数据库路径 */
    vectorDbPath: string;
  };
  /** 检索配置 */
  retrieval: ToolRetrievalConfig;
  /** 执行配置 */
  execution: SandboxExecutionOptions;
}

/**
 * 错误代码枚举
 */
export enum ToolErrorCode {
  TOOL_NOT_FOUND = 'TOOL_NOT_FOUND',
  TOOL_EXECUTION_FAILED = 'TOOL_EXECUTION_FAILED',
  TOOL_TIMEOUT = 'TOOL_TIMEOUT',
  TOOL_OUTPUT_EXCEEDED = 'TOOL_OUTPUT_EXCEEDED',
  TOOL_MEMORY_EXCEEDED = 'TOOL_MEMORY_EXCEEDED',
  SKILL_NOT_FOUND = 'SKILL_NOT_FOUND',
  SKILL_INVALID_STRUCTURE = 'INVALID_SKILL_STRUCTURE',
  SKILL_ALREADY_EXISTS = 'SKILL_ALREADY_EXISTS',
  VECTOR_DB_ERROR = 'VECTOR_DB_ERROR',
  EMBEDDING_MODEL_ERROR = 'EMBEDDING_MODEL_ERROR'
}

/**
 * 工具错误类
 */
export class ToolError extends Error {
  constructor(
    message: string,
    public code: ToolErrorCode,
    public details?: any
  ) {
    super(message);
    this.name = 'ToolError';
  }
}
````

## File: src/types/trajectory.ts
````typescript
/**
 * Trajectory 相关类型定义
 * Stage 0.6: Trajectory 质量提升
 */

/**
 * 错误类型枚举
 */
export enum ErrorType {
  /** 网络连接失败 */
  NETWORK_ERROR = 'network',

  /** 请求超时 */
  TIMEOUT = 'timeout',

  /** API 速率限制 */
  RATE_LIMIT = 'rate_limit',

  /** 输入参数错误 */
  INVALID_INPUT = 'invalid_input',

  /** 业务逻辑错误 */
  LOGIC_ERROR = 'logic',

  /** 资源耗尽（内存/磁盘） */
  RESOURCE_EXHAUSTED = 'resource',

  /** 权限不足 */
  PERMISSION_DENIED = 'permission',

  /** 未知错误 */
  UNKNOWN = 'unknown'
}

/**
 * 工具调用详情
 */
export interface ToolCallDetails {
  tool_name: string;
  input_params: Record<string, any>;
  output_content: string;
  output_metadata?: {
    token_count?: number;
    execution_time_ms?: number;
    rate_limit_remaining?: number;
  };
}

/**
 * 错误详情
 */
export interface ErrorDetails {
  error_type: ErrorType;
  error_message: string;
  error_stack?: string;
  context?: Record<string, any>;
}

/**
 * 轨迹步骤（增强版）
 */
export interface TrajectoryStep {
  thought: string;
  action: string;
  output: string;

  // 🆕 工具调用详情
  tool_details?: ToolCallDetails;

  // 🆕 错误详情
  error_details?: ErrorDetails;

  // 保留原有 duration 和 timestamp 字段
  duration?: number;
  timestamp?: number;
}

/**
 * 轨迹完整结构（增强版）
 */
export interface Trajectory {
  task_id: string;
  session_id?: string;
  user_input: string;
  steps: TrajectoryStep[];
  final_result: string;
  outcome: 'SUCCESS' | 'FAILURE';
  environment_feedback: string;
  used_rule_ids: string[];
  timestamp: number;
  duration_ms: number;
  evolution_status: 'PENDING' | 'COMPLETED' | 'FAILED';
}
````

## File: src/types/vector.ts
````typescript
/**
 * Vector Search 相关类型定义
 */

export interface VectorToolResult {
  id: string;
  tool: any;
  score: number;
  metadata?: Record<string, any>;
}

export interface VectorSearchResult {
  id: string;
  score: number;
  metadata?: Record<string, any>;
}
````

## File: src/utils/config/disclosure-config.ts
````typescript
/**
 * Disclosure Configuration Loader
 *
 * Phase 2: 三层披露机制配置加载
 * 从 disclosure.yaml 加载披露配置，支持默认值回退
 */

import * as fs from "fs";
import * as path from "path";
import * as yaml from "js-yaml";
import { logger } from "../logger";
import { PathService } from "../../services/PathService";
import { DisclosureManagerConfigV2 } from "../../services/tool-retrieval/DisclosureManager";
import { DisclosureStrategy } from "../../types/enhanced-skill";

/**
 * 披露配置原始结构
 */
interface DisclosureConfigRaw {
  disclosure: {
    enabled: boolean;
    thresholds: { l2: number; l3: number };
    tokenBudget: {
      l1MaxTokens: number;
      l2MaxTokens: number;
      adaptiveMaxTokens: number;
    };
    cache: {
      enabled: boolean;
      maxSize: number;
      l1TtlMs: number;
      l2TtlMs: number;
      cleanupIntervalMs: number;
    };
    parallelLoad: { enabled: boolean; maxConcurrency: number };
    metrics: { enabled: boolean; sampleRate: number };
  };
}

/**
 * 披露配置加载器
 * 单例模式，带缓存
 */
export class DisclosureConfigLoader {
  private static instance: DisclosureConfigLoader | null = null;
  private configCache: DisclosureManagerConfigV2 | null = null;
  private readonly configPath: string;

  private constructor() {
    const pathService = PathService.getInstance();
    this.configPath = path.join(pathService.getConfigDir(), "disclosure.yaml");
  }

  /**
   * 获取单例实例
   */
  public static getInstance(): DisclosureConfigLoader {
    if (!DisclosureConfigLoader.instance) {
      DisclosureConfigLoader.instance = new DisclosureConfigLoader();
    }
    return DisclosureConfigLoader.instance;
  }

  /**
   * 加载配置（同步）
   */
  public loadSync(): DisclosureManagerConfigV2 {
    if (this.configCache) {
      return this.configCache;
    }

    try {
      if (!fs.existsSync(this.configPath)) {
        logger.info("[DisclosureConfigLoader] Config file not found, using defaults");
        this.configCache = this.getDefaultConfig();
        return this.configCache;
      }

      const content = fs.readFileSync(this.configPath, "utf-8");
      const raw = yaml.load(content) as DisclosureConfigRaw;

      this.configCache = this.parseConfig(raw);
      return this.configCache;
    } catch (error) {
      logger.error("[DisclosureConfigLoader] Failed to load config, using defaults", error);
      this.configCache = this.getDefaultConfig();
      return this.configCache;
    }
  }

  /**
   * 加载配置（异步）
   */
  public async loadAsync(): Promise<DisclosureManagerConfigV2> {
    if (this.configCache) {
      return this.configCache;
    }

    try {
      if (!fs.existsSync(this.configPath)) {
        logger.info("[DisclosureConfigLoader] Config file not found, using defaults");
        this.configCache = this.getDefaultConfig();
        return this.configCache;
      }

      const content = await fs.promises.readFile(this.configPath, "utf-8");
      const raw = yaml.load(content) as DisclosureConfigRaw;

      this.configCache = this.parseConfig(raw);
      return this.configCache;
    } catch (error) {
      logger.error("[DisclosureConfigLoader] Failed to load config, using defaults", error);
      this.configCache = this.getDefaultConfig();
      return this.configCache;
    }
  }

  /**
   * 清除缓存
   */
  public clearCache(): void {
    this.configCache = null;
  }

  /**
   * 获取配置文件路径
   */
  public getConfigPath(): string {
    return this.configPath;
  }

  /**
   * 解析配置
   */
  private parseConfig(raw: DisclosureConfigRaw): DisclosureManagerConfigV2 {
    const disclosure = raw.disclosure;

    return {
      enabled: disclosure.enabled ?? true,
      strategy: DisclosureStrategy.METADATA,
      adaptiveMaxTokens: disclosure.tokenBudget?.adaptiveMaxTokens ?? 3000,
      preferMetadataBelow: 500,
      thresholds: {
        l2: disclosure.thresholds?.l2 ?? 0.7,
        l3: disclosure.thresholds?.l3 ?? 0.85,
      },
      l1MaxTokens: disclosure.tokenBudget?.l1MaxTokens ?? 120,
      l2MaxTokens: disclosure.tokenBudget?.l2MaxTokens ?? 5000,
      cache: {
        enabled: disclosure.cache?.enabled ?? true,
        maxSize: disclosure.cache?.maxSize ?? 2000,
        l1TtlMs: disclosure.cache?.l1TtlMs ?? 300000,
        l2TtlMs: disclosure.cache?.l2TtlMs ?? 300000,
        cleanupIntervalMs: disclosure.cache?.cleanupIntervalMs ?? 300000,
      },
      parallelLoad: {
        enabled: disclosure.parallelLoad?.enabled ?? true,
        maxConcurrency: disclosure.parallelLoad?.maxConcurrency ?? 8,
      },
      metrics: {
        enabled: disclosure.metrics?.enabled ?? true,
        sampleRate: disclosure.metrics?.sampleRate ?? 1.0,
      },
    };
  }

  /**
   * 获取默认配置
   */
  private getDefaultConfig(): DisclosureManagerConfigV2 {
    return {
      enabled: true,
      strategy: DisclosureStrategy.METADATA,
      adaptiveMaxTokens: 3000,
      preferMetadataBelow: 500,
      thresholds: { l2: 0.7, l3: 0.85 },
      l1MaxTokens: 120,
      l2MaxTokens: 5000,
      cache: {
        enabled: true,
        maxSize: 2000,
        l1TtlMs: 300000,
        l2TtlMs: 300000,
        cleanupIntervalMs: 300000,
      },
      parallelLoad: { enabled: true, maxConcurrency: 8 },
      metrics: { enabled: true, sampleRate: 1.0 },
    };
  }
}

/**
 * 获取披露配置（便捷函数）
 */
export function getDisclosureConfig(): DisclosureManagerConfigV2 {
  return DisclosureConfigLoader.getInstance().loadSync();
}

/**
 * 异步获取披露配置（便捷函数）
 */
export async function getDisclosureConfigAsync(): Promise<DisclosureManagerConfigV2> {
  return DisclosureConfigLoader.getInstance().loadAsync();
}
````

## File: src/utils/config-constants.ts
````typescript
import type {
  AdminConfig,
  RateLimitSettings,
  RedisConfig,
  SystemConfig,
  FullConfig
} from '../types/config/index';
import type { ApiKeyInfo } from '../types/config/api-key';

/**
 * 默认 API Key 信息
 */
export const DEFAULT_API_KEY: ApiKeyInfo = {
  id: 'default',
  name: '默认项目',
  key: '',
  createdAt: Date.now()
};

/**
 * 创建默认速率限制设置
 */
export function createDefaultRateLimitSettings(): RateLimitSettings {
  return {
    enabled: true,
    windowMs: 15 * 60 * 1000, // 15分钟
    max: 1000, // 限制每个IP 15分钟内最多1000个请求
    message: '请求过于频繁，请稍后再试',
    standardHeaders: true,
    legacyHeaders: false,
    trustProxy: false
  };
}

/**
 * 默认 Redis 配置
 */
export const DEFAULT_REDIS_CONFIG: RedisConfig = {
  enabled: false,
  host: 'localhost',
  port: 6379,
  db: 0,
  keyPrefix: 'apex_bridge:',
  connectTimeout: 10000,
  lazyConnect: true,
  maxRetriesPerRequest: 3,
  retryDelayOnFailover: 100
};

/**
 * 默认配置
 */
export const DEFAULT_CONFIG: AdminConfig = {
  api: {
    host: '0.0.0.0',
    port: 3000,
    cors: {
      origin: '*',
      credentials: true
    }
  },
  llm: {
    providers: [],
    defaultProvider: 'openai',
    timeout: 30000,
    maxRetries: 3
  },
  auth: {
    enabled: true,
    apiKey: process.env.ABP_API_KEY || '',
    jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
    jwtExpiresIn: '24h'
  },
  performance: {
    workerPoolSize: 4,
    requestTimeout: 60000,
    maxRequestSize: '50mb'
  },
  redis: {
    ...DEFAULT_REDIS_CONFIG
  },
  security: {
    rateLimit: createDefaultRateLimitSettings()
  }
};
````

## File: src/utils/config-loader.ts
````typescript
/**
 * 配置加载器
 * 负责从文件系统读取和缓存配置
 */

import * as fs from 'fs';
import * as fsPromises from 'fs/promises';
import * as path from 'path';
import { logger } from './logger';
import type { AdminConfig } from '../types/config/index';
import { DEFAULT_CONFIG } from './config-constants';
import { PathService } from '../services/PathService';

export class ConfigLoader {
  private static instance: ConfigLoader | null = null;
  private configCache: AdminConfig | null = null;
  private readonly configPath: string;

  private constructor() {
    const pathService = PathService.getInstance();
    this.configPath = pathService.getConfigFilePath();
  }

  /**
   * 获取单例实例
   */
  public static getInstance(): ConfigLoader {
    if (!ConfigLoader.instance) {
      ConfigLoader.instance = new ConfigLoader();
    }
    return ConfigLoader.instance;
  }

  /**
   * 读取配置（同步）
   */
  public loadSync(): AdminConfig {
    if (this.configCache) {
      return this.configCache;
    }

    try {
      const configData = fs.readFileSync(this.configPath, 'utf-8');
      const config = JSON.parse(configData) as AdminConfig;
      this.configCache = config;
      return config;
    } catch (error: unknown) {
      const err = error as { code?: string; message?: string };
      if (err.code === 'ENOENT') {
        logger.warn(`配置文件不存在: ${this.configPath}，创建默认配置`);
        this.writeSync(DEFAULT_CONFIG);
        return DEFAULT_CONFIG;
      }
      logger.error(`配置文件损坏: ${this.configPath}`, err.message);
      throw new Error(`Configuration load failed: ${err.message}`);
    }
  }

  /**
   * 读取配置（异步）
   */
  public async loadAsync(): Promise<AdminConfig> {
    if (this.configCache) {
      return this.configCache;
    }

    try {
      const configData = await fsPromises.readFile(this.configPath, 'utf-8');
      const config = JSON.parse(configData) as AdminConfig;
      this.configCache = config;
      return config;
    } catch (error: unknown) {
      const err = error as { code?: string; message?: string };
      if (err.code === 'ENOENT') {
        logger.warn(`配置文件不存在: ${this.configPath}，创建默认配置`);
        await this.writeAsync(DEFAULT_CONFIG);
        return DEFAULT_CONFIG;
      }
      logger.error(`配置文件损坏: ${this.configPath}`, err.message);
      throw new Error(`Configuration load failed: ${err.message}`);
    }
  }

  /**
   * 写入配置（同步 - 原子写入）
   */
  public writeSync(config: AdminConfig): void {
    try {
      const configDir = path.dirname(this.configPath);
      if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { recursive: true });
      }

      const configData = JSON.stringify(config, null, 2);
      const tempPath = `${this.configPath}.tmp`;

      fs.writeFileSync(tempPath, configData, 'utf-8');
      fs.renameSync(tempPath, this.configPath);

      this.configCache = config;
      logger.info(`配置已保存: ${this.configPath}`);
    } catch (error) {
      logger.error(`写入配置失败: ${this.configPath}`, error);
      // 清理可能的临时文件
      try {
        const tempPath = `${this.configPath}.tmp`;
        if (fs.existsSync(tempPath)) {
          fs.unlinkSync(tempPath);
        }
      } catch {
        // 忽略清理错误
      }
      throw error;
    }
  }

  /**
   * 写入配置（异步 - 原子写入）
   */
  public async writeAsync(config: AdminConfig): Promise<void> {
    try {
      const configDir = path.dirname(this.configPath);
      await fsPromises.mkdir(configDir, { recursive: true });

      const configData = JSON.stringify(config, null, 2);
      const tempPath = `${this.configPath}.tmp`;

      await fsPromises.writeFile(tempPath, configData, 'utf-8');
      await fsPromises.rename(tempPath, this.configPath);

      this.configCache = config;
      logger.info(`配置已保存: ${this.configPath}`);
    } catch (error) {
      logger.error(`写入配置失败: ${this.configPath}`, error);
      // 清理可能的临时文件
      try {
        const tempPath = `${this.configPath}.tmp`;
        await fsPromises.unlink(tempPath).catch(() => {
          // 忽略清理错误
        });
      } catch {
        // 忽略清理错误
      }
      throw error;
    }
  }

  /**
   * 清除缓存
   */
  public clearCache(): void {
    this.configCache = null;
  }

  /**
   * 获取缓存的配置
   */
  public getCached(): AdminConfig | null {
    return this.configCache;
  }
}
````

## File: src/utils/config-writer.ts
````typescript
/**
 * 配置写入器
 * 负责配置的更新和合并
 */

import type { AdminConfig } from '../types/config/index';
import { ConfigLoader } from './config-loader';

export class ConfigWriter {
  private readonly loader: ConfigLoader;

  constructor() {
    this.loader = ConfigLoader.getInstance();
  }

  /**
   * 更新配置（异步）
   */
  public async updateAsync(updates: Partial<AdminConfig>): Promise<AdminConfig> {
    const currentConfig = await this.loader.loadAsync();
    const updatedConfig = this.mergeConfig(currentConfig, updates);
    await this.loader.writeAsync(updatedConfig);
    return updatedConfig;
  }

  /**
   * 更新配置（同步）
   */
  public update(updates: Partial<AdminConfig>): AdminConfig {
    const currentConfig = this.loader.loadSync();
    const updatedConfig = this.mergeConfig(currentConfig, updates);
    this.loader.writeSync(updatedConfig);
    return updatedConfig;
  }

  /**
   * 重载配置
   */
  public reload(): AdminConfig {
    this.loader.clearCache();
    return this.loader.loadSync();
  }

  /**
   * 递归合并配置对象
   */
  private mergeConfig(base: AdminConfig, updates: Partial<AdminConfig>): AdminConfig {
    const result: AdminConfig = { ...base };

    for (const key of Object.keys(updates)) {
      const updateValue = updates[key as keyof Partial<AdminConfig>];
      const baseValue = base[key as keyof AdminConfig];

      // 如果更新值和基础值都是对象（非数组），进行递归合并
      if (
        updateValue !== undefined &&
        updateValue !== null &&
        typeof updateValue === 'object' &&
        !Array.isArray(updateValue) &&
        baseValue !== undefined &&
        baseValue !== null &&
        typeof baseValue === 'object' &&
        !Array.isArray(baseValue)
      ) {
        result[key as keyof AdminConfig] = this.mergeConfig(
          baseValue as AdminConfig,
          updateValue as Partial<AdminConfig>
        ) as AdminConfig[keyof AdminConfig];
      } else if (updateValue !== undefined) {
        result[key as keyof AdminConfig] = updateValue as AdminConfig[keyof AdminConfig];
      }
    }

    return result;
  }
}
````

## File: src/utils/message-utils.ts
````typescript
/**
 * 消息工具函数
 * 用于处理多模态消息和纯文本消息的通用操作
 */

import { Message, ContentPart } from '../types';

/**
 * 提取消息中的纯文本内容
 * @param message 消息对象
 * @returns 纯文本字符串
 */
export function extractTextFromMessage(message: Message): string {
  if (typeof message.content === 'string') {
    return message.content;
  }

  // 多模态消息：提取所有文本部分
  if (Array.isArray(message.content)) {
    const textParts = message.content
      .filter((part: ContentPart) => part.type === 'text')
      .map((part: ContentPart) => part.text || '');
    return textParts.join(' ');
  }

  return '';
}

/**
 * 检查消息是否包含图像
 * @param message 消息对象
 * @returns 是否包含图像
 */
export function messageHasImage(message: Message): boolean {
  if (typeof message.content === 'string') {
    return false;
  }

  if (Array.isArray(message.content)) {
    return message.content.some((part: ContentPart) => part.type === 'image_url');
  }

  return false;
}

/**
 * 将消息转换为字符串表示（用于日志等）
 * @param message 消息对象
 * @returns 字符串表示
 */
export function messageToString(message: Message): string {
  const text = extractTextFromMessage(message);
  const hasImage = messageHasImage(message);
  const imageSuffix = hasImage ? ' [包含图像]' : '';
  return `${message.role}: ${text}${imageSuffix}`;
}

/**
 * 类型守卫：检查content是否为字符串
 */
export function isStringContent(message: Message): message is Message & { content: string } {
  return typeof message.content === 'string';
}

/**
 * 类型守卫：检查content是否为ContentPart数组
 */
export function isArrayContent(message: Message): message is Message & { content: ContentPart[] } {
  return Array.isArray(message.content);
}
````

## File: .eslintignore
````
# Ignore legacy plugin samples and build outputs
plugins/**
admin/dist/**
dist/**
node_modules/**
````

## File: .versionrc
````
{
  "types": [
    {
      "type": "feat",
      "section": "✨ 新功能",
      "hidden": false
    },
    {
      "type": "fix",
      "section": "🐛 Bug 修复",
      "hidden": false
    },
    {
      "type": "perf",
      "section": "⚡ 性能优化",
      "hidden": false
    },
    {
      "type": "refactor",
      "section": "♻️ 重构",
      "hidden": false
    },
    {
      "type": "revert",
      "section": "⏪ 回滚",
      "hidden": false
    },
    {
      "type": "docs",
      "section": "📚 文档",
      "hidden": false
    },
    {
      "type": "style",
      "section": "💄 代码格式",
      "hidden": true
    },
    {
      "type": "test",
      "section": "✅ 测试",
      "hidden": true
    },
    {
      "type": "build",
      "section": "👷 构建",
      "hidden": true
    },
    {
      "type": "ci",
      "section": "🔧 CI/CD",
      "hidden": true
    },
    {
      "type": "chore",
      "section": "🔩 其他杂项",
      "hidden": true
    }
  ],
  "scopeEnum": [
    "core",
    "services",
    "api",
    "strategies",
    "utils",
    "config",
    "docs",
    "scripts",
    "tests"
  ],
  "releaseCommitMessageFormat": "chore(release): {{currentTag}}",
  "issueUrlFormat": "https://github.com/suntianc/apex-bridge/issues/{{id}}",
  "compareUrlFormat": "https://github.com/suntianc/apex-bridge/compare/{{previousTag}}...{{currentTag}}",
  "changelogSections": [
    {
      "type": "feat",
      "section": "✨ 新功能"
    },
    {
      "type": "fix",
      "section": "🐛 Bug 修复"
    },
    {
      "type": "perf",
      "section": "⚡ 性能优化"
    },
    {
      "type": "refactor",
      "section": "♻️ 重构"
    },
    {
      "type": "revert",
      "section": "⏪ 回滚"
    },
    {
      "type": "docs",
      "section": "📚 文档"
    }
  ],
  "template": "# Changelog\n\n## {{Release.Version}}\n\n{{Release.Date}}\n\n### {{Release.Type}}\n\n{{#if Commit.Features}}\n#### Features\n{{#each Commit.Features}}\n- **{{this.scope}}**: {{this.subject}}\n{{/each}}\n{{/if}}\n\n{{#if Commit.Fixes}}\n#### Bug Fixes\n{{#each Commit.Fixes}}\n- **{{this.scope}}**: {{this.subject}}\n{{/each}}\n{{/if}}\n\n{{#if Commit.Other}}\n#### Other\n{{#each Commit.Other}}\n- {{this.subject}}\n{{/each}}\n{{/if}}\n",
  "header": "# Changelog\n\n*ApexBridge 变更日志*\n\n",
  "unreleasedGroupBy": {
    "types": [
      {
        "type": "feat",
        "section": "✨ 新功能"
      },
      {
        "type": "fix",
        "section": "🐛 Bug 修复"
      },
      {
        "type": "perf",
        "section": "⚡ 性能优化"
      }
    ]
  },
  "unreleasedTitle": "Unreleased",
  "unreleasedVersion": "Unreleased",
  "bumpFiles": [
    {
      "filename": "package.json",
      "type": "json",
      "path": "./package.json"
    }
  ],
  "ignoreMessages": [
    "Merge pull request",
    "Merge branch",
    "chore: Release"
  ]
}
````

## File: config/skills-config.yaml
````yaml
skills:
  storage:
    path: "./data/skills"
    vectorDbPath: "./.data/skills.lance"
  retrieval:
    model: "nomic-embed-text"
    cacheSize: 1000
    dimensions: 768
    similarityThreshold: 0.40  # 从0.20提升至0.40，过滤噪声，优化语义搜索
  execution:
    timeout: 60000
    maxOutputSize: 10485760  # 10MB
    maxConcurrency: 3
````

## File: src/api/middleware/customValidators.ts
````typescript
/**
 * Custom Validators - 自定义业务规则验证器
 *
 * 提供业务特定的验证规则，用于补充 JSON Schema 验证
 */

import { addCustomFormat } from './validationMiddleware';

/**
 * 验证 API Key 格式
 */
export function validateAPIKey(value: string): boolean {
  if (typeof value !== 'string' || value.length < 10 || value.length > 200) {
    throw new Error('API Key 长度必须在 10 到 200 个字符之间');
  }

  // 基本格式检查（可以包含字母、数字、连字符、下划线）
  if (!/^[a-zA-Z0-9_-]+$/.test(value)) {
    throw new Error('API Key 格式无效');
  }

  return true;
}

/**
 * 验证端口号
 */
export function validatePort(value: number): boolean {
  if (!Number.isInteger(value) || value < 1 || value > 65535) {
    throw new Error('端口号必须在 1 到 65535 之间');
  }
  return true;
}

/**
 * 验证温度值
 */
export function validateTemperature(value: number): boolean {
  if (typeof value !== 'number' || value < 0 || value > 2) {
    throw new Error('温度值必须在 0 到 2 之间');
  }
  return true;
}

/**
 * 初始化自定义验证器
 * 注册所有自定义格式到验证中间件
 */
export function initializeCustomValidators(): void {
  // API Key格式
  addCustomFormat('api-key', {
    validate: (value: string) => {
      try {
        return validateAPIKey(value);
      } catch {
        return false;
      }
    }
  });
}
````

## File: src/api/middleware/rateLimitMiddleware.ts
````typescript
import { NextFunction, Request, Response } from 'express';
import {
  ConfigService,
  RateLimitRuleConfig,
  RateLimitSettings,
  RateLimitMatcherConfig,
  RateLimitStrategyConfig,
  createDefaultRateLimitSettings
} from '../../services/ConfigService';
import { logger } from '../../utils/logger';
import { InMemoryRateLimiter } from './rateLimit/inMemoryRateLimiter';
import { RedisRateLimiter } from './rateLimit/redisRateLimiter';
import { RateLimiter, RateLimiterMode } from './rateLimit/types';
import { RedisService } from '../../services/RedisService';

type StrategyType = 'ip' | 'apiKey';

interface SimpleRateLimitRule {
  id: string;
  name: string;
  description?: string;
  priority: number;
  windowMs: number;
  maxRequests: number;
  mode: RateLimiterMode;
  skipSuccessfulRequests: boolean;
  skipFailedRequests: boolean;
  responseHeaders: boolean;
  strategyOrder: StrategyType[];
  matchers: Array<(req: Request) => boolean>;
}

interface RateLimitHeaderNames {
  limit: string;
  remaining: string;
  reset: string;
  retryAfter: string;
}

interface SimpleRateLimitRuntimeConfig {
  enabled: boolean;
  provider: 'auto' | 'redis' | 'memory';
  trustProxy: boolean;
  keyPrefix: string;
  headers: RateLimitHeaderNames;
  rules: SimpleRateLimitRule[];
}

interface RateLimitIdentity {
  strategy: StrategyType;
  value: string;
  key: string;
}

export interface RateLimitMiddlewareOptions {
  configService?: ConfigService;
  limiter?: RateLimiter;
  clock?: () => number;
}

const DEFAULT_HEADERS: RateLimitHeaderNames = {
  limit: 'X-RateLimit-Limit',
  remaining: 'X-RateLimit-Remaining',
  reset: 'X-RateLimit-Reset',
  retryAfter: 'Retry-After'
};

function normalizeSettings(settings: RateLimitSettings): SimpleRateLimitRuntimeConfig {
  const headers: RateLimitHeaderNames = {
    limit: settings.headers?.limit || DEFAULT_HEADERS.limit,
    remaining: settings.headers?.remaining || DEFAULT_HEADERS.remaining,
    reset: settings.headers?.reset || DEFAULT_HEADERS.reset,
    retryAfter: settings.headers?.retryAfter || DEFAULT_HEADERS.retryAfter
  };

  const defaultStrategies: StrategyType[] = (settings.defaultStrategyOrder ?? ['apiKey', 'ip'])
    .filter((s): s is StrategyType => s === 'ip' || s === 'apiKey');

  const normalizedRules = (settings.rules || [])
    .map((rule) => normalizeRule(rule, defaultStrategies))
    .filter((rule): rule is SimpleRateLimitRule => rule !== null)
    .sort((a, b) => a.priority - b.priority);

  return {
    enabled: settings.enabled ?? true,
    provider: settings.provider ?? 'auto',
    trustProxy: settings.trustProxy ?? true,
    keyPrefix: settings.keyPrefix ?? 'rate_limit',
    headers,
    rules: normalizedRules
  };
}

function normalizeRule(rule: RateLimitRuleConfig, defaultStrategies: StrategyType[]): SimpleRateLimitRule | null {
  if (!rule.id || !rule.name || !rule.windowMs || !rule.maxRequests) {
    logger.warn(`[RateLimit] 规则 ${rule.id || '(unknown)'} 缺少必要字段，已跳过`);
    return null;
  }

  const matchers = (rule.matchers || [])
    .map((matcher) => compileSimpleMatcher(matcher))
    .filter((matcher): matcher is (req: Request) => boolean => matcher !== null);

  if (matchers.length === 0) {
    logger.warn(`[RateLimit] 规则 ${rule.id} 缺少有效的匹配器，已跳过`);
    return null;
  }

  const rawMode = rule.mode ?? 'sliding';
  const mode: RateLimiterMode = rawMode === 'fixed' ? 'fixed' : 'sliding';

  const strategyOrder: StrategyType[] = (rule.strategyOrder || defaultStrategies)
    .filter((s): s is StrategyType => s === 'ip' || s === 'apiKey');

  return {
    id: rule.id,
    name: rule.name,
    description: rule.description,
    priority: rule.priority || 0,
    windowMs: rule.windowMs,
    maxRequests: rule.maxRequests,
    mode,
    skipSuccessfulRequests: rule.skipSuccessfulRequests ?? false,
    skipFailedRequests: rule.skipFailedRequests ?? false,
    responseHeaders: rule.responseHeaders ?? true,
    strategyOrder,
    matchers
  };
}

function compileSimpleMatcher(config: RateLimitMatcherConfig): ((req: Request) => boolean) | null {
  const methods = config.methods?.map((method) => method.toUpperCase());

  if (config.prefix) {
    const prefix = config.prefix.endsWith('/') ? config.prefix : `${config.prefix}`;
    return (req: Request) =>
      matchMethod(req, methods) && req.path.startsWith(prefix);
  }

  logger.warn('[RateLimit] 匹配器配置缺少 prefix 信息');
  return null;
}

function matchMethod(req: Request, allowedMethods?: string[]): boolean {
  if (!allowedMethods || allowedMethods.length === 0) {
    return true;
  }
  return allowedMethods.includes(req.method?.toUpperCase() || 'GET');
}

function resolveIdentity(
  req: Request,
  res: Response,
  rule: SimpleRateLimitRule,
  runtime: SimpleRateLimitRuntimeConfig
): RateLimitIdentity | null {
  for (const strategyType of rule.strategyOrder) {
    const identity = resolveIdentityByStrategy(req, res, strategyType);
    if (identity) {
      return identity;
    }
  }
  return null;
}

function resolveIdentityByStrategy(
  req: Request,
  res: Response,
  strategyType: StrategyType
): RateLimitIdentity | null {
  switch (strategyType) {
    case 'ip': {
      const value = extractClientIp(req, true); // 总是启用代理信任
      if (!value) return null;
      return {
        strategy: 'ip',
        value,
        key: `ip:${value}`
      };
    }
    case 'apiKey': {
      const localsKey = res.locals.auth?.apiKeyId || res.locals.auth?.apiKeyToken;
      const headerKey =
        (req.headers['x-api-key'] as string | undefined) ??
        extractBearerToken(req.headers.authorization);

      const value = localsKey || headerKey;
      if (!value) return null;
      return {
        strategy: 'apiKey',
        value,
        key: `apiKey:${value}`
      };
    }
    default:
      return null;
  }
}

function extractClientIp(req: Request, trustProxy: boolean): string | null {
  if (trustProxy && Array.isArray(req.ips) && req.ips.length > 0) {
    return req.ips[0];
  }
  if (req.ip) {
    return req.ip;
  }
  return null;
}

function extractBearerToken(authHeader?: string): string | undefined {
  if (!authHeader) {
    return undefined;
  }
  const parts = authHeader.split(' ');
  if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {
    return undefined;
  }
  return parts[1];
}

function applyHeaders(
  res: Response,
  rule: SimpleRateLimitRule,
  headers: RateLimitHeaderNames,
  data: { limit: number; remaining: number; reset: number; retryAfterSeconds?: number }
): void {
  if (!rule.responseHeaders) {
    return;
  }

  res.setHeader(headers.limit, data.limit);
  res.setHeader(headers.remaining, Math.max(data.remaining, 0));
  res.setHeader(headers.reset, Math.floor(data.reset / 1000));

  if (typeof data.retryAfterSeconds === 'number') {
    res.setHeader(headers.retryAfter, Math.max(data.retryAfterSeconds, 0));
  }
}

function shouldCountRequest(statusCode: number, rule: SimpleRateLimitRule): boolean {
  if (rule.skipSuccessfulRequests && statusCode >= 200 && statusCode < 300) {
    return false;
  }
  if (rule.skipFailedRequests && statusCode >= 400) {
    return false;
  }
  return true;
}

export function createRateLimitMiddleware(
  options?: RateLimitMiddlewareOptions
) {
  const configService = options?.configService ?? ConfigService.getInstance();
  const fallbackLimiter =
    options?.limiter ?? new InMemoryRateLimiter({ now: options?.clock });
  const redisService = RedisService.getInstance();
  let redisLimiter: RedisRateLimiter | null = null;
  let redisClientRef: any = null;

  let cachedSettingsHash: string | null = null;
  let cachedRuntimeConfig: SimpleRateLimitRuntimeConfig | null = null;

  const getRuntimeConfig = (): SimpleRateLimitRuntimeConfig => {
    const adminConfig = configService.readConfig();
    const settings =
      adminConfig.security?.rateLimit ?? createDefaultRateLimitSettings();

    const serialized = JSON.stringify(settings);
    if (cachedRuntimeConfig && cachedSettingsHash === serialized) {
      return cachedRuntimeConfig;
    }

    cachedRuntimeConfig = normalizeSettings(settings);
    cachedSettingsHash = serialized;
    return cachedRuntimeConfig;
  };

  return async function rateLimitMiddleware(
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<void> {
    try {
      const runtimeConfig = getRuntimeConfig();

      if (!runtimeConfig.enabled) {
        return next();
      }

      const rule = runtimeConfig.rules.find((candidate) => candidate.matchers.some((matcher) => matcher(req)));

      if (!rule) {
        return next();
      }

      const identity = resolveIdentity(req, res, rule, runtimeConfig);
      if (!identity) {
        return next();
      }

      const key = `${runtimeConfig.keyPrefix}:${rule.id}:${identity.key}`;
      let limiter: RateLimiter = fallbackLimiter;

      if (runtimeConfig.provider === 'redis') {
        if (!redisLimiter) {
          try {
            const redisClient = await redisService.getClient();
            if (redisClient) {
              redisClientRef = redisClient;
              redisLimiter = new RedisRateLimiter({ client: redisClient });
            }
          } catch (error: any) {
            logger.warn('[RateLimit] Redis client unavailable, using memory limiter');
          }
        }

        if (redisLimiter) {
          limiter = redisLimiter;
        }
      }

      const result = await limiter.hit(key, {
        id: rule.id,
        windowMs: rule.windowMs,
        maxRequests: rule.maxRequests,
        mode: rule.mode
      });

      if (result.allowed) {
        applyHeaders(res, rule, runtimeConfig.headers, {
          limit: rule.maxRequests,
          remaining: result.remaining,
          reset: result.reset
        });

        res.on('finish', () => {
          if (!shouldCountRequest(res.statusCode, rule) && identity && result.context) {
            limiter.undo?.(result.context).catch((error: any) => {
              logger.warn('[RateLimit] Failed to undo rate limit hit', { error });
            });
          }
        });

        next();
        return;
      }

      applyHeaders(res, rule, runtimeConfig.headers, {
        limit: rule.maxRequests,
        remaining: 0,
        reset: result.reset
      });

      const retryAfterSeconds = result.reset ? Math.ceil((result.reset - Date.now()) / 1000) : undefined;

      res.status(429).json({
        error: 'Too Many Requests',
        message: `Rate limit exceeded for ${rule.name}`,
        retryAfter: retryAfterSeconds
      });

    } catch (error: any) {
      logger.error('[RateLimit] Rate limit middleware error', { error });
      next();
    }
  };
}

export const rateLimitMiddleware = createRateLimitMiddleware();
````

## File: src/api/routes/skillRoutes.ts
````typescript
/**
 * Skills路由配置
 * 提供Skills管理的RESTful API路由
 */

import { Router } from 'express';
import {
  installSkill,
  uninstallSkill,
  updateSkillDescription,
  listSkills,
  getSkill,
  checkSkillExists,
  getSkillStats,
  reindexAllSkills,
  upload
} from '../controllers/SkillsController';

const router = Router();

/**
 * @route   POST /api/skills/install
 * @desc    安装Skills（ZIP文件上传）
 * @access  Private (需要API Key)
 * @body    { file: ZIP, overwrite?: boolean, skipVectorization?: boolean }
 */
router.post(
  '/install',
  upload.single('file'),
  installSkill
);

/**
 * @route   DELETE /api/skills/:name
 * @desc    卸载Skills
 * @access  Private (需要API Key)
 */
router.delete('/:name', uninstallSkill);

/**
 * @route   PUT /api/skills/:name/description
 * @desc    更新Skills描述
 * @access  Private (需要API Key)
 * @body    { description: string }
 */
router.put('/:name/description', updateSkillDescription);

/**
 * @route   GET /api/skills/stats
 * @desc    获取Skills统计信息
 * @access  Private (需要API Key)
 * @note    必须在 /:name 之前定义，否则 :name 会捕获 "stats"
 */
router.get('/stats', getSkillStats);

/**
 * @route   GET /api/skills
 * @desc    列出Skills（支持分页、过滤、排序）
 * @access  Private (需要API Key)
 * @query   page, limit, name, tags, sortBy, sortOrder
 */
router.get('/', listSkills);

/**
 * @route   GET /api/skills/:name
 * @desc    获取单个Skills详情
 * @access  Private (需要API Key)
 */
router.get('/:name', getSkill);

/**
 * @route   GET /api/skills/:name/exists
 * @desc    检查Skills是否存在
 * @access  Private (需要API Key)
 */
router.get('/:name/exists', checkSkillExists);

/**
 * @route   POST /api/skills/reindex
 * @desc    重新索引所有Skills（用于向量数据库重建）
 * @access  Private (需要API Key，建议仅限管理员）
 */
router.post('/reindex', reindexAllSkills);

export default router;
````

## File: src/api/utils/response-formatter.ts
````typescript
/**
 * 响应格式化工具函数
 * 纯函数，无状态，易于测试
 */

/**
 * 规范化 Usage 统计
 * 支持多种格式的 usage 数据（snake_case 和 camelCase）
 * @param usage 原始的usage数据
 * @returns 规范化的usage对象或null
 */
export function normalizeUsage(
  usage: any
): { prompt_tokens: number; completion_tokens: number; total_tokens: number } | null {
  if (!usage || typeof usage !== "object") {
    return null;
  }

  const prompt =
    typeof usage.prompt_tokens === "number"
      ? usage.prompt_tokens
      : typeof usage.promptTokens === "number"
        ? usage.promptTokens
        : undefined;

  const completion =
    typeof usage.completion_tokens === "number"
      ? usage.completion_tokens
      : typeof usage.completionTokens === "number"
        ? usage.completionTokens
        : undefined;

  let total =
    typeof usage.total_tokens === "number"
      ? usage.total_tokens
      : typeof usage.totalTokens === "number"
        ? usage.totalTokens
        : undefined;

  // 如果 total 不存在，尝试计算
  if (typeof total !== "number" && typeof prompt === "number" && typeof completion === "number") {
    total = prompt + completion;
  }

  // 验证所有字段都是数字
  if (typeof prompt !== "number" || typeof completion !== "number" || typeof total !== "number") {
    return null;
  }

  return {
    prompt_tokens: prompt,
    completion_tokens: completion,
    total_tokens: total,
  };
}

/**
 * 构建OpenAI兼容的响应对象
 * @param content 响应内容
 * @param model 使用的模型
 * @param usage usage统计（可选）
 * @param conversationId 对话ID（可选）
 * @returns OpenAI格式的响应对象
 */
export function buildChatResponse(
  content: string,
  model: string,
  usage?: { prompt_tokens: number; completion_tokens: number; total_tokens: number } | null,
  conversationId?: string
): any {
  return {
    id: `chatcmpl-${Date.now()}`,
    object: "chat.completion",
    created: Math.floor(Date.now() / 1000),
    model: model,
    choices: [
      {
        index: 0,
        message: {
          role: "assistant" as const,
          content: content,
        },
        finish_reason: "stop" as const,
      },
    ],
    usage: usage || {
      prompt_tokens: 0,
      completion_tokens: 0,
      total_tokens: 0,
    },
    // 返回 conversationId，方便前端进行后续操作
    ...(conversationId && { conversation_id: conversationId }),
  };
}
````

## File: src/api/websocket/channels/ChatChannel.ts
````typescript
/**
 * ChatChannel - 实时对话通道
 * 提供 WebSocket 实时聊天功能，支持普通对话和流式响应
 */

import { WebSocket } from 'ws';
import { ChatService } from '../../../services/ChatService';
import { logger } from '../../../utils/logger';
import { Message, ChatOptions } from '../../../types';

/**
 * 扩展 WebSocket 类型以追踪当前请求ID（用于中断）
 */
interface ChatWebSocket extends WebSocket {
  currentRequestId?: string;
  isAlive?: boolean; // 复用 Manager 的定义
}

/**
 * 客户端发送的消息格式
 */
export interface ChatMessage {
  type: 'chat' | 'stream_chat' | 'stop'; // 🆕 新增 stop 类型
  payload?: { // 改为可选，因为 stop 不需要 payload
    messages?: Message[];
    options?: ChatOptions;
    requestId?: string; // stop 时可选
  };
}

/**
 * 服务器响应的消息格式
 */
export interface ChatResponse {
  type: 'chat_response' | 'stream_chunk' | 'stream_done' | 'error' | 'status' | 'meta_event';
  payload?: any;
  error?: string;
}

export class ChatChannel {
  constructor(private chatService: ChatService) {}

  /**
   * 处理 WebSocket 连接
   * 注意：API Key 验证已由 WebSocketManager 完成，此处不再重复验证
   */
  handleConnection(ws: ChatWebSocket, _apiKey: string, _request: any): void {
    logger.info('💬 Chat WebSocket connection attached');

    // 监听消息
    ws.on('message', async (data) => {
      try {
        const rawStr = data.toString();
        
        // 心跳检测 Pong (如果在 Manager 层没处理，这里可以忽略)
        if (rawStr === 'pong') {
          return;
        }

        const message = JSON.parse(rawStr) as ChatMessage;

        switch (message.type) {
          case 'chat':
            if (message.payload) {
              await this.handleChat(ws, message.payload);
            }
            break;

          case 'stream_chat':
            if (message.payload) {
              await this.handleStreamChat(ws, message.payload);
            }
            break;

          case 'stop': // 🆕 处理中断请求
            await this.handleStop(ws);
            break;

          default:
            this.sendError(ws, `Unknown message type: ${message.type}`);
        }
      } catch (error: any) {
        // JSON 解析失败或其他同步错误
        logger.error('❌ Chat WebSocket message error:', error);
        this.sendError(ws, 'Invalid message format');
      }
    });

    // 监听关闭
    ws.on('close', () => {
      // 连接关闭时，如果有正在进行的请求，尝试自动中断
      if (ws.currentRequestId) {
        logger.info(`🔌 Connection closed, auto-interrupting request: ${ws.currentRequestId}`);
        this.chatService.interruptRequest(ws.currentRequestId).catch(() => {
          // 忽略中断失败的错误，因为连接已经关闭
        });
      }
      logger.info('💬 Chat WebSocket connection closed');
    });

    // 监听错误
    ws.on('error', (error) => {
      logger.error('❌ Chat WebSocket connection error:', error);
    });
  }

  /**
   * 处理普通聊天消息
   */
  private async handleChat(ws: ChatWebSocket, payload: ChatMessage['payload']): Promise<void> {
    const { messages, options = {} } = payload || {};

    try {
      logger.debug('💬 Processing chat message');

      // 调用 ChatService
      const response = await this.chatService.createChatCompletion({
        messages: messages || [],
        ...options
      });

      // 发送响应
      this.safeSend(ws, {
        type: 'chat_response',
        payload: response
      });

      logger.info('💬 Chat response sent successfully');

    } catch (error: any) {
      logger.error('💬 Chat processing error:', error);
      this.sendError(ws, error.message || 'Internal processing error');
    }
  }

  /**
   * 处理流式聊天消息
   */
  private async handleStreamChat(ws: ChatWebSocket, payload: ChatMessage['payload']): Promise<void> {
    const { messages, options = {} } = payload || {};

    try {
      logger.debug('🌊 Processing stream chat message');

      // 调用 ChatService 的流式接口
      const stream = await this.chatService.createStreamChatCompletion({
        messages: messages || [],
        ...options,
        stream: true
      });

      // 逐块发送响应
      for await (const chunk of stream) {
        // 🆕 修复：不要再次包装 chunk，直接发送
        // ChatService 的 chunk 格式已经是 { type: 'stream_chunk', payload: ... } 或 { type: 'meta_event', payload: ... }
        
        // 如果 chunk 包含 request_id，记录到 ws
        if (chunk.type === 'meta_event' && chunk.payload?.requestId) {
          ws.currentRequestId = chunk.payload.requestId;
          logger.debug(`📌 Request ID captured: ${ws.currentRequestId}`);
        }

        // 直接透传 chunk，不要再次包装
        this.safeSend(ws, chunk);
      }

      // 发送完成标记
      this.safeSend(ws, {
        type: 'stream_done'
      });

      // 清理 RequestID
      ws.currentRequestId = undefined;

      logger.info('🌊 Stream chat completed successfully');

    } catch (error: any) {
      logger.error('🌊 Stream chat processing error:', error);
      this.sendError(ws, error.message || 'Stream processing error');
      ws.currentRequestId = undefined;
    }
  }

  /**
   * 🆕 处理中断请求
   */
  private async handleStop(ws: ChatWebSocket): Promise<void> {
    if (!ws.currentRequestId) {
      // 如果 ws 上没有记录 ID，说明可能没有正在进行的请求
      // 或者 ChatService 还没来得及返回 ID
      logger.warn('⚠️ Received stop command but no active request ID found on socket');
      
      this.safeSend(ws, {
        type: 'status',
        payload: {
          status: 'no_active_request',
          success: false
        }
      });
      return;
    }

    logger.info(`🛑 Client requested stop for request: ${ws.currentRequestId}`);
    const success = await this.chatService.interruptRequest(ws.currentRequestId);
    
    this.safeSend(ws, {
      type: 'status',
      payload: { 
        status: 'interrupted', 
        success,
        requestId: ws.currentRequestId 
      }
    });
    
    ws.currentRequestId = undefined;
  }

  /**
   * 安全发送消息（检查连接状态）
   */
  private safeSend(ws: WebSocket, data: any): void {
    if (ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(JSON.stringify(data));
      } catch (error: any) {
        logger.warn('⚠️ Error sending WebSocket message:', error.message);
      }
    } else {
      logger.warn('⚠️ Attempted to send message to closed socket');
    }
  }

  /**
   * 发送错误消息
   */
  private sendError(ws: WebSocket, error: string): void {
    this.safeSend(ws, {
      type: 'error',
      error
    });
  }
}
````

## File: src/config/endpoint-mappings.ts
````typescript
/**
 * API 端点映射配置
 * 
 * 定义各 LLM 提供商针对不同模型类型的 API 端点后缀
 */

import { LLMModelType, ProviderEndpointConfig, EndpointMapping } from '../types/llm-models';

/**
 * 默认端点映射
 * 
 * 大多数提供商遵循 OpenAI 兼容的端点格式
 */
const DEFAULT_ENDPOINT_CONFIG: ProviderEndpointConfig = {
  nlp: '/chat/completions',
  embedding: '/embeddings',
  rerank: '/rerank',
  image: '/images/generations',
  audio: '/audio/transcriptions'
};

/**
 * 各提供商的端点映射配置
 * 
 * 如果某提供商未配置，则使用默认配置
 */
export const PROVIDER_ENDPOINT_MAPPINGS: EndpointMapping = {
  /**
   * OpenAI
   * 文档: https://platform.openai.com/docs/api-reference
   */
  openai: {
    nlp: '/chat/completions',
    embedding: '/embeddings',
    image: '/images/generations',
    audio: '/audio/transcriptions'
    // rerank 暂不支持
  },

  /**
   * DeepSeek
   * 文档: https://platform.deepseek.com/api-docs/
   */
  deepseek: {
    nlp: '/chat/completions',
    embedding: '/embeddings'
    // 其他类型待补充
  },

  /**
   * 智谱 AI (GLM)
   * 文档: https://open.bigmodel.cn/dev/api
   */
  zhipu: {
    nlp: '/chat/completions',
    embedding: '/embeddings'
    // 智谱可能有不同的端点格式，待确认
  },

  /**
   * Ollama (本地模型)
   * 文档: https://github.com/ollama/ollama/blob/main/docs/api.md
   *
   * 注意: Ollama 支持 OpenAI 兼容格式 (/v1/*)
   */
  ollama: {
    nlp: '/chat/completions',
    embedding: '/embeddings'
    // 使用OpenAI兼容的端点格式
  },

  /**
   * Claude (Anthropic)
   * 文档: https://docs.anthropic.com/claude/reference
   * 
   * 注意: Claude 使用不同的 API 格式
   */
  claude: {
    nlp: '/messages'
    // Claude 目前不支持其他类型
  },

  /**
   * Azure OpenAI
   * 文档: https://learn.microsoft.com/en-us/azure/ai-services/openai/
   * 
   * 注意: Azure OpenAI 使用不同的 URL 结构
   */
  azure: {
    nlp: '/chat/completions',
    embedding: '/embeddings'
    // Azure 的端点在 baseURL 中已包含部署名称
  },

  /**
   * 通义千问 (Qwen)
   * 待补充
   */
  qwen: {
    nlp: '/chat/completions',
    embedding: '/embeddings'
  },

  /**
   * 文心一言 (ERNIE)
   * 待补充
   */
  ernie: {
    nlp: '/chat/completions'
  },

  /**
   * Cohere
   * 待补充
   */
  cohere: {
    nlp: '/generate',
    embedding: '/embed',
    rerank: '/rerank'
  },

  /**
   * SiliconFlow
   * 中转服务，兼容 OpenAI 格式
   */
  siliconflow: {
    nlp: '/chat/completions',
    embedding: '/embeddings'
  }
};

/**
 * 获取提供商的端点后缀
 * 
 * @param provider 提供商标识
 * @param modelType 模型类型
 * @returns API 端点后缀，如果未配置则返回默认值
 */
export function getEndpointSuffix(provider: string, modelType: LLMModelType | string): string | undefined {
  const providerConfig = PROVIDER_ENDPOINT_MAPPINGS[provider.toLowerCase()];
  
  if (providerConfig && providerConfig[modelType]) {
    return providerConfig[modelType];
  }
  
  // 使用默认配置
  const defaultConfig = DEFAULT_ENDPOINT_CONFIG[modelType as keyof ProviderEndpointConfig];
  return defaultConfig;
}

/**
 * 获取提供商支持的所有模型类型
 * 
 * @param provider 提供商标识
 * @returns 支持的模型类型列表
 */
export function getSupportedModelTypes(provider: string): string[] {
  const providerConfig = PROVIDER_ENDPOINT_MAPPINGS[provider.toLowerCase()];
  
  if (!providerConfig) {
    // 未配置的提供商，假设支持基本的 nlp 和 embedding
    return ['nlp', 'embedding'];
  }
  
  return Object.keys(providerConfig);
}

/**
 * 构建完整的 API URL
 * 
 * @param baseURL 基础 URL
 * @param endpointSuffix 端点后缀
 * @returns 完整的 API URL
 */
export function buildApiUrl(baseURL: string, endpointSuffix: string): string {
  const normalizedBase = baseURL.replace(/\/+$/, ''); // 移除尾部斜杠
  const normalizedSuffix = endpointSuffix.startsWith('/') ? endpointSuffix : `/${endpointSuffix}`;
  
  return `${normalizedBase}${normalizedSuffix}`;
}

/**
 * 验证端点配置
 * 
 * @param provider 提供商标识
 * @param modelType 模型类型
 * @returns 是否支持该模型类型
 */
export function validateEndpoint(provider: string, modelType: string): boolean {
  const endpoint = getEndpointSuffix(provider, modelType);
  return endpoint !== undefined;
}
````

## File: src/constants/index.ts
````typescript
/**
 * ApexBridge 常量定义
 *
 * 集中管理所有魔法数字，提高代码可维护性
 * 使用 as const 确保类型安全
 */

// ==================== 工具超时配置 ====================

export interface ToolTimeoutConfig {
  default: number;
  byType: Record<string, number>;
}

export const TOOL_TIMEOUT: ToolTimeoutConfig = {
  default: 30000,
  byType: {
    skill: 30000,
    mcp: 60000,
    builtin: 10000,
    file_read: 15000,
    file_write: 15000,
    vector_search: 20000,
    web_search: 30000,
  },
} as const;

// ==================== 超时常量 ====================

export const TIMEOUT = {
  /** 工具执行超时 (毫秒, 默认30秒) */
  TOOL_EXECUTION: 30000,

  /** LLM 请求超时 (毫秒, 默认60秒) */
  LLM_REQUEST: 60000,

  /** 清理定时器间隔 (毫秒) */
  CLEANUP_INTERVAL: 60000,

  /** Skills 缓存 TTL (毫秒, 5分钟) */
  SKILL_CACHE_TTL: 5 * 60 * 1000,

  /** 适配器缓存 TTL (毫秒, 5分钟) */
  ADAPTER_CACHE_TTL: 5 * 60 * 1000,

  /** 技能自动注销时间 (毫秒, 5分钟) */
  SKILL_AUTO_UNREGISTER: 5 * 60 * 1000,

  /** 清理定时器执行间隔 (毫秒, 1分钟) */
  CLEANUP_TIMER_INTERVAL: 60 * 1000,
} as const;

// ==================== 限制常量 ====================

export const LIMITS = {
  /** 最大迭代次数 (ReAct 循环) */
  MAX_ITERATIONS: 50,

  /** 最大并发工具数 */
  MAX_CONCURRENT_TOOLS: 3,

  /** 适配器缓存大小 */
  ADAPTER_CACHE_SIZE: 20,

  /** 向量搜索返回数量限制 */
  VECTOR_SEARCH_LIMIT: 10,

  /** 请求 ID 生成长度 */
  REQUEST_ID_LENGTH: 32,

  /** 会话历史最大消息数 */
  SESSION_HISTORY_MAX_MESSAGES: 100,

  /** 单次向量搜索的最大结果数 */
  VECTOR_SEARCH_MAX_RESULTS: 10,
} as const;

// ==================== 阈值常量 ====================

export const THRESHOLDS = {
  /** 向量搜索相似度阈值 (过滤噪声) */
  VECTOR_SEARCH: 0.4,

  /** 相关 Skills 检索阈值 (降低以提高召回率) */
  RELEVANT_SKILLS: 0.4,

  /** Doom Loop 检测阈值 (相同调用次数) */
  DOOM_LOOP_THRESHOLD: 3,
} as const;

// ==================== Doom Loop 常量 ====================

export const DOOM_LOOP = {
  /** 检测阈值 */
  THRESHOLD: 3,

  /** 历史记录最大长度 (阈值 * 2) */
  MAX_HISTORY_LENGTH: 6,
} as const;

// ==================== 向量常量 ====================

export const VECTOR = {
  /** 默认向量维度 */
  DEFAULT_DIMENSIONS: 768,

  /** 向量索引分区数 */
  INDEX_PARTITIONS: 64,

  /** 向量子向量数 */
  INDEX_SUB_VECTORS: 8,

  /** IVF_PQ 索引类型 */
  INDEX_TYPE: "ivf_pq" as const,
} as const;

// ==================== LLM 常量 ====================

export const LLM = {
  /** 默认温度参数 */
  DEFAULT_TEMPERATURE: 0.7,

  /** 默认最大 Token 数 */
  DEFAULT_MAX_TOKENS: 4096,

  /** 默认重试次数 */
  DEFAULT_MAX_RETRIES: 3,

  /** 默认超时时间 (毫秒) */
  DEFAULT_TIMEOUT: 60000,
} as const;

// ==================== API 常量 ====================

export const API = {
  /** 默认端口 */
  DEFAULT_PORT: 8088,

  /** API 路径前缀 */
  V1_PREFIX: "/v1",

  /** API 路径前缀 */
  API_PREFIX: "/api",

  /** WebSocket 路径 */
  WS_PATH: "/chat",

  /** 健康检查路径 */
  HEALTH_PATH: "/health",

  /** 最大请求体大小 */
  MAX_REQUEST_SIZE: "100mb" as const,
} as const;

// ==================== 数据库常量 ====================

export const DATABASE = {
  /** SQLite 数据库文件名 */
  DB_FILENAME: "apex-bridge.db",

  /** 向量数据库路径 */
  VECTOR_DB_PATH: "./.data",

  /** 向量数据库表名 */
  VECTOR_TABLE_NAME: "skills",

  /** MCP 配置表名 */
  MCP_CONFIG_TABLE: "mcp_servers",

  /** LLM 配置表名 */
  LLM_CONFIG_TABLE: "llm_config",
} as const;

// ==================== 日志常量 ====================

export const LOG = {
  /** 默认日志级别 */
  DEFAULT_LEVEL: "info" as const,

  /** 安全日志级别 */
  SECURITY_LEVEL: "warn" as const,

  /** 日志格式时间戳格式 */
  TIMESTAMP_FORMAT: "YYYY-MM-DD HH:mm:ss" as const,
} as const;

// ==================== 安全常量 ====================

export const SECURITY = {
  /** API 密钥长度 */
  API_KEY_LENGTH: 64,

  /** 速率限制时间窗口 (毫秒) */
  RATE_LIMIT_WINDOW: 60000,

  /** 默认速率限制次数 */
  RATE_LIMIT_MAX_REQUESTS: 100,

  /** JWT 过期时间 (天) */
  JWT_EXPIRY_DAYS: 7,
} as const;

// ==================== 导出辅助函数 ====================

/**
 * 检查值是否在有效范围内
 */
export function inRange(value: number, min: number, max: number): boolean {
  return value >= min && value <= max;
}

/**
 * 格式化时间间隔
 */
export function formatDuration(ms: number): string {
  if (ms < 1000) {
    return `${ms}ms`;
  }
  if (ms < 60000) {
    return `${(ms / 1000).toFixed(2)}s`;
  }
  return `${(ms / 60000).toFixed(2)}m`;
}

/**
 * 获取常量值 (用于需要动态值的场景)
 */
export function getTimeoutValue(key: keyof typeof TIMEOUT): number {
  return TIMEOUT[key];
}

export function getLimitValue(key: keyof typeof LIMITS): number {
  return LIMITS[key];
}

export function getThresholdValue(key: keyof typeof THRESHOLDS): number {
  return THRESHOLDS[key];
}

// ==================== 检索常量 ====================
// 从专门的 retrieval 常量文件导入，保持关注点分离
export * from "./retrieval";

// ==================== 压缩常量 ====================
export * from "./compression";

// ==================== 保留常量 ====================
export * from "./retention";
````

## File: src/core/stream-orchestrator/CachedLLMAdapter.ts
````typescript
import { LRUCache } from 'lru-cache';
import type { LLMAdapter, LLMOptions, StreamEvent } from './types';

interface CacheEntry {
  content: string;
  timestamp: number;
}

export interface CachedAdapterOptions {
  ttl?: number;
  maxSize?: number;
  enableL2?: boolean;
}

export class CachedLLMAdapter implements LLMAdapter {
  private l1Cache: LRUCache<string, CacheEntry>;
  private l2Cache: Map<string, any>;
  private delegate: LLMAdapter;
  private options: Required<CachedAdapterOptions>;

  constructor(delegate: LLMAdapter, options: CachedAdapterOptions = {}) {
    this.delegate = delegate;
    this.options = {
      ttl: options.ttl ?? 30_000,
      maxSize: options.maxSize ?? 100,
      enableL2: options.enableL2 ?? true
    };

    this.l1Cache = new LRUCache({
      max: this.options.maxSize,
      ttl: this.options.ttl,
      updateAgeOnGet: true
    });

    this.l2Cache = new Map();
  }

  async *streamChat(
    messages: any[],
    options?: LLMOptions,
    tools?: any[],
    signal?: AbortSignal
  ): AsyncGenerator<any, void, void> {
    const cacheKey = this.generateCacheKey(messages, options);

    const cached = this.l1Cache.get(cacheKey);
    if (cached) {
      yield { type: 'text', content: cached.content, cached: true };
      return;
    }

    const l2Result = this.options.enableL2 ? this.getL2Cache(messages) : null;
    if (l2Result) {
      yield { type: 'text', content: l2Result, cached: 'l2' };
      return;
    }

    const chunks: string[] = [];
    for await (const chunk of this.delegate.streamChat(messages, options, tools, signal)) {
      if (chunk.type === 'text') {
        chunks.push(chunk.content);
      }
      yield chunk;
    }

    const fullContent = chunks.join('');
    this.l1Cache.set(cacheKey, {
      content: fullContent,
      timestamp: Date.now()
    });

    if (this.options.enableL2 && messages.length > 2) {
      this.updateL2Cache(messages, fullContent);
    }
  }

  private generateCacheKey(messages: any[], options?: LLMOptions): string {
    const messagesKey = JSON.stringify(messages);
    const optionsKey = JSON.stringify(options || {});
    return `${messagesKey}::${optionsKey}`;
  }

  private getL2Cache(messages: any[]): string | null {
    const systemPrompt = messages.find(m => m.role === 'system')?.content;
    const userPrompt = messages.find(m => m.role === 'user')?.content;

    if (!systemPrompt || !userPrompt) return null;

    const cacheKey = this.hashCode(systemPrompt);
    const cacheValue = this.l2Cache.get(cacheKey);

    if (!cacheValue) return null;

    const promptTemplate = systemPrompt.split('\n').find(line =>
      line.includes('{') && line.includes('}')
    );

    if (promptTemplate && userPrompt.includes('continue')) {
      return cacheValue;
    }

    return null;
  }

  private updateL2Cache(messages: any[], result: string): void {
    const systemPrompt = messages.find(m => m.role === 'system')?.content;
    if (!systemPrompt) return;

    const cacheKey = this.hashCode(systemPrompt);
    this.l2Cache.set(cacheKey, result);
  }

  private hashCode(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return hash.toString();
  }

  clearCache(): void {
    this.l1Cache.clear();
    this.l2Cache.clear();
  }

  get cacheStats(): { l1Size: number; l2Size: number } {
    return {
      l1Size: this.l1Cache.size,
      l2Size: this.l2Cache.size
    };
  }
}
````

## File: src/core/stream-orchestrator/ToolExecutor.ts
````typescript
import PQueue from 'p-queue';
import type { ToolCall, ToolResult } from './types';
import { ToolExecutorManager } from '../../services/executors/ToolExecutor';

export interface ToolExecutorOptions {
  maxConcurrency?: number;
}

export class ToolExecutor {
  private queue: PQueue;
  private executorManager: ToolExecutorManager;

  constructor(options: ToolExecutorOptions = {}) {
    this.queue = new PQueue({
      concurrency: options.maxConcurrency ?? 5
    });
    // Create a new instance of ToolExecutorManager instead of using singleton
    // to avoid circular dependency issues
    this.executorManager = new ToolExecutorManager();
  }

  async *executeStreaming(
    call: ToolCall,
    iteration: number,
    onChunk?: (chunk: any) => void
  ): AsyncGenerator<any, void, void> {
    const result = await this.executeTool(call, iteration);

    if (onChunk) {
      onChunk(result.result);
    }

    yield result;
  }

  async executeAll(
    toolCalls: ToolCall[],
    iteration: number,
    onComplete?: (result: ToolResult) => void
  ): Promise<Map<ToolCall, ToolResult>> {
    const results = new Map<ToolCall, ToolResult>();

    const executeWithConcurrency = async (call: ToolCall): Promise<void> => {
      const result = await this.executeTool(call, iteration);
      results.set(call, result);

      if (onComplete) {
        onComplete(result);
      }
    };

    await this.queue.addAll(
      toolCalls.map(call => () => executeWithConcurrency(call))
    );

    return results;
  }

  private async executeTool(call: ToolCall, iteration: number): Promise<ToolResult> {
    // Find the tool using executor manager
    const toolInfo = this.executorManager.findTool(call.function.name);

    if (!toolInfo) {
      return {
        toolCallId: call.id,
        name: call.function.name,
        status: 'error',
        result: null,
        error: `Tool "${call.function.name}" not found`,
        durationMs: 0
      };
    }

    const startTime = Date.now();

    try {
      // Execute the tool using the appropriate executor
      const result = await this.executorManager.execute(toolInfo.type, {
        name: call.function.name,
        args: JSON.parse(call.function.arguments || '{}')
      });
      const durationMs = Date.now() - startTime;

      return {
        toolCallId: call.id,
        name: call.function.name,
        status: result.success ? 'success' : 'error',
        result: result.success ? result.output : null,
        error: result.success ? undefined : result.error,
        durationMs
      };
    } catch (error) {
      const durationMs = Date.now() - startTime;

      return {
        toolCallId: call.id,
        name: call.function.name,
        status: 'error',
        result: null,
        error: error instanceof Error ? error.message : String(error),
        durationMs
      };
    }
  }

  async pause(): Promise<void> {
    await this.queue.pause();
  }

  async resume(): Promise<void> {
    this.queue.start();
  }

  async clear(): Promise<void> {
    this.queue.clear();
  }

  get pendingCount(): number {
    return this.queue.pending;
  }

  get size(): number {
    return this.queue.size;
  }
}
````

## File: src/core/tools/builtin/FileReadTool.ts
````typescript
/**
 * FileReadTool - 文件读取内置工具
 * 提供安全、高效的文件读取功能
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { ToolResult, BuiltInTool, ToolType } from '../../../types/tool-system';

/**
 * FileReadTool参数接口
 */
export interface FileReadArgs {
  /** 文件路径 */
  path: string;
  /** 文件编码 */
  encoding?: BufferEncoding;
  /** 最大文件大小（字节），默认10MB */
  maxSize?: number;
  /** 是否解析JSON */
  parseJson?: boolean;
  /** 基础路径（用于解析相对路径），如Skill目录路径 */
  basePath?: string;
}

/**
 * 文件读取工具
 * 安全读取文件内容，支持多种格式和大小限制
 */
export class FileReadTool {
  private static readonly DEFAULT_ENCODING: BufferEncoding = 'utf8';
  private static readonly DEFAULT_MAX_SIZE = 10 * 1024 * 1024; // 10MB
  private static readonly ALLOWED_EXTENSIONS = [
    '.txt', '.md', '.json', '.yaml', '.yml', '.xml', '.csv',
    '.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.cpp', '.c',
    '.html', '.css', '.scss', '.less', '.sql', '.sh', '.bat',
    '.dockerfile', '.gitignore', '.env', '.conf', '.config'
  ];

  /**
   * 执行文件读取
   * @param args 读取参数
   * @returns 读取结果
   */
  static async execute(args: FileReadArgs): Promise<ToolResult> {
    const startTime = Date.now();

    try {
      // 参数验证
      this.validateArgs(args);

      // 安全路径检查（支持basePath）
      const safePath = await this.getSafePath(args.path, args.basePath);

      // 检查文件存在性和可读性
      await this.checkFileAccess(safePath);

      // 检查文件大小
      await this.checkFileSize(safePath, args.maxSize || this.DEFAULT_MAX_SIZE);

      // 检查文件扩展名
      this.checkFileExtension(safePath);

      // 读取文件内容
      const content = await this.readFileContent(safePath, args.encoding || this.DEFAULT_ENCODING);

      // 可选的JSON解析
      const output = args.parseJson ? this.parseJsonContent(content) : content;

      const duration = Date.now() - startTime;

      return {
        success: true,
        output: typeof output === 'string' ? output : JSON.stringify(output, null, 2),
        duration,
        exitCode: 0
      };

    } catch (error) {
      const duration = Date.now() - startTime;
      return {
        success: false,
        error: this.formatError(error),
        duration,
        errorCode: 'FILE_READ_ERROR',
        exitCode: 1
      };
    }
  }

  /**
   * 验证参数
   */
  private static validateArgs(args: FileReadArgs): void {
    if (!args.path || typeof args.path !== 'string') {
      throw new Error('File path is required and must be a string');
    }

    if (args.encoding && !Buffer.isEncoding(args.encoding)) {
      throw new Error(`Invalid encoding: ${args.encoding}`);
    }

    if (args.maxSize && (typeof args.maxSize !== 'number' || args.maxSize <= 0)) {
      throw new Error('Max size must be a positive number');
    }
  }

  /**
   * 获取安全路径（防止目录遍历攻击）
   */
  private static async getSafePath(inputPath: string, basePath?: string): Promise<string> {
    // 标准化路径
    const normalizedPath = path.normalize(inputPath);

    // 解析为绝对路径
    let absolutePath: string;
    if (path.isAbsolute(normalizedPath)) {
      absolutePath = normalizedPath;
    } else if (basePath) {
      // 如果提供了basePath，相对于basePath解析
      const normalizedBasePath = path.normalize(basePath);
      const absoluteBasePath = path.isAbsolute(normalizedBasePath)
        ? normalizedBasePath
        : path.resolve(process.cwd(), normalizedBasePath);
      absolutePath = path.resolve(absoluteBasePath, normalizedPath);
    } else {
      // 默认相对于当前工作目录解析
      absolutePath = path.resolve(process.cwd(), normalizedPath);
    }

    // 检查是否包含路径遍历字符
    if (normalizedPath.includes('..') || absolutePath.includes('..')) {
      throw new Error('Path traversal detected');
    }

    // 确保路径在工作目录内（防止访问系统文件）
    const workDir = process.cwd();
    if (!absolutePath.startsWith(workDir)) {
      throw new Error('File path must be within the working directory');
    }

    return absolutePath;
  }

  /**
   * 检查文件访问权限
   */
  private static async checkFileAccess(filePath: string): Promise<void> {
    try {
      await fs.access(filePath, fs.constants.R_OK);
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        throw new Error(`File not found: ${filePath}`);
      } else if ((error as NodeJS.ErrnoException).code === 'EACCES') {
        throw new Error(`Permission denied: ${filePath}`);
      } else {
        throw new Error(`Cannot access file: ${filePath}`);
      }
    }
  }

  /**
   * 检查文件大小
   */
  private static async checkFileSize(filePath: string, maxSize: number): Promise<void> {
    const stats = await fs.stat(filePath);

    if (!stats.isFile()) {
      throw new Error(`Path is not a file: ${filePath}`);
    }

    if (stats.size > maxSize) {
      throw new Error(`File size ${stats.size} exceeds maximum allowed size ${maxSize}`);
    }
  }

  /**
   * 检查文件扩展名
   */
  private static checkFileExtension(filePath: string): void {
    const ext = path.extname(filePath).toLowerCase();

    // 如果没有扩展名，允许读取
    if (!ext) {
      return;
    }

    // 检查是否在允许的扩展名列表中
    if (!this.ALLOWED_EXTENSIONS.includes(ext)) {
      throw new Error(`File extension '${ext}' is not allowed for security reasons`);
    }
  }

  /**
   * 读取文件内容
   */
  private static async readFileContent(filePath: string, encoding: BufferEncoding): Promise<string> {
    return await fs.readFile(filePath, encoding);
  }

  /**
   * 解析JSON内容
   */
  private static parseJsonContent(content: string): any {
    try {
      return JSON.parse(content);
    } catch (error) {
      throw new Error(`Invalid JSON content: ${error}`);
    }
  }

  /**
   * 格式化错误信息
   */
  private static formatError(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === 'string') {
      return error;
    }
    return 'Unknown error occurred';
  }

  /**
   * 获取工具元数据
   */
  static getMetadata() {
    return {
      name: 'file-read',
      description: '安全读取文件内容，支持文本、JSON等多种格式',
      category: 'filesystem',
      level: 1,
      parameters: {
        type: 'object',
        properties: {
          path: {
            type: 'string',
            description: '要读取的文件路径，支持相对路径和绝对路径'
          },
          encoding: {
            type: 'string',
            description: '文件编码，默认为utf8',
            default: 'utf8',
            enum: ['utf8', 'utf16le', 'latin1', 'base64', 'hex', 'ascii']
          },
          maxSize: {
            type: 'number',
            description: '最大文件大小（字节），默认10MB',
            default: 10485760,
            minimum: 1024,
            maximum: 104857600
          },
          parseJson: {
            type: 'boolean',
            description: '是否自动解析JSON内容',
            default: false
          },
          basePath: {
            type: 'string',
            description: '基础路径，用于解析相对路径。例如在Skill中可传入技能目录路径，使相对路径相对于Skill目录解析'
          }
        },
        required: ['path']
      }
    };
  }
}

/**
 * 创建FileReadTool实例（用于注册表）
 */
export function createFileReadTool() {
  return {
    ...FileReadTool.getMetadata(),
    type: ToolType.BUILTIN,
    enabled: true,
    execute: async (args: Record<string, any>) => {
      return FileReadTool.execute(args as FileReadArgs);
    }
  } as BuiltInTool;
}
````

## File: src/core/EventBus.ts
````typescript
/**
 * ApexBridge (ABP-only) - 事件总线
 * 用于解耦各层之间的通信
 */

import { EventEmitter } from 'events';
import { logger } from '../utils/logger';

export class EventBus extends EventEmitter {
  private static instance: EventBus;
  
  private constructor() {
    super();
    this.setMaxListeners(100); // 增加最大监听器数量
  }
  
  static getInstance(): EventBus {
    if (!EventBus.instance) {
      EventBus.instance = new EventBus();
      logger.debug('EventBus instance created');
    }
    return EventBus.instance;
  }
  
  /**
   * 发布事件
   */
  publish(event: string, data: any): void {
    logger.debug(`📢 Event published: ${event}`);
    this.emit(event, data);
  }
  
  /**
   * 订阅事件
   */
  subscribe(event: string, handler: (data: any) => void): void {
    logger.debug(`📡 Subscribed to event: ${event}`);
    this.on(event, handler);
  }
  
  /**
   * 取消订阅
   */
  unsubscribe(event: string, handler: (data: any) => void): void {
    this.off(event, handler);
  }
}

// 导出单例
export default EventBus.getInstance();
````

## File: src/database/migrations/index.ts
````typescript
/**
 * Migration Scripts Index
 * Lists all available migration scripts
 */

export const MIGRATIONS = [
  {
    version: "001",
    name: "create_type_vocabulary",
    description: "Creates the type vocabulary table for storing type tags",
    filename: "001_create_type_vocabulary.sql",
  },
  {
    version: "002",
    name: "create_type_similarity_matrix",
    description: "Creates the type similarity matrix table",
    filename: "002_create_type_similarity_matrix.sql",
  },
  {
    version: "003",
    name: "create_type_evolution_history",
    description: "Creates the type evolution history table",
    filename: "003_create_type_evolution_history.sql",
  },
  {
    version: "004",
    name: "create_type_assignments",
    description: "Creates the type assignments table",
    filename: "004_create_type_assignments.sql",
  },
  {
    version: "005",
    name: "create_prompt_templates",
    description: "Creates the prompt templates table",
    filename: "005_create_prompt_templates.sql",
  },
] as const;

export type MigrationVersion = (typeof MIGRATIONS)[number]["version"];
````

## File: src/services/chat/ChatServiceFactory.ts
````typescript
/**
 * ChatServiceFactory - ChatService 工厂类
 * 负责创建和组装 ChatService 及其依赖
 */

import { LLMManager } from "../../core/LLMManager";
import { ProtocolEngine } from "../../core/ProtocolEngine";
import { EventBus } from "../../core/EventBus";
import { ConversationHistoryService } from "../ConversationHistoryService";
import { SystemPromptService } from "../SystemPromptService";
import { SessionManager } from "../SessionManager";
import { RequestTracker } from "../RequestTracker";
import { VariableEngine } from "../../core/variable/VariableEngine";
import { ChatService } from "../ChatService";
import { MessagePreprocessor } from "./MessagePreprocessor";
import { ConversationSaver } from "./ConversationSaver";
import { StrategySelector } from "./StrategySelector";
import { SingleRoundStrategy } from "../../strategies/SingleRoundStrategy";
import { ReActStrategy } from "../../strategies/ReActStrategy";
import { IWebSocketManager } from "../../api/websocket/WebSocketManager";
import { TIMEOUT } from "../../constants";

export interface ChatServiceFactoryOptions {
  configPath?: string;
  requestTimeout?: number;
  variableCacheTtl?: number;
}

export class ChatServiceFactory {
  private options: ChatServiceFactoryOptions;

  constructor(options: ChatServiceFactoryOptions = {}) {
    this.options = {
      configPath: "./config",
      requestTimeout: TIMEOUT.SKILL_CACHE_TTL, // 5分钟
      variableCacheTtl: TIMEOUT.TOOL_EXECUTION, // 30秒
      ...options,
    };
  }

  /**
   * 创建 ChatService 实例
   */
  create(protocolEngine: ProtocolEngine, llmManager: LLMManager, eventBus: EventBus): ChatService {
    // 1. 创建共享服务实例
    const conversationHistoryService = ConversationHistoryService.getInstance();
    const systemPromptService = new SystemPromptService(this.options.configPath);
    const variableEngine = new VariableEngine({ cacheTtlMs: this.options.variableCacheTtl });

    // 2. 创建会话管理器
    const sessionManager = new SessionManager(conversationHistoryService);

    // 3. 创建请求追踪器
    const requestTracker = new RequestTracker(null, this.options.requestTimeout);

    // 4. 创建策略
    const strategies = [
      new ReActStrategy(llmManager, conversationHistoryService),
      new SingleRoundStrategy(llmManager, conversationHistoryService),
    ];

    // 5. 创建子服务
    const messagePreprocessor = new MessagePreprocessor(systemPromptService, variableEngine);
    const conversationSaver = new ConversationSaver(conversationHistoryService, sessionManager);
    const strategySelector = new StrategySelector(strategies);

    // 6. 创建 ChatService
    const chatService = new ChatService(
      protocolEngine,
      llmManager,
      eventBus,
      messagePreprocessor,
      conversationSaver,
      strategySelector,
      sessionManager,
      requestTracker
    );

    return chatService;
  }

  /**
   * 设置 WebSocket 管理器
   */
  attachWebSocketManager(chatService: ChatService, manager: IWebSocketManager): void {
    chatService.setWebSocketManager(manager);
  }
}
````

## File: src/services/chat/MessagePreprocessor.ts
````typescript
/**
 * MessagePreprocessor - 消息预处理器
 * 负责消息的系统提示词注入和变量替换
 */

import { Message, ChatOptions } from "../../types";
import { logger } from "../../utils/logger";
import { SystemPromptService } from "../SystemPromptService";
import { VariableEngine } from "../../core/variable/VariableEngine";

export interface PreprocessResult {
  messages: Message[];
  variableCount: number;
}

export class MessagePreprocessor {
  constructor(
    private systemPromptService: SystemPromptService,
    private variableEngine: VariableEngine
  ) {}

  /**
   * 预处理消息：注入系统提示词 + 变量替换
   */
  async preprocess(
    messages: Message[],
    options: ChatOptions,
    strategyVariables: Record<string, string> = {}
  ): Promise<PreprocessResult> {
    let processedMessages = [...messages];

    // DEBUG: 检查输入消息中的图片数据
    this.debugImageData(messages, "Input");

    // 1. 注入系统提示词（如果没有）
    const hasSystemMessage = processedMessages.some((m) => m.role === "system");
    if (!hasSystemMessage) {
      const systemPromptTemplate = this.systemPromptService.getSystemPromptTemplate();
      if (systemPromptTemplate) {
        processedMessages = [
          { role: "system", content: systemPromptTemplate } as Message,
          ...processedMessages,
        ];
        logger.debug(
          `[MessagePreprocessor] Injected system prompt (${systemPromptTemplate.length} chars)`
        );
      }
    }

    // 2. 构建统一的变量上下文
    const variables = this.buildVariableContext(options, strategyVariables);

    // 3. 统一变量替换
    processedMessages = await this.variableEngine.resolveMessages(processedMessages, variables);
    logger.debug(
      `[MessagePreprocessor] Variable replacement completed with ${Object.keys(variables).length} variables`
    );

    // DEBUG: 检查输出消息中的图片数据
    this.debugImageData(processedMessages, "Output");

    return {
      messages: processedMessages,
      variableCount: Object.keys(variables).length,
    };
  }

  /**
   * 构建变量上下文
   */
  private buildVariableContext(
    options: ChatOptions,
    strategyVariables: Record<string, string>
  ): Record<string, string> {
    return {
      // 基础变量
      model: options.model || "",
      provider: options.provider || "",
      current_time: new Date().toISOString(),
      user_prompt: options.user_prompt || "",
      // 从 options 中提取字符串类型的变量
      ...Object.entries(options).reduce(
        (acc, [key, value]) => {
          if (typeof value === "string") {
            acc[key] = value;
          }
          return acc;
        },
        {} as Record<string, string>
      ),
      // 策略提供的变量（如 available_tools）
      ...strategyVariables,
    };
  }

  /**
   * 调试图片数据
   *
   * M-005 修复：敏感数据脱敏，不记录完整 URL
   */
  private debugImageData(messages: Message[], stage: string): void {
    const imageCount = messages.filter(
      (m) => Array.isArray(m.content) && m.content.some((p) => p.type === "image_url")
    ).length;

    if (imageCount > 0) {
      logger.debug(`[MessagePreprocessor] ${stage} has ${imageCount} multimodal messages`);
      messages.forEach((msg, idx) => {
        if (Array.isArray(msg.content)) {
          msg.content.forEach((part, pIdx) => {
            if (part.type === "image_url") {
              const url = typeof part.image_url === "string" ? part.image_url : part.image_url?.url;
              if (url) {
                // M-005: 敏感数据脱敏 - 只记录 URL 长度和是否包含 base64，不记录完整 URL
                const isBase64 = url.includes(";base64,");
                const urlLength = url.length;
                logger.debug(
                  `[MessagePreprocessor] ${stage} msg[${idx}].content[${pIdx}]: ${urlLength} chars, has ;base64,: ${isBase64}`
                );
              }
            }
          });
        }
      });
    }
  }
}
````

## File: src/services/chat/StrategySelector.ts
````typescript
/**
 * StrategySelector - 策略选择器
 * 负责根据聊天选项选择合适的策略
 */

import { ChatOptions } from "../../types";
import { logger } from "../../utils/logger";
import type { ChatStrategy } from "../../strategies/ChatStrategy";

export class StrategySelector {
  private strategyMap: Map<string, ChatStrategy> = new Map();

  constructor(strategies: ChatStrategy[]) {
    for (const strategy of strategies) {
      this.strategyMap.set(strategy.getName(), strategy);
    }
    logger.debug(`[StrategySelector] Initialized with ${this.strategyMap.size} strategies`);
  }

  /**
   * 根据选项选择合适的策略
   * 优先使用 ReActStrategy（深度思考），如果没有则报错
   */
  select(options: ChatOptions): ChatStrategy {
    // 优先使用 ReActStrategy（深度思考模式）
    const reactStrategy = this.strategyMap.get("ReActStrategy");
    if (reactStrategy && reactStrategy.supports(options)) {
      logger.debug(`[StrategySelector] Selected strategy: ${reactStrategy.getName()}`);
      return reactStrategy;
    }

    // 如果 ReActStrategy 不支持，尝试其他策略
    for (const strategy of this.strategyMap.values()) {
      if (strategy.getName() === "ReActStrategy") continue; // 已检查
      if (strategy.supports(options)) {
        logger.debug(`[StrategySelector] Selected strategy: ${strategy.getName()}`);
        return strategy;
      }
    }

    // 没有可用策略，抛出错误（不再回退到单轮策略）
    throw new Error(
      "No suitable chat strategy found. ReActStrategy requires selfThinking.enabled=true"
    );
  }

  /**
   * 获取所有可用策略名称
   */
  getStrategyNames(): string[] {
    return Array.from(this.strategyMap.keys());
  }

  /**
   * 根据名称获取策略
   */
  getStrategy(name: string): ChatStrategy | undefined {
    return this.strategyMap.get(name);
  }

  /**
   * 检查策略是否支持给定选项
   */
  supports(name: string, options: ChatOptions): boolean {
    const strategy = this.strategyMap.get(name);
    return strategy ? strategy.supports(options) : false;
  }
}
````

## File: src/services/executors/BuiltInExecutor.ts
````typescript
/**
 * 内置工具执行器
 * 通过直接方法调用执行内置工具，无进程开销
 */

import { BaseToolExecutor } from './ToolExecutor';
import { BuiltInTool, ToolExecuteOptions, ToolResult, ToolError, ToolErrorCode } from '../../types/tool-system';
import { getBuiltInToolsRegistry } from '../BuiltInToolsRegistry';
import { logger } from '../../utils/logger';

/**
 * 内置工具执行器
 * 提供高性能的内置工具执行能力
 */
export class BuiltInExecutor extends BaseToolExecutor {
  private registry = getBuiltInToolsRegistry();

  constructor() {
    super();
    logger.debug('BuiltInExecutor initialized');
  }

  /**
   * 执行内置工具
   * @param options 执行选项
   * @returns 执行结果
   */
  async execute(options: ToolExecuteOptions): Promise<ToolResult> {
    const startTime = Date.now();

    try {
      // 验证执行选项
      this.validateExecuteOptions(options);

      // 获取工具
      const tool = this.registry.getTool(options.name);
      if (!tool) {
        throw new ToolError(
          `Built-in tool not found: ${options.name}`,
          ToolErrorCode.TOOL_NOT_FOUND
        );
      }

      if (!tool.enabled) {
        throw new ToolError(
          `Built-in tool is disabled: ${options.name}`,
          ToolErrorCode.TOOL_NOT_FOUND
        );
      }

      logger.info(`Executing built-in tool: ${options.name}`);
      logger.debug(`Tool arguments:`, options.args);

      // 验证工具参数
      this.registry.validateToolParameters(tool, options.args);

      // 执行工具
      const result = await tool.execute(options.args);

      // 记录执行时间
      const duration = this.calculateDuration(startTime);
      logger.info(`Built-in tool ${options.name} completed in ${duration}ms`);

      return {
        ...result,
        duration: result.duration || duration
      };

    } catch (error) {
      const duration = this.calculateDuration(startTime);

      if (error instanceof ToolError) {
        logger.error(`Built-in tool ${options.name} failed: ${error.message}`);
        return this.createErrorResult(error.message, duration, error.code);
      }

      logger.error(`Built-in tool ${options.name} failed with unexpected error:`, error);
      return this.createErrorResult(
        `Built-in tool execution failed: ${this.formatError(error)}`,
        duration,
        ToolErrorCode.TOOL_EXECUTION_FAILED
      );
    }
  }

  /**
   * 获取支持的工具列表
   * @returns 工具列表
   */
  listTools(): BuiltInTool[] {
    return this.registry.listTools();
  }

  /**
   * 获取所有工具（包括禁用的）
   * @returns 所有工具列表
   */
  listAllTools(): BuiltInTool[] {
    return this.registry.listAllTools();
  }

  /**
   * 获取工具详情
   * @param name 工具名称
   * @returns 工具详情或undefined
   */
  getTool(name: string): BuiltInTool | undefined {
    return this.registry.getTool(name);
  }

  /**
   * 启用工具
   * @param name 工具名称
   * @returns 是否成功
   */
  enableTool(name: string): boolean {
    return this.registry.enableTool(name);
  }

  /**
   * 禁用工具
   * @param name 工具名称
   * @returns 是否成功
   */
  disableTool(name: string): boolean {
    return this.registry.disableTool(name);
  }

  /**
   * 批量启用工具
   * @param names 工具名称列表
   */
  enableTools(names: string[]): void {
    this.registry.enableTools(names);
  }

  /**
   * 批量禁用工具
   * @param names 工具名称列表
   */
  disableTools(names: string[]): void {
    this.registry.disableTools(names);
  }

  /**
   * 获取执行器统计信息
   * @returns 统计信息
   */
  getStatistics() {
    return {
      type: 'builtin',
      registryStats: this.registry.getStatistics()
    };
  }

  /**
   * 获取工具分类统计
   * @returns 分类统计
   */
  getCategoryStatistics() {
    const tools = this.listTools();
    const categories: Record<string, number> = {};

    tools.forEach(tool => {
      categories[tool.category] = (categories[tool.category] || 0) + 1;
    });

    return categories;
  }

  /**
   * 批量执行工具
   * @param optionsList 执行选项列表
   * @returns 执行结果列表
   */
  async executeBatch(optionsList: ToolExecuteOptions[]): Promise<ToolResult[]> {
    const results: ToolResult[] = [];

    for (const options of optionsList) {
      try {
        const result = await this.execute(options);
        results.push(result);
      } catch (error) {
        results.push({
          success: false,
          error: this.formatError(error),
          duration: 0,
          errorCode: ToolErrorCode.TOOL_EXECUTION_FAILED,
          exitCode: 1
        });
      }
    }

    return results;
  }

  /**
   * 并行执行工具
   * @param optionsList 执行选项列表
   * @param concurrency 并发数
   * @returns 执行结果列表
   */
  async executeParallel(
    optionsList: ToolExecuteOptions[],
    concurrency: number = 5
  ): Promise<ToolResult[]> {
    // 使用p-limit控制并发
    const pLimit = require('p-limit');
    const limit = pLimit(concurrency);

    const promises = optionsList.map(options =>
      limit(() => this.execute(options))
    );

    return Promise.all(promises);
  }

  /**
   * 验证工具是否存在且可用
   * @param name 工具名称
   * @returns 验证结果
   */
  validateTool(name: string): { valid: boolean; reason?: string } {
    const tool = this.registry.getTool(name);

    if (!tool) {
      return { valid: false, reason: `Tool '${name}' not found` };
    }

    if (!tool.enabled) {
      return { valid: false, reason: `Tool '${name}' is disabled` };
    }

    return { valid: true };
  }
}

/**
 * 内置工具执行器工厂
 */
export class BuiltInExecutorFactory {
  private static instance: BuiltInExecutor | null = null;

  /**
   * 获取内置工具执行器实例
   * @returns 执行器实例
   */
  static getInstance(): BuiltInExecutor {
    if (!this.instance) {
      this.instance = new BuiltInExecutor();
    }
    return this.instance;
  }

  /**
   * 重置实例（用于测试）
   */
  static resetInstance(): void {
    this.instance = null;
  }
}

/**
 * 获取默认的内置工具执行器
 * @returns 内置工具执行器实例
 */
export function getBuiltInExecutor(): BuiltInExecutor {
  return BuiltInExecutorFactory.getInstance();
}
````

## File: src/services/mcp/convert.ts
````typescript
/**
 * MCP Tool Converter - MCP 工具转换器
 * 将 MCP 工具定义转换为统一工具框架格式
 */

import type { MCPTool } from "../../types/mcp";
import type { Tool } from "../../core/tool/tool";

/**
 * MCP 工具转换器
 * 提供 MCP 工具定义到统一 Tool.Info 格式的转换功能
 */

/**
 * 工具类型
 */
export type ToolType = "builtin" | "skill" | "mcp";

/**
 * 转换 MCP 工具为统一工具格式
 * @param serverId - MCP 服务器 ID
 * @param serverName - MCP 服务器名称
 * @param tool - MCP 工具定义
 * @returns 统一工具定义
 */
export function convertMcpTool(serverId: string, serverName: string, tool: MCPTool): Tool.Info {
  // 生成工具 ID：{clientName}_{toolName} 格式
  const toolId = `${serverName}_${tool.name}`;

  return {
    id: toolId,
    init: async () => {
      const parameters = tool.inputSchema || {
        type: "object" as const,
        properties: {},
      };

      return {
        description: tool.description || "",
        parameters,
        execute: async (args, ctx) => {
          // 这里需要依赖 MCPIntegrationService 来执行实际的 MCP 工具调用
          // 由于循环依赖问题，我们在执行时动态获取服务
          const { mcpIntegration } = await import("../../services/MCPIntegrationService");

          try {
            const result = await mcpIntegration.callTool({
              toolName: tool.name,
              arguments: args,
              serverId,
            });

            // 转换 MCP 结果为统一格式
            let output = "";
            const metadata: Record<string, unknown> = {
              serverId,
              serverName,
              toolName: tool.name,
              success: result.success,
            };

            if (result.success && result.content) {
              // 聚合文本内容并清理
              const textContents = result.content
                .filter((c) => c.type === "text" && c.text)
                .map((c) => cleanMcpToolResult(c.text as string));
              output = textContents.join("\n");

              // 提取资源附件
              const attachments = result.content
                .filter(
                  (
                    c
                  ): c is {
                    type: "resource";
                    resource: { uri: string; mimeType?: string; text?: string };
                  } => c.type === "resource" && "resource" in c && typeof c.resource === "object"
                )
                .map((c) => {
                  const resource = c.resource;
                  return {
                    type: "file" as const,
                    file: {
                      filename: resource.uri.split("/").pop() || "resource",
                      mimeType: resource.mimeType,
                      fileData: resource.text,
                    },
                  };
                });

              if (attachments.length > 0) {
                metadata.attachments = attachments;
              }
            } else if (result.error) {
              output = `Error: ${result.error.message}`;
              metadata.error = result.error;
            }

            return {
              title: tool.name,
              metadata,
              output,
            };
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "Unknown error";
            return {
              title: tool.name,
              metadata: {
                serverId,
                serverName,
                toolName: tool.name,
                success: false,
                error: errorMessage,
              },
              output: `Error executing MCP tool: ${errorMessage}`,
            };
          }
        },
      };
    },
  };
}

/**
 * 解析 MCP 资源 URI
 * @param uri - MCP 资源 URI，格式为 mcp://{clientName}/{resourcePath}
 * @returns 解析结果或 null（如果格式无效）
 */
export function parseMcpResourceUri(
  uri: string
): { clientName: string; resourcePath: string } | null {
  if (!uri || typeof uri !== "string") {
    return null;
  }

  // 检查是否为 mcp:// URI
  if (!uri.startsWith("mcp://")) {
    return null;
  }

  // 移除协议前缀
  const pathPart = uri.slice(6);

  // 查找第一个斜杠，分隔客户端名称和资源路径
  const slashIndex = pathPart.indexOf("/");

  if (slashIndex === -1) {
    // 没有资源路径，只有客户端名称
    return {
      clientName: pathPart,
      resourcePath: "",
    };
  }

  const clientName = pathPart.slice(0, slashIndex);
  const resourcePath = pathPart.slice(slashIndex + 1);

  // 验证客户端名称非空
  if (!clientName) {
    return null;
  }

  return { clientName, resourcePath };
}

/**
 * 生成 MCP 工具 URI
 * @param serverName - 服务器名称
 * @param toolName - 工具名称
 * @returns MCP 工具 URI
 */
export function createMcpToolUri(serverName: string, toolName: string): string {
  return `mcp://${serverName}/${toolName}`;
}

/**
 * 从工具 ID 提取 MCP 服务器名称和工具名称
 * @param toolId - 工具 ID，格式为 {clientName}_{toolName}
 * @returns 服务器名称和工具名称
 */
export function parseMcpToolId(toolId: string): { serverName: string; toolName: string } | null {
  const lastUnderscore = toolId.lastIndexOf("_");

  if (lastUnderscore === -1 || lastUnderscore === 0 || lastUnderscore === toolId.length - 1) {
    return null;
  }

  return {
    serverName: toolId.slice(0, lastUnderscore),
    toolName: toolId.slice(lastUnderscore + 1),
  };
}

/**
 * 清理 MCP 工具返回的原始结果
 * 移除技术元数据，提取对用户有价值的内容
 * @param rawResult - 原始工具返回结果
 * @returns 清理后的结果
 */
export function cleanMcpToolResult(rawResult: string): string {
  // 1. 尝试 JSON 解析（处理结构化搜索结果）
  try {
    const parsed = JSON.parse(rawResult);

    // 如果是搜索结果格式，提取有机结果
    if (parsed.organic && Array.isArray(parsed.organic) && parsed.organic.length > 0) {
      const cleaned = parsed.organic
        .map((item: { title?: string; link?: string; snippet?: string; date?: string }) => {
          let line = "";
          if (item.title && item.link) {
            line += `[${item.title}](${item.link})`;
          }
          if (item.snippet) {
            line += `\n${item.snippet.trim()}`;
          }
          return line.trim();
        })
        .filter((line: string) => line.length > 0)
        .join("\n\n");

      // 添加相关搜索（如果有）
      if (parsed.related_searches && Array.isArray(parsed.related_searches)) {
        const relatedQueries = parsed.related_searches
          .map((r: { query?: string }) => r.query)
          .filter((q: string | undefined): q is string => typeof q === "string" && q.length > 0);
        if (relatedQueries.length > 0) {
          return `${cleaned}\n\n**相关搜索**: ${relatedQueries.join(" | ")}`;
        }
      }

      return cleaned;
    }
  } catch {
    // 不是 JSON 格式，继续清理
  }

  // 2. 非 JSON 格式，清理技术元数据
  let cleaned = rawResult;

  // 移除 Description 后的所有内容
  cleaned = cleaned.replace(
    /\n{2}Description:[\s\S]*?(?=\n{2}Args:|\n{2}Search Strategy:|\n{2}Returns:|\n{2}Type:|\n{2}Source:|\n{2}Reason:)/g,
    ""
  );

  // 移除 Args 规范
  cleaned = cleaned.replace(
    /\n{2}Args:[\s\S]*?(?=\n{2}Search Strategy:|\n{2}Returns:|\n{2}Type:|\n{2}Source:|\n{2}Reason:)/g,
    ""
  );

  // 移除 Search Strategy
  cleaned = cleaned.replace(
    /\n{2}Search Strategy:[\s\S]*?(?=\n{2}Returns:|\n{2}Type:|\n{2}Source:|\n{2}Reason:)/g,
    ""
  );

  // 移除 Returns 规范
  cleaned = cleaned.replace(/\n{2}Returns:[\s\S]*?(?=\n{2}Type:|\n{2}Source:|\n{2}Reason:)/g, "");

  // 移除 Type 和 Source
  cleaned = cleaned.replace(/\n{2}Type:.*$/gm, "");
  cleaned = cleaned.replace(/\n{2}Source:.*$/gm, "");

  // 移除 Reason
  cleaned = cleaned.replace(/\n{2}Reason:.*$/gm, "");

  // 移除 Score 百分比
  cleaned = cleaned.replace(/Score: \d+(\.\d+)?%/g, "");

  // 移除 MCP Tool 标记
  cleaned = cleaned.replace(/\[🔌 MCP Tool\]/g, "");

  // 移除工具列表头部（如 "Found 2 relevant Tool(s) for: ..."）
  cleaned = cleaned.replace(/^Found \d+ relevant.*?\n\n/g, "");

  // 移除编号列表头部（如 "1. web_search"）
  cleaned = cleaned.replace(/^\d+\.\s+\S+\s*(\n|$)/gm, "\n");

  // 移除重复的换行
  cleaned = cleaned.replace(/\n{3,}/g, "\n\n");

  return cleaned.trim();
}
````

## File: src/services/tool-retrieval/EmbeddingGenerator.ts
````typescript
/**
 * EmbeddingGenerator - Embedding Generation
 *
 * Handles embedding generation for skills and tools using LLMManager.
 */

import { logger } from "../../utils/logger";
import {
  EmbeddingConfig,
  EmbeddingVector,
  SkillData,
  MCPTool,
  ToolError,
  ToolErrorCode,
  EmbeddingInput,
} from "./types";
import { BatchEmbeddingService, BatchEmbeddingResult } from "./BatchEmbeddingService";

// LLMManager lazy import to avoid circular dependency
let llmManagerInstance: unknown = null;

// Batch embedding service singleton
let batchEmbeddingService: BatchEmbeddingService | null = null;

/**
 * EmbeddingGenerator interface
 */
export interface IEmbeddingGenerator {
  generateForSkill(skill: SkillData): Promise<EmbeddingVector>;
  generateForTool(tool: MCPTool): Promise<EmbeddingVector>;
  generateForText(text: string): Promise<EmbeddingVector>;
  generateBatch(texts: string[]): Promise<EmbeddingVector[]>;
  getConfig(): EmbeddingConfig;
  getActualDimensions(): Promise<number>;
}

/**
 * EmbeddingGenerator implementation
 */
export class EmbeddingGenerator implements IEmbeddingGenerator {
  private config: EmbeddingConfig;
  private dimensionsCache: number | null = null;
  private llmConfigService: unknown = null;
  private batchService: BatchEmbeddingService;

  constructor(config: EmbeddingConfig) {
    this.config = config;
    this.batchService = new BatchEmbeddingService({
      batchSize: 100,
      maxConcurrency: 5,
      retryAttempts: 3,
    });
    logger.info("[EmbeddingGenerator] Created with config:", {
      provider: config.provider,
      model: config.model,
      dimensions: config.dimensions,
    });
  }

  /**
   * Get actual dimensions from LLMConfigService
   */
  async getActualDimensions(): Promise<number> {
    if (this.dimensionsCache !== null) {
      return this.dimensionsCache;
    }

    try {
      // Lazy import to avoid circular dependency
      if (!this.llmConfigService) {
        const { LLMConfigService } = await import("../../services/LLMConfigService");
        this.llmConfigService = LLMConfigService.getInstance();
      }

      // Get default embedding model
      const embeddingModel = (
        this.llmConfigService as { getDefaultModel(type: string): unknown }
      ).getDefaultModel("embedding");

      if (embeddingModel && typeof embeddingModel === "object") {
        const modelConfig = (embeddingModel as { modelConfig?: { dimensions?: number } })
          .modelConfig;
        const dimensions = modelConfig?.dimensions || this.config.dimensions;

        logger.info(`[EmbeddingGenerator] Using actual dimensions: ${dimensions}`);
        this.dimensionsCache = dimensions;
        return dimensions;
      }
    } catch (error) {
      logger.warn("[EmbeddingGenerator] Failed to get actual dimensions:", error);
    }

    return this.config.dimensions;
  }

  /**
   * Generate embedding for a skill
   */
  async generateForSkill(skill: SkillData): Promise<EmbeddingVector> {
    const input: EmbeddingInput = {
      name: skill.name,
      description: skill.description,
      tags: skill.tags || [],
    };

    return this.generate(input);
  }

  /**
   * Generate embedding for an MCP tool
   */
  async generateForTool(tool: MCPTool): Promise<EmbeddingVector> {
    const input: EmbeddingInput = {
      name: tool.name,
      description: tool.description,
      tags: (tool.metadata?.tags as string[]) || [],
    };

    return this.generate(input);
  }

  /**
   * Generate embedding for text
   */
  async generateForText(text: string): Promise<EmbeddingVector> {
    return this.generate({
      name: text,
      description: text,
      tags: [],
    });
  }

  /**
   * Generate batch embeddings (optimized with parallel processing)
   */
  async generateBatch(texts: string[]): Promise<EmbeddingVector[]> {
    if (texts.length === 0) {
      return [];
    }

    // For small batches, use direct LLMManager call for efficiency
    if (texts.length <= 10) {
      return this.generateBatchDirect(texts);
    }

    // For larger batches, use batch service with parallel processing
    const startTime = Date.now();

    try {
      // Prepare embedding inputs
      const inputs = texts.map((text) =>
        this.prepareEmbeddingText({
          name: text,
          description: text,
          tags: [],
        })
      );

      // Use batch embedding service
      const result = await this.batchService.generateBatch(inputs, async (batchTexts: string[]) => {
        return this.callLLMEmbed(batchTexts);
      });

      logger.debug(
        `[EmbeddingGenerator] Batch generated ${result.totalProcessed}/${texts.length} embeddings in ${result.duration}ms`
      );

      // Convert to EmbeddingVector format
      return result.embeddings.map((values) => ({
        values,
        dimensions: values.length,
        model: this.config.model,
      }));
    } catch (error) {
      logger.error(
        "[EmbeddingGenerator] Batch embedding failed, falling back to sequential:",
        error
      );
      // Fallback to sequential processing
      return this.generateBatchDirect(texts);
    }
  }

  /**
   * Direct batch embedding (for small batches)
   */
  private async generateBatchDirect(texts: string[]): Promise<EmbeddingVector[]> {
    const vectors: EmbeddingVector[] = [];

    for (const text of texts) {
      const vector = await this.generateForText(text);
      vectors.push(vector);
    }

    return vectors;
  }

  /**
   * Call LLMManager embed method
   */
  private async callLLMEmbed(texts: string[]): Promise<number[][]> {
    // Lazy import LLMManager
    if (!llmManagerInstance) {
      const { LLMManager } = await import("../../core/LLMManager");
      llmManagerInstance = new LLMManager();
    }

    const embeddings = await (
      llmManagerInstance as { embed(texts: string[]): Promise<number[][]> }
    ).embed(texts);

    if (!embeddings || embeddings.length === 0) {
      throw new Error("Empty embedding result from LLMManager");
    }

    return embeddings;
  }

  /**
   * Core embedding generation
   */
  private async generate(input: EmbeddingInput): Promise<EmbeddingVector> {
    try {
      logger.debug(`[EmbeddingGenerator] Generating embedding for: ${input.name}`);

      // Generate embedding using remote API
      const vector = await this.generateRemoteEmbedding(input);

      return {
        values: vector,
        dimensions: vector.length,
        model: this.config.model,
      };
    } catch (error) {
      logger.error(`[EmbeddingGenerator] Failed to generate embedding for ${input.name}:`, error);
      throw new ToolError(
        `Embedding generation failed: ${this.formatError(error)}`,
        ToolErrorCode.EMBEDDING_MODEL_ERROR
      );
    }
  }

  /**
   * Generate embedding using remote API (via LLMManager)
   */
  private async generateRemoteEmbedding(input: EmbeddingInput): Promise<number[]> {
    try {
      // Lazy import LLMManager
      if (!llmManagerInstance) {
        const { LLMManager } = await import("../../core/LLMManager");
        llmManagerInstance = new LLMManager();
      }

      // Prepare text for embedding
      const text = this.prepareEmbeddingText(input);

      // Call LLMManager.embed()
      const embeddings = await (
        llmManagerInstance as { embed(texts: string[]): Promise<number[][]> }
      ).embed([text]);

      if (!embeddings || embeddings.length === 0 || !embeddings[0]) {
        throw new Error("Empty embedding result");
      }

      logger.debug(
        `[EmbeddingGenerator] Generated remote embedding: ${embeddings[0].length} dimensions`
      );
      return embeddings[0];
    } catch (error) {
      logger.error("[EmbeddingGenerator] Remote embedding generation failed:", error);
      throw error;
    }
  }

  /**
   * Prepare text for embedding
   */
  private prepareEmbeddingText(input: EmbeddingInput): string {
    const parts = [input.name, input.description, ...(input.tags || [])];

    return parts.join(" ").trim();
  }

  /**
   * Get configuration
   */
  getConfig(): EmbeddingConfig {
    return this.config;
  }

  /**
   * Format error message
   */
  private formatError(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error occurred in EmbeddingGenerator";
  }
}

/**
 * Get LLMManager instance (for embedding)
 */
export function getEmbeddingLLMManager(): unknown {
  return llmManagerInstance;
}

/**
 * Reset LLMManager instance (for testing)
 */
export function resetEmbeddingLLMManager(): void {
  llmManagerInstance = null;
}

/**
 * Get batch embedding service (for advanced usage)
 */
export function getBatchEmbeddingService(): BatchEmbeddingService | null {
  return batchEmbeddingService;
}

/**
 * Reset batch embedding service (for testing)
 */
export function resetBatchEmbeddingService(): void {
  batchEmbeddingService = null;
}
````

## File: src/services/tool-retrieval/index.ts
````typescript
/**
 * ToolRetrieval Module - Unified Exports
 *
 * Main entry point for the tool retrieval service module.
 */

// Types
export * from "./types";

// Core Classes
export {
  ToolRetrievalService,
  IToolRetrievalService,
  getToolRetrievalService,
  resetToolRetrievalService,
} from "./ToolRetrievalService";

// Sub-modules
export { LanceDBConnection, ILanceDBConnection } from "./LanceDBConnection";
export {
  IndexConfigOptimizer,
  IndexConfig,
  OptimizationResult,
  INDEX_PRESETS,
} from "./IndexConfigOptimizer";
export {
  EmbeddingGenerator,
  IEmbeddingGenerator,
  getEmbeddingLLMManager,
  resetEmbeddingLLMManager,
  getBatchEmbeddingService,
  resetBatchEmbeddingService,
} from "./EmbeddingGenerator";
export {
  BatchEmbeddingService,
  BatchEmbeddingConfig,
  BatchEmbeddingResult,
} from "./BatchEmbeddingService";
export { SkillIndexer, ISkillIndexer } from "./SkillIndexer";
export { SearchEngine, ISearchEngine } from "./SearchEngine";
export { MCPToolSupport, IMCPToolSupport } from "./MCPToolSupport";

// Phase 1: Hybrid Retrieval Components
export {
  TagMatchingEngine,
  ITagMatchingEngine,
  TagMatchingEngineConfig,
  DEFAULT_TAG_MATCHING_CONFIG,
} from "./TagMatchingEngine";
export {
  UnifiedScoringEngine,
  IUnifiedScoringEngine,
  UnifiedScoringEngineConfig,
  DEFAULT_SCORING_CONFIG,
} from "./UnifiedScoringEngine";
export {
  HybridRetrievalEngine,
  IHybridRetrievalEngine,
  HybridRetrievalQuery,
  HybridRetrievalEngineConfig,
} from "./HybridRetrievalEngine";
export {
  DisclosureManager,
  IDisclosureManager,
  DisclosureManagerConfig,
  DEFAULT_DISCLOSURE_CONFIG,
  DEFAULT_DISCLOSURE_CONFIG_V2,
  DisclosureDecisionManager,
  IDisclosureDecisionManager,
  DisclosureCache,
  IDisclosureCache,
  DisclosureDecisionInput,
  DisclosureDecisionOutput,
  DisclosureCacheKey,
  DisclosureMetrics,
  DisclosureManagerConfigV2,
} from "./DisclosureManager";
````

## File: src/services/tool-retrieval/types.ts
````typescript
/**
 * ToolRetrieval Service Types
 *
 * Type definitions for the tool retrieval service module.
 */

// ==================== Tool Retrieval Result ====================

/**
 * Tool retrieval result
 */
export interface ToolRetrievalResult {
  /** Tool/Skill ID */
  id: string;
  /** Tool name */
  name: string;
  /** Tool description */
  description: string;
  /** Similarity score (0-1) */
  score: number;
  /** Tool type: 'mcp' | 'builtin' | 'skill' */
  toolType: 'mcp' | 'builtin' | 'skill';
  /** Metadata */
  metadata?: Record<string, unknown>;
  /** Type tags */
  tags?: string[];
}

/**
 * Retrieval result sorting options
 */
export interface RetrievalSortingOptions {
  /** Sort field */
  field: 'score' | 'relevance' | 'popularity';
  /** Sort order */
  order: 'asc' | 'desc';
}

// ==================== Skill Data ====================

/**
 * Skill data structure
 */
export interface SkillData {
  /** Skill ID */
  id: string;
  /** Skill name */
  name: string;
  /** Skill description */
  description: string;
  /** Execution command */
  command?: string;
  /** Parameters pattern */
  parameters?: Record<string, unknown>;
  /** Type */
  type?: string;
  /** Tags */
  tags?: string[];
  /** File path */
  filePath?: string;
  /** Last modified time */
  lastModified?: Date;
  /** Metadata */
  metadata?: Record<string, unknown>;
  /** Version */
  version?: string;
}

// ==================== MCP Tool ====================

/**
 * MCP tool definition
 */
export interface MCPTool {
  /** Tool name */
  name: string;
  /** Tool description */
  description: string;
  /** Input schema */
  inputSchema: MCPInputSchema;
  /** Tool type */
  type?: string;
  /** Metadata */
  metadata?: Record<string, unknown>;
}

/**
 * MCP input schema
 */
export interface MCPInputSchema {
  /** JSON Schema */
  schema: Record<string, unknown>;
  /** Properties */
  properties?: Record<string, unknown>;
}

/**
 * MCP tool retrieval result
 */
export interface MCPToolRetrievalResult {
  /** Tool name */
  name: string;
  /** Similarity score */
  score: number;
  /** Description */
  description: string;
  /** Parameters pattern */
  parameters?: Record<string, unknown>;
}

// ==================== Embedding Vector ====================

/**
 * Embedding vector configuration
 */
export interface EmbeddingConfig {
  /** Embedding model provider */
  provider: 'openai' | 'deepseek' | 'zhipu' | 'ollama';
  /** Model name */
  model: string;
  /** Embedding dimensions */
  dimensions: number;
  /** Max tokens */
  maxTokens?: number;
}

/**
 * Embedding vector
 */
export interface EmbeddingVector {
  /** Vector values */
  values: number[];
  /** Dimensions */
  dimensions: number;
  /** Model info */
  model: string;
}

// ==================== Database Configuration ====================

/**
 * LanceDB configuration
 */
export interface LanceDBConfig {
  /** Database path */
  databasePath: string;
  /** Table name */
  tableName: string;
  /** Vector dimensions */
  vectorDimensions: number;
}

/**
 * Database connection status
 */
export interface ConnectionStatus {
  /** Whether connected */
  connected: boolean;
  /** Last connection time */
  lastConnected?: Date;
  /** Connection error */
  error?: string;
}

// ==================== Index Configuration ====================

/**
 * Index configuration
 */
export interface IndexConfig {
  /** Index name */
  name: string;
  /** Batch size */
  batchSize: number;
  /** Reindex threshold (days) */
  reindexThresholdDays: number;
  /** Enable incremental indexing */
  enableIncrementalIndexing: boolean;
}

/**
 * Index status
 */
export interface IndexStatus {
  /** Number of indexed items */
  indexedCount: number;
  /** Last index time */
  lastIndexed?: Date;
  /** Currently indexing count */
  indexingCount: number;
  /** Pending count */
  pendingCount: number;
}

// ==================== Retrieval Configuration ====================

/**
 * Retrieval configuration
 */
export interface RetrievalConfig {
  /** Max results */
  maxResults: number;
  /** Min score threshold */
  minScore: number;
  /** Similarity threshold */
  similarityThreshold: number;
  /** Enable filtering */
  enableFiltering: boolean;
  /** Filter conditions */
  filters?: RetrievalFilter[];
}

/**
 * Retrieval filter condition
 */
export interface RetrievalFilter {
  /** Field name */
  field: string;
  /** Operator */
  operator: 'eq' | 'ne' | 'gt' | 'lt' | 'contains' | 'in';
  /** Value */
  value: unknown;
}

// ==================== Service Status ====================

/**
 * Service status
 */
export interface ServiceStatus {
  /** Database connection status */
  databaseStatus: ConnectionStatus;
  /** Index status */
  indexStatus: IndexStatus;
  /** Ready flag */
  ready: boolean;
  /** Health status */
  healthy: boolean;
}

// ==================== Tool Retrieval Config ====================

/**
 * Tool retrieval service configuration (matches existing interface)
 */
export interface ToolRetrievalConfig {
  /** Vector database path */
  vectorDbPath: string;
  /** Embedding model */
  model: string;
  /** Cache size */
  cacheSize: number;
  /** Vector dimensions */
  dimensions: number;
  /** Similarity threshold */
  similarityThreshold: number;
  /** Max results */
  maxResults: number;
}

// ==================== Tool System Types ====================

/**
 * Tool type enumeration
 */
export enum ToolType {
  SKILL = 'skill',
  MCP = 'mcp',
  BUILTIN = 'builtin'
}

/**
 * Tool error codes
 */
export enum ToolErrorCode {
  VECTOR_DB_ERROR = 'VECTOR_DB_ERROR',
  EMBEDDING_MODEL_ERROR = 'EMBEDDING_MODEL_ERROR',
  SKILL_NOT_FOUND = 'SKILL_NOT_FOUND',
  SKILL_EXECUTION_ERROR = 'SKILL_EXECUTION_ERROR',
  INVALID_CONFIG = 'INVALID_CONFIG'
}

/**
 * Tool error
 */
export class ToolError extends Error {
  code: ToolErrorCode;

  constructor(message: string, code: ToolErrorCode) {
    super(message);
    this.name = 'ToolError';
    this.code = code;
  }
}

/**
 * Skill tool interface (matches existing ToolSystem interface)
 */
export interface SkillTool {
  name: string;
  description: string;
  type?: ToolType;
  tags?: string[];
  version?: string;
  path?: string;
  parameters?: Record<string, unknown>;
  enabled?: boolean;
  level?: number;
  metadata?: Record<string, unknown>;
}

// ==================== Internal Types ====================

/**
 * Internal tools table interface (for LanceDB schema)
 */
export interface ToolsTable {
  id: string;
  name: string;
  description: string;
  tags: string[];
  path?: string;
  version?: string;
  source?: string;
  toolType: 'skill' | 'mcp' | 'builtin';
  metadata: string;
  vector: number[];
  indexedAt: Date;
}

/**
 * Vectorized file data
 */
export interface VectorizedFileData {
  indexedAt: number;
  skillSize: number;
  skillHash: string;
}

/**
 * Embedding input (for internal use)
 */
export interface EmbeddingInput {
  name: string;
  description: string;
  tags: string[];
}

/**
 * Remote embedding input
 */
export interface RemoteEmbeddingInput {
  name: string;
  description: string;
  tags: string[];
}
````

## File: src/services/IdleScheduler.ts
````typescript
/**
 * 闲时调度器（空实现，Playbook功能已移除）

 * 职责:
 * - 监控 CPU 使用率
 * - 在系统空闲时执行任务队列中的任务
 * - 避免影响主业务性能
 *
 * 注意: 此文件保留但 PlaybookTaskQueue 已移除，
 * 调度器不再执行任何任务。
 */

import os from 'os';
import { TaskType, TaskHandler, IdleSchedulerOptions } from '../types/task-queue';
import { logger } from '../utils/logger';

export class IdleScheduler {
  private interval: NodeJS.Timeout | null = null;
  private isRunning: boolean = false;
  private isExecuting: boolean = false;
  private cpuThreshold: number;
  private checkIntervalMs: number;
  private taskHandlers: Map<TaskType, TaskHandler>;

  constructor(options: IdleSchedulerOptions = {}) {
    this.cpuThreshold = options.cpuThreshold ?? 0.3;
    this.checkIntervalMs = options.checkIntervalMs ?? 30000;
    this.taskHandlers = new Map();
    logger.info('[IdleScheduler] Initialized (no-op, Playbook removed)');
  }

  /**
   * 注册任务处理器
   */
  registerHandler(taskType: TaskType, handler: TaskHandler): void {
    this.taskHandlers.set(taskType, handler);
    logger.debug(`[IdleScheduler] Handler registered for task type: ${taskType} (not used)`);
  }

  /**
   * 启动调度器
   */
  start(): void {
    if (this.isRunning) {
      logger.warn('[IdleScheduler] Scheduler is already running');
      return;
    }

    this.isRunning = true;
    logger.info('[IdleScheduler] Started (no-op mode)');
  }

  /**
   * 停止调度器
   */
  stop(): void {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }

    this.isRunning = false;
    logger.info('[IdleScheduler] Stopped');
  }

  /**
   * 手动触发执行（前端调用）
   */
  async triggerManual(limit: number = 10): Promise<number> {
    logger.info('[IdleScheduler] Manual trigger called (no tasks to process)');
    return 0;
  }

  /**
   * 获取调度器状态
   */
  getStatus(): {
    isRunning: boolean;
    isExecuting: boolean;
    cpuThreshold: number;
    checkIntervalMs: number;
    registeredHandlers: TaskType[];
    currentCpuLoad: number;
  } {
    const loadAvg = os.loadavg();
    const cpuCount = os.cpus().length;

    return {
      isRunning: this.isRunning,
      isExecuting: this.isExecuting,
      cpuThreshold: this.cpuThreshold,
      checkIntervalMs: this.checkIntervalMs,
      registeredHandlers: Array.from(this.taskHandlers.keys()),
      currentCpuLoad: loadAvg[0] / cpuCount
    };
  }
}
````

## File: src/services/RedisService.ts
````typescript
import { createClient } from 'redis';
import { logger } from '../utils/logger';
import { ConfigService, RedisConfig } from './ConfigService';

// ⚡️ 优化类型推导
type ClientType = ReturnType<typeof createClient>;

export class RedisService {
  private static instance: RedisService;
  private client: ClientType | null = null;
  private initializing: Promise<ClientType | null> | null = null;

  private constructor() {
    // 构造函数中不预加载配置，保持懒加载特性
    // 配置会在 getClient 时读取（依赖 ConfigService 的内部缓存）
  }

  public static getInstance(): RedisService {
    if (!RedisService.instance) {
      RedisService.instance = new RedisService();
    }
    return RedisService.instance;
  }

  public async getClient(): Promise<ClientType | null> {
    const configService = ConfigService.getInstance();
    const adminConfig = configService.readConfig();
    const redisConfig = adminConfig.redis;

    if (!redisConfig?.enabled) {
      return null;
    }

    // ⚡️ 增加 isOpen 检查更稳妥
    if (this.client && this.client.isOpen) {
      return this.client;
    }

    if (this.initializing) {
      return this.initializing;
    }

    // 开始初始化
    this.initializing = (async () => {
      let client: ClientType | null = null;
      try {
        client = this.createClient(redisConfig);
        if (!client) {
          throw new Error('Failed to create client instance');
        }

        await client.connect();
        
        logger.info('[RedisService] ✅ Redis client connected');
        this.client = client;
        return client;
      } catch (error) {
        logger.error('[RedisService] ❌ Failed to connect to Redis', error);
        
        if (client) {
          try {
            await client.disconnect();
          } catch {
            // ignore disconnect errors
          }
        }
        
        return null;
      } finally {
        this.initializing = null;
      }
    })();

    return this.initializing;
  }

  private createClient(redisConfig: RedisConfig): ClientType | null {
    try {
      // 🛠️ 修复：正确处理 TLS 配置
      // 如果 tls 是对象（包含 ca/cert/key），需要传递给 socket.tls
      // 如果 tls 是 true，则仅开启 TLS
      // 如果 tls 是 false/undefined，则不使用 TLS
      const tlsOptions = redisConfig.tls === true 
        ? true // 仅开启 TLS，使用默认配置
        : (typeof redisConfig.tls === 'object' && redisConfig.tls !== null 
            ? redisConfig.tls 
            : false); // 传递证书对象或 false

      const socketConfig: any = {
        host: redisConfig.host,
        port: redisConfig.port,
        connectTimeout: redisConfig.connectTimeoutMs || 5000,
        keepAlive: 5000,
        // ⚡️ 建议：添加重试策略，防止无限挂起
        reconnectStrategy: (retries: number) => {
          if (retries > 20) {
            return new Error('Redis retry exhausted after 20 attempts');
          }
          // 指数退避，最大 3秒
          return Math.min(retries * 100, 3000);
        }
      };

      // 处理 TLS 配置
      // node-redis v4: socket.tls 可以是 boolean 或 TLS 配置对象
      if (tlsOptions !== false) {
        socketConfig.tls = tlsOptions;
      }

      const client = createClient({
        url: redisConfig.url, // 如果 url 存在，通常会覆盖 socket 中的 host/port
        socket: socketConfig,
        username: redisConfig.username,
        password: redisConfig.password,
        database: redisConfig.db,
        legacyMode: false,
        // ⚠️ 移除 maxRetriesPerRequest 的错误映射
        // maxRetriesPerRequest 在 node-redis 中不是 commandsQueueMaxLength
        // 如果需要控制队列长度，应该使用其他配置项
      });

      client.on('error', (err: any) => {
        // 忽略连接过程中的一些噪音错误，只记录严重的
        logger.error('[RedisService] ⚠️ Redis error event:', err?.message || err);
      });

      client.on('end', () => {
        logger.warn('[RedisService] ⚠️ Redis connection ended');
        this.client = null;
      });

      client.on('reconnecting', () => {
        logger.info('[RedisService] 🔁 Redis reconnecting...');
      });

      return client;
    } catch (error) {
      logger.error('[RedisService] ❌ Failed to create Redis client configuration', error);
      return null;
    }
  }
}
````

## File: src/services/RequestTracker.ts
````typescript
/**
 * RequestTracker - 活动请求生命周期管理
 * 职责：注册、中断、清理活动请求，支持超时自动清理
 *
 * 修复内容：
 * - M-003: 优化清理逻辑确保请求完整中断
 * - 添加等待机制确保 destroy() 等待完成
 */

import { EventEmitter } from "events";
import type { IWebSocketManager } from "../api/websocket/WebSocketManager";
import { logger } from "../utils/logger";

/**
 * 活动请求接口
 */
interface ActiveRequest {
  requestId: string;
  abortController: AbortController;
  startTime: number;
  context?: any;
}

export class RequestTracker extends EventEmitter {
  private activeRequests = new Map<string, ActiveRequest>();
  private cleanupTimer: NodeJS.Timeout | null = null;
  private timeoutMs: number;
  private destroyPromise: Promise<void> | null = null;
  private isDestroying = false;

  constructor(
    private wsManager: IWebSocketManager | null,
    timeoutMs = 300000 // 默认5分钟超时
  ) {
    super();
    this.timeoutMs = timeoutMs;
    this.startCleanupTimer();
  }

  /**
   * 注册请求
   */
  register(requestId: string, abortController: AbortController, context?: any): void {
    if (this.isDestroying) {
      logger.warn(`[RequestTracker] Ignoring register request during destroy: ${requestId}`);
      return;
    }

    this.activeRequests.set(requestId, {
      requestId,
      abortController,
      startTime: Date.now(),
      context,
    });

    this.emit("request:registered", requestId, context);
    logger.debug(
      `[RequestTracker] Registered request: ${requestId} (total: ${this.activeRequests.size})`
    );
  }

  /**
   * 中断请求
   */
  async interrupt(requestId: string): Promise<boolean> {
    if (this.isDestroying) {
      logger.warn(`[RequestTracker] Ignoring interrupt request during destroy: ${requestId}`);
      return false;
    }

    const request = this.activeRequests.get(requestId);
    if (!request) {
      logger.warn(`[RequestTracker] Request not found for interrupt: ${requestId}`);
      return false;
    }

    logger.debug(`[RequestTracker] Interrupting request: ${requestId}`);

    // 触发中断
    request.abortController.abort();

    // 发送事件
    this.emit("request:interrupted", requestId, request);

    // WebSocket通知
    this.notifyWebSocket(requestId, "interrupted", request);

    // 清理请求
    this.cleanup(requestId);

    return true;
  }

  /**
   * 清理单个请求
   */
  cleanup(requestId: string): void {
    const request = this.activeRequests.get(requestId);

    if (request) {
      const duration = Date.now() - request.startTime;
      logger.debug(`[RequestTracker] Cleaning up request: ${requestId} (duration: ${duration}ms)`);

      this.activeRequests.delete(requestId);
      this.emit("request:cleanup", requestId, duration);
    }
  }

  /**
   * 启动定期清理定时器（每分钟检查一次）
   *
   * M-003 修复：优化清理逻辑确保请求完整中断
   */
  private startCleanupTimer(): void {
    // 每分钟检查一次
    this.cleanupTimer = setInterval(async () => {
      if (this.isDestroying) {
        return;
      }

      const now = Date.now();
      let cleanedCount = 0;

      for (const [id, request] of this.activeRequests.entries()) {
        const age = now - request.startTime;

        if (age > this.timeoutMs) {
          logger.warn(`[RequestTracker] Auto-cleaning timeout request: ${id} (age: ${age}ms)`);

          // 确保请求被完整中断
          request.abortController.abort();

          // 等待一小段时间确保中断生效
          await new Promise((resolve) => setTimeout(resolve, 100));

          this.cleanup(id);
          cleanedCount++;
        }
      }

      if (cleanedCount > 0) {
        logger.debug(`[RequestTracker] Cleaned ${cleanedCount} timeout request(s)`);
      }
    }, 60000);

    logger.debug(`[RequestTracker] Cleanup timer started (timeout: ${this.timeoutMs}ms)`);
  }

  /**
   * 停止清理定时器
   */
  stopCleanupTimer(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
      logger.debug("[RequestTracker] Cleanup timer stopped");
    }
  }

  /**
   * 获取活动请求数量
   */
  getCount(): number {
    return this.activeRequests.size;
  }

  /**
   * 🆕 获取活动请求数量（兼容方法）
   */
  getActiveRequestCount(): number {
    return this.activeRequests.size;
  }

  /**
   * 🆕 注销请求（兼容方法）
   */
  unregister(requestId: string): void {
    this.cleanup(requestId);
  }

  /**
   * 检查请求是否存在
   */
  hasRequest(requestId: string): boolean {
    return this.activeRequests.has(requestId);
  }

  /**
   * 获取请求（用于调试）
   */
  getRequest(requestId: string): ActiveRequest | undefined {
    return this.activeRequests.get(requestId);
  }

  /**
   * 获取所有活动请求（用于监控）
   */
  getAllRequests(): Map<string, ActiveRequest> {
    return new Map(this.activeRequests);
  }

  /**
   * WebSocket通知
   */
  private notifyWebSocket(requestId: string, status: string, request: ActiveRequest): void {
    if (!this.wsManager) {
      return;
    }

    try {
      const channel = this.wsManager.getChannel?.("ABPLog");
      if (channel) {
        (channel as any).pushLog?.({
          status,
          content: `请求已${status === "interrupted" ? "中断" : status}: ${requestId}`,
          source: "request_interrupt",
          metadata: {
            requestId,
            timestamp: new Date().toISOString(),
            duration: Date.now() - request.startTime,
            context: request.context,
          },
        });

        logger.debug(`[RequestTracker] Pushed ${status} notification to ABPLog`);
      }
    } catch (wsError) {
      logger.warn(`[RequestTracker] WebSocket push failed (non-critical):`, wsError);
    }
  }

  /**
   * 销毁（清理所有请求和定时器）
   *
   * M-003 修复：添加等待机制确保 destroy() 等待完成
   */
  async destroy(): Promise<void> {
    // 防止重复调用
    if (this.isDestroying) {
      return this.destroyPromise ?? undefined;
    }

    this.isDestroying = true;

    this.destroyPromise = (async () => {
      // 停止定时器
      this.stopCleanupTimer();

      // 中断所有活动请求
      let interruptedCount = 0;
      const requestsToInterrupt = Array.from(this.activeRequests.entries());

      for (const [id, request] of requestsToInterrupt) {
        try {
          request.abortController.abort();
          interruptedCount++;
          this.emit("request:interrupted", id, request);

          // 等待一小段时间确保中断生效
          await new Promise((resolve) => setTimeout(resolve, 50));
        } catch (error) {
          logger.warn(`[RequestTracker] Error interrupting request ${id}:`, error);
        }
      }

      // 清空请求列表
      this.activeRequests.clear();

      logger.info(`[RequestTracker] Destroyed (interrupted ${interruptedCount} active requests)`);

      this.isDestroying = false;
    })();

    return this.destroyPromise;
  }
}
````

## File: src/types/react.ts
````typescript
/**
 * ReAct 引擎类型定义
 * 极简设计：纯 AsyncGenerator，无事件队列和任务池
 */

/**
 * 工具接口
 * 符合 OpenAI Tool 规范
 */
export interface Tool {
  name: string;
  description: string;
  parameters: Record<string, any>;
  execute: (args: any) => Promise<any>;
}

/**
 * ReAct 配置选项
 */
export interface ReActOptions {
  /** 最大迭代次数（默认 50） */
  maxIterations?: number;

  /** 总超时时间（毫秒，默认 5 分钟） */
  timeout?: number;

  /** 是否启用思考流式输出（默认 true） */
  enableThink?: boolean;
}

/**
 * 流式事件类型
 */
export interface StreamEvent {
  type: 'reasoning' | 'content' | 'tool_start' | 'tool_end' | 'error' | 'done';
  data: any;
  timestamp: number;
}
````

## File: src/types/request-abort.ts
````typescript
/**
 * Request Abort Types
 * 
 * 请求中断相关的类型定义
 * 
 * @module types/request-abort
 */

/**
 * 活动请求信息
 */
export interface ActiveRequest {
  /** 请求ID */
  requestId: string;
  
  /** 中断控制器 */
  abortController: AbortController;
  
  /** 请求开始时间 */
  startTime: number;
  
  /** 客户端信息（可选） */
  clientInfo?: {
    ip?: string;
    userAgent?: string;
  };
  
  /** 请求上下文（可选） */
  context?: {
    model?: string;
    messageCount?: number;
  };
}

/**
 * 中断请求体
 */
export interface InterruptRequest {
  /** 要中断的请求ID */
  requestId: string;
  
  /** 中断原因（可选） */
  reason?: string;
}

/**
 * 中断响应
 */
export interface InterruptResponse {
  /** 是否成功 */
  success: boolean;
  
  /** 消息 */
  message: string;
  
  /** 请求ID */
  requestId?: string;
  
  /** 是否已中断 */
  interrupted?: boolean;
  
  /** 部分生成的内容（如有） */
  partialContent?: string;
  
  /** 错误信息（如失败） */
  error?: string;
  
  /** 失败原因 */
  reason?: string;
}

/**
 * 请求清理统计
 */
export interface CleanupStats {
  /** 清理的请求数 */
  cleanedCount: number;
  
  /** 清理时间戳 */
  timestamp: number;
  
  /** 清理原因 */
  reason: 'timeout' | 'manual' | 'shutdown';
}
````

## File: src/utils/config/index.ts
````typescript
/**
 * 配置工具导出
 */

export { ConfigLoader } from "../config-loader";
export { ConfigValidator, type ValidationResult } from "../config-validator";
export { ConfigWriter } from "../config-writer";
export {
  DisclosureConfigLoader,
  getDisclosureConfig,
  getDisclosureConfigAsync,
} from "./disclosure-config";
````

## File: src/utils/config-validator.ts
````typescript
/**
 * 配置验证器
 * 负责验证配置的正确性
 *
 * ACE 功能已删除 (2026-01-11)
 */

import { logger } from "./logger";
import type { AdminConfig } from "../types/config/index";

/**
 * 配置验证结果
 */
export interface ValidationResult {
  /** 是否有效 */
  valid: boolean;
  /** 错误列表 */
  errors: string[];
  /** 警告列表 */
  warnings?: string[];
}

export class ConfigValidator {
  /**
   * 验证完整配置
   */
  public validate(config: AdminConfig): ValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    try {
      // 基础验证
      this.validateAuth(config.auth, errors, warnings);
      this.validateApi(config.api, errors, warnings);

      return {
        valid: errors.length === 0,
        errors,
        warnings: warnings.length > 0 ? warnings : undefined,
      };
    } catch (error) {
      logger.error("配置验证失败:", error);
      return {
        valid: false,
        errors: ["配置验证过程中发生错误"],
      };
    }
  }

  /**
   * 验证认证配置
   */
  private validateAuth(auth: AdminConfig["auth"], errors: string[], warnings: string[]): void {
    if (!auth || typeof auth.enabled !== "boolean") {
      errors.push("auth.enabled 必须是布尔值");
    }

    if (auth?.enabled && !auth?.apiKey) {
      errors.push("启用认证时必须提供 apiKey");
    }
  }

  /**
   * 验证 API 配置
   */
  private validateApi(api: AdminConfig["api"], errors: string[], warnings: string[]): void {
    if (!api || typeof api.port !== "number") {
      errors.push("api.port 必须是数字");
    }

    if (api?.port && (api.port < 1 || api.port > 65535)) {
      errors.push("api.port 必须在 1-65535 范围内");
    }
  }
}
````

## File: src/utils/error-classifier.ts
````typescript
/**
 * 错误分类工具类
 *
 * 用于将原始错误自动分类为 8 种 ErrorType
 * 支持基于错误码、HTTP 状态码、关键词等多种识别方式
 */

import { ErrorType } from "../types/trajectory";

/**
 * 错误分类器
 */
export class ErrorClassifier {
  /**
   * 错误分类核心逻辑
   * @param error 原始错误对象
   * @returns 分类后的错误类型
   */
  static classifyError(error: any): ErrorType {
    // 处理 null/undefined
    if (error == null) {
      return ErrorType.UNKNOWN;
    }

    // 1. 基于错误码分类（最精确）
    if (error.code) {
      const errorCode = String(error.code).toUpperCase();
      switch (errorCode) {
        case "ECONNREFUSED":
        case "ETIMEDOUT":
        case "ENOTFOUND":
        case "ECONNRESET":
        case "EHOSTUNREACH":
          return ErrorType.NETWORK_ERROR;
        case "ENOMEM":
        case "EMFILE":
        case "ENFILE":
          return ErrorType.RESOURCE_EXHAUSTED;
      }
    }

    // 2. 基于 HTTP 状态码（较精确）
    const statusCode = error.status || error.statusCode;
    if (statusCode !== undefined) {
      const status = Number(statusCode);
      switch (status) {
        case 429:
          return ErrorType.RATE_LIMIT;
        case 403:
          return ErrorType.PERMISSION_DENIED;
        case 400:
        case 422:
          return ErrorType.INVALID_INPUT;
        case 401:
          return ErrorType.PERMISSION_DENIED;
        case 404:
          return ErrorType.INVALID_INPUT;
        case 500:
        case 502:
        case 503:
        case 504:
          return ErrorType.NETWORK_ERROR;
      }
    }

    // 3. 业务逻辑错误（自定义错误类型）- 在关键词检查之前
    if (
      error.name === "BusinessError" ||
      error.name === "ValidationError" ||
      error.name === "LogicError"
    ) {
      return ErrorType.LOGIC_ERROR;
    }

    // 4. 基于错误消息关键词（按优先级排序）
    const message = (error.message || error.toString() || "").toLowerCase();

    // 4.1 资源耗尽相关（具体关键词）
    if (
      message.includes("out of memory") ||
      message.includes("heap") ||
      message.includes("allocation failed") ||
      /disk\s+(is\s+)?full/.test(message) || // 匹配 "disk full" 或 "disk is full"
      message.includes("quota exceeded") ||
      message.includes("out of space")
    ) {
      return ErrorType.RESOURCE_EXHAUSTED;
    }

    // 4.2 速率限制相关
    if (message.includes("rate limit") || message.includes("too many requests")) {
      return ErrorType.RATE_LIMIT;
    }

    // 4.3 超时相关
    if (message.includes("timeout") || message.includes("timed out")) {
      return ErrorType.TIMEOUT;
    }

    // 4.4 权限相关
    if (
      message.includes("permission") ||
      message.includes("forbidden") ||
      message.includes("unauthorized") ||
      message.includes("access denied") ||
      message.includes("insufficient privileges")
    ) {
      return ErrorType.PERMISSION_DENIED;
    }

    // 4.5 网络相关
    if (
      message.includes("connection") ||
      message.includes("network") ||
      message.includes("refused") ||
      message.includes("unreachable") ||
      message.includes("dns")
    ) {
      return ErrorType.NETWORK_ERROR;
    }

    // 4.6 输入参数相关（放在最后，避免与业务逻辑冲突）
    if (
      message.includes("invalid") ||
      message.includes("validation") ||
      message.includes("required") ||
      message.includes("missing") ||
      message.includes("bad request") ||
      message.includes("malformed")
    ) {
      return ErrorType.INVALID_INPUT;
    }

    // 4.7 超时相关（补充）
    if (message.includes("exceeded") && !message.includes("rate limit")) {
      return ErrorType.TIMEOUT;
    }

    // 5. 默认未知
    return ErrorType.UNKNOWN;
  }

  /**
   * 估算 Token 数量
   * 简单估算：英文约 4 字符 = 1 token，中文约 2 字符 = 1 token
   * @param text 输入文本
   * @returns 估算的 Token 数量
   */
  static estimateTokens(text: string): number {
    if (!text || typeof text !== "string") {
      return 0;
    }

    // 匹配英文字符（包括数字和空格）
    const englishChars = (text.match(/[a-zA-Z0-9\s]/g) || []).length;

    // 匹配中文字符
    const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;

    // 估算：英文 4 字符/token，中文 2 字符/token
    return Math.ceil(englishChars / 4) + Math.ceil(chineseChars / 2);
  }

  /**
   * 获取错误类型的详细描述
   * @param errorType 错误类型
   * @returns 错误类型描述
   */
  static getErrorTypeDescription(errorType: ErrorType): string {
    switch (errorType) {
      case ErrorType.NETWORK_ERROR:
        return "网络连接失败或服务器无响应";
      case ErrorType.TIMEOUT:
        return "请求超时";
      case ErrorType.RATE_LIMIT:
        return "API 速率限制";
      case ErrorType.INVALID_INPUT:
        return "输入参数错误";
      case ErrorType.LOGIC_ERROR:
        return "业务逻辑错误";
      case ErrorType.RESOURCE_EXHAUSTED:
        return "资源耗尽（内存/磁盘等）";
      case ErrorType.PERMISSION_DENIED:
        return "权限不足";
      case ErrorType.UNKNOWN:
        return "未知错误";
      default:
        return "未知错误类型";
    }
  }

  /**
   * 获取错误类型的自动修复建议
   * @param errorType 错误类型
   * @returns 修复建议
   */
  static getErrorTypeSuggestion(errorType: ErrorType): string {
    switch (errorType) {
      case ErrorType.NETWORK_ERROR:
        return "检查网络连接和服务可用性，考虑添加重试机制";
      case ErrorType.TIMEOUT:
        return "将数据分批处理，每批不超过 100 条，或增加超时时间";
      case ErrorType.RATE_LIMIT:
        return "添加速率限制器，间隔至少 1 秒，或使用队列控制并发";
      case ErrorType.INVALID_INPUT:
        return "增加输入校验逻辑，确保参数格式正确";
      case ErrorType.LOGIC_ERROR:
        return "检查业务逻辑前置条件，确保数据完整性";
      case ErrorType.RESOURCE_EXHAUSTED:
        return "使用流式处理或分块读取，释放不需要的资源";
      case ErrorType.PERMISSION_DENIED:
        return "检查 API Key 或权限配置，确保有足够权限";
      case ErrorType.UNKNOWN:
        return "记录详细日志，人工分析根本原因";
      default:
        return "未知错误类型，建议检查日志";
    }
  }
}
````

## File: src/utils/jwt.ts
````typescript
/**
 * JWT 工具类
 * 用于管理员认证的 JWT token 生成和验证
 */

import * as crypto from 'crypto';
import { logger } from './logger';
import { ConfigService } from '../services/ConfigService';

export interface JWTPayload {
  username: string;
  iat: number; // issued at
  exp: number; // expiration time
}

export interface JWTConfig {
  secret: string;
  expiresIn: number; // seconds
  algorithm?: 'HS256' | 'HS384' | 'HS512';
}

// 默认配置
const DEFAULT_EXPIRES_IN = 7 * 24 * 60 * 60; // 7天
const DEFAULT_ALGORITHM = 'HS256';

/**
 * Base64 URL 安全编码（JWT标准）
 */
function base64UrlEncode(str: string): string {
  return Buffer.from(str)
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}

/**
 * Base64 URL 安全解码
 */
function base64UrlDecode(str: string): string {
  str = str.replace(/-/g, '+').replace(/_/g, '/');
  const padding = (4 - (str.length % 4)) % 4;
  str += '='.repeat(padding);
  return Buffer.from(str, 'base64').toString('utf-8');
}

/**
 * 创建 HMAC 签名
 */
function createSignature(header: string, payload: string, secret: string, algorithm: string): string {
  const signature = crypto
    .createHmac(algorithm.replace('HS', 'sha'), secret)
    .update(`${header}.${payload}`)
    .digest('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
  return signature;
}

/**
 * 验证 HMAC 签名
 */
function verifySignature(header: string, payload: string, signature: string, secret: string, algorithm: string): boolean {
  const expectedSignature = createSignature(header, payload, secret, algorithm);
  // 使用常量时间比较防止时序攻击
  if (signature.length !== expectedSignature.length) {
    return false;
  }
  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expectedSignature));
}

/**
 * 生成 JWT token
 */
export function generateJWT(payload: Omit<JWTPayload, 'iat' | 'exp'>, config: JWTConfig): string {
  const algorithm = config.algorithm || DEFAULT_ALGORITHM;
  const now = Math.floor(Date.now() / 1000);
  const expiresAt = now + (config.expiresIn || DEFAULT_EXPIRES_IN);

  const jwtPayload: JWTPayload = {
    ...payload,
    iat: now,
    exp: expiresAt
  };

  // Header
  const header = {
    alg: algorithm,
    typ: 'JWT'
  };

  // 编码
  const encodedHeader = base64UrlEncode(JSON.stringify(header));
  const encodedPayload = base64UrlEncode(JSON.stringify(jwtPayload));

  // 签名
  const signature = createSignature(encodedHeader, encodedPayload, config.secret, algorithm);

  // 组合成 JWT
  return `${encodedHeader}.${encodedPayload}.${signature}`;
}

/**
 * 验证 JWT token
 */
export function verifyJWT(token: string, config: JWTConfig): { valid: boolean; payload?: JWTPayload; error?: string } {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) {
      return { valid: false, error: 'Invalid token format' };
    }

    const [encodedHeader, encodedPayload, signature] = parts;

    // 解码 header
    const header = JSON.parse(base64UrlDecode(encodedHeader));
    
    // 验证算法
    const algorithm = header.alg || DEFAULT_ALGORITHM;
    if (algorithm !== (config.algorithm || DEFAULT_ALGORITHM)) {
      return { valid: false, error: 'Invalid algorithm' };
    }

    // 验证签名
    const isValidSignature = verifySignature(
      encodedHeader,
      encodedPayload,
      signature,
      config.secret,
      algorithm
    );

    if (!isValidSignature) {
      return { valid: false, error: 'Invalid signature' };
    }

    // 解码 payload
    const payload: JWTPayload = JSON.parse(base64UrlDecode(encodedPayload));

    // 验证过期时间
    const now = Math.floor(Date.now() / 1000);
    if (payload.exp && payload.exp < now) {
      return { valid: false, error: 'Token expired' };
    }

    return { valid: true, payload };
  } catch (error: any) {
    logger.debug('JWT verification error:', error.message);
    return { valid: false, error: error.message || 'Invalid token' };
  }
}

/**
 * 获取或生成 JWT 密钥
 * 从配置中读取，如果没有则生成并保存
 */
export function getOrGenerateJWTSecret(configService: ConfigService): string {
  const config = configService.readConfig();
  
  // 检查配置中是否已有 JWT secret（使用扁平结构：auth.jwtSecret）
  if (config.auth?.jwtSecret) {
    return config.auth.jwtSecret;
  }

  // 生成新的密钥（32字节，base64编码）
  const secret = crypto.randomBytes(32).toString('base64');
  
  // 保存到配置（使用扁平结构）
  configService.updateConfig({
    auth: {
      ...config.auth,
      jwtSecret: secret,
      jwtExpiresIn: `${DEFAULT_EXPIRES_IN}s` // 转换为字符串格式（如 "604800s"）
    }
  });

  logger.info('✅ Generated new JWT secret');
  return secret;
}

/**
 * 获取 JWT 配置
 */
export function getJWTConfig(configService: ConfigService): JWTConfig {
  const config = configService.readConfig();
  const secret = config.auth?.jwtSecret || getOrGenerateJWTSecret(configService);
  
  // 解析 jwtExpiresIn（可能是 "7d", "24h", "604800s" 等格式）
  let expiresIn = DEFAULT_EXPIRES_IN;
  if (config.auth?.jwtExpiresIn) {
    const expiresInStr = config.auth.jwtExpiresIn;
    // 尝试解析字符串格式（如 "7d", "24h", "604800s"）
    const match = expiresInStr.match(/^(\d+)([dhms])?$/);
    if (match) {
      const value = parseInt(match[1], 10);
      const unit = match[2] || 's';
      switch (unit) {
        case 'd':
          expiresIn = value * 24 * 60 * 60;
          break;
        case 'h':
          expiresIn = value * 60 * 60;
          break;
        case 'm':
          expiresIn = value * 60;
          break;
        case 's':
        default:
          expiresIn = value;
          break;
      }
    } else {
      // 如果不是字符串格式，尝试直接解析为数字
      const parsed = parseInt(expiresInStr, 10);
      if (!isNaN(parsed)) {
        expiresIn = parsed;
      }
    }
  }

  return {
    secret,
    expiresIn,
    algorithm: DEFAULT_ALGORITHM // 算法固定为 HS256，配置中不再存储
  };
}
````

## File: src/utils/request-id.ts
````typescript
/**
 * Request ID Generation Utilities
 * 
 * 生成和管理唯一的请求标识符
 * 
 * @module utils/request-id
 */

import * as crypto from 'crypto';

/**
 * 生成唯一的请求ID
 * 
 * 格式: req_{timestamp}_{random}
 * 示例: req_1730296800000_a3f9k2x8b
 * 
 * @returns 唯一的请求ID
 */
export function generateRequestId(): string {
  const timestamp = Date.now();
  // 🛡️ 使用 crypto.randomBytes 保证长度固定且熵值更高
  // 生成 5 字节的随机数据并转为 hex (10字符)，截取前9位
  // 结果必定是 [0-9a-f]，符合 [a-z0-9] 的正则
  const random = crypto.randomBytes(5).toString('hex').substring(0, 9);
  return `req_${timestamp}_${random}`;
}

/**
 * 验证请求ID格式
 * 
 * @param requestId - 待验证的请求ID
 * @returns 是否有效
 */
export function isValidRequestId(requestId: string): boolean {
  if (!requestId || typeof requestId !== 'string') {
    return false;
  }
  
  // 格式: req_{timestamp}_{random}
  const pattern = /^req_\d{13}_[a-z0-9]{9}$/;
  return pattern.test(requestId);
}

/**
 * 从请求ID提取时间戳
 * 
 * @param requestId - 请求ID
 * @returns Unix时间戳（毫秒），如果无效返回null
 */
export function extractTimestamp(requestId: string): number | null {
  // ⚡️ 优化：简单的分割提取，不强制进行完整的正则校验，性能更好
  if (!requestId || !requestId.startsWith('req_')) {
    return null;
  }
  
  const parts = requestId.split('_');
  if (parts.length < 2) {
    return null;
  }
  
  const timestamp = parseInt(parts[1], 10);
  return isNaN(timestamp) ? null : timestamp;
}
````

## File: .repomixignore
````
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
.claude
.vscode
.github
dist
docs
assets
exmples
logs
node_modules
scripts
tests
.env
*.json
**/*.md
````

## File: LICENSE
````
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

Copyright 2025 ApexBridge Team

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
````

## File: src/api/controllers/ModelController.ts
````typescript
/**
 * ModelController - 模型管理 API 控制器
 * 
 * 管理 LLM 模型的 CRUD 操作
 */

import { Request, Response } from 'express';
import { LLMConfigService } from '../../services/LLMConfigService';
import { ModelRegistry } from '../../services/ModelRegistry';
import { CreateModelInput, UpdateModelInput, LLMModelType } from '../../types/llm-models';
import { logger } from '../../utils/logger';

const configService = LLMConfigService.getInstance();
const modelRegistry = ModelRegistry.getInstance();

/**
 * 解析布尔值查询参数
 * 支持多种格式：'true', '1', true, 'TRUE' 等
 * 
 * @param value - 查询参数值
 * @returns 布尔值或 undefined（如果未提供）
 */
function parseBooleanQuery(value: any): boolean | undefined {
  if (value === undefined || value === null) {
    return undefined;
  }
  
  // 处理字符串
  if (typeof value === 'string') {
    const lower = value.toLowerCase().trim();
    return lower === 'true' || lower === '1' || lower === 'yes';
  }
  
  // 处理布尔值
  if (typeof value === 'boolean') {
    return value;
  }
  
  // 处理数字
  if (typeof value === 'number') {
    return value === 1;
  }
  
  return undefined;
}

/**
 * 统一处理服务层错误
 * 将字符串匹配的错误转换为合适的 HTTP 状态码
 * 
 * @param res - Express 响应对象
 * @param error - 错误对象
 * @param action - 操作名称（用于日志）
 * @returns 是否已处理错误
 */
function handleServiceError(res: Response, error: any, action: string): boolean {
  logger.error(`❌ Failed to ${action}:`, error);
  
  const msg = error.message || '';
  
  // 使用字符串匹配（如果 Service 层没有使用 AppError）
  // 注意：这是临时方案，理想情况下 Service 层应该抛出 AppError
  if (msg.includes('not found') || msg.toLowerCase().includes('not found')) {
    res.status(404).json({
      error: 'Resource not found',
      message: error.message
    });
    return true;
  }
  
  if (msg.includes('already exists') || msg.toLowerCase().includes('already exists')) {
    res.status(409).json({
      error: 'Resource already exists',
      message: error.message
    });
    return true;
  }
  
  if (msg.includes('required') || msg.includes('Invalid') || msg.toLowerCase().includes('validation')) {
    res.status(400).json({
      error: 'Validation failed',
      message: error.message
    });
    return true;
  }
  
  // 默认返回 500
  res.status(500).json({
    error: `Failed to ${action}`,
    message: error.message
  });
  return true;
}

/**
 * 列出提供商的所有模型
 * GET /api/llm/providers/:providerId/models
 */
export async function listProviderModels(req: Request, res: Response): Promise<void> {
  try {
    const providerId = parseInt(req.params.providerId, 10);
    
    if (isNaN(providerId)) {
      res.status(400).json({
        error: 'Invalid provider ID',
        message: 'Provider ID must be a number'
      });
      return;
    }

    // 验证提供商存在
    const provider = configService.getProvider(providerId);
    if (!provider) {
      res.status(404).json({
        error: 'Provider not found',
        message: `Provider with id ${providerId} not found`
      });
      return;
    }

    const models = configService.listModels({ providerId });

    res.json({
      success: true,
      provider: {
        id: provider.id,
        provider: provider.provider,
        name: provider.name
      },
      models: models.map(m => ({
        id: m.id,
        modelKey: m.modelKey,
        modelName: m.modelName,
        modelType: m.modelType,
        modelConfig: m.modelConfig,
        apiEndpointSuffix: m.apiEndpointSuffix,
        enabled: m.enabled,
        isDefault: m.isDefault,
        displayOrder: m.displayOrder,
        createdAt: m.createdAt,
        updatedAt: m.updatedAt
      }))
    });
  } catch (error: any) {
    logger.error('❌ Failed to list models:', error);
    res.status(500).json({
      error: 'Failed to list models',
      message: error.message
    });
  }
}

/**
 * 获取模型详情
 * GET /api/llm/providers/:providerId/models/:modelId
 */
export async function getModel(req: Request, res: Response): Promise<void> {
  try {
    const providerId = parseInt(req.params.providerId, 10);
    const modelId = parseInt(req.params.modelId, 10);
    
    if (isNaN(providerId) || isNaN(modelId)) {
      res.status(400).json({
        error: 'Invalid ID',
        message: 'Provider ID and Model ID must be numbers'
      });
      return;
    }

    const model = configService.getModel(modelId);
    
    if (!model || model.providerId !== providerId) {
      res.status(404).json({
        error: 'Model not found',
        message: `Model with id ${modelId} not found for provider ${providerId}`
      });
      return;
    }

    res.json({
      success: true,
      model: {
        id: model.id,
        providerId: model.providerId,
        provider: model.provider,
        providerName: model.providerName,
        modelKey: model.modelKey,
        modelName: model.modelName,
        modelType: model.modelType,
        modelConfig: model.modelConfig,
        apiEndpointSuffix: model.apiEndpointSuffix,
        enabled: model.enabled,
        isDefault: model.isDefault,
        displayOrder: model.displayOrder,
        createdAt: model.createdAt,
        updatedAt: model.updatedAt
      }
    });
  } catch (error: any) {
    logger.error('❌ Failed to get model:', error);
    res.status(500).json({
      error: 'Failed to get model',
      message: error.message
    });
  }
}

/**
 * 创建模型
 * POST /api/llm/providers/:providerId/models
 */
export async function createModel(req: Request, res: Response): Promise<void> {
  try {
    const providerId = parseInt(req.params.providerId, 10);
    
    if (isNaN(providerId)) {
      res.status(400).json({
        error: 'Invalid provider ID',
        message: 'Provider ID must be a number'
      });
      return;
    }

    const input: CreateModelInput = req.body;

    // 基本验证
    if (!input.modelKey || !input.modelName || !input.modelType) {
      res.status(400).json({
        error: 'Missing required fields',
        message: 'modelKey, modelName, and modelType are required'
      });
      return;
    }

    const created = configService.createModel(providerId, input);
    
    // 刷新缓存
    modelRegistry.forceRefresh();

    res.status(201).json({
      success: true,
      message: 'Model created successfully',
      model: {
        id: created.id,
        providerId: created.providerId,
        modelKey: created.modelKey,
        modelName: created.modelName,
        modelType: created.modelType,
        enabled: created.enabled,
        isDefault: created.isDefault,
        createdAt: created.createdAt,
        updatedAt: created.updatedAt
      }
    });
  } catch (error: any) {
    handleServiceError(res, error, 'create model');
  }
}

/**
 * 更新模型
 * PUT /api/llm/providers/:providerId/models/:modelId
 */
export async function updateModel(req: Request, res: Response): Promise<void> {
  try {
    const providerId = parseInt(req.params.providerId, 10);
    const modelId = parseInt(req.params.modelId, 10);
    
    if (isNaN(providerId) || isNaN(modelId)) {
      res.status(400).json({
        error: 'Invalid ID',
        message: 'Provider ID and Model ID must be numbers'
      });
      return;
    }

    const input: UpdateModelInput = req.body;

    if (Object.keys(input).length === 0) {
      res.status(400).json({
        error: 'No updates provided',
        message: 'At least one field must be provided'
      });
      return;
    }

    // 验证模型属于该提供商
    const existing = configService.getModel(modelId);
    if (!existing || existing.providerId !== providerId) {
      res.status(404).json({
        error: 'Model not found',
        message: `Model with id ${modelId} not found for provider ${providerId}`
      });
      return;
    }

    const updated = configService.updateModel(modelId, input);
    
    // 刷新缓存
    modelRegistry.forceRefresh();

    res.json({
      success: true,
      message: 'Model updated successfully',
      model: {
        id: updated.id,
        providerId: updated.providerId,
        modelKey: updated.modelKey,
        modelName: updated.modelName,
        modelType: updated.modelType,
        enabled: updated.enabled,
        isDefault: updated.isDefault,
        updatedAt: updated.updatedAt
      }
    });
  } catch (error: any) {
    handleServiceError(res, error, 'update model');
  }
}

/**
 * 删除模型
 * DELETE /api/llm/providers/:providerId/models/:modelId
 */
export async function deleteModel(req: Request, res: Response): Promise<void> {
  try {
    const providerId = parseInt(req.params.providerId, 10);
    const modelId = parseInt(req.params.modelId, 10);
    
    if (isNaN(providerId) || isNaN(modelId)) {
      res.status(400).json({
        error: 'Invalid ID',
        message: 'Provider ID and Model ID must be numbers'
      });
      return;
    }

    // 验证模型属于该提供商
    const existing = configService.getModel(modelId);
    if (!existing || existing.providerId !== providerId) {
      res.status(404).json({
        error: 'Model not found',
        message: `Model with id ${modelId} not found for provider ${providerId}`
      });
      return;
    }

    configService.deleteModel(modelId);
    
    // 刷新缓存
    modelRegistry.forceRefresh();

    res.json({
      success: true,
      message: 'Model deleted successfully'
    });
  } catch (error: any) {
    handleServiceError(res, error, 'delete model');
  }
}

/**
 * 查询模型（跨提供商）
 * GET /api/llm/models?type=nlp&enabled=true
 */
export async function queryModels(req: Request, res: Response): Promise<void> {
  try {
    const type = req.query.type as string;
    // ⚡️ 优化：更健壮的布尔值解析
    const enabled = parseBooleanQuery(req.query.enabled);
    const isDefault = parseBooleanQuery(req.query.default);

    const params: any = {};
    
    if (type) {
      // 验证模型类型
      if (!Object.values(LLMModelType).includes(type as LLMModelType)) {
        res.status(400).json({
          error: 'Invalid model type',
          message: `Model type must be one of: ${Object.values(LLMModelType).join(', ')}`
        });
        return;
      }
      params.modelType = type as LLMModelType;
    }

    // 只有当值明确为 true 时才设置参数
    if (enabled !== undefined) {
      params.enabled = enabled;
    }

    if (isDefault !== undefined) {
      params.isDefault = isDefault;
    }

    const models = configService.listModels(params);

    res.json({
      success: true,
      count: models.length,
      models: models.map(m => ({
        id: m.id,
        providerId: m.providerId,
        provider: m.provider,
        providerName: m.providerName,
        modelKey: m.modelKey,
        modelName: m.modelName,
        modelType: m.modelType,
        modelConfig: m.modelConfig,
        apiEndpointSuffix: m.apiEndpointSuffix,
        enabled: m.enabled,
        isDefault: m.isDefault,
        displayOrder: m.displayOrder
      }))
    });
  } catch (error: any) {
    logger.error('❌ Failed to query models:', error);
    res.status(500).json({
      error: 'Failed to query models',
      message: error.message
    });
  }
}

/**
 * 获取默认模型
 * GET /api/llm/models/default?type=embedding
 */
export async function getDefaultModel(req: Request, res: Response): Promise<void> {
  try {
    const type = req.query.type as string;

    if (!type) {
      res.status(400).json({
        error: 'Missing type parameter',
        message: 'type query parameter is required'
      });
      return;
    }

    // 验证模型类型
    if (!Object.values(LLMModelType).includes(type as LLMModelType)) {
      res.status(400).json({
        error: 'Invalid model type',
        message: `Model type must be one of: ${Object.values(LLMModelType).join(', ')}`
      });
      return;
    }

    const model = modelRegistry.getDefaultModel(type as LLMModelType);

    if (!model) {
      res.status(404).json({
        error: 'No default model found',
        message: `No default model configured for type: ${type}`
      });
      return;
    }

    res.json({
      success: true,
      model: {
        id: model.id,
        providerId: model.providerId,
        provider: model.provider,
        providerName: model.providerName,
        modelKey: model.modelKey,
        modelName: model.modelName,
        modelType: model.modelType,
        modelConfig: model.modelConfig,
        apiEndpointSuffix: model.apiEndpointSuffix,
        baseConfig: {
          baseURL: model.providerBaseConfig.baseURL,
          timeout: model.providerBaseConfig.timeout,
          maxRetries: model.providerBaseConfig.maxRetries
        }
      }
    });
  } catch (error: any) {
    logger.error('❌ Failed to get default model:', error);
    res.status(500).json({
      error: 'Failed to get default model',
      message: error.message
    });
  }
}
````

## File: src/api/controllers/ProviderController.ts
````typescript
/**
 * ProviderController - 提供商管理 API 控制器
 *
 * 管理 LLM 提供商的 CRUD 操作
 */

import { Request, Response } from "express";
import { LLMConfigService } from "../../services/LLMConfigService";
import { ModelRegistry } from "../../services/ModelRegistry";
import { CreateProviderInput, UpdateProviderInput } from "../../types/llm-models";
import { logger } from "../../utils/logger";
import { LLMAdapterFactory } from "../../core/llm/adapters/LLMAdapterFactory";
import { AppError, isAppError, ErrorCode } from "../../utils/errors";

const configService = LLMConfigService.getInstance();
const modelRegistry = ModelRegistry.getInstance();

/**
 * 统一处理服务层错误
 * 使用类型化错误 (AppError) 处理，替代脆弱的字符串匹配
 *
 * @param res - Express 响应对象
 * @param error - 错误对象
 * @param action - 操作名称（用于日志）
 * @returns 是否已处理错误
 */
function handleServiceError(res: Response, error: any, action: string): boolean {
  logger.error(`❌ Failed to ${action}:`, error);

  // 如果是 AppError，使用类型化的错误处理
  if (isAppError(error)) {
    res.status(error.statusCode).json({
      error: {
        message: error.message,
        code: error.code,
        type: error.type,
        ...(error.details && { details: error.details }),
      },
    });
    return true;
  }

  // 向后兼容：处理非 AppError 的错误（降级到字符串匹配）
  const msg = error?.message || String(error);
  const lowerMsg = msg.toLowerCase();

  if (lowerMsg.includes("not found") || lowerMsg.includes("does not exist")) {
    res.status(404).json({
      error: {
        message: msg,
        code: ErrorCode.NOT_FOUND,
        type: "client_error",
      },
    });
    return true;
  }

  if (lowerMsg.includes("already exists") || lowerMsg.includes("duplicate")) {
    res.status(409).json({
      error: {
        message: msg,
        code: "RESOURCE_CONFLICT",
        type: "client_error",
      },
    });
    return true;
  }

  if (
    lowerMsg.includes("required") ||
    lowerMsg.includes("invalid") ||
    lowerMsg.includes("validation") ||
    lowerMsg.includes("validation failed")
  ) {
    res.status(400).json({
      error: {
        message: msg,
        code: ErrorCode.VALIDATION_ERROR,
        type: "client_error",
      },
    });
    return true;
  }

  if (
    lowerMsg.includes("unauthorized") ||
    lowerMsg.includes("authentication") ||
    lowerMsg.includes("auth failed")
  ) {
    res.status(401).json({
      error: {
        message: msg,
        code: ErrorCode.UNAUTHORIZED,
        type: "client_error",
      },
    });
    return true;
  }

  if (lowerMsg.includes("forbidden") || lowerMsg.includes("permission")) {
    res.status(403).json({
      error: {
        message: msg,
        code: ErrorCode.FORBIDDEN,
        type: "client_error",
      },
    });
    return true;
  }

  // 默认返回 500
  res.status(500).json({
    error: {
      message: msg,
      code: ErrorCode.INTERNAL_ERROR,
      type: "server_error",
    },
  });
  return true;
}

/**
 * 转换为 Provider DTO
 * 统一响应结构，确保所有接口返回格式一致，且绝对安全（脱敏处理）
 *
 * @param provider - 提供商对象
 * @param modelCount - 模型数量（可选，默认 0）
 * @returns 标准化的 Provider DTO
 */
function toProviderDTO(provider: any, modelCount: number = 0) {
  return {
    id: provider.id,
    provider: provider.provider,
    name: provider.name,
    description: provider.description,
    enabled: provider.enabled,
    modelCount: modelCount, // 统一包含模型数量
    baseConfig: {
      // 🛡️ 统一脱敏逻辑，防止未来新增字段时忘记脱敏
      baseURL: provider.baseConfig?.baseURL,
      timeout: provider.baseConfig?.timeout,
      maxRetries: provider.baseConfig?.maxRetries,
      // Explicitly OMIT apiKey - 确保敏感信息不会泄露
    },
    createdAt: provider.createdAt,
    updatedAt: provider.updatedAt,
  };
}

/**
 * 列出所有提供商
 * GET /api/llm/providers
 */
export async function listProviders(req: Request, res: Response): Promise<void> {
  try {
    const providers = configService.listProviders();

    // 为每个提供商添加模型统计，使用统一的 DTO
    const providersWithStats = providers.map((p) => {
      const models = configService.getProviderModels(p.id);
      // ✅ 使用统一 DTO，确保响应结构一致
      return toProviderDTO(p, models.length);
    });

    res.json({
      success: true,
      providers: providersWithStats,
    });
  } catch (error: any) {
    handleServiceError(res, error, "list providers");
  }
}

/**
 * 获取提供商详情
 * GET /api/llm/providers/:id
 */
export async function getProvider(req: Request, res: Response): Promise<void> {
  try {
    const id = parseInt(req.params.id, 10);

    if (isNaN(id)) {
      res.status(400).json({
        error: "Invalid provider ID",
        message: "Provider ID must be a number",
      });
      return;
    }

    const provider = configService.getProvider(id);

    if (!provider) {
      res.status(404).json({
        error: "Provider not found",
        message: `Provider with id ${id} not found`,
      });
      return;
    }

    // 获取该提供商的所有模型
    const models = configService.getProviderModels(id);

    res.json({
      success: true,
      // ✅ 使用统一 DTO，确保响应结构一致
      provider: toProviderDTO(provider, models.length),
    });
  } catch (error: any) {
    handleServiceError(res, error, "get provider");
  }
}

/**
 * 创建提供商
 * POST /api/llm/providers
 */
export async function createProvider(req: Request, res: Response): Promise<void> {
  try {
    const input: CreateProviderInput = req.body;

    // 基本验证
    if (!input.provider || !input.name || !input.baseConfig) {
      res.status(400).json({
        error: "Missing required fields",
        message: "provider, name, and baseConfig are required",
      });
      return;
    }

    const created = configService.createProvider(input);

    // 刷新缓存
    modelRegistry.forceRefresh();

    res.status(201).json({
      success: true,
      message: "Provider created successfully",
      // ✅ 返回完整的、一致的结构（新创建的 Provider 模型数为 0）
      provider: toProviderDTO(created, 0),
    });
  } catch (error: any) {
    handleServiceError(res, error, "create provider");
  }
}

/**
 * 更新提供商
 * PUT /api/llm/providers/:id
 */
export async function updateProvider(req: Request, res: Response): Promise<void> {
  try {
    const id = parseInt(req.params.id, 10);

    if (isNaN(id)) {
      res.status(400).json({
        error: "Invalid provider ID",
        message: "Provider ID must be a number",
      });
      return;
    }

    const input: UpdateProviderInput = req.body;

    if (Object.keys(input).length === 0) {
      res.status(400).json({
        error: "No updates provided",
        message: "At least one field must be provided",
      });
      return;
    }

    const updated = configService.updateProvider(id, input);

    // 刷新缓存
    modelRegistry.forceRefresh();

    // 获取当前模型数以保持一致性
    const models = configService.getProviderModels(id);

    res.json({
      success: true,
      message: "Provider updated successfully",
      // ✅ 返回完整的、一致的结构
      provider: toProviderDTO(updated, models.length),
    });
  } catch (error: any) {
    handleServiceError(res, error, "update provider");
  }
}

/**
 * 删除提供商
 * DELETE /api/llm/providers/:id
 */
export async function deleteProvider(req: Request, res: Response): Promise<void> {
  try {
    const id = parseInt(req.params.id, 10);

    if (isNaN(id)) {
      res.status(400).json({
        error: "Invalid provider ID",
        message: "Provider ID must be a number",
      });
      return;
    }

    configService.deleteProvider(id);

    // 刷新缓存
    modelRegistry.forceRefresh();

    res.json({
      success: true,
      message: "Provider and associated models deleted successfully",
    });
  } catch (error: any) {
    handleServiceError(res, error, "delete provider");
  }
}

/**
 * 获取支持的适配器供应商列表
 * GET /api/llm/providers/adapters
 */
export async function listAdapters(req: Request, res: Response): Promise<void> {
  try {
    const adapters = LLMAdapterFactory.getSupportedAdapters();

    res.json({
      success: true,
      adapters,
    });
  } catch (error: any) {
    logger.error("❌ Failed to list adapters:", error);
    res.status(500).json({
      error: "Failed to list adapters",
      message: error.message,
    });
  }
}

/**
 * 测试LLM提供商连接（仅测试服务商连通性）
 * POST /api/llm/providers/test-connect
 */
export async function testProviderConnection(req: Request, res: Response) {
  try {
    // 1. 直接从 Body 获取配置 (此时数据未入库)
    const { provider, baseConfig } = req.body;

    // 2. 基础校验
    if (!provider || !baseConfig) {
      return res.status(400).json({
        success: false,
        message: "Missing required parameters: provider or baseConfig",
      });
    }

    // 3. 实例化适配器 (使用前端传来的临时配置)
    // 注意：这里不需要 defaultModel，因为我们只测服务连通性
    const adapter = LLMAdapterFactory.create(provider, baseConfig);

    const start = Date.now();

    // 4. 执行核心测试 (拉取模型列表)
    // 这一步能同时验证：网络通畅 + API Key 正确 + BaseURL 正确
    await adapter.getModels();

    // 5. 成功返回
    res.json({
      success: true,
      latency: Date.now() - start,
      message: "连接成功",
      details: {
        provider,
        testedAt: new Date().toISOString(),
      },
    });
  } catch (error: any) {
    // 6. 错误处理与智能提示
    const status = parseErrorStatus(error);
    const hint = getFailureHint(status, req.body.provider, req.body.baseConfig?.baseURL);

    res.status(status).json({
      success: false,
      message: error.message || "Connection failed",
      hint, //这字段可以让前端展示给用户，例如 "请检查 Ollama 是否启动"
    });
  }
}

/**
 * 新增模型前验证模型是否可用（使用临时配置进行测试）
 * POST /api/llm/providers/validate-model
 * 请求体: { provider: "openai", baseConfig: { apiKey: "xxx", baseURL: "xxx" }, model: "gpt-4" }
 */
export async function validateModelBeforeAdd(req: Request, res: Response) {
  const { provider, baseConfig, model } = req.body;

  // 1. 守卫语句：一行代码完成所有必填校验
  if (!provider || !baseConfig || !model) {
    return res
      .status(400)
      .json({ success: false, message: "Missing: provider, baseConfig, or model" });
  }

  try {
    // 2. 实例化 (仅内存操作，无网络请求)
    // 假设 Factory 内部已有简单的 provider 校验，报错会直接抛出进入 catch
    const adapter = LLMAdapterFactory.create(provider, { ...baseConfig, defaultModel: model });

    const start = Date.now();

    // 3. 唯一的网络交互 (Core)
    // 优化：max_tokens=1。只要模型能吐出 1 个字，就证明网络通、Key 对、模型存在。
    // 无需判断返回内容具体是什么，不报错就是成功。
    await adapter.chat([{ role: "user", content: "Hi" }], {
      model,
      max_tokens: 1,
      temperature: 0,
    });

    // 4. 成功返回
    res.json({
      success: true,
      latency: Date.now() - start,
      message: "连接成功",
    });
  } catch (error: any) {
    // 5. 错误收敛：将所有异常统一由辅助函数解析状态码
    const status = parseErrorStatus(error);
    res.status(status).json({ success: false, message: "Connection failed" });
  }
}

// --- 辅助函数：保持主逻辑干净 ---

function parseErrorStatus(error: any): number {
  const msg = error.message?.toLowerCase() || "";
  if (msg.includes("401") || msg.includes("auth")) return 401;
  if (msg.includes("403") || msg.includes("permission")) return 403;
  if (msg.includes("404") || msg.includes("not found")) return 404;
  if (msg.includes("429") || msg.includes("quota")) return 429;
  if (msg.includes("timeout")) return 504;
  return 500;
}

// --- 辅助函数：生成排查建议 (可选) ---
function getFailureHint(status: number, provider: string, url: string = ""): string | undefined {
  if (status === 502) {
    if (provider === "ollama") {
      return "无法连接到 Ollama。请检查：1. Ollama 是否已启动？ 2. 若在 Docker 中，请使用 http://host.docker.internal:11434/v1";
    }
    return "无法连接到服务器，请检查 Base URL 是否正确，或网络是否通畅。";
  }
  if (status === 401) return "鉴权失败，请检查 API Key 是否正确。";
  if (status === 404) return "接口路径错误。请检查 Base URL (通常应以 /v1 结尾)。";
  return undefined;
}
````

## File: src/api/middleware/auditLoggerMiddleware.ts
````typescript
/**
 * Audit Logger Middleware - 简化审计日志中间件
 *
 * 记录API访问日志
 */

import { Request, Response, NextFunction } from 'express';
import { logger } from '../../utils/logger';

export interface AuditLogEvent {
  timestamp: number;
  path: string;
  method: string;
  statusCode: number;
  ip: string;
  userAgent?: string;
  apiKeyId?: string;
  duration?: number;
}

/**
 * 简化的审计日志中间件
 */
export function createAuditLoggerMiddleware(): (req: Request, res: Response, next: NextFunction) => void {
  const startTime = Date.now();

  return (req: Request, res: Response, next: NextFunction) => {
    // 跳过静态资源和健康检查
    const skipPaths = ['/health', '/metrics', '/favicon.ico', '/vite.svg'];
    if (skipPaths.includes(req.path) || /\.(svg|ico|png|jpg|jpeg|gif|css|js|woff|woff2|ttf|eot)$/i.test(req.path)) {
      return next();
    }

    const ip = req.ip || req.socket.remoteAddress || 'unknown';
    const userAgent = req.headers['user-agent'];
    const auth = res.locals.auth as any;
    const apiKeyId = auth?.apiKeyId;

    // 监听响应完成
    res.on('finish', () => {
      const auditEvent: AuditLogEvent = {
        timestamp: Date.now(),
        path: req.path,
        method: req.method,
        statusCode: res.statusCode,
        ip,
        userAgent,
        apiKeyId,
        duration: Date.now() - startTime
      };

      // 记录访问日志
      if (res.statusCode >= 400) {
        logger.warn(`⚠️ API Access Failed: ${req.method} ${req.path}`, auditEvent);
      } else {
        logger.info(`✅ API Access Success: ${req.method} ${req.path}`, auditEvent);
      }
    });

    next();
  };
}

/**
 * 默认审计日志中间件
 */
export const auditLoggerMiddleware = createAuditLoggerMiddleware();
````

## File: src/api/middleware/errorHandler.ts
````typescript
/**
 * ApexBridge (ABP-only) - 统一错误处理中间件
 * 标准化错误响应格式和错误码
 */

import { Request, Response, NextFunction } from "express";
import { logger } from "../../utils/logger";
import { AppError, normalizeError, isAppError } from "../../utils/errors";

export function errorHandler(err: unknown, req: Request, res: Response, next: NextFunction): void {
  // 标准化错误
  const error = normalizeError(err);

  // 记录错误
  logger.error("❌ Error caught by errorHandler:", {
    message: error.message,
    code: error.code,
    statusCode: error.statusCode,
    path: req.path,
    method: req.method,
    ...(process.env.NODE_ENV === "development" && {
      stack: error.stack,
      details: error.details,
    }),
  });

  // 发送标准错误响应
  const response = error.toJSON() as { error: { stack?: string; details?: unknown } };

  // 开发环境下添加堆栈跟踪
  if (process.env.NODE_ENV === "development") {
    response.error.stack = error.stack;
    if (error.details) {
      response.error.details = error.details;
    }
  }

  res.status(error.statusCode).json(response);
}
````

## File: src/api/middleware/securityHeadersMiddleware.ts
````typescript
/**
 * Security Headers Middleware - 安全头中间件
 * 
 * 配置 Helmet.js 安全头，包括 CSP、HSTS、X-Frame-Options 等
 */

import { Request, Response, NextFunction } from 'express';
import helmet from 'helmet';
import { ConfigService } from '../../services/ConfigService';
import { logger } from '../../utils/logger';

export interface SecurityHeadersConfig {
  enabled: boolean;
  csp?: {
    enabled: boolean;
    directives?: Record<string, string[]>;
  };
  hsts?: {
    enabled: boolean;
    maxAge?: number;
    includeSubDomains?: boolean;
    preload?: boolean;
  };
  frameguard?: {
    enabled: boolean;
    action?: 'DENY' | 'SAMEORIGIN';
  };
  contentTypeNosniff?: boolean;
  xssFilter?: boolean;
  referrerPolicy?: string;
  permissionsPolicy?: Record<string, string[]>;
}

/**
 * 创建安全头中间件
 * @param config 安全头配置
 * @returns Express 中间件
 */
export function createSecurityHeadersMiddleware(config?: Partial<SecurityHeadersConfig>): (req: Request, res: Response, next: NextFunction) => void {
  const configService = ConfigService.getInstance();
  const adminConfig = configService.readConfig();

  // 默认配置
  const defaultConfig: SecurityHeadersConfig = {
    enabled: true,
    csp: {
      enabled: true,
      directives: {
        'default-src': ["'self'"],
        'script-src': ["'self'", "'unsafe-inline'", "'unsafe-eval'"], // 允许内联脚本
        'style-src': ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'], // 允许内联样式 + Google Fonts
        'style-src-elem': ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
        'img-src': ["'self'", 'data:', 'https:'], // 允许图片
        'font-src': ["'self'", 'data:', 'https://fonts.gstatic.com'], // 允许字体
        'connect-src': ["'self'", 'ws:', 'wss:'], // 允许 WebSocket 连接
        'frame-ancestors': ["'none'"], // 不允许嵌入
        'base-uri': ["'self'"], // 基础 URI
        'form-action': ["'self'"], // 表单提交
        'frame-src': ["'self'"], // iframe 源
        'object-src': ["'none'"], // 不允许对象
        'upgrade-insecure-requests': [] // 升级不安全请求
      }
    },
    hsts: {
      enabled: true,
      maxAge: 31536000, // 1年
      includeSubDomains: true,
      preload: false
    },
    frameguard: {
      enabled: true,
      action: 'DENY'
    },
    contentTypeNosniff: true,
    xssFilter: true,
    referrerPolicy: 'strict-origin-when-cross-origin',
    permissionsPolicy: {
      'geolocation': [],
      'microphone': [],
      'camera': [],
      'payment': [],
      'usb': []
    }
  };

  // 合并配置
  const securityConfig: SecurityHeadersConfig = {
    ...defaultConfig,
    ...config,
    csp: {
      ...defaultConfig.csp,
      ...config?.csp
    },
    hsts: {
      ...defaultConfig.hsts,
      ...config?.hsts
    },
    frameguard: {
      ...defaultConfig.frameguard,
      ...config?.frameguard
    }
  };

  // 如果禁用，返回空中间件
  if (!securityConfig.enabled) {
    return (req: Request, res: Response, next: NextFunction) => {
      next();
    };
  }

  // 配置 Helmet
  const helmetOptions: any = {
    contentSecurityPolicy: securityConfig.csp?.enabled ? {
      directives: securityConfig.csp.directives as any
    } : false,
    hsts: securityConfig.hsts?.enabled ? {
      maxAge: securityConfig.hsts.maxAge || 31536000,
      includeSubDomains: securityConfig.hsts.includeSubDomains !== false,
      preload: securityConfig.hsts.preload === true
    } : false,
    frameguard: securityConfig.frameguard?.enabled ? {
      action: securityConfig.frameguard.action === 'SAMEORIGIN' ? 'sameorigin' : 'deny'
    } : false,
    noSniff: securityConfig.contentTypeNosniff !== false,
    xssFilter: securityConfig.xssFilter !== false,
    referrerPolicy: {
      policy: securityConfig.referrerPolicy as any || 'strict-origin-when-cross-origin'
    },
    permittedCrossDomainPolicies: {
      permittedPolicies: 'none'
    },
    expectCt: {
      maxAge: 86400, // 24小时
      enforce: true
    },
    crossOriginEmbedderPolicy: false, // 禁用，避免破坏现有功能
    crossOriginOpenerPolicy: {
      policy: 'same-origin'
    },
    crossOriginResourcePolicy: {
      policy: 'cross-origin'
    },
    originAgentCluster: true,
    dnsPrefetchControl: {
      allow: false
    },
    downloadOptions: {
      action: 'deny'
    },
    hidePoweredBy: true,
    ieNoOpen: true,
    permissionsPolicy: securityConfig.permissionsPolicy ? {
      features: securityConfig.permissionsPolicy as any
    } : undefined
  };

  // 创建 Helmet 中间件
  const helmetMiddleware = helmet(helmetOptions);

  // 返回包装后的中间件
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      // 应用 Helmet 中间件
      helmetMiddleware(req, res, () => {
        // 添加自定义安全头
        if (securityConfig.referrerPolicy) {
          res.setHeader('Referrer-Policy', securityConfig.referrerPolicy);
        }

        // 添加 Permissions-Policy 头
        if (securityConfig.permissionsPolicy) {
          const permissionsPolicyValue = Object.entries(securityConfig.permissionsPolicy)
            .map(([feature, allowlist]) => {
              if (allowlist.length === 0) {
                return `${feature}=()`;
              }
              return `${feature}=(${allowlist.join(' ')})`;
            })
            .join(', ');
          res.setHeader('Permissions-Policy', permissionsPolicyValue);
        }

        next();
      });
    } catch (error: any) {
      logger.error('❌ Security headers middleware error:', error);
      next();
    }
  };
}

/**
 * 默认安全头中间件（使用默认配置）
 */
export const securityHeadersMiddleware = createSecurityHeadersMiddleware();
````

## File: src/api/middleware/securityLoggerMiddleware.ts
````typescript
/**
 * Security Logger Middleware - 简化安全日志中间件
 *
 * 记录安全相关事件和错误
 */

import { Request, Response, NextFunction } from 'express';
import { logger } from '../../utils/logger';

export interface SecurityLogEvent {
  timestamp: number;
  method: string;
  path: string;
  statusCode: number;
  duration: number;
  ip: string;
  userAgent?: string;
  apiKey?: string;
  suspicious?: boolean;
  suspiciousReason?: string;
}

/**
 * 创建简化安全日志中间件
 */
export function createSecurityLoggerMiddleware(): (req: Request, res: Response, next: NextFunction) => void {
  return (req: Request, res: Response, next: NextFunction) => {
    const startTime = Date.now();

    // 跳过静态资源和健康检查
    const skipPaths = ['/health', '/metrics', '/favicon.ico', '/vite.svg'];
    if (skipPaths.includes(req.path) || /\.(svg|ico|png|jpg|jpeg|gif|css|js|woff|woff2|ttf|eot)$/i.test(req.path)) {
      return next();
    }

    const ip = req.ip || req.socket.remoteAddress || 'unknown';
    const userAgent = req.headers['user-agent'];
    const apiKey = req.headers['x-api-key'];

    // 监听响应完成
    res.on('finish', () => {
      const duration = Date.now() - startTime;
      const suspiciousReason = detectSuspiciousActivity(req);

      const securityEvent: SecurityLogEvent = {
        timestamp: Date.now(),
        path: req.path,
        method: req.method,
        statusCode: res.statusCode,
        duration,
        ip,
        userAgent,
        apiKey: apiKey ? 'present' : 'absent',
        suspicious: !!suspiciousReason,
        suspiciousReason
      };

      // 记录安全事件
      if (res.statusCode === 429) {
        logger.warn('🚫 Rate limit exceeded', securityEvent);
      } else if (securityEvent.suspicious) {
        logger.warn('⚠️ Suspicious request detected', securityEvent);
      } else if (res.statusCode >= 500) {
        logger.error('❌ Server error', securityEvent);
      } else if (res.statusCode >= 400) {
        logger.warn('⚠️ Client error', securityEvent);
      }
    });

    next();
  };
}

/**
 * 检测可疑活动
 */
function detectSuspiciousActivity(req: Request): string | undefined {
  const suspiciousPatterns = [
    { pattern: /<script/i, reason: 'Possible XSS attempt' },
    { pattern: /union.*select/i, reason: 'Possible SQL injection' },
    { pattern: /\.\.[\\/]/i, reason: 'Possible path traversal' },
    { pattern: /eval\s*\(/i, reason: 'Possible code injection' },
    { pattern: /javascript:/i, reason: 'Possible script injection' }
  ];

  const requestString = JSON.stringify({
    path: req.path,
    method: req.method,
    headers: req.headers,
    query: req.query
  });

  for (const { pattern, reason } of suspiciousPatterns) {
    if (pattern.test(requestString)) {
      return reason;
    }
  }

  return undefined;
}

/**
 * 默认安全日志中间件
 */
export const securityLoggerMiddleware = createSecurityLoggerMiddleware();
````

## File: src/api/middleware/validationMiddleware.ts
````typescript
/**
 * Validation Middleware - 简化验证中间件
 *
 * 基于 AJV 的 JSON Schema 验证，支持自定义格式
 */

import { Request, Response, NextFunction } from "express";
import Ajv, { ErrorObject, AnySchemaObject, ValidateFunction } from "ajv";
import addFormats from "ajv-formats";
import { logger } from "../../utils/logger";

/**
 * 验证中间件选项
 */
export interface ValidationOptions {
  /** 验证目标: 'body' | 'query' | 'params' */
  target?: "body" | "query" | "params";
}

/**
 * 验证模式定义
 */
export interface ValidationSchema {
  body?: AnySchemaObject;
  query?: AnySchemaObject;
  params?: AnySchemaObject;
}

/**
 * 自定义格式注册表
 */
const customFormats = new Map<string, (data: string) => boolean>();

// 创建 AJV 实例
const ajv = new Ajv({
  allErrors: true,
  removeAdditional: true,
  useDefaults: true,
  coerceTypes: true,
});

// 添加格式支持
addFormats(ajv);

/**
 * 格式化验证错误
 */
function formatValidationErrors(errors: ErrorObject[]): string[] {
  if (!errors || errors.length === 0) {
    return [];
  }

  return errors.map((error) => {
    const field = error.instancePath || error.schemaPath || "unknown";
    const message = error.message || "Validation failed";

    switch (error.keyword) {
      case "required":
        return `${field} 缺少必需字段: ${error.params.missingProperty}`;
      case "type":
        return `${field} 类型错误，期望 ${error.params.type}`;
      case "enum":
        return `${field} 值无效，可选值: ${error.params.allowedValues?.join(", ")}`;
      case "format":
        return `${field} 格式错误: ${error.params.format}`;
      case "minimum":
        return `${field} 值太小，最小值: ${error.params.limit}`;
      case "maximum":
        return `${field} 值太大，最大值: ${error.params.limit}`;
      case "minLength":
        return `${field} 长度太短，最小长度: ${error.params.limit}`;
      case "maxLength":
        return `${field} 长度太长，最大长度: ${error.params.limit}`;
      case "pattern":
        return `${field} 格式不匹配模式: ${error.params.pattern}`;
      default:
        return `${field}: ${message}`;
    }
  });
}

/**
 * 创建验证中间件
 */
export function createValidationMiddleware(
  schema: ValidationSchema,
  options: ValidationOptions = {}
): (req: Request, res: Response, next: NextFunction) => void {
  const finalOptions: ValidationOptions = {
    target: "body",
    ...options,
  };

  // 编译验证函数
  const validateFunctions: Record<string, ValidateFunction> = {};

  if (schema.body) {
    validateFunctions.body = ajv.compile(schema.body);
  }
  if (schema.query) {
    validateFunctions.query = ajv.compile(schema.query);
  }
  if (schema.params) {
    validateFunctions.params = ajv.compile(schema.params);
  }

  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const validateFunction = validateFunctions[finalOptions.target || "body"];

      // 如果没有定义验证模式，跳过验证
      if (!validateFunction) {
        next();
        return;
      }

      // 根据目标选择验证数据
      let data: unknown;
      switch (finalOptions.target) {
        case "body":
          data = req.body;
          break;
        case "query":
          data = req.query;
          break;
        case "params":
          data = req.params;
          break;
        default:
          res.status(500).json({
            error: "Validation Error",
            message: "Invalid validation target",
          });
          return;
      }

      // 执行验证
      const isValid = validateFunction(data);

      if (!isValid) {
        const errors = formatValidationErrors(validateFunction.errors || []);
        res.status(400).json({
          error: "Validation Error",
          message: "请求参数验证失败",
          details: errors,
        });
        return;
      }

      next();
    } catch (error) {
      logger.error("Validation middleware error:", error);
      res.status(500).json({
        error: "Validation Error",
        message: "验证过程中发生错误",
      });
    }
  };
}

/**
 * 添加自定义格式
 */
export function addCustomFormat(
  name: string,
  format: { validate: (data: string) => boolean }
): void {
  customFormats.set(name, format.validate);
  ajv.addFormat(name, format.validate);
}
````

## File: src/api/utils/stream-parser.ts
````typescript
/**
 * 流式输出解析器
 * 处理LLM返回的嵌套JSON格式，提取推理内容和输出内容
 */

/**
 * 解析LLM的chunk内容（支持嵌套JSON）
 * LLM返回格式：{"content":"{\\"reasoning_content\\":\\"\\n\\"}"}
 * 或 {"content":"输出"} 或 {"reasoning_content":"。","content":null}
 *
 * @param chunkContent chunk中的content字符串
 * @returns 解析结果 { isReasoning: boolean, content: string }
 */
export function parseLLMChunk(chunkContent: string): { isReasoning: boolean; content: string } {
  try {
    // 第一次解析：尝试解析外层的JSON
    const parsed = JSON.parse(chunkContent);

    // 如果包含嵌套JSON字符串（如glm-4的格式）
    if (parsed.content && typeof parsed.content === 'string' && parsed.content.includes('{"')) {
      try {
        // 第二次解析：解析内层JSON
        const nested = JSON.parse(parsed.content);
        
        // 优先判断内层是否有reasoning_content
        if (nested.reasoning_content !== undefined && nested.reasoning_content !== null) {
          return { isReasoning: true, content: nested.reasoning_content };
        }
        if (nested.content !== undefined && nested.content !== null) {
          return { isReasoning: false, content: nested.content };
        }
      } catch {
        // 内层解析失败，使用外层content作为普通文本
        return { isReasoning: false, content: parsed.content };
      }
    }

    // 处理非嵌套格式（如直接返回的JSON）
    if (parsed.reasoning_content !== undefined && parsed.reasoning_content !== null) {
      return { isReasoning: true, content: parsed.reasoning_content };
    }
    
    if (parsed.content !== undefined && parsed.content !== null) {
      return { isReasoning: false, content: parsed.content };
    }

    // 未知格式，返回原字符串
    return { isReasoning: false, content: chunkContent };
  } catch (error) {
    // JSON解析失败，说明是纯文本内容
    return { isReasoning: false, content: chunkContent };
  }
}

/**
 * 解析聚合的LLM输出（用于对话历史存储）
 * 支持格式：
 * - {"reasoning_content":"思考","content":"输出"}
 * - {"reasoning_content":"思考"}{"content":"输出"}
 * - 普通文本和代码片段
 *
 * @param rawContent 收集的原始内容（可能包含多个JSON）
 * @returns 解析后的内容对象 { reasoning: string, content: string }
 */
export function parseAggregatedContent(rawContent: string): {
  reasoning: string;
  content: string;
} {
  const reasoningParts: string[] = [];
  const contentParts: string[] = [];

  // 改进的正则：匹配完整的JSON对象，支持两个键值对和null值
  // 支持格式：{"key":"value"} 或 {"key1":"val1","key2":null}
  const jsonPattern = /\{(?:"(?:content|reasoning_content)":(?:"(?:[^"\\]|\\.)*"|null)(?:,(?:"(?:content|reasoning_content)":(?:"(?:[^"\\]|\\.)*"|null)))?)\}/g;

  let lastIndex = 0;
  let match: RegExpExecArray | null;

  while ((match = jsonPattern.exec(rawContent)) !== null) {
    // 添加JSON之间的内容（代码或普通文本）
    const betweenContent = rawContent.slice(lastIndex, match.index);
    if (betweenContent) {
      contentParts.push(betweenContent);
    }

    // 解析JSON，提取内容
    const parsed = parseLLMChunk(match[0]);
    if (parsed.isReasoning) {
      reasoningParts.push(parsed.content);
    } else {
      contentParts.push(parsed.content);
    }

    lastIndex = jsonPattern.lastIndex;
  }

  // 处理剩余内容
  const remainingContent = rawContent.slice(lastIndex);
  if (remainingContent) {
    contentParts.push(remainingContent);
  }

  return {
    reasoning: reasoningParts.join(''),
    content: contentParts.join('')
  };
}

/**
 * 构建前端渲染格式的内容
 * 推理内容包裹在<thinking>标签中
 */
export function buildFrontendContent(content: string, isReasoning: boolean): string {
  return isReasoning ? `<thinking>${content}</thinking>` : content;
}

/**
 * 批量处理LLM输出，分离推理历史和对话历史
 */
export function splitLLMOutput(chunks: string[]): {
  reasoningHistory: string[];
  contentHistory: string[];
} {
  const reasoningHistory: string[] = [];
  const contentHistory: string[] = [];

  for (const chunk of chunks) {
    const parsed = parseLLMChunk(chunk);
    if (parsed.isReasoning) {
      reasoningHistory.push(parsed.content);
    } else {
      contentHistory.push(parsed.content);
    }
  }

  return { reasoningHistory, contentHistory };
}
````

## File: src/api/validators/chat-request-validator.ts
````typescript
/**
 * Chat请求验证器
 * 纯函数式验证，无状态，易于测试
 */

import type { Message, ChatOptions, ToolDefinition } from '../../types';

/**
 * OpenAI标准聊天参数白名单
 */
const STANDARD_CHAT_PARAMS = new Set([
  'model', 'temperature', 'max_tokens', 'top_p',
  'frequency_penalty', 'presence_penalty',
  'stop', 'n', 'stream', 'user', 'top_k', 'user_prompt'
]);

/**
 * Self-Thinking配置接口
 */
export interface SelfThinkingConfig {
  enabled: boolean;
  maxIterations?: number;
  includeThoughtsInResponse?: boolean;
  systemPrompt?: string;
  additionalPrompts?: string[];
  tools?: ToolDefinition[];
  enableStreamThoughts?: boolean;
}

/**
 * 验证结果接口
 */
export interface ValidationResult<T> {
  success: boolean;
  data?: T;
  error?: string;
}

/**
 * 解析并验证Chat请求
 * @param body 请求体
 * @returns 验证结果
 */
export function parseChatRequest(body: any): ValidationResult<ChatRequestOptions> {
  try {
    // 验证messages格式
    const messages = body.messages;
    if (!messages || !Array.isArray(messages)) {
      return { success: false, error: 'messages must be a non-empty array' };
    }

    if (messages.length === 0) {
      return { success: false, error: 'messages array cannot be empty' };
    }

    // 验证每条消息的格式
    for (const msg of messages) {
      if (!msg.role || !['system', 'user', 'assistant'].includes(msg.role)) {
        return { success: false, error: `Invalid message role: ${msg.role}` };
      }

      // 验证content格式：支持string或ContentPart[]
      if (typeof msg.content === 'string') {
        // 文本内容
        if (msg.content.length === 0) {
          return { success: false, error: 'message content cannot be empty' };
        }
      } else if (Array.isArray(msg.content)) {
        // 多模态内容
        if (msg.content.length === 0) {
          return { success: false, error: 'message content array cannot be empty' };
        }

        // 验证每个ContentPart
        for (const part of msg.content) {
          if (!part.type || !['text', 'image_url'].includes(part.type)) {
            return { success: false, error: `Invalid content part type: ${part.type}` };
          }

          if (part.type === 'text') {
            if (typeof part.text !== 'string' || part.text.length === 0) {
              return { success: false, error: 'text part must have non-empty text' };
            }
          } else if (part.type === 'image_url') {
            if (!part.image_url) {
              return { success: false, error: 'image_url part must have image_url' };
            }
          }
        }
      } else {
        return { success: false, error: 'message content must be a string or array' };
      }
    }

    // 提取白名单参数
    const options: ChatRequestOptions = {
      provider: body.provider,
      model: body.model
    };

    for (const key of STANDARD_CHAT_PARAMS) {
      if (key in body && key !== 'provider' && key !== 'model') {
        (options as any)[key] = body[key];
      }
    }

    // 确保stream是布尔值
    options.stream = options.stream === true;

    // 提取userId
    options.userId = body.user_id || body.user;

    // 提取agentId
    options.agentId = body.agent_id || body.agentId ||
                      (typeof body.apexMeta === 'object' ? body.apexMeta?.agentId : undefined);

    // 提取或生成conversationId
    options.conversationId = body.conversation_id || body.conversationId ||
                            (typeof body.apexMeta === 'object' ? body.apexMeta?.conversationId : undefined);

    if (!options.conversationId) {
      options.conversationId = generateConversationId();
    }

    // 验证selfThinking配置
    if (body.selfThinking) {
      const result = validateSelfThinking(body.selfThinking);
      if (!result.success) {
        return result;
      }
      options.selfThinking = result.data;
    }

    return { success: true, data: options };

  } catch (error: any) {
    return { success: false, error: error.message || 'Failed to parse chat request' };
  }
}

/**
 * 验证Self-Thinking配置
 * @param selfThinking 配置对象
 * @returns 验证结果
 */
export function validateSelfThinking(selfThinking: any): ValidationResult<SelfThinkingConfig> {
  try {
    // enabled必须是boolean
    if (typeof selfThinking.enabled !== 'boolean') {
      return { success: false, error: 'selfThinking.enabled must be a boolean' };
    }

    const config: SelfThinkingConfig = {
      enabled: selfThinking.enabled
    };

    // maxIterations必须是正整数（如果提供）
    if (selfThinking.maxIterations !== undefined) {
      if (typeof selfThinking.maxIterations !== 'number' || selfThinking.maxIterations < 1) {
        return { success: false, error: 'selfThinking.maxIterations must be a positive integer' };
      }
      config.maxIterations = selfThinking.maxIterations;
    }

    // includeThoughtsInResponse必须是boolean（如果提供）
    if (selfThinking.includeThoughtsInResponse !== undefined) {
      if (typeof selfThinking.includeThoughtsInResponse !== 'boolean') {
        return { success: false, error: 'selfThinking.includeThoughtsInResponse must be a boolean' };
      }
      config.includeThoughtsInResponse = selfThinking.includeThoughtsInResponse;
    }

    // enableStreamThoughts必须是boolean（如果提供）
    if (selfThinking.enableStreamThoughts !== undefined) {
      if (typeof selfThinking.enableStreamThoughts !== 'boolean') {
        return { success: false, error: 'selfThinking.enableStreamThoughts must be a boolean' };
      }
      config.enableStreamThoughts = selfThinking.enableStreamThoughts;
    }

    // systemPrompt必须是string（如果提供）
    if (selfThinking.systemPrompt !== undefined) {
      if (typeof selfThinking.systemPrompt !== 'string') {
        return { success: false, error: 'selfThinking.systemPrompt must be a string' };
      }
      config.systemPrompt = selfThinking.systemPrompt;
    }

    // additionalPrompts必须是string数组（如果提供）
    if (selfThinking.additionalPrompts !== undefined) {
      if (!Array.isArray(selfThinking.additionalPrompts) ||
          !selfThinking.additionalPrompts.every(p => typeof p === 'string')) {
        return { success: false, error: 'selfThinking.additionalPrompts must be an array of strings' };
      }
      config.additionalPrompts = selfThinking.additionalPrompts;
    }

    // tools验证
    if (selfThinking.tools !== undefined) {
      if (!Array.isArray(selfThinking.tools)) {
        return { success: false, error: 'selfThinking.tools must be an array' };
      }

      for (const tool of selfThinking.tools) {
        if (!tool.name || typeof tool.name !== 'string') {
          return { success: false, error: 'Each tool must have a name (string)' };
        }
        if (!tool.description || typeof tool.description !== 'string') {
          return { success: false, error: `Tool ${tool.name} must have a description (string)` };
        }
      }

      config.tools = selfThinking.tools;
    }

    return { success: true, data: config };

  } catch (error: any) {
    return { success: false, error: error.message || 'Failed to validate selfThinking config' };
  }
}

/**
 * 生成Conversation ID
 * @returns 格式化的ID
 */
export function generateConversationId(): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 11);
  return `conv_${timestamp}_${random}`;
}

/**
 * Chat请求选项接口
 */
export interface ChatRequestOptions {
  provider?: string;
  model?: string;
  temperature?: number;
  max_tokens?: number;
  top_p?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
  stop?: string[];
  n?: number;
  stream?: boolean;
  user?: string;
  top_k?: number;
  agentId?: string;
  userId?: string;
  conversationId?: string;
  selfThinking?: SelfThinkingConfig;
  [key: string]: any;
}
````

## File: src/config/index.ts
````typescript
/**
 * ApexBridge (ABP-only) - 配置管理
 * 
 * 注意：已完全取消.env配置读取，所有配置从JSON文件（config/admin-config.json）读取
 */

import { } from '../types';
import { ConfigService } from '../services/ConfigService';
import { logger } from '../utils/logger';

// ConfigService实例（单例）
const configService = ConfigService.getInstance();

/**
 * 加载配置（从JSON文件读取）
 */
export function loadConfig() {
  try {
    // 从ConfigService读取配置
    const adminConfig = configService.readConfig();
    
    logger.debug('✅ Configuration loaded from JSON file');
    return adminConfig;
  } catch (error: any) {
    logger.error('❌ Failed to load config from JSON file:', error);
    throw new Error(`Configuration loading failed: ${error.message}`);
  }
}

/**
 * 验证配置
 * 如果设置未完成，跳过严格验证（允许系统启动进入设置向导）
 */
export function validateConfig(): void {
  const adminConfig = configService.readConfig();
  
  // 如果设置未完成，允许配置不完整（系统将引导用户完成设置）
  if (!adminConfig.setup_completed) {
    logger.debug('⚠️ Setup not completed, skipping strict validation');
    return; // 跳过验证，允许系统启动
  }
  
  // 设置完成后，进行严格验证
  const validation = configService.validateConfig(adminConfig);
  
  if (!validation.valid) {
    throw new Error(`Configuration errors:\n${validation.errors.join('\n')}`);
  }
}

/**
 * 检查首次启动状态
 */
export function isSetupCompleted(): boolean {
  return configService.isSetupCompleted();
}
````

## File: src/core/llm/adapters/ClaudeAdapter.ts
````typescript
/**
 * Claude适配器（Anthropic API）
 */

import axios, { AxiosInstance } from 'axios';
import { Message, ChatOptions, LLMResponse, LLMProviderConfig } from '../../../types';
import { logger } from '../../../utils/logger';
import { retry, RetryConfig } from '../../../utils/retry';
import { ILLMAdapter } from './BaseAdapter';

export class ClaudeAdapter implements ILLMAdapter {
  private client: AxiosInstance;

  constructor(private config: LLMProviderConfig) {
    this.client = axios.create({
      baseURL: this.config.baseURL,
      headers: {
        'x-api-key': this.config.apiKey || '',
        'anthropic-version': '2023-06-01',
        'Content-Type': 'application/json'
      },
      timeout: this.config.timeout || 60000
    });

    logger.debug(`Claude adapter initialized (${this.config.baseURL})`);
  }

  async chat(messages: Message[], options: ChatOptions, signal?: AbortSignal): Promise<LLMResponse> {
    const maxRetries = this.config.maxRetries || 3;
    const retryConfig: RetryConfig = {
      maxRetries,
      initialDelay: 1000,
      maxDelay: 10000,
      backoffMultiplier: 2,
      retryOn4xx: false,
      shouldRetry: (error: any) => {
        if (signal?.aborted || error.name === 'AbortError' || error.code === 'ERR_CANCELED') {
          return false;
        }
        if (error.response?.status === 400 || error.response?.status === 401 ||
            error.response?.status === 403 || error.response?.status === 404) {
          return false;
        }
        return true;
      }
    };

    return retry(async () => {
      try {
        const systemMessages = messages.filter(m => m.role === 'system');
        const otherMessages = messages.filter(m => m.role !== 'system');

        const response = await this.client.post('/messages', {
          model: options.model || this.config.defaultModel,
          max_tokens: options.max_tokens || 4096,
          temperature: options.temperature ?? 0.7,
          system: systemMessages.map(m => m.content).join('\n\n') || undefined,
          messages: otherMessages.map(m => ({
            role: m.role === 'assistant' ? 'assistant' : 'user',
            content: m.content
          })),
          stream: false
        }, {
          signal
        });

        // 转换为OpenAI格式
        return {
          id: response.data.id,
          object: 'chat.completion',
          created: Math.floor(Date.now() / 1000),
          model: response.data.model,
          choices: [{
            index: 0,
            message: {
              role: 'assistant',
              content: response.data.content[0]?.text || ''
            },
            finish_reason: response.data.stop_reason
          }]
        };
      } catch (error: any) {
        if (signal?.aborted || error.name === 'AbortError' || error.code === 'ERR_CANCELED') {
          throw error;
        }

        logger.error('❌ Claude chat error:', error.message);
        throw new Error(`Claude request failed: ${error.message}`);
      }
    }, retryConfig);
  }

  async *streamChat(messages: Message[], options: ChatOptions, tools?: any[], signal?: AbortSignal): AsyncIterableIterator<string> {
    try {
      const systemMessages = messages.filter(m => m.role === 'system');
      const otherMessages = messages.filter(m => m.role !== 'system');

      // 构建请求体
      const requestBody: any = {
        model: options.model || this.config.defaultModel,
        max_tokens: options.max_tokens || 4096,
        temperature: options.temperature ?? 0.7,
        system: systemMessages.map(m => m.content).join('\n\n') || undefined,
        messages: otherMessages.map(m => ({
          role: m.role === 'assistant' ? 'assistant' : 'user',
          content: m.content
        })),
        stream: true
      };

      // Claude目前不直接支持tools参数，需要特殊处理
      // 将工具描述添加到system message中
      if (tools && tools.length > 0) {
        const toolsDescription = tools.map((tool: any) => {
          const func = tool.function || {};
          return `
## Tool: ${func.name}
Description: ${func.description}
Parameters: ${JSON.stringify(func.parameters, null, 2)}
`;
        }).join('\n');

        if (requestBody.system) {
          requestBody.system += `\n\n# Available Tools\n${toolsDescription}`;
        } else {
          requestBody.system = `# Available Tools\n${toolsDescription}`;
        }
      }

      const response = await this.client.post('/messages', requestBody, {
        responseType: 'stream',
        signal
      });

      for await (const chunk of response.data) {
        const lines = chunk.toString().split('\n').filter((line: string) => line.trim());

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.substring(6);

            try {
              const parsed = JSON.parse(data);

              if (parsed.type === 'content_block_delta') {
                const content = parsed.delta?.text;
                if (content) {
                  yield content;
                }
              }
            } catch (e) {
              // Skip parse errors
            }
          }
        }
      }
    } catch (error: any) {
      logger.error('❌ Claude stream error:', error.message);
      throw new Error(`Claude stream request failed: ${error.message}`);
    }
  }

  async getModels(): Promise<string[]> {
    // Claude不提供模型列表API，返回常用模型
    return [
      'claude-3-5-sonnet-20241022',
      'claude-3-5-haiku-20241022',
      'claude-3-opus-20240229',
      'claude-3-sonnet-20240229',
      'claude-3-haiku-20240307'
    ];
  }
}
````

## File: src/core/llm/adapters/LLMAdapterFactory.ts
````typescript
/**
 * LLM适配器工厂
 * 根据provider字段创建对应的适配器实例
 */

import { ILLMAdapter } from './BaseAdapter';
import { LLMProviderConfig } from '../../../types';
import { OpenAIAdapter } from './OpenAIAdapter';
import { DeepSeekAdapter } from './DeepSeekAdapter';
import { ZhipuAdapter } from './ZhipuAdapter';
import { ClaudeAdapter } from './ClaudeAdapter';
import { OllamaAdapter } from './OllamaAdapter';
import { CustomAdapter } from './CustomAdapter';
import { logger } from '../../../utils/logger';

export class LLMAdapterFactory {
  /**
   * 供应商名称映射表
   */
  private static readonly PROVIDER_NAMES: Record<string, string> = {
    openai: 'OpenAI',
    deepseek: 'DeepSeek',
    zhipu: '智谱AI',
    claude: 'Claude',
    ollama: 'Ollama',
    custom: 'Custom'
  };

  /**
   * 供应商默认 baseURL 映射表
   */
  private static readonly PROVIDER_DEFAULT_BASEURLS: Record<string, string> = {
    openai: 'https://api.openai.com/v1',
    deepseek: 'https://api.deepseek.com/v1',
    zhipu: 'https://open.bigmodel.cn/api/paas/v4',
    claude: 'https://api.anthropic.com/v1',
    ollama: 'http://localhost:11434',
    custom: 'https://api.openai.com/v1' // Custom 默认使用 OpenAI 格式
  };

  /**
   * 根据provider创建适配器
   */
  static create(provider: string, config: LLMProviderConfig): ILLMAdapter {
    switch (provider.toLowerCase()) {
      case 'openai':
        return new OpenAIAdapter(config);
      case 'deepseek':
        return new DeepSeekAdapter(config);
      case 'zhipu':
        return new ZhipuAdapter(config);
      case 'claude':
        return new ClaudeAdapter(config);
      case 'ollama':
        return new OllamaAdapter(config);
      case 'custom':
        return new CustomAdapter(config);
      default:
        logger.error(`Unknown provider: ${provider}`);
        throw new Error(`Unknown provider: ${provider}. Supported providers: openai, deepseek, zhipu, claude, ollama, custom`);
    }
  }

  /**
   * 获取支持的provider列表
   */
  static getSupportedProviders(): string[] {
    return ['openai', 'deepseek', 'zhipu', 'claude', 'ollama', 'custom'];
  }

  /**
   * 获取支持的适配器供应商列表（包含显示名称和默认baseURL）
   */
  static getSupportedAdapters(): Array<{name: string, provider: string, defaultBaseURL: string}> {
    return Object.entries(this.PROVIDER_NAMES).map(([provider, name]) => ({
      name,
      provider,
      defaultBaseURL: this.PROVIDER_DEFAULT_BASEURLS[provider] || ''
    }));
  }
}
````

## File: src/core/stream-orchestrator/LLMAdapter.ts
````typescript
import { LLMManager } from '../LLMManager';
import type { LLMAdapter, LLMOptions } from './types';
import { logger } from '../../utils/logger';

/**
 * LLMManager适配器
 * 将LLMManager适配为LLMAdapter接口
 *
 * 负责将 LLMManager 返回的 JSON 字符串格式转换为 ReActEngine 期望的事件格式
 */
export class LLMManagerAdapter implements LLMAdapter {
  private llmManager: LLMManager;

  constructor(llmManager: LLMManager) {
    this.llmManager = llmManager;
  }

  async *streamChat(
    messages: any[],
    options?: LLMOptions,
    tools?: any[],
    signal?: AbortSignal
  ): AsyncGenerator<any, void, void> {
    const stream = this.llmManager.streamChat(messages, options || {}, signal);

    for await (const chunk of stream) {
      // BaseAdapter.streamChat 返回的是 JSON 字符串
      // 格式: {"reasoning_content": "...", "content": "...", "tool_calls": [...]}
      if (typeof chunk === 'string') {
        try {
          const parsed = JSON.parse(chunk);

          // 处理深度思考内容
          if (parsed.reasoning_content) {
            yield { type: 'reasoning', content: parsed.reasoning_content };
          }

          // 处理普通内容
          if (parsed.content) {
            yield { type: 'content', content: parsed.content };
          }

          // 处理工具调用
          if (parsed.tool_calls && parsed.tool_calls.length > 0) {
            yield { type: 'tool_calls', tool_calls: parsed.tool_calls };
          }
        } catch (e) {
          // JSON 解析失败，可能是普通文本
          logger.debug('[LLMManagerAdapter] Failed to parse chunk as JSON, treating as content:', chunk.substring(0, 100));
          yield { type: 'content', content: chunk };
        }
      } else {
        // 已经是对象格式，直接返回
        yield chunk;
      }
    }
  }
}
````

## File: src/core/tool/registry.ts
````typescript
/**
 * Tool Registry - 工具注册表
 * 管理工具的注册、注销和查询
 */

import { Tool } from "./tool";

/**
 * 工具类型枚举
 */
export enum ToolType {
  BUILTIN = "builtin",
  SKILL = "skill",
  MCP = "mcp",
}

/**
 * 工具状态枚举
 */
export enum ToolStatus {
  HEALTHY = "healthy",
  UNHEALTHY = "unhealthy",
  UNKNOWN = "unknown",
}

/**
 * 工具信息接口（用于 ToolDispatcher 兼容）
 */
export interface ToolInfo {
  /** 工具ID */
  id: string;
  /** 工具描述 */
  description: string;
  /** 参数模式 */
  parameters?: {
    type: "object";
    properties: Record<string, any>;
    required?: string[];
  };
  /** 执行函数 */
  execute: (args: Record<string, unknown>) => Promise<{
    output: string;
    metadata?: Record<string, any>;
  }>;
}

/**
 * 注册工具项（带类型信息和状态）
 */
interface RegisteredTool extends Tool.Info {
  type: ToolType;
  registeredAt: Date;
  status: ToolStatus;
  lastError?: string;
  lastCheckAt?: Date;
}

/**
 * 工具注册表
 * 提供工具的注册、注销、查询等生命周期管理功能
 */
export class ToolRegistry {
  private tools: Map<string, RegisteredTool> = new Map();
  private simpleTools: Map<string, ToolInfo> = new Map();

  /**
   * 注册工具
   * @param tool - 工具定义
   */
  async register(tool: Tool.Info, type: ToolType): Promise<void> {
    const existingTool = this.tools.get(tool.id);

    this.tools.set(tool.id, {
      ...tool,
      type,
      status: existingTool?.status ?? ToolStatus.UNKNOWN,
      registeredAt: existingTool?.registeredAt ?? new Date(),
    });
  }

  /**
   * 更新工具状态
   * @param id - 工具 ID
   * @param status - 新状态
   * @param error - 错误信息（如果状态为 unhealthy）
   */
  async updateStatus(id: string, status: ToolStatus, error?: string): Promise<boolean> {
    const tool = this.tools.get(id);
    if (!tool) {
      return false;
    }

    this.tools.set(id, {
      ...tool,
      status,
      lastError: status === ToolStatus.UNHEALTHY ? error : undefined,
      lastCheckAt: new Date(),
    });
    return true;
  }

  /**
   * 检查工具健康状态
   * @param id - 工具 ID
   * @returns 工具是否健康
   */
  async isHealthy(id: string): Promise<boolean> {
    const tool = this.tools.get(id);
    return tool?.status === ToolStatus.HEALTHY;
  }

  /**
   * 获取所有不健康的工具
   * @returns 不健康的工具列表
   */
  async getUnhealthyTools(): Promise<Tool.Info[]> {
    return Array.from(this.tools.values())
      .filter((tool) => tool.status === ToolStatus.UNHEALTHY)
      .map((tool) => ({
        id: tool.id,
        init: tool.init,
      }));
  }

  /**
   * 注销工具
   * @param id - 工具 ID
   * @returns 是否成功注销
   */
  async unregister(id: string): Promise<boolean> {
    // 同时清理 simpleTools
    this.simpleTools.delete(id);
    return this.tools.delete(id);
  }

  /**
   * 获取工具（自动过滤不健康的工具）
   * @param id - 工具 ID
   * @returns 工具定义或 undefined（不健康的工具返回 undefined）
   */
  async get(id: string): Promise<Tool.Info | undefined> {
    const tool = this.tools.get(id);
    // 如果工具状态为 unhealthy，返回 undefined
    if (tool?.status === ToolStatus.UNHEALTHY) {
      return undefined;
    }
    return tool;
  }

  /**
   * 获取简单工具（用于 ToolDispatcher 兼容）
   * @param id - 工具 ID
   * @returns 简单工具定义或 undefined
   */
  async getSimple(id: string): Promise<ToolInfo | undefined> {
    return this.simpleTools.get(id);
  }

  /**
   * 注册简单工具（用于 ToolDispatcher 兼容）
   * @param tool - 简单工具定义
   */
  async registerSimple(tool: ToolInfo): Promise<void> {
    this.simpleTools.set(tool.id, tool);
  }

  /**
   * 获取工具类型
   * @param id - 工具 ID
   * @returns 工具类型或 undefined
   */
  async getType(id: string): Promise<ToolType | undefined> {
    return this.tools.get(id)?.type;
  }

  /**
   * 获取所有工具
   * @returns 工具定义列表
   */
  async list(): Promise<Tool.Info[]> {
    return Array.from(this.tools.values());
  }

  /**
   * 按类型获取工具
   * @param type - 工具类型
   * @returns 工具定义列表
   */
  async listByType(type: ToolType): Promise<Tool.Info[]> {
    return Array.from(this.tools.values())
      .filter((tool) => tool.type === type)
      .map((tool) => ({
        id: tool.id,
        init: tool.init,
      }));
  }

  /**
   * 检查工具是否存在
   * @param id - 工具 ID
   * @returns 是否存在
   */
  async has(id: string): Promise<boolean> {
    return this.tools.has(id);
  }

  /**
   * 清空所有工具
   */
  async clear(): Promise<void> {
    this.tools.clear();
  }

  /**
   * 获取工具数量
   * @returns 工具数量
   */
  async size(): Promise<number> {
    return this.tools.size;
  }

  /**
   * 获取所有工具 ID
   * @returns 工具 ID 列表
   */
  async ids(): Promise<string[]> {
    return Array.from(this.tools.keys());
  }
}

/**
 * 工具注册表单例
 */
export const toolRegistry = new ToolRegistry();
````

## File: src/core/tool-action/ToolActionParser.ts
````typescript
/**
 * ToolActionParser - <tool_action> 标签解析器
 *
 * 解析 LLM 输出中的 tool_action 标签格式工具调用
 * 标签格式:
 *   <tool_action name="工具名称" type="skill|mcp|builtin">
 *     <参数名 value="参数值" />
 *   </tool_action>
 */

import { ToolActionCall, ParseResult, TextSegment, ToolType } from "./types";
import { logger } from "../../utils/logger";

export class ToolActionParser {
  // 最大输入长度限制（防止 ReDoS 攻击）
  private static readonly MAX_INPUT_LENGTH = 50000;

  // 匹配完整的 action 标签（支持 tool_action 向后兼容）
  // 使用非贪婪匹配并添加长度限制，防止 ReDoS
  private static readonly TAG_REGEX =
    /<(action|tool_action)\s+name="([^"]{1,1000})"(?:\s+type="([^"]{1,100})")?\s*>([\s\S]{0,5000})<\/\1>/g;

  // 匹配参数子标签 - 支持两种格式:
  // 1. 自闭合: <param value="xxx" />
  // 2. 标准闭合: <param value="xxx"></param>
  private static readonly PARAM_REGEX =
    /<(\w{1,100})\s+value="([^"]{0,5000})"(?:\s*\/>|\s*><\/\1>)/g;

  // 检测未闭合的标签开始 - 更宽松的匹配
  private static readonly PENDING_TAG_REGEX = /<(action|tool_action)[^>]*>/;

  /**
   * 解析文本中的所有工具调用
   * @param text 要解析的文本
   * @returns 解析结果
   */
  parse(text: string): ParseResult {
    // 输入长度验证（防止 ReDoS 攻击）
    if (!text || typeof text !== "string" || text.length > ToolActionParser.MAX_INPUT_LENGTH) {
      logger.warn(`[ToolActionParser] Input too long or invalid: ${text?.length ?? 0} chars`);
      return { toolCalls: [], textSegments: [], pendingText: "" };
    }

    const toolCalls: ToolActionCall[] = [];
    const textSegments: TextSegment[] = [];

    let lastIndex = 0;
    let match: RegExpExecArray | null;

    // 重置正则表达式状态
    ToolActionParser.TAG_REGEX.lastIndex = 0;

    while ((match = ToolActionParser.TAG_REGEX.exec(text)) !== null) {
      const [fullMatch, tagName, toolName, toolType, content] = match;
      const startIndex = match.index;
      const endIndex = startIndex + fullMatch.length;

      // 收集标签前的文本
      if (startIndex > lastIndex) {
        textSegments.push({
          content: text.slice(lastIndex, startIndex),
          startIndex: lastIndex,
          endIndex: startIndex,
        });
      }

      // 解析参数
      const parameters = this.extractParameters(content);

      // L-001 修复：使用公共方法解析工具类型
      const type = ToolActionParser.parseToolType(toolType);

      toolCalls.push({
        name: toolName,
        type,
        parameters,
        rawText: fullMatch,
        startIndex,
        endIndex,
      });

      lastIndex = endIndex;
    }

    // 收集最后一段文本
    if (lastIndex < text.length) {
      const remainingText = text.slice(lastIndex);

      // 检查是否有未完成的标签（有开始但没有结束）
      if (this.hasPendingTag(remainingText)) {
        const openTagIndex = remainingText.indexOf("<tool_action");

        // 未完成标签前的文本
        if (openTagIndex > 0) {
          textSegments.push({
            content: remainingText.slice(0, openTagIndex),
            startIndex: lastIndex,
            endIndex: lastIndex + openTagIndex,
          });
        }

        return {
          toolCalls,
          textSegments,
          pendingText: remainingText.slice(openTagIndex >= 0 ? openTagIndex : 0),
        };
      }

      textSegments.push({
        content: remainingText,
        startIndex: lastIndex,
        endIndex: text.length,
      });
    }

    return {
      toolCalls,
      textSegments,
      pendingText: "",
    };
  }

  /**
   * 检测文本中是否有未完成的标签
   * @param text 要检测的文本
   * @returns 是否有未完成标签
   */
  hasPendingTag(text: string): boolean {
    // 检查是否有 <tool_action 开始但没有 </tool_action> 结束
    const openTagIndex = text.lastIndexOf("<tool_action");
    if (openTagIndex === -1) {
      return false;
    }

    const closeTagIndex = text.indexOf("</tool_action>", openTagIndex);
    return closeTagIndex === -1;
  }

  /**
   * 从标签内容中提取参数
   * @param content 标签内部内容
   * @returns 参数键值对
   */
  private extractParameters(content: string): Record<string, string> {
    const parameters: Record<string, string> = {};

    // 重置正则表达式状态
    ToolActionParser.PARAM_REGEX.lastIndex = 0;

    let match: RegExpExecArray | null;
    while ((match = ToolActionParser.PARAM_REGEX.exec(content)) !== null) {
      const [, paramName, paramValue] = match;
      parameters[paramName] = paramValue;
    }

    return parameters;
  }

  /**
   * L-001 修复：提取公共方法，消除代码重复
   * 验证并解析工具类型
   */
  private static parseToolType(toolType: string | undefined): ToolType {
    if (!toolType) {
      return ToolType.BUILTIN;
    }

    const validTypes = Object.values(ToolType);
    if (validTypes.includes(toolType as ToolType)) {
      return toolType as ToolType;
    }

    logger.warn(`[ToolActionParser] Invalid tool type: ${toolType}, using default: builtin`);
    return ToolType.BUILTIN;
  }

  /**
   * 解析单个工具调用标签
   * @param tagText 完整的标签文本
   * @returns 工具调用对象或 null
   */
  parseSingleTag(tagText: string): ToolActionCall | null {
    // 重置正则表达式状态
    ToolActionParser.TAG_REGEX.lastIndex = 0;

    const match = ToolActionParser.TAG_REGEX.exec(tagText);
    if (!match) {
      return null;
    }

    const [fullMatch, tagName, toolName, toolType, content] = match;
    const parameters = this.extractParameters(content);

    // L-001 修复：使用公共方法解析工具类型
    const type = ToolActionParser.parseToolType(toolType);

    return {
      name: toolName,
      type,
      parameters,
      rawText: fullMatch,
      startIndex: 0,
      endIndex: fullMatch.length,
    };
  }

  /**
   * 验证工具调用格式是否正确
   * @param toolAction 工具调用对象
   * @returns 是否有效
   */
  isValidToolAction(toolAction: ToolActionCall): boolean {
    return (
      typeof toolAction.name === "string" &&
      toolAction.name.length > 0 &&
      typeof toolAction.parameters === "object"
    );
  }
}

// 导出单例实例
export const toolActionParser = new ToolActionParser();
````

## File: src/core/variable/index.ts
````typescript
/**
 * Variable Engine Module - Simplified Version
 *
 * 简化版的变量引擎模块导出
 * 特点：移除提供者模式，只保留核心引擎
 */

export * from '../../types/variable';
import { VariableEngine } from './VariableEngine';
import type { IVariableEngine, VariableEngineOptions } from '../../types/variable';

export { VariableEngine };

/**
 * 创建变量引擎实例（简化版）
 *
 * @param options - 变量引擎配置选项（简化版中不再使用）
 * @returns 变量引擎实例
  19  */
export function createVariableEngine(_options?: VariableEngineOptions): IVariableEngine {
  return new VariableEngine();
}
````

## File: src/database/MigrationRunner.ts
````typescript
/**
 * Migration Runner for Playbook System Database
 * Executes SQL migration scripts in order and tracks execution history
 */

import * as fs from "fs";
import * as path from "path";
import Database from "better-sqlite3";

export interface Migration {
  version: string;
  name: string;
  sql: string;
  timestamp: number;
}

export interface MigrationResult {
  success: boolean;
  version: string;
  name: string;
  duration: number;
  error?: string;
}

export class MigrationRunner {
  private db: Database.Database;
  private migrationsDir: string;

  constructor(dbPath: string, migrationsDir: string = path.join(__dirname, "migrations")) {
    this.db = new Database(dbPath);
    this.migrationsDir = migrationsDir;

    // Initialize migrations tracking table
    this.initializeMigrationsTable();
  }

  /**
   * Create migrations tracking table if it doesn't exist
   */
  private initializeMigrationsTable(): void {
    const createTableSQL = `
      CREATE TABLE IF NOT EXISTS schema_migrations (
        version TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        executed_at INTEGER NOT NULL,
        duration INTEGER NOT NULL,
        checksum TEXT NOT NULL
      );
    `;

    const createIndexSQL = `
      CREATE INDEX IF NOT EXISTS idx_migrations_executed_at ON schema_migrations(executed_at DESC);
    `;

    this.db.exec(createTableSQL);
    this.db.exec(createIndexSQL);
  }

  /**
   * Calculate checksum for SQL file
   */
  private calculateChecksum(sql: string): string {
    const crypto = require("crypto");
    return crypto.createHash("sha256").update(sql).digest("hex");
  }

  /**
   * Get all migration files from migrations directory
   */
  private getMigrationFiles(): string[] {
    if (!fs.existsSync(this.migrationsDir)) {
      return [];
    }

    const files = fs
      .readdirSync(this.migrationsDir)
      .filter((file) => file.match(/^\d+_.*\.sql$/))
      .sort();

    return files.map((file) => path.join(this.migrationsDir, file));
  }

  /**
   * Parse migration filename to extract version and name
   */
  private parseMigrationFilename(filename: string): { version: string; name: string } {
    const basename = path.basename(filename);
    const match = basename.match(/^(\d+)_([^.]+)\.sql$/);

    if (!match) {
      throw new Error(`Invalid migration filename: ${filename}`);
    }

    const version = match[1].padStart(3, "0"); // Pad with zeros for proper sorting
    const name = match[2];

    return { version, name };
  }

  /**
   * Load all pending migrations
   */
  private loadPendingMigrations(): Migration[] {
    const migrationFiles = this.getMigrationFiles();
    const pendingMigrations: Migration[] = [];

    for (const file of migrationFiles) {
      const { version, name } = this.parseMigrationFilename(file);
      const sql = fs.readFileSync(file, "utf-8");
      const checksum = this.calculateChecksum(sql);

      // Check if migration was already executed
      const row = this.db
        .prepare("SELECT checksum FROM schema_migrations WHERE version = ?")
        .get(version) as { checksum: string } | undefined;

      if (row) {
        // Migration exists, check if checksum matches
        if (row.checksum === checksum) {
          continue; // Migration already executed with same content
        } else {
          throw new Error(
            `Migration ${version} (${name}) has already been executed with different content. ` +
              `Expected checksum: ${checksum}, found: ${row.checksum}`
          );
        }
      }

      pendingMigrations.push({
        version,
        name,
        sql,
        timestamp: Date.now(),
      });
    }

    return pendingMigrations;
  }

  /**
   * Execute a single migration
   */
  private executeMigration(migration: Migration): MigrationResult {
    const startTime = Date.now();

    try {
      // Begin transaction
      this.db.exec("BEGIN TRANSACTION");

      // Execute the migration SQL
      this.db.exec(migration.sql);

      // Record migration in schema_migrations table
      const checksum = this.calculateChecksum(migration.sql);
      this.db
        .prepare(
          `
        INSERT INTO schema_migrations (version, name, executed_at, duration, checksum)
        VALUES (?, ?, ?, ?, ?)
      `
        )
        .run(
          migration.version,
          migration.name,
          migration.timestamp,
          0, // Will update with actual duration after commit
          checksum
        );

      // Commit transaction
      this.db.exec("COMMIT");

      const duration = Date.now() - startTime;

      // Update duration
      this.db
        .prepare(
          `
        UPDATE schema_migrations
        SET duration = ?
        WHERE version = ?
      `
        )
        .run(duration, migration.version);

      return {
        success: true,
        version: migration.version,
        name: migration.name,
        duration,
      };
    } catch (error) {
      // Rollback on error
      this.db.exec("ROLLBACK");

      return {
        success: false,
        version: migration.version,
        name: migration.name,
        duration: Date.now() - startTime,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Run all pending migrations
   */
  public async run(): Promise<MigrationResult[]> {
    const pendingMigrations = this.loadPendingMigrations();

    if (pendingMigrations.length === 0) {
      console.log("No pending migrations to execute.");
      return [];
    }

    console.log(`Found ${pendingMigrations.length} pending migration(s).`);
    console.log("Starting migration process...\n");

    const results: MigrationResult[] = [];

    for (const migration of pendingMigrations) {
      console.log(`Executing migration ${migration.version}: ${migration.name}...`);

      const result = this.executeMigration(migration);
      results.push(result);

      if (result.success) {
        console.log(`  ✓ Completed in ${result.duration}ms`);
      } else {
        console.error(`  ✗ Failed: ${result.error}`);
        console.error("\nMigration process halted. Please resolve the error and try again.");
        break;
      }
    }

    console.log("\nMigration process completed.");
    return results;
  }

  /**
   * Get migration history
   */
  public getMigrationHistory(): Array<{
    version: string;
    name: string;
    executed_at: number;
    duration: number;
    checksum: string;
  }> {
    const rows = this.db
      .prepare(
        `
        SELECT version, name, executed_at, duration, checksum
        FROM schema_migrations
        ORDER BY version ASC
      `
      )
      .all() as Array<{
      version: string;
      name: string;
      executed_at: number;
      duration: number;
      checksum: string;
    }>;

    return rows;
  }

  /**
   * Rollback last N migrations
   */
  public rollback(count: number = 1): MigrationResult[] {
    if (count <= 0) {
      throw new Error("Rollback count must be positive");
    }

    console.log(`Rolling back last ${count} migration(s)...\n`);

    const results: MigrationResult[] = [];

    try {
      // Get the last N migrations to rollback
      const migrationsToRollback = this.db
        .prepare(
          `
          SELECT version, name
          FROM schema_migrations
          ORDER BY version DESC
          LIMIT ?
        `
        )
        .all(count) as Array<{ version: string; name: string }>;

      if (migrationsToRollback.length === 0) {
        console.log("No migrations to rollback.");
        return [];
      }

      // For simplicity, we'll delete the migration records
      // In production, you would create rollback scripts for each migration
      for (const migration of migrationsToRollback) {
        try {
          const startTime = Date.now();

          this.db.prepare("DELETE FROM schema_migrations WHERE version = ?").run(migration.version);

          console.log(`Rolled back migration ${migration.version}: ${migration.name}`);

          results.push({
            success: true,
            version: migration.version,
            name: migration.name,
            duration: Date.now() - startTime,
          });
        } catch (error) {
          results.push({
            success: false,
            version: migration.version,
            name: migration.name,
            duration: 0,
            error: error instanceof Error ? error.message : String(error),
          });
        }
      }

      console.log("\nRollback process completed.");
    } catch (error) {
      console.error("Rollback failed:", error);
    }

    return results;
  }

  /**
   * Get database version (latest executed migration)
   */
  public getCurrentVersion(): string | null {
    const row = this.db
      .prepare("SELECT version FROM schema_migrations ORDER BY version DESC LIMIT 1")
      .get() as { version: string } | undefined;

    return row?.version || null;
  }

  /**
   * Check if database is up to date
   */
  public isUpToDate(): boolean {
    return this.loadPendingMigrations().length === 0;
  }

  /**
   * Close database connection
   */
  public close(): void {
    this.db.close();
  }
}
````

## File: src/services/tool-retrieval/LanceDBConnection.ts
````typescript
/**
 * LanceDBConnection - Database Connection Management
 *
 * Handles database connection, schema management, and table initialization.
 * Uses connection pooling for improved concurrency and stability.
 */

import * as lancedb from "@lancedb/lancedb";
import { Index } from "@lancedb/lancedb";
import * as arrow from "apache-arrow";
import * as fs from "fs/promises";
import * as path from "path";
import { logger } from "../../utils/logger";
import { LanceDBConfig, ConnectionStatus, ToolsTable } from "./types";
import { LanceDBConnectionPool } from "./LanceDBConnectionPool";
import { IndexConfigOptimizer, OptimizationResult } from "./IndexConfigOptimizer";

/**
 * LanceDB Connection interface
 */
export interface ILanceDBConnection {
  connect(config: LanceDBConfig): Promise<void>;
  disconnect(): Promise<void>;
  initializeTable(): Promise<void>;
  getTable(): Promise<lancedb.Table | null>;
  checkSchemaCompatibility(): Promise<boolean>;
  getStatus(): ConnectionStatus;
  getDb(): lancedb.Connection | null;
  addRecords(records: ToolsTable[]): Promise<void>;
  deleteById(id: string): Promise<void>;
  getCount(): Promise<number>;
}

/**
 * LanceDB Connection implementation with connection pooling
 */
export class LanceDBConnection implements ILanceDBConnection {
  private static pool: LanceDBConnectionPool | null = null;
  private db: lancedb.Connection | null = null;
  private table: lancedb.Table | null = null;
  private config: LanceDBConfig | null = null;
  private connected = false;
  private dbPath: string = "";
  private optimizer: IndexConfigOptimizer;

  /**
   * Initialize the optimizer
   */
  constructor() {
    this.optimizer = new IndexConfigOptimizer();
  }

  /**
   * Get the connection pool instance
   */
  static getPool(): LanceDBConnectionPool {
    if (!this.pool) {
      this.pool = new LanceDBConnectionPool();
    }
    return this.pool;
  }

  /**
   * Set a custom connection pool (for testing)
   */
  static setPool(pool: LanceDBConnectionPool): void {
    this.pool = pool;
  }

  /**
   * Reset the pool (for testing)
   */
  static resetPool(): void {
    this.pool = null;
  }

  /**
   * Connect to LanceDB using connection pool
   */
  async connect(config: LanceDBConfig): Promise<void> {
    try {
      // Ensure database directory exists
      await fs.mkdir(config.databasePath, { recursive: true });

      this.dbPath = config.databasePath;
      this.db = await LanceDBConnection.getPool().getConnection(config.databasePath);
      this.config = config;
      this.connected = true;

      logger.info(`[LanceDB] Connected to LanceDB at: ${config.databasePath}`);
    } catch (error) {
      logger.error("[LanceDB] Failed to connect to LanceDB:", error);
      this.connected = false;
      throw error;
    }
  }

  /**
   * Disconnect from LanceDB
   */
  async disconnect(): Promise<void> {
    try {
      this.table = null;
      if (this.dbPath && this.db) {
        await LanceDBConnection.getPool().releaseConnection(this.dbPath);
      }
      this.db = null;
      this.connected = false;
      logger.info("[LanceDB] Disconnected from LanceDB");
    } catch (error) {
      logger.warn("[LanceDB] Error during disconnect:", error);
    }
  }

  /**
   * Initialize the skills table
   */
  async initializeTable(): Promise<void> {
    if (!this.db || !this.config) {
      throw new Error("Database not connected");
    }

    try {
      const tableName = this.config.tableName;

      // Try to open existing table
      try {
        this.table = await this.db.openTable(tableName);
        logger.info(`[LanceDB] Table '${tableName}' exists, checking dimensions...`);

        // Check if dimensions match
        const dimensionsMatch = await this.checkTableDimensions();
        logger.info(`[LanceDB] Dimension check: ${dimensionsMatch ? "MATCH" : "MISMATCH"}`);

        if (!dimensionsMatch) {
          // Dimensions don't match, need to recreate
          logger.warn(
            `[LanceDB] Table dimensions mismatch. Dropping and recreating table: ${tableName}`
          );
          await this.dropTableCompletely(tableName);
          await this.createTable();
        } else {
          // Dimensions match, check for missing fields (MCP support)
          await this.checkAndAddMissingFields(tableName);
          await this.createVectorIndex();
        }

        return;
      } catch (openError) {
        logger.info(`[LanceDB] Table '${tableName}' does not exist, will create new table`);
      }

      // Create new table
      await this.createTable();
    } catch (error) {
      logger.error("[LanceDB] Failed to initialize table:", error);
      throw error;
    }
  }

  /**
   * Create the table with schema
   */
  private async createTable(): Promise<void> {
    if (!this.db || !this.config) {
      throw new Error("Database not connected");
    }

    // Create schema with Apache Arrow
    const schema = new arrow.Schema([
      new arrow.Field("id", new arrow.Utf8(), false),
      new arrow.Field("name", new arrow.Utf8(), false),
      new arrow.Field("description", new arrow.Utf8(), false),
      new arrow.Field(
        "tags",
        new arrow.List(new arrow.Field("item", new arrow.Utf8(), true)),
        false
      ),
      new arrow.Field("path", new arrow.Utf8(), true),
      new arrow.Field("version", new arrow.Utf8(), true),
      new arrow.Field("source", new arrow.Utf8(), true),
      new arrow.Field("toolType", new arrow.Utf8(), false),
      new arrow.Field("metadata", new arrow.Utf8(), false),
      new arrow.Field(
        "vector",
        new arrow.FixedSizeList(
          this.config.vectorDimensions,
          new arrow.Field("item", new arrow.Float32(), true)
        ),
        false
      ),
      new arrow.Field("indexedAt", new arrow.Timestamp(arrow.TimeUnit.MICROSECOND), false),
    ]);

    this.table = await this.db.createTable(this.config.tableName, [], { schema });
    logger.info(
      `[LanceDB] Created new table: ${this.config.tableName} with ${this.config.vectorDimensions} dimensions`
    );

    // Create vector index
    await this.createVectorIndex();
  }

  /**
   * Check table dimensions compatibility
   */
  private async checkTableDimensions(): Promise<boolean> {
    if (!this.db || !this.table || !this.config) {
      return false;
    }

    try {
      // Create a test vector
      const testVector = new Array(this.config.vectorDimensions).fill(0.1);

      // Try to add a temporary record
      const tempId = `dimension-check-${Date.now()}`;
      const tempTable = await this.db.openTable(this.config.tableName);

      try {
        await tempTable.add([
          {
            id: tempId,
            name: "Dimension Check",
            description: "Temporary record for dimension validation",
            tags: [],
            path: "temp",
            version: "1.0",
            metadata: JSON.stringify({}),
            vector: testVector,
            indexedAt: new Date(),
          },
        ]);

        // If successful, delete test record
        await tempTable.delete(`id = '${tempId}'`);
        return true;
      } catch (insertError: any) {
        const errorMsg = insertError.message || "";
        if (
          errorMsg.includes("dimension") ||
          errorMsg.includes("length") ||
          errorMsg.includes("schema") ||
          errorMsg.includes("FixedSizeList")
        ) {
          logger.debug("[LanceDB] Dimension mismatch error:", errorMsg);
          return false;
        }
        throw insertError;
      }
    } catch (error) {
      logger.error("[LanceDB] Failed to check table dimensions:", error);
      return false;
    }
  }

  /**
   * Check and add missing fields (for MCP support)
   */
  private async checkAndAddMissingFields(tableName: string): Promise<void> {
    if (!this.table || !this.config) {
      return;
    }

    try {
      const testVector = new Array(this.config.vectorDimensions).fill(0.0);

      const testRecord = {
        id: `field-check-${Date.now()}`,
        name: "Field Check",
        description: "Checking for missing fields",
        tags: [],
        path: null,
        version: null,
        source: null,
        toolType: "mcp",
        metadata: "{}",
        vector: testVector,
        indexedAt: new Date(),
      };

      await this.table.add([testRecord]);
      logger.info("[LanceDB] All fields (including MCP fields) are present");

      // Delete test record
      await this.table.delete(`id == "${testRecord.id}"`);
    } catch (error: any) {
      if (error.message && error.message.includes("Found field not in schema")) {
        logger.warn("[LanceDB] Table is missing MCP-related fields. Recreating table...");

        // Drop and recreate
        await this.dropTableCompletely(tableName);
        await this.createTable();
      } else {
        throw error;
      }
    }
  }

  /**
   * Drop table and completely remove physical files
   * This ensures no leftover .lance files cause "Not found" errors
   */
  private async dropTableCompletely(tableName: string): Promise<void> {
    if (!this.db || !this.config) {
      throw new Error("Database not connected");
    }

    try {
      // First, drop the table from LanceDB
      await this.db.dropTable(tableName);
      logger.info(`[LanceDB] Dropped table: ${tableName}`);

      // Then, manually remove physical files to ensure complete cleanup
      const tablePath = path.join(this.config.databasePath, tableName);
      try {
        await fs.rm(tablePath, { recursive: true, force: true });
        logger.info(`[LanceDB] Completely removed physical files: ${tablePath}`);
      } catch (rmError: any) {
        if (rmError.code !== "ENOENT") {
          logger.warn(
            `[LanceDB] Failed to remove physical files (may not exist): ${rmError.message}`
          );
        }
      }
    } catch (error) {
      logger.error("[LanceDB] Failed to drop table completely:", error);
      throw error;
    }
  }

  /**
   * Create vector index for faster search
   * Uses optimized IVF_PQ configuration based on expected data scale
   */
  private async createVectorIndex(rowCount?: number): Promise<void> {
    if (!this.table || !this.config) {
      return;
    }

    try {
      // Use provided row count or estimate from table
      const estimatedRows = rowCount || (await this.getCount()) || 10000;
      const dimension = this.config.vectorDimensions;

      // Calculate optimal configuration
      const optimizationResult = this.optimizer.calculateOptimalConfig(
        estimatedRows,
        dimension,
        0.95, // target recall
        false // prefer accuracy over speed
      );

      // Log the optimization reasoning
      logger.info(`[LanceDB] ${optimizationResult.reasoning}`);

      // Create index with optimized configuration
      await this.table.createIndex("vector", {
        config: Index.ivfPq({
          numPartitions: optimizationResult.config.numPartitions,
          numSubVectors: optimizationResult.config.numSubVectors,
        }),
        replace: true,
      });

      logger.info(
        `[LanceDB] Created optimized vector index: ${optimizationResult.config.numPartitions} partitions, ` +
          `${optimizationResult.config.numSubVectors} sub-vectors, ` +
          `est. recall: ${(optimizationResult.estimatedRecall * 100).toFixed(1)}%`
      );
    } catch (error) {
      // Index may already exist, ignore error
      logger.debug("[LanceDB] Vector index may already exist:", error);
    }
  }

  /**
   * Get table instance
   */
  async getTable(): Promise<lancedb.Table | null> {
    return this.table;
  }

  /**
   * Get database instance
   */
  getDb(): lancedb.Connection | null {
    return this.db;
  }

  /**
   * Check schema compatibility
   */
  async checkSchemaCompatibility(): Promise<boolean> {
    return this.checkTableDimensions();
  }

  /**
   * Get connection status
   */
  getStatus(): ConnectionStatus {
    return {
      connected: this.connected,
      lastConnected: this.connected ? new Date() : undefined,
      error: this.connected ? undefined : "Not connected",
    };
  }

  /**
   * Add records to table
   */
  async addRecords(records: ToolsTable[]): Promise<void> {
    if (!this.table) {
      throw new Error("Table not initialized");
    }

    await this.table.add(records as unknown as Record<string, unknown>[]);
  }

  /**
   * Delete record by ID
   */
  async deleteById(id: string): Promise<void> {
    if (!this.table) {
      throw new Error("Table not initialized");
    }

    await this.table.delete(`id = "${id}"`);
  }

  /**
   * Get table count
   */
  async getCount(): Promise<number> {
    if (!this.table) {
      return 0;
    }

    try {
      return await this.table.countRows();
    } catch (error) {
      logger.warn("[LanceDB] Failed to get table count:", error);
      return 0;
    }
  }
}
````

## File: src/services/tool-retrieval/ToolRetrievalService.ts
````typescript
/**
 * ToolRetrievalService - Main Service
 *
 * Main service coordinating all tool retrieval modules.
 * Provides public API for tool/skill retrieval operations.
 */

import { logger } from "../../utils/logger";
import {
  ToolRetrievalConfig,
  ToolRetrievalResult,
  SkillData,
  ServiceStatus,
  ToolError,
  ToolErrorCode,
  SkillTool,
} from "./types";
import { LanceDBConnection, ILanceDBConnection } from "./LanceDBConnection";
import { EmbeddingGenerator, IEmbeddingGenerator } from "./EmbeddingGenerator";
import { SkillIndexer, ISkillIndexer } from "./SkillIndexer";
import { SearchEngine, ISearchEngine } from "./SearchEngine";
import { MCPToolSupport, IMCPToolSupport } from "./MCPToolSupport";

/**
 * ToolRetrievalService interface
 */
export interface IToolRetrievalService {
  initialize(): Promise<void>;
  findRelevantSkills(
    query: string,
    limit?: number,
    threshold?: number
  ): Promise<ToolRetrievalResult[]>;
  indexSkill(skill: SkillData): Promise<void>;
  removeSkill(skillId: string): Promise<void>;
  scanAndIndexAllSkills(skillsDir?: string): Promise<void>;
  getStatus(): ServiceStatus;
  cleanup(): Promise<void>;
  indexTools(tools: SkillTool[]): Promise<void>;
  removeTool(toolId: string): Promise<void>;
}

/**
 * ToolRetrievalService implementation
 * Coordinates all tool retrieval modules
 */
export class ToolRetrievalService implements IToolRetrievalService {
  private readonly config: ToolRetrievalConfig;
  private connection: ILanceDBConnection;
  private embeddingGenerator: IEmbeddingGenerator;
  private skillIndexer: ISkillIndexer;
  private searchEngine: ISearchEngine;
  private mcpToolSupport: IMCPToolSupport;
  private isInitialized = false;

  /**
   * Create ToolRetrievalService with dependencies
   */
  constructor(config: ToolRetrievalConfig) {
    this.config = config;

    // Initialize sub-modules
    this.connection = new LanceDBConnection();
    this.embeddingGenerator = new EmbeddingGenerator({
      provider: "openai", // Will be determined dynamically
      model: config.model,
      dimensions: config.dimensions,
    });
    this.skillIndexer = new SkillIndexer(this.connection, this.embeddingGenerator);
    this.searchEngine = new SearchEngine(this.connection, this.embeddingGenerator, {
      defaultLimit: config.maxResults,
      defaultThreshold: config.similarityThreshold,
    });
    this.mcpToolSupport = new MCPToolSupport(this.embeddingGenerator, this.connection);

    logger.info("[ToolRetrievalService] Created with config:", {
      vectorDbPath: config.vectorDbPath,
      model: config.model,
      dimensions: config.dimensions,
      similarityThreshold: config.similarityThreshold,
      maxResults: config.maxResults,
    });
  }

  /**
   * Initialize the service
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      logger.debug("[ToolRetrievalService] Already initialized");
      return;
    }

    const startTime = Date.now();

    try {
      logger.info("[ToolRetrievalService] Initializing...");

      // Get actual embedding dimensions from LLMConfigService
      const actualDimensions = await this.embeddingGenerator.getActualDimensions();
      if (actualDimensions !== this.config.dimensions) {
        logger.info(
          `[ToolRetrievalService] Updating dimensions from ${this.config.dimensions} to ${actualDimensions}`
        );
        this.config.dimensions = actualDimensions;
      }

      // Connect to LanceDB
      await this.connection.connect({
        databasePath: this.config.vectorDbPath,
        tableName: "skills",
        vectorDimensions: this.config.dimensions,
      });

      // Initialize table
      await this.connection.initializeTable();

      this.isInitialized = true;

      const duration = Date.now() - startTime;
      logger.debug(`[ToolRetrievalService] Initialized in ${duration}ms`);
    } catch (error) {
      logger.error("[ToolRetrievalService] Initialization failed:", error);
      throw new ToolError(
        `ToolRetrievalService initialization failed: ${this.formatError(error)}`,
        ToolErrorCode.VECTOR_DB_ERROR
      );
    }
  }

  /**
   * Find relevant skills for a query with graceful degradation
   * Implements fallback strategy: vector search -> keyword search -> empty array
   */
  async findRelevantSkills(
    query: string,
    limit?: number,
    threshold?: number
  ): Promise<ToolRetrievalResult[]> {
    const startTime = Date.now();
    let fallbackTriggered = false;
    let fallbackReason = "";

    try {
      // Ensure initialized
      if (!this.isInitialized) {
        logger.warn("[ToolRetrievalService] Not initialized, initializing now...");
        await this.initialize();
      }

      // Try vector search (with internal fallback to keyword search)
      const results = await this.searchEngine.search(query, { limit, minScore: threshold });

      const duration = Date.now() - startTime;
      logger.debug(`[ToolRetrievalService] Search completed in ${duration}ms`, {
        query: query.substring(0, 50),
        resultCount: results.length,
      });

      return results;
    } catch (error) {
      fallbackTriggered = true;

      // Determine fallback reason
      if (error instanceof ToolError && error.code === ToolErrorCode.VECTOR_DB_ERROR) {
        fallbackReason = "vector_db_error";
      } else if (this.formatError(error).includes("embedding")) {
        fallbackReason = "embedding_failure";
      } else {
        fallbackReason = "unknown_error";
      }

      // Log fallback trigger
      logger.warn(
        `[ToolRetrievalService] Search fallback triggered for query "${query.substring(0, 50)}..."`,
        {
          errorType: error instanceof ToolError ? error.code : "UNKNOWN_ERROR",
          fallbackReason,
          query: query.substring(0, 100),
          limit,
          threshold,
          duration: Date.now() - startTime,
        }
      );

      // Try keyword search fallback
      try {
        const fallbackResults = await this.keywordSearchFallback(query, limit, threshold);

        logger.info(
          `[ToolRetrievalService] Fallback keyword search returned ${fallbackResults.length} results`,
          {
            originalQuery: query.substring(0, 50),
            fallbackResultCount: fallbackResults.length,
          }
        );

        return fallbackResults;
      } catch (fallbackError) {
        // All methods failed - return empty array as last resort
        logger.error(
          `[ToolRetrievalService] All search methods failed for query "${query.substring(0, 50)}..."`,
          {
            originalError: this.formatError(error),
            fallbackError: this.formatError(fallbackError),
            query: query.substring(0, 100),
          }
        );

        // Return empty array instead of throwing - ensures service availability
        return [];
      }
    }
  }

  /**
   * Keyword search fallback implementation
   * Used when vector search fails completely
   */
  private async keywordSearchFallback(
    query: string,
    limit?: number,
    threshold?: number
  ): Promise<ToolRetrievalResult[]> {
    const effectiveLimit = limit || this.config.maxResults;
    const effectiveThreshold = threshold || this.config.similarityThreshold;

    try {
      logger.info(`[ToolRetrievalService] Executing fallback keyword search for: "${query}"`);

      // Get search terms from query
      const searchTerms = query
        .toLowerCase()
        .split(/\s+/)
        .filter((t) => t.length > 0);

      if (searchTerms.length === 0) {
        return [];
      }

      // In a real implementation, this would query the database
      // For now, return empty results to maintain service availability
      logger.debug(
        `[ToolRetrievalService] Fallback search completed with 0 results for query "${query.substring(0, 50)}"`
      );
      return [];
    } catch (error) {
      logger.error("[ToolRetrievalService] Keyword fallback search failed:", error);
      throw error;
    }
  }

  /**
   * Index a skill
   */
  async indexSkill(skill: SkillData): Promise<void> {
    await this.skillIndexer.addSkill(skill);
  }

  /**
   * Remove a skill from the index
   */
  async removeSkill(skillId: string): Promise<void> {
    await this.skillIndexer.removeSkill(skillId);
  }

  /**
   * Scan and index all skills in a directory
   */
  async scanAndIndexAllSkills(skillsDir?: string): Promise<void> {
    const dir = skillsDir || this.getDefaultSkillsDir();
    await this.skillIndexer.scanAndIndex(dir);
  }

  /**
   * Index tools (supports both skills and MCP tools)
   */
  async indexTools(tools: SkillTool[]): Promise<void> {
    try {
      logger.info(`[ToolRetrievalService] Indexing ${tools.length} tools...`);

      const records: import("./types").ToolsTable[] = [];

      for (const tool of tools) {
        try {
          // Generate ID based on tool type
          const toolId = this.generateToolId(tool);

          // Generate embedding
          const vector = await this.embeddingGenerator.generateForText(
            `${tool.name}\n${tool.description}`
          );

          // Prepare record
          const record: import("./types").ToolsTable = {
            id: toolId,
            name: tool.name,
            description: tool.description,
            tags: tool.tags || [],
            path: tool.path,
            version: tool.version,
            source: tool.path || tool.name,
            toolType: (tool.type as "skill" | "mcp") || "skill",
            metadata: JSON.stringify(tool.metadata || {}),
            vector: vector.values,
            indexedAt: new Date(),
          };

          records.push(record);
        } catch (error) {
          logger.error(`[ToolRetrievalService] Failed to index tool ${tool.name}:`, error);
        }
      }

      if (records.length > 0) {
        // Remove existing
        for (const record of records) {
          await this.connection.deleteById(record.id);
        }

        // Add new
        await this.connection.addRecords(records);
        logger.info(`[ToolRetrievalService] Successfully indexed ${records.length} tools`);
      }
    } catch (error) {
      logger.error("[ToolRetrievalService] Failed to index tools:", error);
      throw error;
    }
  }

  /**
   * Remove a tool from the index
   */
  async removeTool(toolId: string): Promise<void> {
    await this.connection.deleteById(toolId);
  }

  /**
   * Get service status
   */
  getStatus(): ServiceStatus {
    const dbStatus = this.connection.getStatus();
    return {
      databaseStatus: dbStatus,
      indexStatus: {
        indexedCount: 0,
        indexingCount: 0,
        pendingCount: 0,
      },
      ready: this.isInitialized && dbStatus.connected,
      healthy: this.isInitialized && dbStatus.connected,
    };
  }

  /**
   * Cleanup resources - 完整清理
   */
  async cleanup(): Promise<void> {
    logger.info("[ToolRetrievalService] Cleaning up...");

    try {
      // 关闭数据库连接
      if (this.connection) {
        await this.connection.disconnect();
        logger.debug("[ToolRetrievalService] Database connection closed");
      }

      // 清理状态
      this.isInitialized = false;

      // 清理模块级变量（通过导出的重置函数）
      resetToolRetrievalService();

      logger.info("[ToolRetrievalService] Cleanup completed");
    } catch (error) {
      logger.error("[ToolRetrievalService] Cleanup failed:", error);
      throw new ToolError(
        `ToolRetrievalService cleanup failed: ${this.formatError(error)}`,
        ToolErrorCode.VECTOR_DB_ERROR
      );
    }
  }

  /**
   * Get default skills directory
   */
  private getDefaultSkillsDir(): string {
    return "./.data/skills";
  }

  /**
   * Generate tool ID
   */
  private generateToolId(tool: SkillTool): string {
    const source = tool.path || tool.name;
    return require("crypto")
      .createHash("md5")
      .update(`${tool.type}:${source}:${tool.name}`)
      .digest("hex");
  }

  /**
   * Format error message
   */
  private formatError(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error occurred in ToolRetrievalService";
  }
}

// ==================== Singleton Instance ====================

let instance: ToolRetrievalService | null = null;

/**
 * Get tool retrieval service instance (singleton)
 */
export function getToolRetrievalService(config?: ToolRetrievalConfig): ToolRetrievalService {
  if (!instance) {
    if (!config) {
      config = {
        vectorDbPath: "./.data",
        model: "nomic-embed-text:latest",
        cacheSize: 1000,
        dimensions: 768,
        similarityThreshold: 0.4,
        maxResults: 10,
      };
    }
    instance = new ToolRetrievalService(config);
  }
  return instance;
}

/**
 * Reset tool retrieval service instance (for testing)
 */
export function resetToolRetrievalService(): void {
  instance = null;
}
````

## File: src/services/MCPServerManager.ts
````typescript
/**
 * MCP Server Manager
 * 负责管理单个MCP服务器实例的生命周期
 * 包括连接管理、工具发现、调用执行等
 */

import { EventEmitter } from "events";
import { spawn } from "child_process";
import { randomUUID } from "crypto";
import { logger } from "../utils/logger";
import {
  CallToolResult,
  Tool as MCPToolDefinition,
  JSONRPCMessage,
} from "@modelcontextprotocol/sdk/types.js";
import { Client as MCPClient } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport } from "@modelcontextprotocol/sdk/client/stdio.js";
import type {
  MCPServerConfig,
  MCPServerStatus,
  MCPTool,
  MCPToolCall,
  MCPToolResult,
} from "../types/mcp";

export interface ServerMetrics {
  startTime: Date;
  endTime?: Date;
  totalCalls: number;
  successfulCalls: number;
  failedCalls: number;
  averageResponseTime: number;
}

export class MCPServerManager extends EventEmitter {
  private status: MCPServerStatus;
  private tools: MCPTool[] = [];
  private lastActivity?: Date;
  private metrics: ServerMetrics;
  private config: MCPServerConfig;
  private client?: MCPClient;
  private process?: ReturnType<typeof spawn>;
  private transport?: StdioClientTransport;
  private monitoringTimer: NodeJS.Timeout | null = null;
  private processErrorListener?: (error: Error) => void;

  constructor(config: MCPServerConfig) {
    super();
    this.config = config;
    this.status = {
      phase: "not-started",
      message: "Server not started",
      uptime: 0,
      startTime: undefined,
    };
    this.metrics = {
      startTime: new Date(),
      totalCalls: 0,
      successfulCalls: 0,
      failedCalls: 0,
      averageResponseTime: 0,
    };
  }

  /**
   * 初始化MCP服务器
   */
  async initialize(): Promise<void> {
    try {
      logger.info(`[MCP] Initializing server ${this.config.id}...`);

      this.status = {
        phase: "initializing",
        message: "Starting server...",
        uptime: 0,
        startTime: undefined,
      };
      this.emit("status-changed", this.status);

      // 启动MCP客户端
      await this.start();

      logger.info(`[MCP] Server ${this.config.id} initialized successfully`);
    } catch (error: any) {
      logger.error(`[MCP] Failed to initialize server ${this.config.id}:`, error);

      this.status = {
        phase: "error",
        message: error.message || "Initialization failed",
        error: error.message,
        uptime: 0,
        startTime: undefined,
      };

      this.emit("status-changed", this.status);
      throw error;
    }
  }

  /**
   * 启动MCP客户端
   */
  private async start(): Promise<void> {
    if (this.config.type !== "stdio") {
      throw new Error(`Unsupported transport type: ${this.config.type}`);
    }

    this.status = {
      phase: "starting",
      message: "Server starting...",
      uptime: 0,
      startTime: undefined,
    };
    this.emit("status-changed", this.status);

    // 创建子进程
    const env = {
      ...process.env,
      ...this.config.env,
    };

    this.process = spawn(this.config.command, this.config.args, {
      stdio: ["pipe", "pipe", "pipe"],
      env,
      cwd: this.config.cwd,
    });

    // 监听进程错误（保存引用以便在 shutdown 时移除）
    this.processErrorListener = (error: Error) => {
      logger.error(`[MCP] Process error for server ${this.config.id}:`, error);
      this.status = {
        phase: "error",
        message: `Process error: ${error.message}`,
        error: error.message,
        uptime: 0,
        startTime: undefined,
      };
      this.emit("status-changed", this.status);
    };
    this.process.on("error", this.processErrorListener);

    // 创建传输层
    this.transport = new StdioClientTransport({
      command: this.config.command,
      args: this.config.args,
      env,
      cwd: this.config.cwd,
    });

    // 创建MCP客户端
    this.client = new MCPClient({
      name: "apex-bridge",
      version: "1.0.0",
    });

    // 连接到服务器
    await this.client.connect(this.transport);

    // 发现工具
    await this.discoverTools();

    // 更新状态
    this.status = {
      phase: "running",
      message: "Server running",
      uptime: 0,
      startTime: new Date(),
    };

    this.emit("status-changed", this.status);

    // 启动运行监控
    this.startMonitoring();
  }

  /**
   * 发现可用工具
   */
  private async discoverTools(): Promise<void> {
    if (!this.client) {
      throw new Error("MCP client not initialized");
    }

    logger.debug(`[MCP] Discovering tools for server ${this.config.id}...`);

    try {
      const result = await this.client.listTools();

      if (result && result.tools) {
        this.tools = result.tools.map((tool) => ({
          name: tool.name,
          description: tool.description || "",
          inputSchema: tool.inputSchema,
        }));

        logger.info(`[MCP] Discovered ${this.tools.length} tools for server ${this.config.id}`);

        this.emit("tools-changed", this.tools);
      }
    } catch (error: any) {
      logger.error(`[MCP] Failed to discover tools:`, error);
      throw error;
    }
  }

  /**
   * 执行工具调用
   */
  async callTool(call: MCPToolCall): Promise<MCPToolResult> {
    if (!this.client) {
      throw new Error("MCP client not initialized");
    }

    const startTime = Date.now();

    try {
      // 检查工具是否存在
      const tool = this.tools.find((t) => t.name === call.tool);

      if (!tool) {
        throw new Error(`Tool ${call.tool} not found`);
      }

      this.updateLastActivity();

      logger.debug(`[MCP] Calling tool ${call.tool} on server ${this.config.id}`);

      // 调用工具
      const result = (await this.client.callTool({
        name: call.tool,
        arguments: call.arguments,
      })) as CallToolResult;

      const duration = Date.now() - startTime;

      // 更新指标
      this.updateMetrics(true, duration);

      // 转换结果格式
      const toolResult: MCPToolResult = {
        success: true,
        content: (result.content || []).map((content) => {
          if (content.type === "text") {
            return {
              type: "text" as const,
              text: content.text || "",
            };
          } else if (content.type === "image") {
            return {
              type: "image" as const,
              mimeType: content.mimeType,
              data: content.data,
            };
          } else {
            return {
              type: "resource" as const,
              text: (content as any).text,
            };
          }
        }),
        duration,
        metadata: {
          toolType: "mcp",
          source: this.config.id,
          toolName: call.tool,
        },
      };

      logger.debug(`[MCP] Tool ${call.tool} executed successfully in ${duration}ms`);

      return toolResult;
    } catch (error: any) {
      const duration = Date.now() - startTime;

      // 更新指标
      this.updateMetrics(false, duration);

      logger.error(`[MCP] Tool ${call.tool} failed:`, error);

      return {
        success: false,
        content: [],
        duration,
        error: {
          code: "TOOL_EXECUTION_ERROR",
          message: error.message || "Unknown error",
        },
      };
    }
  }

  /**
   * 更新最后活动时间
   */
  updateLastActivity(): void {
    this.lastActivity = new Date();
  }

  /**
   * 更新指标
   */
  private updateMetrics(success: boolean, responseTime: number): void {
    this.metrics.totalCalls++;
    this.metrics.successfulCalls += success ? 1 : 0;
    this.metrics.failedCalls += success ? 0 : 1;

    // 计算平均响应时间
    this.metrics.averageResponseTime =
      (this.metrics.averageResponseTime * (this.metrics.totalCalls - 1) + responseTime) /
      this.metrics.totalCalls;
  }

  /**
   * 启动监控
   */
  private startMonitoring(): void {
    // 更新运行时间
    this.monitoringTimer = setInterval(() => {
      if (this.status.phase === "running" && this.status.startTime) {
        this.status.uptime = Date.now() - this.status.startTime.getTime();
      }
    }, 1000);
  }

  /**
   * 获取服务器配置
   */
  getConfig(): MCPServerConfig {
    return this.config;
  }

  /**
   * 获取服务器状态
   */
  getStatus(): MCPServerStatus {
    return { ...this.status };
  }

  /**
   * 获取可用工具
   */
  getTools(): MCPTool[] {
    return [...this.tools];
  }

  /**
   * 获取最后活动时间
   */
  getLastActivity(): Date | undefined {
    return this.lastActivity;
  }

  /**
   * 获取指标
   */
  getMetrics(): ServerMetrics {
    return { ...this.metrics };
  }

  /**
   * 重启服务器
   */
  async restart(): Promise<void> {
    logger.info(`[MCP] Restarting server ${this.config.id}...`);

    await this.shutdown();
    await this.initialize();
  }

  /**
   * 关闭服务器
   */
  async shutdown(): Promise<void> {
    try {
      if (
        this.status.phase === "running" ||
        this.status.phase === "starting" ||
        this.status.phase === "initializing"
      ) {
        logger.info(`[MCP] Shutting down server ${this.config.id}...`);

        this.status = {
          phase: "shutting-down",
          message: "Shutting down...",
          uptime: this.status.startTime ? Date.now() - this.status.startTime.getTime() : 0,
          startTime: this.status.startTime,
        };

        this.emit("status-changed", this.status);

        // 清除监控定时器
        if (this.monitoringTimer) {
          clearInterval(this.monitoringTimer);
          this.monitoringTimer = null;
        }

        // 1. 先关闭 MCP 客户端连接（优雅关闭）
        if (this.client) {
          try {
            await this.client.close();
          } catch (e) {
            // 忽略关闭时的错误
            logger.debug(`[MCP] Client close error (ignored): ${e}`);
          }
          this.client = undefined;
        }

        // 2. 关闭传输层
        if (this.transport) {
          try {
            await this.transport.close();
          } catch (e) {
            // 忽略关闭时的错误
            logger.debug(`[MCP] Transport close error (ignored): ${e}`);
          }
          this.transport = undefined;
        }

        // 3. 移除进程事件监听器
        if (this.process && this.processErrorListener) {
          this.process.removeListener("error", this.processErrorListener);
          this.processErrorListener = undefined;
        }

        // 4. 优雅终止子进程
        if (this.process && !this.process.killed) {
          await this.gracefulKillProcess();
        }

        this.metrics.endTime = new Date();

        this.status = {
          phase: "stopped",
          message: "Server stopped",
          uptime: this.status.uptime,
          startTime: this.status.startTime,
        };

        this.emit("status-changed", this.status);

        logger.info(`[MCP] Server ${this.config.id} shut down`);
      }
    } catch (error: any) {
      logger.error(`[MCP] Error during shutdown of server ${this.config.id}:`, error);

      this.status = {
        phase: "error",
        message: "Shutdown failed",
        error: error.message,
        uptime: this.status.uptime,
        startTime: this.status.startTime,
      };

      this.emit("status-changed", this.status);
    }
  }

  /**
   * 优雅终止子进程
   * 先发送 SIGTERM，等待进程退出，超时后强制 SIGKILL
   */
  private async gracefulKillProcess(): Promise<void> {
    if (!this.process) return;

    const proc = this.process;
    const serverId = this.config.id;

    return new Promise<void>((resolve) => {
      let killed = false;

      // 监听进程退出
      const onExit = () => {
        killed = true;
        resolve();
      };

      proc.once("exit", onExit);
      proc.once("close", onExit);

      // 关闭 stdin 以通知子进程关闭
      if (proc.stdin && !proc.stdin.destroyed) {
        proc.stdin.end();
      }

      // 发送 SIGTERM
      proc.kill("SIGTERM");

      // 设置超时，3秒后强制 SIGKILL
      setTimeout(() => {
        if (!killed && proc && !proc.killed) {
          logger.warn(`[MCP] Server ${serverId} did not exit gracefully, forcing SIGKILL`);
          proc.kill("SIGKILL");
        }
        resolve();
      }, 3000);
    }).finally(() => {
      this.process = undefined;
    });
  }
}
````

## File: src/services/ModelRegistry.ts
````typescript
/**
 * ModelRegistry - 模型注册表服务
 * 
 * 提供快速的模型查询和缓存功能
 */

import { logger } from '../utils/logger';
import { LLMConfigService } from './LLMConfigService';
import { LLMModelType, LLMModelFull } from '../types/llm-models';

/**
 * 模型注册表
 */
export class ModelRegistry {
  private static instance: ModelRegistry;
  private configService: LLMConfigService;
  private modelCache: Map<number, LLMModelFull>;
  private defaultModelCache: Map<LLMModelType, LLMModelFull>;
  private typeIndexCache: Map<LLMModelType, LLMModelFull[]>;
  private keyIndexCache: Map<string, LLMModelFull>; // 🆕 Key 索引: "provider:modelKey" -> model
  private lastRefreshTime: number;
  private refreshInterval: number;

  private constructor() {
    this.configService = LLMConfigService.getInstance();
    this.modelCache = new Map();
    this.defaultModelCache = new Map();
    this.typeIndexCache = new Map();
    this.keyIndexCache = new Map(); // 🆕 初始化 Key 索引
    this.lastRefreshTime = 0;
    this.refreshInterval = 60000; // 60 秒刷新间隔

    this.refreshCache();
    logger.debug('ModelRegistry initialized');
  }

  /**
   * 获取单例实例
   */
  public static getInstance(): ModelRegistry {
    if (!ModelRegistry.instance) {
      ModelRegistry.instance = new ModelRegistry();
    }
    return ModelRegistry.instance;
  }

  /**
   * 刷新缓存
   */
  public refreshCache(): void {
    try {
      // 清空旧缓存
      this.modelCache.clear();
      this.defaultModelCache.clear();
      this.typeIndexCache.clear();
      this.keyIndexCache.clear(); // 🆕 清空 Key 索引

      // 加载所有启用的模型
      const models = this.configService.listModels({ enabled: true });

      // 构建缓存
      models.forEach(model => {
        // 只缓存提供商也启用的模型
        if (!model.providerEnabled) {
          return;
        }

        // ID 索引
        this.modelCache.set(model.id, model);

        // 类型索引
        if (!this.typeIndexCache.has(model.modelType as LLMModelType)) {
          this.typeIndexCache.set(model.modelType as LLMModelType, []);
        }
        this.typeIndexCache.get(model.modelType as LLMModelType)!.push(model);

        // 默认模型索引
        if (model.isDefault) {
          this.defaultModelCache.set(model.modelType as LLMModelType, model);
        }

        // 🆕 Key 索引 (Provider + ModelKey) - 用于 O(1) 查找
        const uniqueKey = `${model.provider}:${model.modelKey}`;
        this.keyIndexCache.set(uniqueKey, model);
      });

      this.lastRefreshTime = Date.now();
      logger.debug(`✅ ModelRegistry cache refreshed: ${models.length} models`);
    } catch (error: any) {
      logger.error('❌ Failed to refresh ModelRegistry cache:', error);
    }
  }

  /**
   * 检查缓存是否需要刷新
   */
  private checkRefresh(): void {
    const now = Date.now();
    if (now - this.lastRefreshTime > this.refreshInterval) {
      this.refreshCache();
    }
  }

  /**
   * 根据 ID 获取模型
   */
  public getModelById(modelId: number): LLMModelFull | null {
    this.checkRefresh();
    return this.modelCache.get(modelId) || null;
  }

  /**
   * 获取默认模型
   */
  public getDefaultModel(modelType: LLMModelType): LLMModelFull | null {
    this.checkRefresh();
    return this.defaultModelCache.get(modelType) || null;
  }

  /**
   * 按类型获取所有模型
   */
  public getModelsByType(modelType: LLMModelType): LLMModelFull[] {
    this.checkRefresh();
    return this.typeIndexCache.get(modelType) || [];
  }

  /**
   * 获取所有模型
   */
  public getAllModels(): LLMModelFull[] {
    this.checkRefresh();
    return Array.from(this.modelCache.values());
  }

  /**
   * 获取所有 NLP 模型
   */
  public getNLPModels(): LLMModelFull[] {
    return this.getModelsByType(LLMModelType.NLP);
  }

  /**
   * 获取所有 Embedding 模型
   */
  public getEmbeddingModels(): LLMModelFull[] {
    return this.getModelsByType(LLMModelType.EMBEDDING);
  }

  /**
   * 获取所有 Rerank 模型
   */
  public getRerankModels(): LLMModelFull[] {
    return this.getModelsByType(LLMModelType.RERANK);
  }

  /**
   * 查找模型（按 provider + modelKey）
   * ⚡️ 优化为 O(1) 查找（使用 Key 索引）
   */
  public findModel(provider: string, modelKey: string): LLMModelFull | null {
    this.checkRefresh();
    
    // 🆕 使用 Key 索引实现 O(1) 查找
    const uniqueKey = `${provider}:${modelKey}`;
    return this.keyIndexCache.get(uniqueKey) || null;
  }

  /**
   * 获取缓存统计信息
   */
  public getStats() {
    this.checkRefresh();
    
    return {
      totalModels: this.modelCache.size,
      modelsByType: {
        nlp: this.getModelsByType(LLMModelType.NLP).length,
        embedding: this.getModelsByType(LLMModelType.EMBEDDING).length,
        rerank: this.getModelsByType(LLMModelType.RERANK).length,
        image: this.getModelsByType(LLMModelType.IMAGE).length,
        audio: this.getModelsByType(LLMModelType.AUDIO).length
      },
      defaultModels: this.defaultModelCache.size,
      lastRefreshTime: this.lastRefreshTime,
      cacheAge: Date.now() - this.lastRefreshTime
    };
  }

  /**
   * 强制刷新（立即）
   */
  public forceRefresh(): void {
    this.refreshCache();
  }

  /**
   * 设置刷新间隔
   */
  public setRefreshInterval(intervalMs: number): void {
    this.refreshInterval = intervalMs;
  }
}
````

## File: src/services/PathService.ts
````typescript
/**
 * PathService - 路径管理服务
 * 统一管理项目中的所有路径，支持环境变量覆盖
 */

import * as path from 'path';
import * as fs from 'fs';
import { logger } from '../utils/logger';

export interface PathConfig {
  /** 项目根目录（默认为 process.cwd()） */
  rootDir?: string;
  /** 配置目录（默认为 {rootDir}/config） */
  configDir?: string;
  /** 数据目录（默认为 {rootDir}/data） */
  dataDir?: string;
  /** 日志目录（默认为 {rootDir}/logs） */
  logDir?: string;
  /** 向量存储目录（从配置读取） */
  vectorStoreDir?: string;
}

/**
 * 路径服务单例
 */
export class PathService {
  private static instance: PathService;
  private config: Required<PathConfig>;

  private constructor() {
    // 从环境变量或默认值初始化配置
    const rootDir = process.env.APEX_BRIDGE_ROOT_DIR || process.cwd();
    
    this.config = {
      rootDir: path.resolve(rootDir),
      configDir: path.resolve(
        process.env.APEX_BRIDGE_CONFIG_DIR || path.join(rootDir, 'config')
      ),
      dataDir: path.resolve(
        process.env.APEX_BRIDGE_DATA_DIR || path.join(rootDir, '.data')
      ),
      logDir: path.resolve(
        process.env.APEX_BRIDGE_LOG_DIR || path.join(rootDir, 'logs')
      ),
      vectorStoreDir: path.resolve(
        process.env.APEX_BRIDGE_VECTOR_STORE_DIR || path.join(rootDir, 'vector_store')
      )
    };

    logger.debug('✅ PathService initialized:', {
      rootDir: this.config.rootDir,
      configDir: this.config.configDir
    });
  }

  public static getInstance(): PathService {
    if (!PathService.instance) {
      PathService.instance = new PathService();
    }
    return PathService.instance;
  }

  /**
   * 获取项目根目录
   */
  public getRootDir(): string {
    return this.config.rootDir;
  }

  /**
   * 获取配置目录
   */
  public getConfigDir(): string {
    return this.config.configDir;
  }

  /**
   * 获取数据目录
   */
  public getDataDir(): string {
    return this.config.dataDir;
  }

  /**
   * 获取日志目录
   */
  public getLogDir(): string {
    return this.config.logDir;
  }

  /**
   * 获取向量存储目录（可动态更新）
   */
  public getVectorStoreDir(): string {
    return this.config.vectorStoreDir;
  }

  /**
   * 设置向量存储目录（从配置读取）
   */
  public setVectorStoreDir(vectorStoreDir: string): void {
    this.config.vectorStoreDir = path.resolve(vectorStoreDir);
  }

  /**
   * 获取配置文件路径
   */
  public getConfigFilePath(): string {
    return path.join(this.config.configDir, 'admin-config.json');
  }

  /**
   * 获取配置文件备份路径
   */
  public getConfigBackupPath(): string {
    return path.join(this.config.configDir, 'admin-config.json.backup');
  }

  /**
   * 确保目录存在（如果不存在则创建）
   * 
   * @param dirPath - 目录路径
   * @throws 如果创建目录失败（非 EEXIST 错误）
   */
  public ensureDir(dirPath: string): void {
    if (!fs.existsSync(dirPath)) {
      try {
        fs.mkdirSync(dirPath, { recursive: true, mode: 0o755 });
        logger.debug(`✅ Created directory: ${dirPath}`);
      } catch (error: any) {
        // 如果并发创建导致 EEXIST，通常可以忽略
        // 但如果是 EACCES 等权限错误，需要记录并抛出
        if (error.code !== 'EEXIST') {
          logger.error(`❌ Failed to create directory ${dirPath}:`, error);
          throw error;
        }
        // EEXIST 错误通常表示目录已存在（可能是并发创建），可以安全忽略
        logger.debug(`⚠️ Directory already exists (concurrent creation?): ${dirPath}`);
      }
    }
  }

  /**
   * 确保所有必要的目录都存在
   * 
   * @throws 如果关键目录创建失败，应阻断启动
   */
  public ensureAllDirs(): void {
    try {
      this.ensureDir(this.config.configDir);
      this.ensureDir(this.config.dataDir);
      this.ensureDir(this.config.logDir);
      // vectorStoreDir 可能从配置读取，在需要时确保
    } catch (error) {
      logger.error('❌ Failed to initialize project directories', error);
      throw error; // 关键目录创建失败应阻断启动
    }
  }

  /**
   * 更新配置（从ConfigService读取的配置）
   */
  public updateFromConfig(config: { rag?: { storagePath?: string } }): void {
    if (config.rag?.storagePath) {
      this.setVectorStoreDir(config.rag.storagePath);
    }
  }

  /**
   * 获取所有路径配置（用于调试）
   */
  public getAllPaths(): PathConfig {
    return { ...this.config };
  }
}
````

## File: src/services/SystemPromptService.ts
````typescript
/**
 * SystemPromptService - 系统提示词服务
 * 极简实现：只有一份全局配置，通过{{variable}}占位符动态注入
 *
 * @author 浮浮酱
 * @date 2025-11-30
 */

import * as fs from 'fs';
import * as path from 'path';
import { VariableEngine } from '../core/variable/VariableEngine';
import { logger } from '../utils/logger';

/**
 * 系统提示词配置接口
 */
export interface SystemPromptConfig {
  /** 模板内容 (支持{{variable}}语法) */
  template: string;

  /** 是否启用 */
  enabled: boolean;

  /** 默认变量 */
  variables?: Record<string, any>;

  /** 版本 */
  version?: string;
}

/**
 * 系统提示词服务 - 极简实现
 *
 * 特点：
 * - 只有一份全局配置
 * - 启动时加载，无热更新
 * - 通过{{variable}}占位符动态注入
 * - 无管理接口，通过编辑配置文件修改
 */
export class SystemPromptService {
  private configPath: string;
  private config: SystemPromptConfig;
  private variableEngine: VariableEngine;

  constructor(configDir: string = './config') {
    this.configPath = path.join(configDir, 'system-prompt.md');

    // 初始化VariableEngine（简化版，无缓存）
    this.variableEngine = new VariableEngine();

    // 加载配置文件（仅一次）
    this.loadConfig();
  }

  /**
   * 加载配置文件
   */
  private loadConfig(): void {
    try {
      if (!fs.existsSync(this.configPath)) {
        logger.warn('[SystemPromptService] Config file not found:', this.configPath);
        this.config = {
          template: '',
          enabled: false
        };
        return;
      }

      const content = fs.readFileSync(this.configPath, 'utf-8');
      
      // 检查文件扩展名来确定解析方式
      const fileExt = path.extname(this.configPath).toLowerCase();
      
      if (fileExt === '.md') {
        // Markdown文件：直接使用内容作为模板
        this.config = {
          template: content,
          enabled: true,
          version: '1.0.0'
        };
        logger.debug('[SystemPromptService] Markdown config loaded');
      } else {
        // JSON文件：解析为配置对象
        this.config = JSON.parse(content);
        logger.info(`[SystemPromptService] JSON config loaded (version: ${this.config.version || '1.0.0'})`);
      }

    } catch (error) {
      logger.error('[SystemPromptService] Failed to load config:', error);
      this.config = {
        template: '',
        enabled: false
      };
    }
  }

  /**
   * 获取系统提示词模板（原始模板，不进行变量替换）
   *
   * @returns 原始模板字符串，如果没有配置或禁用返回null
   */
  getSystemPromptTemplate(): string | null {
    // 检查全局配置是否启用
    if (this.config.enabled && this.config.template) {
      logger.debug('[SystemPromptService] Returning system prompt template');
      return this.config.template;
    }

    // 没有配置或已禁用
    logger.debug('[SystemPromptService] System prompt disabled or not configured');
    return null;
  }



  /**
   * 更新全局系统提示词配置（运行时）
   *
   * @param config 新配置
   * @param saveToFile 是否保存到文件（默认false）
   */
  updateConfig(config: SystemPromptConfig, saveToFile: boolean = false): void {
    this.config = {
      ...config,
      enabled: config.enabled ?? true
    };

    logger.info('[SystemPromptService] Config updated');

    if (saveToFile) {
      this.saveConfigToFile();
    }
  }

  /**
   * 保存配置到文件
   */
  private saveConfigToFile(): void {
    try {
      const content = JSON.stringify(this.config, null, 2);
      fs.writeFileSync(this.configPath, content, 'utf-8');
      logger.info('[SystemPromptService] Config saved to file');
    } catch (error) {
      logger.error('[SystemPromptService] Failed to save config:', error);
    }
  }

  /**
   * 获取当前配置（调试用）
   */
  getConfig(): Readonly<SystemPromptConfig> {
    return { ...this.config };
  }

  /**
   * 清理资源
   */
  cleanup(): void {
    // 无需清理（没有文件监听器）
    logger.debug('[SystemPromptService] Cleanup completed');
  }
}
````

## File: src/strategies/ChatStrategy.ts
````typescript
/**
 * ChatStrategy - 聊天处理策略接口
 * 定义所有聊天处理策略的契约
 */

import type { Message, ChatOptions } from '../types';

/**
 * 策略执行结果接口
 */
export interface ChatResult {
  content: string;
  usage?: any;
  iterations?: number;
  thinkingProcess?: string;
  rawThinkingProcess?: string[];  // 原始思考过程（供ChatService统一存储）
}

/**
 * 策略准备结果接口
 * 包含策略需要注入的变量
 */
export interface StrategyPrepareResult {
  /** 需要注入到消息中的变量 */
  variables: Record<string, string>;
}

/**
 * 聊天处理策略接口
 * 支持同步和异步/流式两种模式
 */
export interface ChatStrategy {
  /**
   * 准备阶段：初始化策略并返回需要注入的变量
   * ChatService 会在变量替换阶段使用这些变量
   * @param messages 消息数组（用于上下文分析，如工具发现）
   * @param options 聊天选项
   * @returns 准备结果，包含需要注入的变量
   */
  prepare?(messages: Message[], options: ChatOptions): Promise<StrategyPrepareResult>;

  /**
   * 执行聊天处理
   * @param messages 消息数组（已完成变量替换）
   * @param options 聊天选项
   * @returns 结果（Promise for 单轮，AsyncGenerator for 流式）
   */
  execute(messages: Message[], options: ChatOptions): Promise<ChatResult> | AsyncGenerator<any>;

  /**
   * 流式执行聊天处理
   * @param messages 消息数组（已完成变量替换）
   * @param options 聊天选项
   * @param abortSignal 中断信号
   * @returns 流式结果
   */
  stream(messages: Message[], options: ChatOptions, abortSignal?: AbortSignal): AsyncIterableIterator<any>;

  /**
   * 检查策略是否支持给定的选项
   * @param options 聊天选项
   * @returns true if 支持
   */
  supports(options: ChatOptions): boolean;

  /**
   * 策略名称（用于调试和日志）
   */
  getName(): string;
}
````

## File: src/types/config/admin.ts
````typescript
/**
 * 管理员配置类型定义
 *
 * ACE 功能已删除 (2026-01-11)
 */

import type { ApiKeyInfo } from "./api-key";
import type { RateLimitSettings } from "./rate-limit";
import type { RedisConfig } from "./redis";

/**
 * API 配置
 */
export interface ApiConfig {
  /** 主机地址 */
  host?: string;
  /** 端口 */
  port?: number;
  /** CORS 配置 */
  cors?: {
    /** 允许的源 */
    origin?: string | string[];
    /** 是否支持凭证 */
    credentials?: boolean;
  };
}

/**
 * LLM 提供商配置项
 */
export interface LLMProviderItem {
  /** 提供商 ID */
  id: string;
  /** 提供商标识 */
  provider: string;
  /** 提供商名称 */
  name: string;
  /** 提供商配置 */
  config: Record<string, unknown>;
  /** 是否启用 */
  enabled: boolean;
  /** 创建时间戳 */
  createdAt: number;
  /** 更新时间戳 */
  updatedAt: number;
}

/**
 * LLM 配置
 */
export interface LLMConfig {
  /** LLM 提供商列表 */
  providers?: LLMProviderItem[];
  /** 默认提供商 */
  defaultProvider?: string;
  /** 备用提供商 */
  fallbackProvider?: string;
  /** 请求超时（毫秒） */
  timeout?: number;
  /** 最大重试次数 */
  maxRetries?: number;
}

/**
 * 认证配置
 */
export interface AuthConfig {
  /** 是否启用认证 */
  enabled: boolean;
  /** API Key */
  apiKey?: string;
  /** JWT 密钥 */
  jwtSecret?: string;
  /** JWT 过期时间 */
  jwtExpiresIn?: string;
  /** API Key 列表 */
  apiKeys?: ApiKeyInfo[];
}

/**
 * 日志配置
 */
export interface LoggingConfig {
  /** 日志级别 */
  level?: string;
  /** 日志文件路径 */
  file?: string;
}

/**
 * 性能配置
 */
export interface PerformanceConfig {
  /** 工作线程池大小 */
  workerPoolSize?: number;
  /** 请求超时（毫秒） */
  requestTimeout?: number;
  /** 最大请求大小 */
  maxRequestSize?: string;
}

/**
 * 安全配置
 */
export interface SecurityConfig {
  /** 速率限制设置 */
  rateLimit?: RateLimitSettings;
}

/**
 * 管理员配置（主配置类型）
 */
export interface AdminConfig {
  /** API 配置 */
  api: ApiConfig;
  /** LLM 配置 */
  llm: LLMConfig;
  /** 认证配置 */
  auth: AuthConfig;
  /** 日志配置 */
  logging?: LoggingConfig;
  /** 性能配置 */
  performance?: PerformanceConfig;
  /** Redis 配置 */
  redis?: RedisConfig;
  /** 安全配置 */
  security?: SecurityConfig;
  /** 设置完成状态 */
  setup_completed?: boolean;
  /** 允许动态属性 */
  [key: string]: unknown;
}

/**
 * 路径配置
 */
export interface PathsConfig {
  /** 根目录 */
  rootDir: string;
  /** 配置目录 */
  configDir: string;
  /** 数据目录 */
  dataDir: string;
  /** 日志目录 */
  logDir: string;
  /** 向量存储目录 */
  vectorStoreDir: string;
}

/**
 * 安全配置（系统级）
 */
export interface SystemSecurityConfig {
  /** ABP API Key */
  abpApiKey: string;
  /** JWT 密钥 */
  jwtSecret: string;
  /** 宪法文件路径 */
  constitutionPath: string;
}

/**
 * 环境配置
 */
export interface EnvironmentConfig {
  /** Node 环境 */
  nodeEnv: string;
  /** 日志级别 */
  logLevel: string;
  /** 日志文件路径 */
  logFile: string;
  /** 最大请求大小 */
  maxRequestSize: string;
  /** 安全日志级别 */
  securityLogLevel: string;
  /** 是否启用安全日志 */
  securityLogEnabled: boolean;
  /** 是否详细日志 */
  verboseLogging: boolean;
}

/**
 * 数据库配置
 */
export interface DatabaseConfig {
  /** SQLite 数据库路径 */
  sqlitePath: string;
  /** LanceDB 路径 */
  lancedbPath: string;
}

/**
 * 系统级配置接口
 */
export interface SystemConfig {
  /** 服务端口 */
  port: number;
  /** 是否自动启动 */
  autostart: boolean;
  /** 路径配置 */
  paths: PathsConfig;
  /** 安全配置 */
  security: SystemSecurityConfig;
  /** 环境配置 */
  environment: EnvironmentConfig;
  /** 数据库配置 */
  database: DatabaseConfig;
}

/**
 * 完整配置接口（系统级 + 应用级）
 */
export interface FullConfig {
  /** 系统级配置 */
  port: number;
  autostart: boolean;
  paths: PathsConfig;
  systemSecurity: SystemSecurityConfig;
  environment: EnvironmentConfig;
  database: DatabaseConfig;
  /** 应用级配置 */
  setup_completed?: boolean;
  api?: ApiConfig;
  auth?: AuthConfig;
  performance?: PerformanceConfig;
  redis?: RedisConfig;
  appSecurity?: SecurityConfig;
}
````

## File: src/types/config/index.ts
````typescript
/**
 * 配置类型统一导出
 *
 * ACE 功能已删除 (2026-01-11)
 */

// API Key 类型
export type { ApiKeyInfo } from "./api-key";

// 速率限制类型
export type {
  RateLimitStrategyType,
  RateLimitStrategyConfig,
  RateLimitMatcherConfig,
  RateLimitRuleConfig,
  RateLimitHeadersConfig,
  RateLimitSettings,
} from "./rate-limit";

// Redis 配置类型
export type { RedisConfig } from "./redis";

// Admin 配置类型
export type {
  AdminConfig,
  ApiConfig,
  LLMProviderItem,
  LLMConfig,
  AuthConfig,
  LoggingConfig,
  PerformanceConfig,
  SecurityConfig,
  SystemConfig,
  FullConfig,
  PathsConfig,
  SystemSecurityConfig,
  EnvironmentConfig,
  DatabaseConfig,
  // PlaybookConfig 已移除
} from "./admin";
````

## File: src/types/abp.ts
````typescript
/**
 * ABP (ApexBridge Protocol) Type Definitions
 * 
 * ABP协议类型定义（ABP-only）
 */

/**
 * ABP消息角色
 */
export type ABPMessageRole = 'system' | 'user' | 'assistant';

/**
 * ABP消息
 */
export interface ABPMessage {
  /** 消息角色（必需） */
  role: ABPMessageRole;
  /** 消息内容（必需） */
  content: string;
  /** 消息时间戳（可选） */
  timestamp?: number;
}

/**
 * ABP协议配置
 */
export interface ABPProtocolConfig {
  /** 是否启用双协议模式 */
  dualProtocolEnabled?: boolean;
  /** 是否启用错误恢复 */
  errorRecoveryEnabled?: boolean;
  /** JSON修复配置 */
  jsonRepair?: {
    enabled: boolean;
    strict: boolean;
  };
  /** 噪声文本剥离配置 */
  noiseStripping?: {
    enabled: boolean;
    aggressive: boolean;
  };
  /** 协议边界校验配置 */
  boundaryValidation?: {
    enabled: boolean;
    strict: boolean;
  };
  /** Fallback配置 */
  fallback?: {
    enabled: boolean;
    toPlainText: boolean;
  };
  /** 变量系统配置 */
  variable?: {
    /** 是否启用变量缓存 */
    cacheEnabled?: boolean;
    /** 缓存过期时间（毫秒） */
    cacheTTL?: number;
  };
}
````

## File: src/utils/errors.ts
````typescript
/**
 * 统一错误处理工具
 * 标准化错误响应格式和错误码
 */

/**
 * 错误码枚举
 */
export enum ErrorCode {
  // 通用错误 (1000-1999)
  INTERNAL_ERROR = 'INTERNAL_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  NOT_FOUND = 'NOT_FOUND',
  FORBIDDEN = 'FORBIDDEN',
  
  // 认证错误 (2000-2999)
  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR',
  UNAUTHORIZED = 'UNAUTHORIZED',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',
  INVALID_TOKEN = 'INVALID_TOKEN',
  INVALID_CREDENTIALS = 'INVALID_CREDENTIALS',
  MISSING_AUTHORIZATION = 'MISSING_AUTHORIZATION',
  
  // 配置错误 (3000-3999)
  CONFIG_ERROR = 'CONFIG_ERROR',
  MISSING_CONFIG = 'MISSING_CONFIG',
  INVALID_CONFIG = 'INVALID_CONFIG',
  
  // 请求错误 (4000-4999)
  BAD_REQUEST = 'BAD_REQUEST',
  INVALID_PARAMETER = 'INVALID_PARAMETER',
  MISSING_PARAMETER = 'MISSING_PARAMETER',
  
  // 服务错误 (5000-5999)
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  TIMEOUT = 'TIMEOUT',
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
  
  // 插件错误 (6000-6999)
  PLUGIN_ERROR = 'PLUGIN_ERROR',
  PLUGIN_NOT_FOUND = 'PLUGIN_NOT_FOUND',
  PLUGIN_EXECUTION_FAILED = 'PLUGIN_EXECUTION_FAILED',
  
  // LLM错误 (7000-7999)
  LLM_ERROR = 'LLM_ERROR',
  LLM_TIMEOUT = 'LLM_TIMEOUT',
  LLM_QUOTA_EXCEEDED = 'LLM_QUOTA_EXCEEDED',
  LLM_INVALID_RESPONSE = 'LLM_INVALID_RESPONSE'
}

/**
 * 统一错误类
 */
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly code: ErrorCode;
  public readonly type: string;
  public readonly details?: any;
  public readonly timestamp: number;

  constructor(
    message: string,
    statusCode: number = 500,
    code: ErrorCode = ErrorCode.INTERNAL_ERROR,
    details?: any
  ) {
    super(message);
    this.name = 'AppError';
    this.statusCode = statusCode;
    this.code = code;
    this.type = this.getErrorType(statusCode);
    this.details = details;
    this.timestamp = Date.now();

    // 保持堆栈跟踪
    Error.captureStackTrace(this, this.constructor);
  }

  /**
   * 根据状态码获取错误类型
   */
  private getErrorType(statusCode: number): string {
    if (statusCode >= 400 && statusCode < 500) {
      return 'client_error';
    } else if (statusCode >= 500) {
      return 'server_error';
    }
    return 'unknown_error';
  }

  /**
   * 转换为JSON格式（用于响应）
   */
  toJSON() {
    return {
      error: {
        message: this.message,
        code: this.code,
        type: this.type,
        ...(this.details && { details: this.details })
      }
    };
  }
}

/**
 * 创建常用错误的工厂函数
 */
export const createError = {
  /**
   * 内部服务器错误
   */
  internal: (message: string = 'Internal server error', details?: any) =>
    new AppError(message, 500, ErrorCode.INTERNAL_ERROR, details),

  /**
   * 未授权错误
   */
  unauthorized: (message: string = 'Unauthorized', details?: any) =>
    new AppError(message, 401, ErrorCode.UNAUTHORIZED, details),

  /**
   * 禁止访问错误
   */
  forbidden: (message: string = 'Forbidden', details?: any) =>
    new AppError(message, 403, ErrorCode.FORBIDDEN, details),

  /**
   * 未找到错误
   */
  notFound: (message: string = 'Resource not found', details?: any) =>
    new AppError(message, 404, ErrorCode.NOT_FOUND, details),

  /**
   * 请求错误
   */
  badRequest: (message: string = 'Bad request', details?: any) =>
    new AppError(message, 400, ErrorCode.BAD_REQUEST, details),

  /**
   * 验证错误
   */
  validation: (message: string = 'Validation error', details?: any) =>
    new AppError(message, 400, ErrorCode.VALIDATION_ERROR, details),

  /**
   * 认证错误
   */
  authentication: (message: string = 'Authentication failed', details?: any) =>
    new AppError(message, 401, ErrorCode.AUTHENTICATION_ERROR, details),

  /**
   * Token过期错误
   */
  tokenExpired: (message: string = 'Token expired', details?: any) =>
    new AppError(message, 401, ErrorCode.TOKEN_EXPIRED, details),

  /**
   * 配置错误
   */
  config: (message: string = 'Configuration error', details?: any) =>
    new AppError(message, 500, ErrorCode.CONFIG_ERROR, details),

  /**
   * 服务不可用错误
   */
  serviceUnavailable: (message: string = 'Service unavailable', details?: any) =>
    new AppError(message, 503, ErrorCode.SERVICE_UNAVAILABLE, details),

  /**
   * 超时错误
   */
  timeout: (message: string = 'Request timeout', details?: any) =>
    new AppError(message, 408, ErrorCode.TIMEOUT, details)
};

/**
 * 判断是否为AppError实例
 */
export function isAppError(error: any): error is AppError {
  return error instanceof AppError;
}

/**
 * 将任何错误转换为AppError
 */
export function normalizeError(error: any): AppError {
  if (isAppError(error)) {
    return error;
  }

  // 如果是已知的HTTP错误
  if (error.statusCode) {
    return new AppError(
      error.message || 'Unknown error',
      error.statusCode,
      error.code || ErrorCode.INTERNAL_ERROR,
      error.details
    );
  }

  // 默认内部错误
  return createError.internal(error.message || 'Unknown error', error);
}
````

## File: src/utils/logger.ts
````typescript
/**
 * ApexBridge - 简化日志系统
 */

import winston from 'winston';

const logFormat = winston.format.combine(
  winston.format.timestamp({ format: 'HH:mm:ss' }),
  winston.format.errors({ stack: true }),
  winston.format.printf(({ timestamp, level, message, stack }) => {
    let log = `[${timestamp}] ${message}`;
    if (stack) {
      log += `\n${stack}`;
    }
    return log;
  })
);

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'warn',
  format: logFormat,
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        logFormat
      )
    })
  ]
});

// 生产环境只输出 warn 和 error
if (process.env.NODE_ENV === 'production') {
  logger.level = 'warn';
}

export default logger;
````

## File: src/api/middleware/sanitizationMiddleware.ts
````typescript
/**
 * Sanitization Middleware - 简化输入清理中间件
 *
 * 提供基本的输入清理功能，防止常见的注入攻击
 */

import { Request, Response, NextFunction } from "express";
import { logger } from "../../utils/logger";

/**
 * 基本清理选项
 */
export interface SanitizationOptions {
  skipFields?: string[];
}

/**
 * 移除HTML标签
 */
function removeHtmlTags(input: string): string {
  if (!input || typeof input !== "string") {
    return input;
  }
  return input.replace(/<[^>]*>/g, "");
}

/**
 * 防止SQL注入和命令注入
 */
function preventInjections(input: string): string {
  if (!input || typeof input !== "string") {
    return input;
  }

  // 移除危险字符
  return input
    .replace(/['";\\]/g, "") // SQL注入
    .replace(/[&|`$(){}[\];<>]/g, "") // 命令注入
    .replace(/\.\./g, "") // 路径遍历
    .replace(/--.*$/gm, "") // SQL注释
    .replace(/\/\*[\s\S]*?\*\//g, ""); // 多行注释
}

/**
 * 清理字符串
 */
function sanitizeString(value: string, options?: SanitizationOptions): string {
  if (!value || typeof value !== "string") {
    return value;
  }

  // 基础清理
  let sanitized = removeHtmlTags(value);
  sanitized = preventInjections(sanitized);

  // 限制长度，防止过长输入
  return sanitized.substring(0, 10000);
}

/**
 * 递归清理对象
 */
function sanitizeObject<T>(obj: T, options?: SanitizationOptions, fieldPath: string = ""): T {
  if (!obj || typeof obj !== "object") {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map((item, index) => sanitizeObject(item, options, `${fieldPath}[${index}]`)) as T;
  }

  const sanitized: Record<string, unknown> = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const currentPath = fieldPath ? `${fieldPath}.${key}` : key;
      const value = (obj as Record<string, unknown>)[key];

      // 检查是否需要跳过敏感字段
      if (options?.skipFields?.includes(key) || options?.skipFields?.includes(currentPath)) {
        sanitized[key] = value;
      } else if (typeof value === "string") {
        sanitized[key] = sanitizeString(value, options);
      } else if (typeof value === "object") {
        sanitized[key] = sanitizeObject(value, options, currentPath);
      } else {
        sanitized[key] = value;
      }
    }
  }

  return sanitized as T;
}

/**
 * 创建简化清理中间件
 */
export function createSanitizationMiddleware(
  options?: SanitizationOptions
): (req: Request, res: Response, next: NextFunction) => void {
  const defaultOptions: SanitizationOptions = {
    skipFields: ["password", "token", "secret", "key"],
  };

  const sanitizationOptions = { ...defaultOptions, ...options };

  return (req: Request, res: Response, next: NextFunction) => {
    try {
      // 清理请求体
      if (req.body) {
        req.body = sanitizeObject(req.body, sanitizationOptions, "body");
      }

      // 清理查询参数
      if (req.query) {
        req.query = sanitizeObject(req.query, sanitizationOptions, "query");
      }

      // 清理路径参数
      if (req.params) {
        req.params = sanitizeObject(req.params, sanitizationOptions, "params");
      }

      next();
    } catch (error) {
      logger.error("Error in sanitization middleware:", error);
      next();
    }
  };
}

/**
 * 默认清理中间件
 */
export const sanitizationMiddleware = createSanitizationMiddleware();
````

## File: src/core/protocol/ABPProtocolParser.ts
````typescript
/**
 * ABP Protocol Parser
 * 
 * ABP (ApexBridge Protocol) 是一个独立的协议（ABP-only）
 * 
 * @module core/protocol
 */

import {
  ABPProtocolConfig,
} from '../../types/abp';
import { logger } from '../../utils/logger';

/**
 * ABP协议解析器默认配置
 */
const DEFAULT_CONFIG: Required<ABPProtocolConfig> = {
  dualProtocolEnabled: false,
  errorRecoveryEnabled: true,
  jsonRepair: {
    enabled: true,
    strict: false,
  },
  noiseStripping: {
    enabled: true,
    aggressive: false,
  },
  boundaryValidation: {
    enabled: true,
    strict: false,
  },
  fallback: {
    enabled: true,
    toPlainText: true,
  },
  variable: {
    cacheEnabled: true,
    cacheTTL: 60000, // 1分钟
  },
};

/**
 * ABP协议解析器实现
 */
export class ABPProtocolParser {
  private config: Required<ABPProtocolConfig>;

  constructor(config?: ABPProtocolConfig) {
    this.config = { ...DEFAULT_CONFIG, ...config } as Required<ABPProtocolConfig>;
  }
}
````

## File: src/database/run-migrations.ts
````typescript
#!/usr/bin/env ts-node
/**
 * Migration Runner Script
 * Run database migrations for the LLM providers system
 *
 * Usage:
 *   npm run migrations --                Run all pending migrations
 *   npm run migrations -- --status       Check migration status
 *   npm run migrations -- --rollback=1   Rollback last migration
 *   npm run migrations -- --help         Show help
 */

import { MigrationRunner } from "./MigrationRunner";
import * as path from "path";

// Configuration
const DATABASE_PATH = process.env.DATABASE_PATH || ".data/llm_providers.db";
const MIGRATIONS_DIR = path.join(__dirname, "migrations");

// Parse command line arguments
function parseArgs(): { action: string; count?: number; help?: boolean } {
  const args = process.argv.slice(2);
  const result: { action: string; count?: number; help?: boolean } = { action: "run" };

  for (const arg of args) {
    if (arg === "--status" || arg === "-s") {
      result.action = "status";
    } else if (arg === "--help" || arg === "-h") {
      result.action = "help";
    } else if (arg.startsWith("--rollback=")) {
      result.action = "rollback";
      const countStr = arg.split("=")[1];
      result.count = parseInt(countStr, 10);
      if (isNaN(result.count) || result.count <= 0) {
        console.error("Error: Rollback count must be a positive number");
        process.exit(1);
      }
    } else if (arg === "--rollback") {
      result.action = "rollback";
      result.count = 1;
    }
  }

  return result;
}

/**
 * Display help information
 */
function showHelp(): void {
  console.log(`
Migration Runner for Playbook System Database

Usage:
  npm run migrations [options]

Options:
  --status, -s         Check migration status without running
  --rollback [=n]      Rollback last n migrations (default: 1)
  --help, -h           Show this help message

Examples:
  npm run migrations                    # Run all pending migrations
  npm run migrations -- --status        # Check migration status
  npm run migrations -- --rollback=2    # Rollback last 2 migrations
`);
}

/**
 * Display migration status
 */
async function showStatus(runner: MigrationRunner): Promise<void> {
  console.log("Database Migration Status\n");
  console.log("=".repeat(60));

  const currentVersion = runner.getCurrentVersion();
  console.log(`Current Version: ${currentVersion || "None"}`);

  const isUpToDate = runner.isUpToDate();
  console.log(`Status: ${isUpToDate ? "✓ Up to date" : "✗ Out of date"}`);

  console.log("\nMigration History:");
  console.log("-".repeat(60));

  const history = runner.getMigrationHistory();

  if (history.length === 0) {
    console.log("No migrations have been executed yet.");
  } else {
    for (const migration of history) {
      const date = new Date(migration.executed_at).toLocaleString();
      console.log(
        `  ${migration.version} - ${migration.name.padEnd(40)} ` +
          `(${migration.duration}ms) - ${date}`
      );
    }
  }

  if (!isUpToDate) {
    console.log("\nPending Migrations:");
    console.log("-".repeat(60));
    // Note: We need to reload pending migrations from files
    // This is a simplified status check
  }

  console.log("\n");
}

/**
 * Main execution function
 */
async function main(): Promise<void> {
  const args = parseArgs();

  if (args.action === "help") {
    showHelp();
    process.exit(0);
  }

  // Ensure database directory exists
  const dbDir = path.dirname(DATABASE_PATH);
  const fs = require("fs");
  if (!fs.existsSync(dbDir)) {
    fs.mkdirSync(dbDir, { recursive: true });
    console.log(`Created database directory: ${dbDir}\n`);
  }

  const runner = new MigrationRunner(DATABASE_PATH, MIGRATIONS_DIR);

  try {
    switch (args.action) {
      case "status":
        await showStatus(runner);
        break;

      case "rollback": {
        console.log(`Rolling back last ${args.count || 1} migration(s)...\n`);
        const rollbackResults = runner.rollback(args.count || 1);

        for (const result of rollbackResults) {
          if (result.success) {
            console.log(`✓ Rolled back ${result.version}: ${result.name}`);
          } else {
            console.error(`✗ Failed to rollback ${result.version}: ${result.error}`);
          }
        }
        break;
      }

      case "run":
      default: {
        const results = await runner.run();

        console.log("\n" + "=".repeat(60));
        console.log("Migration Summary:");
        console.log("=".repeat(60));

        const successful = results.filter((r) => r.success).length;
        const failed = results.filter((r) => !r.success).length;

        console.log(`Total: ${results.length}`);
        console.log(`Successful: ${successful}`);
        console.log(`Failed: ${failed}`);

        if (failed > 0) {
          console.log("\nFailed Migrations:");
          for (const result of results) {
            if (!result.success) {
              console.log(`  ${result.version}: ${result.error}`);
            }
          }
          process.exit(1);
        }
        break;
      }
    }
  } catch (error) {
    console.error("\nError:", error);
    process.exit(1);
  } finally {
    runner.close();
  }
}

// Run main function
main().catch((error) => {
  console.error("Unhandled error:", error);
  process.exit(1);
});
````

## File: src/services/executors/ToolExecutor.ts
````typescript
/**
 * 工具执行器接口定义
 * 定义内置工具和Skills工具的通用执行接口
 */

import {
  ToolExecutor as IToolExecutor,
  ToolExecuteOptions,
  ToolResult,
  BuiltInTool,
  SkillTool,
} from "../../types/tool-system";
// 注意：不在这里导入 BuiltInToolsRegistry 以避免循环依赖

/**
 * 安全序列化函数 - 防止循环引用和特殊值导致的问题
 */
function safeStringify(obj: any): string {
  const seen: any[] = [];
  return JSON.stringify(obj, (key, value) => {
    if (typeof value === "object" && value !== null) {
      // 处理循环引用
      if (seen.includes(value)) {
        return "[Circular]";
      }
      seen.push(value);
    }
    // 处理特殊值
    if (value === undefined) {
      return null;
    }
    if (typeof value === "bigint") {
      return value.toString();
    }
    if (typeof value === "function") {
      return "[Function]";
    }
    return value;
  });
}

/**
 * 抽象工具执行器基类
 * 提供通用的工具执行接口和基础功能
 */
export abstract class BaseToolExecutor implements IToolExecutor {
  /**
   * 执行工具
   * @param options 执行选项
   * @returns 执行结果
   */
  abstract execute(options: ToolExecuteOptions): Promise<ToolResult>;

  /**
   * 获取支持的工具列表
   * @returns 工具列表
   */
  abstract listTools(): (BuiltInTool | SkillTool)[];

  /**
   * 检查工具是否存在
   * @param name 工具名称
   * @returns 是否存在
   */
  hasTool(name: string): boolean {
    return this.listTools().some((tool) => tool.name === name);
  }

  /**
   * 获取工具详情
   * @param name 工具名称
   * @returns 工具详情或undefined
   */
  getTool(name: string): BuiltInTool | SkillTool | undefined {
    return this.listTools().find((tool) => tool.name === name);
  }

  /**
   * 验证执行选项
   * @param options 执行选项
   * @throws 当选项无效时抛出错误
   */
  protected validateExecuteOptions(options: ToolExecuteOptions): void {
    if (!options.name || typeof options.name !== "string") {
      throw new Error("Tool name is required and must be a string");
    }

    if (!options.args || typeof options.args !== "object") {
      throw new Error("Tool arguments are required and must be an object");
    }

    if (options.timeout && (typeof options.timeout !== "number" || options.timeout <= 0)) {
      throw new Error("Timeout must be a positive number");
    }

    if (
      options.maxOutputSize &&
      (typeof options.maxOutputSize !== "number" || options.maxOutputSize <= 0)
    ) {
      throw new Error("Max output size must be a positive number");
    }

    if (
      options.concurrency &&
      (typeof options.concurrency !== "number" || options.concurrency <= 0)
    ) {
      throw new Error("Concurrency must be a positive number");
    }
  }

  /**
   * 创建成功的执行结果
   * @param output 输出内容
   * @param duration 执行耗时
   * @returns 成功结果
   */
  protected createSuccessResult(output: string, duration: number): ToolResult {
    return {
      success: true,
      output,
      duration,
      exitCode: 0,
    };
  }

  /**
   * 创建失败的执行结果
   * @param error 错误信息
   * @param duration 执行耗时
   * @param errorCode 错误代码
   * @returns 失败结果
   */
  protected createErrorResult(error: string, duration: number, errorCode?: string): ToolResult {
    return {
      success: false,
      error,
      duration,
      errorCode,
      exitCode: 1,
    };
  }

  /**
   * 计算执行耗时
   * @param startTime 开始时间
   * @returns 耗时（毫秒）
   */
  protected calculateDuration(startTime: number): number {
    return Date.now() - startTime;
  }

  /**
   * 格式化错误信息
   * @param error 原始错误
   * @returns 格式化的错误信息
   */
  protected formatError(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return safeStringify(error);
  }
}

/**
 * 工具执行器工厂
 */
export class ToolExecutorFactory {
  /**
   * 创建内置工具执行器
   * @returns 内置工具执行器实例
   */
  static createBuiltInExecutor(): IToolExecutor {
    // 使用延迟导入避免循环依赖
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { getBuiltInToolsRegistry } = require("../BuiltInToolsRegistry");
    return getBuiltInToolsRegistry();
  }

  /**
   * 创建Skills沙箱执行器
   * @returns Skills沙箱执行器实例（暂时返回空执行器）
   */
  static createSkillsSandboxExecutor(): IToolExecutor {
    // Skills 沙箱执行器暂未实现，返回空执行器
    return new EmptyToolExecutor();
  }
}

/**
 * 空工具执行器（占位用）
 * 用于 Skills 沙箱执行器未实现时的占位
 */
class EmptyToolExecutor extends BaseToolExecutor {
  async execute(options: ToolExecuteOptions): Promise<ToolResult> {
    return this.createErrorResult(
      `Skills sandbox executor not implemented. Tool: ${options.name}`,
      0,
      "NOT_IMPLEMENTED"
    );
  }

  listTools(): (BuiltInTool | SkillTool)[] {
    return [];
  }
}

/**
 * 工具执行器管理器
 * 统一管理多个执行器
 */
export class ToolExecutorManager {
  private executors: Map<string, IToolExecutor> = new Map();

  constructor() {
    this.registerExecutor("builtin", ToolExecutorFactory.createBuiltInExecutor());
    this.registerExecutor("skill", ToolExecutorFactory.createSkillsSandboxExecutor());
  }

  /**
   * 注册执行器
   * @param type 执行器类型
   * @param executor 执行器实例
   */
  registerExecutor(type: string, executor: IToolExecutor): void {
    this.executors.set(type, executor);
  }

  /**
   * 获取执行器
   * @param type 执行器类型
   * @returns 执行器实例
   */
  getExecutor(type: string): IToolExecutor | undefined {
    return this.executors.get(type);
  }

  /**
   * 执行工具
   * @param type 执行器类型
   * @param options 执行选项
   * @returns 执行结果
   */
  async execute(type: string, options: ToolExecuteOptions): Promise<ToolResult> {
    const executor = this.getExecutor(type);
    if (!executor) {
      throw new Error(`Executor type '${type}' not found`);
    }
    return executor.execute(options);
  }

  /**
   * 获取所有工具
   * @returns 所有工具列表
   */
  listAllTools(): (BuiltInTool | SkillTool)[] {
    const allTools: (BuiltInTool | SkillTool)[] = [];
    const executors = Array.from(this.executors.values());
    for (const executor of executors) {
      allTools.push(...executor.listTools());
    }
    return allTools;
  }

  /**
   * 查找工具
   * @param name 工具名称
   * @returns 工具详情
   */
  findTool(name: string): { tool: BuiltInTool | SkillTool; type: string } | undefined {
    const entries = Array.from(this.executors.entries());
    for (const [type, executor] of entries) {
      const tool = executor.getTool(name);
      if (tool) {
        return { tool, type };
      }
    }
    return undefined;
  }
}

/**
 * 工具执行器管理器实例
 */
let toolExecutorManagerInstance: ToolExecutorManager | null = null;

/**
 * 获取工具执行器管理器实例
 * @returns 管理器实例
 */
export function getToolExecutorManager(): ToolExecutorManager {
  if (!toolExecutorManagerInstance) {
    toolExecutorManagerInstance = new ToolExecutorManager();
  }
  return toolExecutorManagerInstance;
}
````

## File: src/services/tool-retrieval/SearchEngine.ts
````typescript
/**
 * SearchEngine - Search Logic
 *
 * Handles vector search, result formatting, and filtering.
 * Includes semantic caching for improved performance.
 */

import { logger } from "../../utils/logger";
import {
  ToolRetrievalResult,
  RetrievalFilter,
  RetrievalSortingOptions,
  ToolsTable,
  ToolType,
} from "./types";
import { ILanceDBConnection } from "./LanceDBConnection";
import { IEmbeddingGenerator } from "./EmbeddingGenerator";
import { THRESHOLDS } from "../../constants";
import { SemanticCache, type SemanticSearchResult } from "../cache/SemanticCache";

/**
 * Search options extended with caching control
 */
export interface SearchOptions {
  limit?: number;
  minScore?: number;
  /** Disable cache lookup for this search */
  skipCache?: boolean;
  /** Disable caching the result */
  noCache?: boolean;
}

/**
 * SearchEngine interface
 */
export interface ISearchEngine {
  search(query: string, options?: SearchOptions): Promise<ToolRetrievalResult[]>;
  formatResults(results: unknown[]): ToolRetrievalResult[];
  applyFilters(results: ToolRetrievalResult[], filters: RetrievalFilter[]): ToolRetrievalResult[];
  sortResults(
    results: ToolRetrievalResult[],
    options: RetrievalSortingOptions
  ): ToolRetrievalResult[];
  /** Get cache statistics (if caching is enabled) */
  getCacheStats?: () => ReturnType<SemanticCache["getStats"]>;
}

/**
 * SearchEngine implementation
 */
export class SearchEngine implements ISearchEngine {
  private readonly connection: ILanceDBConnection;
  private readonly embeddingGenerator: IEmbeddingGenerator;
  private readonly defaultLimit: number;
  private readonly defaultThreshold: number;
  private readonly semanticCache: SemanticCache | null;

  constructor(
    connection: ILanceDBConnection,
    embeddingGenerator: IEmbeddingGenerator,
    options?: {
      defaultLimit?: number;
      defaultThreshold?: number;
      semanticCache?: SemanticCache;
    }
  ) {
    this.connection = connection;
    this.embeddingGenerator = embeddingGenerator;
    this.defaultLimit = options?.defaultLimit ?? 5;
    this.defaultThreshold = options?.defaultThreshold ?? THRESHOLDS.RELEVANT_SKILLS;
    this.semanticCache = options?.semanticCache ?? null;

    // Set up embedding service for cache if available
    if (this.semanticCache) {
      this.semanticCache.setEmbeddingService({
        generateForText: (text: string) => this.embeddingGenerator.generateForText(text),
      });
    }
  }

  /**
   * Search for relevant skills (with optional caching and fallback)
   */
  async search(query: string, options?: SearchOptions): Promise<ToolRetrievalResult[]> {
    const effectiveLimit = options?.limit ?? this.defaultLimit;
    const effectiveThreshold = options?.minScore ?? this.defaultThreshold;

    // Try semantic cache first
    if (this.semanticCache && !options?.skipCache) {
      const cachedResult = await this.semanticCache.findSimilar(query);
      if (cachedResult) {
        logger.info(
          `[SearchEngine] Cache hit for query "${query.substring(0, 50)}..." (similarity: ${cachedResult.similarity.toFixed(4)})`
        );
        return cachedResult.cachedQuery.result as ToolRetrievalResult[];
      }
    }

    try {
      logger.info(
        `[SearchEngine] Searching for: "${query}" (limit: ${effectiveLimit}, threshold: ${effectiveThreshold})`
      );

      // Generate query vector
      const queryVector = await this.embeddingGenerator.generateForText(query);

      // Get table
      const table = await this.connection.getTable();
      if (!table) {
        logger.warn("[SearchEngine] Table not initialized, using fallback search");
        return this.fallbackKeywordSearch(query, effectiveLimit, effectiveThreshold);
      }

      // Execute vector search
      const vectorQuery = table
        .query()
        .nearestTo(queryVector.values)
        .distanceType("cosine")
        .limit(effectiveLimit * 2);

      const results = await vectorQuery.toArray();

      // Format and filter results
      const formattedResults = this.formatSearchResults(
        results,
        effectiveLimit,
        effectiveThreshold
      );

      // Store the result in cache
      if (this.semanticCache && !options?.noCache) {
        await this.semanticCache.store(query, formattedResults);
      }

      logger.info(`[SearchEngine] Found ${formattedResults.length} relevant skill(s)`);
      return formattedResults;
    } catch (error) {
      logger.error(`[SearchEngine] Vector search failed for query "${query}":`, error);
      logger.warn(`[SearchEngine] Falling back to keyword search for query "${query}"`);

      // Fallback to keyword search
      return this.fallbackKeywordSearch(query, effectiveLimit, effectiveThreshold);
    }
  }

  /**
   * Fallback keyword-based search when vector search fails
   * @param query Search query
   * @param limit Maximum results to return
   * @param threshold Minimum score threshold
   * @returns Tool retrieval results from keyword matching
   */
  private async fallbackKeywordSearch(
    query: string,
    limit: number,
    threshold: number
  ): Promise<ToolRetrievalResult[]> {
    try {
      logger.info(`[SearchEngine] Executing fallback keyword search for: "${query}"`);

      // Get table for keyword matching
      const table = await this.connection.getTable();
      if (!table) {
        logger.warn("[SearchEngine] Table not available for fallback search");
        return [];
      }

      // Get all tools for keyword matching
      const searchTerms = query
        .toLowerCase()
        .split(/\s+/)
        .filter((t) => t.length > 0);

      // Use LanceDB query to get candidates (without vector search)
      const allRecords = await table
        .query()
        .limit(limit * 3)
        .toArray();

      // Filter by keyword matching
      const results: ToolRetrievalResult[] = [];

      for (const record of allRecords) {
        try {
          const data = this.extractResultData(record);

          // Calculate keyword match score
          const searchableText =
            `${data.name} ${data.description} ${(data.tags || []).join(" ")}`.toLowerCase();
          const matchCount = searchTerms.filter((term) => searchableText.includes(term)).length;

          if (matchCount === 0) {
            continue;
          }

          // Calculate score based on match quality
          const nameMatches = searchTerms.filter((term) =>
            data.name.toLowerCase().includes(term)
          ).length;
          const score = (nameMatches * 0.6 + matchCount * 0.4) / searchTerms.length;

          // Apply threshold filter
          if (score < threshold) {
            logger.debug(
              `[SearchEngine] Fallback filtered out result "${data.name}" with score ${score.toFixed(4)} < threshold ${threshold}`
            );
            continue;
          }

          // Parse metadata
          const metadata = this.parseMetadata(data);

          // Format result
          results.push({
            id: data.id,
            name: data.name,
            description: data.description,
            score: Math.min(score, 1),
            toolType: data.toolType || "skill",
            metadata: this.formatFallbackTool(data, metadata),
            tags: data.tags || [],
          });
        } catch (formatError) {
          logger.warn("[SearchEngine] Failed to format fallback result:", formatError);
        }
      }

      // Sort by score and limit results
      const sortedResults = results.sort((a, b) => b.score - a.score).slice(0, limit);

      logger.info(`[SearchEngine] Fallback keyword search found ${sortedResults.length} result(s)`);
      return sortedResults;
    } catch (fallbackError) {
      logger.error("[SearchEngine] Fallback keyword search also failed:", fallbackError);
      // Return empty array as last resort - never throw from search
      return [];
    }
  }

  /**
   * Format tool data for fallback results
   */
  private formatFallbackTool(
    data: ToolsTable,
    metadata: Record<string, unknown>
  ): Record<string, unknown> {
    return {
      name: data.name,
      description: data.description,
      type: data.toolType || "skill",
      source: data.source,
      tags: data.tags,
      metadata: {
        ...metadata,
        version: data.version,
        path: data.path,
      },
    };
  }

  /**
   * Get cache statistics
   */
  getCacheStats() {
    return this.semanticCache?.getStats();
  }

  /**
   * Format search results
   */
  formatResults(results: unknown[]): ToolRetrievalResult[] {
    return this.formatSearchResults(results, this.defaultLimit, this.defaultThreshold);
  }

  /**
   * Format search results (internal)
   */
  private formatSearchResults(
    results: unknown[],
    limit: number,
    threshold: number
  ): ToolRetrievalResult[] {
    const formatted: ToolRetrievalResult[] = [];

    // Handle LanceDB result format
    const resultArray = Array.isArray(results) ? results : [results];

    for (const result of resultArray.slice(0, limit)) {
      try {
        const data = this.extractResultData(result);

        // Calculate score
        const score = this.calculateScore(result);

        // Apply threshold filter
        if (score < threshold) {
          logger.debug(
            `[SearchEngine] Filtered out result with score ${score.toFixed(4)} < threshold ${threshold}`
          );
          continue;
        }

        // Parse metadata
        const metadata = this.parseMetadata(data);

        // Format result based on tool type
        const tool = this.formatTool(data, metadata);

        formatted.push({
          id: data.id,
          name: data.name,
          description: data.description,
          score,
          toolType: data.toolType || "skill",
          metadata: tool as Record<string, unknown>,
          tags: data.tags || [],
        });
      } catch (error) {
        logger.warn("[SearchEngine] Failed to format search result:", error);
      }
    }

    return formatted;
  }

  /**
   * Extract result data from LanceDB response
   */
  private extractResultData(result: unknown): ToolsTable {
    if (result && typeof result === "object") {
      const r = result as Record<string, unknown>;
      if ("item" in r) {
        return r.item as ToolsTable;
      }
    }
    return result as ToolsTable;
  }

  /**
   * Calculate similarity score from result
   */
  private calculateScore(result: unknown): number {
    if (result && typeof result === "object") {
      const r = result as Record<string, number>;

      if (r._distance !== undefined) {
        // LanceDB returns cosine distance, convert to similarity
        // Cosine distance range [0, 2], so similarity = 1 - distance
        return Math.max(0, 1 - r._distance);
      }
      if (r.score !== undefined) {
        return r.score;
      }
      if (r.similarity !== undefined) {
        return r.similarity;
      }
    }
    return 0;
  }

  /**
   * Parse metadata JSON string
   */
  private parseMetadata(data: ToolsTable): Record<string, unknown> {
    try {
      if (typeof data.metadata === "string") {
        return JSON.parse(data.metadata);
      }
      return data.metadata || {};
    } catch {
      logger.warn("[SearchEngine] Failed to parse metadata JSON");
      return {};
    }
  }

  /**
   * Format tool based on type
   */
  private formatTool(data: ToolsTable, metadata: Record<string, unknown>): Record<string, unknown> {
    if (data.toolType === "mcp") {
      // MCP tool format
      return {
        name: data.name,
        description: data.description,
        type: "mcp" as const,
        source: data.source,
        tags: data.tags,
        metadata: {
          ...metadata,
          version: data.version,
          path: data.path,
        },
      };
    }

    if (data.toolType === "builtin") {
      // Builtin tool format
      return {
        name: data.name,
        description: data.description,
        type: ToolType.BUILTIN,
        tags: data.tags,
        version: data.version,
        path: data.path,
        metadata: {
          ...metadata,
          builtin: true,
        },
      };
    }

    // Skill tool format (default)
    return {
      name: data.name,
      description: data.description,
      type: ToolType.SKILL,
      tags: data.tags,
      version: data.version,
      path: data.path,
      parameters: (metadata.parameters as Record<string, unknown>) || {
        type: "object",
        properties: {},
        required: [],
      },
      enabled: true,
      level: 1,
    };
  }

  /**
   * Apply filters to results
   */
  applyFilters(results: ToolRetrievalResult[], filters: RetrievalFilter[]): ToolRetrievalResult[] {
    if (!filters || filters.length === 0) {
      return results;
    }

    return results.filter((result) => {
      return filters.every((filter) => this.applyFilter(result, filter));
    });
  }

  /**
   * Apply single filter
   */
  private applyFilter(result: ToolRetrievalResult, filter: RetrievalFilter): boolean {
    const value = (result.metadata as Record<string, unknown>)?.[filter.field];
    return this.compareValues(value, filter.operator, filter.value);
  }

  /**
   * Compare values based on operator
   */
  private compareValues(
    actual: unknown,
    operator: RetrievalFilter["operator"],
    expected: unknown
  ): boolean {
    switch (operator) {
      case "eq":
        return actual === expected;
      case "ne":
        return actual !== expected;
      case "gt":
        return typeof actual === "number" && actual > (expected as number);
      case "lt":
        return typeof actual === "number" && actual < (expected as number);
      case "contains":
        return typeof actual === "string" && actual.includes(expected as string);
      case "in":
        return Array.isArray(expected) && expected.includes(actual);
      default:
        return true;
    }
  }

  /**
   * Sort results
   */
  sortResults(
    results: ToolRetrievalResult[],
    options: RetrievalSortingOptions
  ): ToolRetrievalResult[] {
    const sorted = [...results];

    sorted.sort((a, b) => {
      let aValue: number | string;
      let bValue: number | string;

      switch (options.field) {
        case "score":
          aValue = a.score;
          bValue = b.score;
          break;
        case "relevance":
          aValue = a.score;
          bValue = b.score;
          break;
        case "popularity":
          aValue = (a.metadata?.useCount as number) || 0;
          bValue = (b.metadata?.useCount as number) || 0;
          break;
        default:
          aValue = a.score;
          bValue = b.score;
      }

      if (options.order === "asc") {
        return aValue > bValue ? 1 : -1;
      } else {
        return aValue < bValue ? 1 : -1;
      }
    });

    return sorted;
  }
}
````

## File: src/services/BuiltInToolsRegistry.ts
````typescript
/**
 * 内置工具注册表
 * 管理系统内置工具，提供统一的注册和调用接口
 * 同时集成 ToolRegistry 进行统一工具管理
 */

import {
  BuiltInTool,
  ToolResult,
  ToolExecuteOptions,
  ToolError,
  ToolErrorCode
} from '../types/tool-system';
import { BaseToolExecutor } from './executors/ToolExecutor';
import { createFileReadTool } from '../core/tools/builtin/FileReadTool';
import { createFileWriteTool } from '../core/tools/builtin/FileWriteTool';
import { createVectorSearchTool } from '../core/tools/builtin/VectorSearchTool';
import { createReadSkillTool } from '../core/tools/builtin/ReadSkillTool';
import { createPlatformDetectorTool } from '../core/tools/builtin/PlatformDetectorTool';
import { toolRegistry, ToolType } from '../core/tool/registry';
import type { Tool } from '../core/tool/tool';
import { logger } from '../utils/logger';

/**
 * 内置工具注册表
 * 负责管理所有内置工具的生命周期和调用
 */
export class BuiltInToolsRegistry extends BaseToolExecutor {
  private tools: Map<string, BuiltInTool> = new Map();
  private initializationPromise: Promise<void> | null = null;

  constructor() {
    super();
    // 启动异步初始化
    this.initializationPromise = this.initializeBuiltinTools().catch(error => {
      logger.error('Failed to initialize built-in tools:', error);
    });
  }

  /**
   * 等待初始化完成
   */
  async waitForInitialization(): Promise<void> {
    if (this.initializationPromise) {
      await this.initializationPromise;
    }
  }

  /**
   * 初始化内置工具
   */
  private async initializeBuiltinTools(): Promise<void> {
    logger.debug('Initializing built-in tools registry...');

    // 注册文件系统工具
    await this.registerTool(createFileReadTool());
    await this.registerTool(createFileWriteTool());

    // 注册搜索工具
    await this.registerTool(createVectorSearchTool());

    // 注册 Skill 工具
    await this.registerTool(createReadSkillTool());

    // 注册系统工具
    await this.registerTool(createPlatformDetectorTool());

    // TODO: 注册其他内置工具
    // await this.registerTool(createDateTimeTool());
    // await this.registerTool(createCalculationTool());

    logger.debug(`Registered ${this.tools.size} built-in tools`);
  }

  /**
   * 将 BuiltInTool 转换为 Tool.Info 格式
   * @param tool BuiltInTool 定义
   * @returns Tool.Info 格式
   */
  private convertToToolInfo(tool: BuiltInTool): Tool.Info {
    return {
      id: tool.name,
      init: async () => ({
        description: tool.description,
        parameters: tool.parameters,
        execute: async (args, ctx) => {
          const result = await tool.execute(args);
          return {
            title: '',
            metadata: {},
            output: result.output || '',
          };
        },
      }),
    };
  }

  /**
   * 注册工具
   * 同时注册到 BuiltInToolsRegistry 和 ToolRegistry
   * @param tool 工具定义
   */
  async registerTool(tool: BuiltInTool): Promise<void> {
    if (!tool.name || !tool.execute) {
      throw new Error('Tool must have name and execute function');
    }

    this.tools.set(tool.name, tool);
    logger.debug(`Registered built-in tool: ${tool.name}`);

    // 同时注册到 ToolRegistry
    const toolInfo = this.convertToToolInfo(tool);
    await toolRegistry.register(toolInfo, ToolType.BUILTIN);
    logger.debug(`Registered built-in tool to ToolRegistry: ${tool.name}`);
  }

  /**
   * 注销工具
   * @param name 工具名称
   */
  unregisterTool(name: string): boolean {
    const existed = this.tools.delete(name);
    if (existed) {
      logger.debug(`Unregistered built-in tool: ${name}`);
    }
    return existed;
  }

  /**
   * 执行工具
   * @param options 执行选项
   * @returns 执行结果
   */
  async execute(options: ToolExecuteOptions): Promise<ToolResult> {
    const startTime = Date.now();

    try {
      // 验证执行选项
      this.validateExecuteOptions(options);

      // 获取工具
      const tool = this.tools.get(options.name);
      if (!tool) {
        throw new ToolError(
          `Built-in tool not found: ${options.name}`,
          ToolErrorCode.TOOL_NOT_FOUND
        );
      }

      if (!tool.enabled) {
        throw new ToolError(
          `Built-in tool is disabled: ${options.name}`,
          ToolErrorCode.TOOL_NOT_FOUND
        );
      }

      logger.info(`Executing built-in tool: ${options.name}`);
      logger.debug(`Tool arguments:`, options.args);

      // 执行工具
      const result = await tool.execute(options.args);

      // 记录执行统计
      const duration = this.calculateDuration(startTime);
      logger.info(`Built-in tool ${options.name} completed in ${duration}ms`);

      return result;

    } catch (error) {
      const duration = this.calculateDuration(startTime);

      if (error instanceof ToolError) {
        logger.error(`Built-in tool ${options.name} failed: ${error.message}`);
        return this.createErrorResult(error.message, duration, error.code);
      }

      logger.error(`Built-in tool ${options.name} failed with unexpected error:`, error);
      return this.createErrorResult(
        `Built-in tool execution failed: ${this.formatError(error)}`,
        duration,
        ToolErrorCode.TOOL_EXECUTION_FAILED
      );
    }
  }

  /**
   * 获取支持的工具列表
   * @returns 工具列表
   */
  listTools(): BuiltInTool[] {
    return Array.from(this.tools.values())
      .filter(tool => tool.enabled)
      .sort((a, b) => a.level - b.level);
  }

  /**
   * 获取所有工具（包括禁用的）
   * @returns 所有工具列表
   */
  listAllTools(): BuiltInTool[] {
    return Array.from(this.tools.values()).sort((a, b) => a.level - b.level);
  }

  /**
   * 获取工具详情
   * @param name 工具名称
   * @returns 工具详情或undefined
   */
  getTool(name: string): BuiltInTool | undefined {
    return this.tools.get(name);
  }

  /**
   * 启用工具
   * @param name 工具名称
   * @returns 是否成功
   */
  enableTool(name: string): boolean {
    const tool = this.tools.get(name);
    if (tool) {
      tool.enabled = true;
      logger.debug(`Enabled built-in tool: ${name}`);
      return true;
    }
    return false;
  }

  /**
   * 禁用工具
   * @param name 工具名称
   * @returns 是否成功
   */
  disableTool(name: string): boolean {
    const tool = this.tools.get(name);
    if (tool) {
      tool.enabled = false;
      logger.debug(`Disabled built-in tool: ${name}`);
      return true;
    }
    return false;
  }

  /**
   * 批量启用工具
   * @param names 工具名称列表
   */
  enableTools(names: string[]): void {
    names.forEach(name => this.enableTool(name));
  }

  /**
   * 批量禁用工具
   * @param names 工具名称列表
   */
  disableTools(names: string[]): void {
    names.forEach(name => this.disableTool(name));
  }

  /**
   * 获取工具统计信息
   * @returns 统计信息
   */
  getStatistics() {
    const allTools = this.listAllTools();
    const enabledTools = this.listTools();

    return {
      total: allTools.length,
      enabled: enabledTools.length,
      disabled: allTools.length - enabledTools.length,
      byCategory: this.groupByCategory(allTools),
      byLevel: this.groupByLevel(allTools)
    };
  }

  /**
   * 按分类分组工具
   */
  private groupByCategory(tools: BuiltInTool[]): Record<string, number> {
    const groups: Record<string, number> = {};
    tools.forEach(tool => {
      groups[tool.category] = (groups[tool.category] || 0) + 1;
    });
    return groups;
  }

  /**
   * 按级别分组工具
   */
  private groupByLevel(tools: BuiltInTool[]): Record<string, number> {
    const groups: Record<string, number> = {};
    tools.forEach(tool => {
      const level = `level_${tool.level}`;
      groups[level] = (groups[level] || 0) + 1;
    });
    return groups;
  }

  /**
   * 验证工具参数
   * @param tool 工具定义
   * @param args 参数对象
   * @throws 当参数无效时抛出错误
   */
  validateToolParameters(tool: BuiltInTool, args: Record<string, any>): void {
    if (!tool.parameters || !tool.parameters.properties) {
      return; // 没有参数模式，跳过验证
    }

    const { properties, required = [] } = tool.parameters;

    // 检查必需参数
    for (const param of required) {
      if (args[param] === undefined || args[param] === null) {
        throw new ToolError(
          `Missing required parameter: ${param}`,
          ToolErrorCode.TOOL_EXECUTION_FAILED
        );
      }
    }

    // 验证参数类型和约束
    for (const [key, value] of Object.entries(args)) {
      const schema = properties[key];
      if (!schema) {
        if (tool.parameters.additionalProperties === false) {
          throw new ToolError(
            `Unknown parameter: ${key}`,
            ToolErrorCode.TOOL_EXECUTION_FAILED
          );
        }
        continue;
      }

      this.validateParameter(key, value, schema);
    }
  }

  /**
   * 验证单个参数
   */
  private validateParameter(name: string, value: any, schema: any): void {
    // 类型验证
    if (schema.type && !this.validateType(value, schema.type)) {
      throw new ToolError(
        `Invalid type for parameter '${name}': expected ${schema.type}, got ${typeof value}`,
        ToolErrorCode.TOOL_EXECUTION_FAILED
      );
    }

    // 枚举验证
    if (schema.enum && !schema.enum.includes(value)) {
      throw new ToolError(
        `Invalid value for parameter '${name}': must be one of ${schema.enum.join(', ')}`,
        ToolErrorCode.TOOL_EXECUTION_FAILED
      );
    }

    // 数值约束
    if (schema.type === 'number') {
      if (schema.minimum !== undefined && value < schema.minimum) {
        throw new ToolError(
          `Value for parameter '${name}' must be >= ${schema.minimum}`,
          ToolErrorCode.TOOL_EXECUTION_FAILED
        );
      }
      if (schema.maximum !== undefined && value > schema.maximum) {
        throw new ToolError(
          `Value for parameter '${name}' must be <= ${schema.maximum}`,
          ToolErrorCode.TOOL_EXECUTION_FAILED
        );
      }
    }

    // 字符串约束
    if (schema.type === 'string') {
      if (schema.minLength !== undefined && value.length < schema.minLength) {
        throw new ToolError(
          `Length of parameter '${name}' must be >= ${schema.minLength}`,
          ToolErrorCode.TOOL_EXECUTION_FAILED
        );
      }
      if (schema.maxLength !== undefined && value.length > schema.maxLength) {
        throw new ToolError(
          `Length of parameter '${name}' must be <= ${schema.maxLength}`,
          ToolErrorCode.TOOL_EXECUTION_FAILED
        );
      }
      if (schema.pattern && !new RegExp(schema.pattern).test(value)) {
        throw new ToolError(
          `Value for parameter '${name}' does not match pattern: ${schema.pattern}`,
          ToolErrorCode.TOOL_EXECUTION_FAILED
        );
      }
    }
  }

  /**
   * 验证类型
   */
  private validateType(value: any, expectedType: string): boolean {
    switch (expectedType) {
      case 'string':
        return typeof value === 'string';
      case 'number':
        return typeof value === 'number';
      case 'boolean':
        return typeof value === 'boolean';
      case 'array':
        return Array.isArray(value);
      case 'object':
        return typeof value === 'object' && value !== null && !Array.isArray(value);
      default:
        return true;
    }
  }
}

/**
 * 内置工具注册表单例
 */
let instance: BuiltInToolsRegistry | null = null;

/**
 * 获取内置工具注册表实例
 * @returns 注册表实例
 */
export function getBuiltInToolsRegistry(): BuiltInToolsRegistry {
  if (!instance) {
    instance = new BuiltInToolsRegistry();
  }
  return instance;
}

/**
 * 重置内置工具注册表实例（用于测试）
 */
export function resetBuiltInToolsRegistry(): void {
  instance = null;
}

/**
 * 内置工具名称常量
 */
export const BUILTIN_TOOL_NAMES = {
  FILE_READ: 'file-read',
  FILE_WRITE: 'file-write',
  VECTOR_SEARCH: 'vector-search',
  READ_SKILL: 'read-skill',
  PLATFORM_DETECTOR: 'platform-detector',
  DATETIME: 'datetime',
  CALCULATION: 'calculation'
} as const;

export type BuiltinToolName = typeof BUILTIN_TOOL_NAMES[keyof typeof BUILTIN_TOOL_NAMES];
````

## File: src/services/MCPIntegrationService.ts
````typescript
/**
 * MCP Integration Service
 * 核心MCP功能集成服务
 * 负责MCP客户端管理、工具发现和执行
 * 集成 ToolRegistry 进行统一工具管理
 */

import { EventEmitter } from "events";
import { logger } from "../utils/logger";
import { MCPServerManager } from "./MCPServerManager";
import { MCPConfigService } from "./MCPConfigService";
import { getToolRetrievalService } from "./ToolRetrievalService";
import { toolRegistry, ToolType } from "../core/tool/registry";
import { convertMcpTool, cleanMcpToolResult } from "./mcp/convert";
import type { Tool } from "../core/tool/tool";
import type {
  MCPServerConfig,
  MCPServerStatus,
  MCPTool,
  MCPToolCall,
  MCPToolResult,
} from "../types/mcp";

export interface MCPServerInfo {
  id: string;
  config: MCPServerConfig;
  status: MCPServerStatus;
  tools: MCPTool[];
  lastActivity?: Date;
}

export class MCPIntegrationService extends EventEmitter {
  private serverManagers: Map<string, MCPServerManager> = new Map();
  private toolIndex: Map<string, { serverId: string; toolName: string }> = new Map();
  private configService: MCPConfigService;
  private managerListeners: Map<
    string,
    {
      statusChanged?: (status: MCPServerStatus) => void;
      toolsChanged?: (tools: MCPTool[]) => void;
    }
  > = new Map();

  constructor() {
    super();
    this.configService = MCPConfigService.getInstance();
    this.setupEventHandlers();
  }

  private setupEventHandlers(): void {
    // 监听服务器状态变化
    this.on("server-status-changed", (data: { serverId: string; status: MCPServerStatus }) => {
      logger.info(`[MCP] Server ${data.serverId} status changed: ${data.status.phase}`);
      this.emit("mcp-event", {
        type: "server-status-changed",
        data,
      });
    });

    // 监听工具变化
    this.on("tools-changed", async (data: { serverId: string; tools: MCPTool[] }) => {
      logger.info(`[MCP] Server ${data.serverId} tools updated: ${data.tools.length} tools`);
      this.updateToolIndex(data.serverId, data.tools);
      // Re-vectorize tools to update vector search index
      // 向量化失败不影响服务器运行，但需要记录详细错误信息
      try {
        await this.vectorizeServerTools(data.serverId, data.tools);
      } catch (vectorError: any) {
        logger.error(
          `[MCP] Vectorization failed for server ${data.serverId}: ${vectorError.message}`,
          vectorError.stack
        );
        // 工具已注册但无法通过语义搜索检索
        // 服务器继续运行，但工具索引可能不完整
      }
    });
  }

  /**
   * 注册MCP服务器
   */
  async registerServer(
    config: MCPServerConfig
  ): Promise<{ serverId: string; success: boolean; error?: string }> {
    try {
      const serverId = config.id;
      const serverName = config.id;

      if (this.serverManagers.has(serverId)) {
        logger.warn(`[MCP] Server ${serverId} already exists`);
        return { serverId, success: false, error: "Server already exists" };
      }

      const manager = new MCPServerManager(config);

      // 设置事件监听并跟踪引用以便后续清理
      const listeners: {
        statusChanged?: (status: MCPServerStatus) => void;
        toolsChanged?: (tools: MCPTool[]) => void;
      } = {};

      listeners.statusChanged = (status: MCPServerStatus) => {
        this.emit("server-status-changed", { serverId, status });
      };
      listeners.toolsChanged = (tools: MCPTool[]) => {
        this.emit("tools-changed", { serverId, tools });
      };

      manager.on("status-changed", listeners.statusChanged);
      manager.on("tools-changed", listeners.toolsChanged);

      this.managerListeners.set(serverId, listeners);

      // 初始化服务器
      await manager.initialize();

      this.serverManagers.set(serverId, manager);

      // 保存到数据库
      this.configService.saveServer(config);
      logger.info(`[MCP] Server ${serverId} configuration saved to database`);

      // 向量化工具（容错处理：向量索引失败不影响服务器注册，但记录详细错误）
      try {
        await this.vectorizeServerTools(serverId, manager.getTools());
      } catch (vectorError: any) {
        logger.error(
          `[MCP] Vectorization failed for server ${serverId}: ${vectorError.message}`,
          vectorError.stack
        );
        // 向量化失败不影响服务器注册，但工具将无法通过语义搜索检索
      }

      // 注册工具到 ToolRegistry（使用 {clientName}_{toolName} 格式）
      const serverTools = manager.getTools();
      for (const tool of serverTools) {
        const toolInfo = convertMcpTool(serverId, serverName, tool);
        await toolRegistry.register(toolInfo, ToolType.MCP);
      }
      logger.info(
        `[MCP] Registered ${serverTools.length} tools to ToolRegistry for server ${serverId}`
      );

      logger.info(`[MCP] Server ${serverId} registered successfully`);
      return { serverId, success: true };
    } catch (error: any) {
      logger.error(`[MCP] Failed to register server:`, error);
      return {
        serverId: config.id,
        success: false,
        error: error.message || "Unknown error",
      };
    }
  }

  /**
   * 注销MCP服务器
   */
  async unregisterServer(serverId: string): Promise<boolean> {
    try {
      const manager = this.serverManagers.get(serverId);

      if (!manager) {
        logger.warn(`[MCP] Server ${serverId} not found`);
        return false;
      }

      // 移除事件监听器
      const listeners = this.managerListeners.get(serverId);
      if (listeners) {
        if (listeners.statusChanged) {
          manager.removeListener("status-changed", listeners.statusChanged);
        }
        if (listeners.toolsChanged) {
          manager.removeListener("tools-changed", listeners.toolsChanged);
        }
        this.managerListeners.delete(serverId);
      }

      // 删除向量化的工具
      await this.removeVectorizedTools(serverId, manager.getTools());

      await manager.shutdown();
      this.serverManagers.delete(serverId);
      this.removeFromToolIndex(serverId);

      // 从数据库删除
      this.configService.deleteServer(serverId);
      logger.info(`[MCP] Server ${serverId} removed from database`);

      logger.info(`[MCP] Server ${serverId} unregistered`);
      return true;
    } catch (error: any) {
      logger.error(`[MCP] Failed to unregister server ${serverId}:`, error);
      return false;
    }
  }

  /**
   * 获取所有注册的服务器
   */
  getServers(): MCPServerInfo[] {
    return Array.from(this.serverManagers.entries()).map(([serverId, manager]) => ({
      id: serverId,
      config: manager.getConfig(),
      status: manager.getStatus(),
      tools: manager.getTools(),
      lastActivity: manager.getLastActivity(),
    }));
  }

  /**
   * 获取特定服务器信息
   */
  getServer(serverId: string): MCPServerInfo | undefined {
    const manager = this.serverManagers.get(serverId);

    if (!manager) {
      return undefined;
    }

    return {
      id: serverId,
      config: manager.getConfig(),
      status: manager.getStatus(),
      tools: manager.getTools(),
      lastActivity: manager.getLastActivity(),
    };
  }

  /**
   * 获取服务器状态
   */
  getServerStatus(serverId: string): MCPServerStatus | undefined {
    const manager = this.serverManagers.get(serverId);
    return manager?.getStatus();
  }

  /**
   * 获取所有可用工具
   */
  getAllTools(): { serverId: string; tools: MCPTool[] }[] {
    return Array.from(this.serverManagers.entries()).map(([serverId, manager]) => ({
      serverId,
      tools: manager.getTools(),
    }));
  }

  /**
   * 根据名称搜索工具
   */
  findToolByName(name: string): { serverId: string; tool: MCPTool } | undefined {
    const index = this.toolIndex.get(name);

    if (!index) {
      return undefined;
    }

    const manager = this.serverManagers.get(index.serverId);

    if (!manager) {
      return undefined;
    }

    const tool = manager.getTools().find((t) => t.name === index.toolName);

    if (!tool) {
      return undefined;
    }

    return { serverId: index.serverId, tool };
  }

  /**
   * 执行工具调用
   */
  async callTool(params: {
    toolName: string;
    arguments: Record<string, any>;
    serverId?: string;
  }): Promise<MCPToolResult> {
    try {
      const { toolName, arguments: args, serverId } = params;

      let manager: MCPServerManager | undefined;
      let tool: MCPTool | undefined;

      if (serverId) {
        // 指定服务器ID
        manager = this.serverManagers.get(serverId);

        if (!manager) {
          throw new Error(`Server ${serverId} not found`);
        }

        tool = manager.getTools().find((t) => t.name === toolName);

        if (!tool) {
          throw new Error(`Tool ${toolName} not found in server ${serverId}`);
        }
      } else {
        // 自动发现
        const result = this.findToolByName(toolName);

        if (!result) {
          throw new Error(`Tool ${toolName} not found`);
        }

        manager = this.serverManagers.get(result.serverId);
        tool = result.tool;
      }

      if (!manager || !tool) {
        throw new Error(`Tool or manager not found`);
      }

      // 检查服务器状态
      const status = manager.getStatus();

      if (status.phase === "error") {
        throw new Error(`Server error: ${status.message}`);
      }

      if (status.phase === "shutting-down") {
        throw new Error(`Server is shutting down`);
      }

      // 更新最后活动时间
      manager.updateLastActivity();

      // 执行工具调用
      const toolCall: MCPToolCall = {
        tool: tool.name,
        arguments: args,
      };

      const result = await manager.callTool(toolCall);

      // 清理 MCP 工具返回结果中的技术元数据
      if (result.success && result.content && result.content.length > 0) {
        result.content = result.content.map((item) => {
          if (item.type === "text" && typeof item.text === "string") {
            return {
              ...item,
              text: cleanMcpToolResult(item.text),
            };
          }
          return item;
        });
      }

      // 记录调用统计
      this.emit("tool-called", {
        serverId: manager.getConfig().id,
        toolName,
        success: result.success,
        duration: result.duration,
      });

      return result;
    } catch (error: any) {
      logger.error(`[MCP] Tool call failed:`, error);

      return {
        success: false,
        content: [],
        duration: 0,
        error: {
          code: "TOOL_CALL_FAILED",
          message: error.message || "Unknown error",
        },
      };
    }
  }

  /**
   * 重启服务器
   */
  async restartServer(serverId: string): Promise<boolean> {
    try {
      const manager = this.serverManagers.get(serverId);

      if (!manager) {
        logger.warn(`[MCP] Server ${serverId} not found`);
        return false;
      }

      logger.info(`[MCP] Restarting server ${serverId}...`);

      await manager.shutdown();
      await manager.initialize();

      logger.info(`[MCP] Server ${serverId} restarted successfully`);
      return true;
    } catch (error: any) {
      logger.error(`[MCP] Failed to restart server ${serverId}:`, error);
      return false;
    }
  }

  /**
   * 更新工具索引
   */
  private updateToolIndex(serverId: string, tools: MCPTool[]): void {
    // 清除该服务器的工具索引
    const toRemove: string[] = [];

    for (const [toolName, index] of this.toolIndex.entries()) {
      if (index.serverId === serverId) {
        toRemove.push(toolName);
      }
    }

    toRemove.forEach((name) => this.toolIndex.delete(name));

    // 添加新工具索引
    for (const tool of tools) {
      this.toolIndex.set(tool.name, { serverId, toolName: tool.name });
    }

    logger.debug(`[MCP] Tool index updated for server ${serverId}: ${tools.length} tools`);
  }

  /**
   * 从索引中移除服务器的工具
   */
  private removeFromToolIndex(serverId: string): void {
    const toRemove: string[] = [];

    for (const [toolName, index] of this.toolIndex.entries()) {
      if (index.serverId === serverId) {
        toRemove.push(toolName);
      }
    }

    toRemove.forEach((name) => this.toolIndex.delete(name));
  }

  /**
   * 获取服务器统计信息
   */
  getStatistics() {
    const servers = this.getServers();

    const stats = {
      totalServers: servers.length,
      serversByStatus: {} as Record<string, number>,
      totalTools: 0,
      servers: servers.map((s) => ({
        id: s.id,
        status: s.status.phase,
        toolCount: s.tools.length,
        lastActivity: s.lastActivity,
      })),
    };

    for (const server of servers) {
      stats.totalTools += server.tools.length;
      stats.serversByStatus[server.status.phase] =
        (stats.serversByStatus[server.status.phase] || 0) + 1;
    }

    return stats;
  }

  /**
   * 健康检查
   */
  async healthCheck(): Promise<{
    healthy: boolean;
    details: Record<string, any>;
  }> {
    const servers = this.getServers();
    const details: Record<string, any> = {};

    let healthy = true;

    for (const server of servers) {
      const serverHealthy = server.status.phase === "running";
      details[server.id] = {
        healthy: serverHealthy,
        status: server.status.phase,
        toolCount: server.tools.length,
        uptime: server.status.uptime,
        lastActivity: server.lastActivity,
      };

      if (!serverHealthy) {
        healthy = false;
      }
    }

    return { healthy, details };
  }

  /**
   * 向量化服务器工具
   */
  public async vectorizeServerTools(serverId: string, tools: MCPTool[]): Promise<void> {
    try {
      const retrievalService = getToolRetrievalService();
      await retrievalService.initialize();

      const unifiedTools = tools.map((tool) => ({
        name: tool.name,
        description: tool.description,
        type: "mcp" as const,
        source: serverId,
        tags: [],
        metadata: {
          inputSchema: tool.inputSchema,
        },
      }));

      await retrievalService.indexTools(unifiedTools);
      logger.info(`[MCP] Vectorized ${tools.length} tools for server ${serverId}`);
    } catch (error: any) {
      logger.error(`[MCP] Failed to vectorize tools for server ${serverId}:`, error);
      throw error;
    }
  }

  /**
   * 删除服务器向量化工具
   */
  private async removeVectorizedTools(serverId: string, tools: MCPTool[]): Promise<void> {
    try {
      const retrievalService = getToolRetrievalService();
      await retrievalService.initialize();

      for (const tool of tools) {
        const toolId = `${serverId}:${tool.name}`;
        await retrievalService.removeTool(toolId);
      }

      logger.info(`[MCP] Removed vectorized tools for server ${serverId}`);
    } catch (error: any) {
      logger.error(`[MCP] Failed to remove vectorized tools for server ${serverId}:`, error);
      // 不抛出错误，避免影响服务器注销流程
    }
  }

  /**
   * 从数据库加载所有已注册的MCP服务器
   */
  async loadServersFromDatabase(): Promise<void> {
    try {
      const records = this.configService.getAllServers();

      logger.info(`[MCP] Loading ${records.length} MCP servers from database`);

      for (const record of records) {
        try {
          // 检查服务器是否已经在内存中
          if (this.serverManagers.has(record.id)) {
            logger.debug(`[MCP] Server ${record.id} already loaded, skipping`);
            continue;
          }

          logger.info(`[MCP] Loading server ${record.id} from database`);

          const result = await this.registerServer(record.config);

          if (!result.success) {
            logger.error(
              `[MCP] Failed to reload server ${record.id} from database: ${result.error}`
            );
          }
        } catch (error: any) {
          logger.error(`[MCP] Error loading server ${record.id}:`, error);
          // 继续加载其他服务器
        }
      }

      logger.info(`[MCP] Completed loading MCP servers from database`);
    } catch (error: any) {
      logger.error("[MCP] Failed to load servers from database:", error);
      throw error;
    }
  }

  /**
   * 优雅关闭
   */
  async shutdown(): Promise<void> {
    logger.info("[MCP] Shutting down integration service...");

    // 移除所有事件监听器
    this.removeAllListeners();

    // 关闭所有服务器并移除监听器
    const shutdownPromises = Array.from(this.serverManagers.values()).map(async (manager) => {
      // 获取服务器 ID 以便从 managerListeners 中移除
      const serverId = Array.from(this.serverManagers.entries()).find(
        ([, m]) => m === manager
      )?.[0];

      if (serverId) {
        const listeners = this.managerListeners.get(serverId);
        if (listeners) {
          if (listeners.statusChanged) {
            manager.removeListener("status-changed", listeners.statusChanged);
          }
          if (listeners.toolsChanged) {
            manager.removeListener("tools-changed", listeners.toolsChanged);
          }
          this.managerListeners.delete(serverId);
        }
      }

      await manager.shutdown();
    });

    await Promise.all(shutdownPromises);

    this.serverManagers.clear();
    this.managerListeners.clear();
    this.toolIndex.clear();

    logger.info("[MCP] Integration service shut down");
  }
}

// 导出单例实例
export const mcpIntegration = new MCPIntegrationService();
````

## File: src/services/SessionManager.ts
````typescript
/**
 * SessionManager - 会话生命周期管理
 * Playbook 和 ACE 功能已删除 (2026-01-11)
 * 职责：会话的创建、验证、更新、归档
 */

import { ConversationHistoryService } from "./ConversationHistoryService";
import { logger } from "../utils/logger";

/**
 * 会话元数据接口
 */
export interface SessionMetadata {
  /** Agent ID */
  agentId?: string;
  /** 用户 ID */
  userId?: string;
  /** 对话 ID */
  conversationId?: string;
  /** 创建时间 */
  createdAt?: number;
  /** 最后一条消息时间 */
  lastMessageAt?: number;
  /** 消息计数 */
  messageCount?: number;
  /** 累计 Token 使用量 */
  totalTokens?: number;
  /** 累计输入 Token */
  totalInputTokens?: number;
  /** 累计输出 Token */
  totalOutputTokens?: number;
}

export class SessionManager {
  // conversationId -> sessionId 映射
  private sessionMap = new Map<string, string>();
  // sessionId -> metadata 缓存
  private metadataCache = new Map<string, SessionMetadata>();
  // pendingPromises 用于防止竞态条件：conversationId -> 创建会话的 Promise
  private pendingPromises = new Map<string, Promise<string>>();

  constructor(private historyService: ConversationHistoryService) {}

  /**
   * 获取或创建会话（并发安全版本）
   * 使用 Promise 锁确保同一 conversationId 的并发请求等待同一创建操作
   * @param agentId Agent ID（可选）
   * @param userId 用户ID（可选）
   * @param conversationId 对话ID（必需）
   * @returns sessionId 或 null
   */
  async getOrCreate(
    agentId: string | undefined,
    userId: string | undefined,
    conversationId: string
  ): Promise<string | null> {
    // 1. 如果没有 conversationId，无法创建会话
    if (!conversationId) {
      logger.debug("[SessionManager] No conversationId provided, processing without session");
      return null;
    }

    // 2. 检查是否有正在进行的创建操作（防止竞态条件）
    const existingPromise = this.pendingPromises.get(conversationId);
    if (existingPromise) {
      // 如果已有请求正在创建此会话，等待它完成
      logger.debug(`[SessionManager] Waiting for existing session creation: ${conversationId}`);
      return existingPromise;
    }

    // 3. 检查是否已存在会话映射
    const existingSessionId = this.sessionMap.get(conversationId);
    if (existingSessionId) {
      logger.debug(
        `[SessionManager] Reused existing session: ${existingSessionId} for conversation: ${conversationId}`
      );
      return existingSessionId;
    }

    // 4. 创建新会话（使用 conversationId 作为 sessionId）
    const sessionId = conversationId;

    // 5. 初始化元数据
    const metadata: SessionMetadata = {
      agentId,
      userId,
      conversationId,
      createdAt: Date.now(),
      lastMessageAt: Date.now(),
      messageCount: 0,
      totalTokens: 0,
      totalInputTokens: 0,
      totalOutputTokens: 0,
    };

    // 6. 使用 Promise 锁确保原子性
    const creationPromise = (async () => {
      // 双重检查（防止在异步等待期间已被其他请求创建）
      const cachedSessionId = this.sessionMap.get(conversationId);
      if (cachedSessionId) {
        logger.debug(`[SessionManager] Session created by concurrent request: ${conversationId}`);
        return cachedSessionId;
      }

      // 保存映射和元数据
      this.sessionMap.set(conversationId, sessionId);
      this.metadataCache.set(sessionId, metadata);

      logger.info(
        `[SessionManager] Created new session: ${sessionId} for conversation: ${conversationId}`
      );
      return sessionId;
    })();

    // 7. 注册 Promise 并在完成后清理
    this.pendingPromises.set(conversationId, creationPromise);
    creationPromise.finally(() => {
      this.pendingPromises.delete(conversationId);
    });

    return creationPromise;
  }

  /**
   * 更新会话元数据（消息计数、Token使用量等）
   * @param sessionId 会话ID
   * @param usage Token使用信息（可选）
   */
  async updateMetadata(
    sessionId: string,
    usage?: { total_tokens?: number; prompt_tokens?: number; completion_tokens?: number }
  ): Promise<void> {
    const metadata = this.metadataCache.get(sessionId);
    if (!metadata) {
      logger.warn(`[SessionManager] No metadata found for session: ${sessionId}`);
      return;
    }

    try {
      // 更新元数据
      metadata.lastMessageAt = Date.now();
      metadata.messageCount = (metadata.messageCount || 0) + 1;

      // 更新 Token 统计
      if (usage) {
        const totalTokens = usage.total_tokens || 0;
        const inputTokens = usage.prompt_tokens || 0;
        const outputTokens = usage.completion_tokens || 0;

        metadata.totalTokens = (metadata.totalTokens || 0) + totalTokens;
        metadata.totalInputTokens = (metadata.totalInputTokens || 0) + inputTokens;
        metadata.totalOutputTokens = (metadata.totalOutputTokens || 0) + outputTokens;
      }

      logger.debug(`[SessionManager] Updated metadata for session: ${sessionId}`);
    } catch (error: any) {
      logger.warn(`[SessionManager] Failed to update session metadata: ${error.message}`);
    }
  }

  /**
   * 归档会话（用户删除对话时调用）
   * @param conversationId 对话ID
   */
  async archive(conversationId: string): Promise<void> {
    const sessionId = this.sessionMap.get(conversationId);

    if (!sessionId) {
      logger.warn(`[SessionManager] No session found for conversation: ${conversationId}`);
      // 即使没有 sessionId，也尝试删除消息历史
      try {
        await this.historyService.deleteMessages(conversationId);
        logger.info(`[SessionManager] Deleted conversation history for: ${conversationId}`);
      } catch (error: any) {
        logger.warn(`[SessionManager] Failed to delete conversation history: ${error.message}`);
      }
      return;
    }

    // 删除对话消息历史
    try {
      await this.historyService.deleteMessages(conversationId);
      logger.info(`[SessionManager] Deleted conversation history for: ${conversationId}`);
    } catch (error: any) {
      logger.error(`[SessionManager] Failed to delete conversation history: ${error.message}`);
    }

    // 移除缓存和映射
    this.metadataCache.delete(sessionId);
    this.sessionMap.delete(conversationId);
    logger.info(
      `[SessionManager] Archived session: ${sessionId} for conversation: ${conversationId}`
    );
  }

  /**
   * 根据 conversationId 获取 sessionId
   * @param conversationId 对话ID
   * @returns sessionId 或 null
   */
  getSessionId(conversationId: string): string | null {
    return this.sessionMap.get(conversationId) || null;
  }

  /**
   * 批量移除会话映射（用于清理）
   * @param conversationIds 对话ID数组
   */
  removeSessionMappings(conversationIds: string[]): void {
    conversationIds.forEach((id) => {
      const sessionId = this.sessionMap.get(id);
      if (sessionId) {
        this.metadataCache.delete(sessionId);
      }
      this.sessionMap.delete(id);
      logger.debug(`[SessionManager] Removed session mapping for: ${id}`);
    });
  }

  /**
   * 获取所有会话映射（用于调试）
   * @returns 会话映射副本
   */
  getAllSessionMappings(): Map<string, string> {
    return new Map(this.sessionMap);
  }

  /**
   * 获取会话总数
   * @returns 会话数量
   */
  getSessionCount(): number {
    return this.sessionMap.size;
  }
}
````

## File: src/types/config.ts
````typescript
/**
 * 配置接口统一导出
 *
 * 此文件统一导出所有配置接口，便于查找和维护。
 * 各模块的配置接口保留在各自的类型文件中，通过此文件统一导出。
 *
 * 注意：由于 types/config.ts 和 types/config/ 目录下的文件存在循环引用，
 * 此文件仅保留对 config 目录的引用，实际类型通过 types/config 导入
 */

// ==================== 默认值和工厂函数 ====================

export {
  DEFAULT_REDIS_CONFIG,
  DEFAULT_CONFIG,
  createDefaultRateLimitSettings
} from '../utils/config-constants';

// ==================== 验证结果类型 ====================

export type { ValidationResult } from '../utils/config-validator';

// ==================== LLM 配置 ====================

export type {
  LLMProviderConfig,
  LLMConfig
} from './index';

// ==================== ABP 配置 ====================

export type {
  ABPProtocolConfig
} from './abp';

// ==================== 服务配置 ====================

// PathService 配置
export type { PathConfig } from '../services/PathService';

// ==================== 核心模块配置 ====================

// ==================== 工具配置 ====================

// Cache 配置
export type { CacheConfig as UtilsCacheConfig } from '../utils/cache';

// Retry 配置
export type { RetryConfig } from '../utils/retry';

// JWT 配置
export type { JWTConfig } from '../utils/jwt';
````

## File: src/types/variable.ts
````typescript
/**
 * Variable Engine Types - Unified Version
 *
 * 统一版的变量引擎类型定义
 */

import type { Message } from './index';

/**
 * 变量上下文信息（简化版，现为可选）
 * @deprecated 简化版中不再使用，保留用于向后兼容
 */
export interface VariableContext {
  userId?: string;
  personaId?: string;
  sessionId?: string;
  messageId?: string;
  [key: string]: any;
}

/**
 * 变量引擎接口（统一版）
 */
export interface IVariableEngine {
  /** 解析内容中的所有变量 */
  resolveAll(content: string, variables?: Record<string, string>, options?: { fillEmptyOnMissing?: boolean }): Promise<string>;

  /** 批量解析消息中的变量（带缓存） */
  resolveMessages?(messages: Message[], variables?: Record<string, string>): Promise<Message[]>;

  /** 解析单个变量（可选实现） */
  resolveSingle?(content: string, key: string, variables?: Record<string, string>): Promise<string | null>;

  /** 重置引擎（清理缓存） */
  reset(): void;

  /** 清理缓存 */
  clearCache?(): void;

  /** 获取缓存统计信息 */
  getCacheStats?(): { size: number; ttlMs: number; enabled: boolean };
}

/**
 * 变量引擎配置选项（简化版）
 */
export interface VariableEngineOptions {
  /** 是否启用递归解析（变量值中可能包含其他变量） */
  enableRecursion?: boolean;
  
  /** 最大递归深度 */
  maxRecursionDepth?: number;
  
  /** 占位符正则表达式模式 */
  placeholderPattern?: RegExp;
}

/**
 * @deprecated 提供者模式已移除，此接口不再使用
 */
export interface IVariableProvider {
  name: string;
  resolve(key: string, context?: VariableContext): Promise<string | null>;
  getSupportedKeys(): string[];
  getDescription?(): string;
}

/**
 * @deprecated 循环依赖检测已移除，此类不再使用
 */
export class CircularDependencyError extends Error {
  constructor(public readonly path: string[]) {
    super(`Circular dependency detected: ${path.join(' -> ')}`);
    this.name = 'CircularDependencyError';
  }
}
````

## File: src/utils/cache.ts
````typescript
/**
 * 统一缓存工具类
 * 提供TTL、自动失效、LRU等功能的智能缓存
 */

import { logger } from "./logger";

/**
 * 缓存项接口
 */
interface CacheItem<T> {
  value: T;
  expiresAt: number;
  createdAt: number;
  accessCount: number;
  lastAccessedAt: number;
}

/**
 * 缓存配置
 */
export interface CacheConfig {
  /** 默认TTL（毫秒），0表示永不过期 */
  defaultTTL?: number;
  /** 最大缓存项数量（LRU淘汰） */
  maxSize?: number;
  /** 是否启用统计 */
  enableStats?: boolean;
}

/**
 * 缓存统计信息
 */
export interface CacheStats {
  hits: number;
  misses: number;
  sets: number;
  deletes: number;
  evictions: number;
  size: number;
  hitRate: number;
}

/**
 * 统一缓存类
 * 支持TTL、LRU淘汰、统计信息
 */
export class Cache<T = any> {
  private cache: Map<string, CacheItem<T>>;
  private config: Required<CacheConfig>;
  private stats: CacheStats;
  private cleanupInterval?: NodeJS.Timeout;

  constructor(config: CacheConfig = {}) {
    this.config = {
      defaultTTL: config.defaultTTL ?? 0, // 0表示永不过期
      maxSize: config.maxSize ?? 1000,
      enableStats: config.enableStats ?? true,
    };

    this.cache = new Map();
    this.stats = {
      hits: 0,
      misses: 0,
      sets: 0,
      deletes: 0,
      evictions: 0,
      size: 0,
      hitRate: 0,
    };

    // 如果启用TTL，启动定期清理
    if (this.config.defaultTTL > 0) {
      this.startCleanup();
    }
  }

  /**
   * 获取缓存值
   */
  get(key: string): T | undefined {
    const item = this.cache.get(key);

    if (!item) {
      if (this.config.enableStats) {
        this.stats.misses++;
        this.updateHitRate();
      }
      return undefined;
    }

    // 检查是否过期
    if (this.config.defaultTTL > 0 && item.expiresAt < Date.now()) {
      this.cache.delete(key);
      if (this.config.enableStats) {
        this.stats.misses++;
        this.stats.evictions++;
        this.updateStats();
      }
      return undefined;
    }

    // 更新访问统计
    item.accessCount++;
    item.lastAccessedAt = Date.now();

    if (this.config.enableStats) {
      this.stats.hits++;
      this.updateHitRate();
    }

    return item.value;
  }

  /**
   * 设置缓存值
   */
  set(key: string, value: T, ttl?: number): void {
    const now = Date.now();
    const itemTTL = ttl ?? this.config.defaultTTL;
    const expiresAt = itemTTL > 0 ? now + itemTTL : Number.MAX_SAFE_INTEGER;

    // 检查是否需要LRU淘汰
    if (this.cache.size >= this.config.maxSize && !this.cache.has(key)) {
      this.evictLRU();
    }

    const item: CacheItem<T> = {
      value,
      expiresAt,
      createdAt: now,
      accessCount: 0,
      lastAccessedAt: now,
    };

    this.cache.set(key, item);

    if (this.config.enableStats) {
      this.stats.sets++;
      this.updateStats();
    }
  }

  /**
   * 删除缓存项
   */
  delete(key: string): boolean {
    const deleted = this.cache.delete(key);
    if (deleted && this.config.enableStats) {
      this.stats.deletes++;
      this.updateStats();
    }
    return deleted;
  }

  /**
   * 清空所有缓存
   */
  clear(): void {
    const size = this.cache.size;
    this.cache.clear();

    if (this.config.enableStats) {
      this.stats.evictions += size;
      this.updateStats();
    }
  }

  /**
   * 检查key是否存在且未过期
   */
  has(key: string): boolean {
    const item = this.cache.get(key);
    if (!item) {
      return false;
    }

    // 检查是否过期
    if (this.config.defaultTTL > 0 && item.expiresAt < Date.now()) {
      this.cache.delete(key);
      return false;
    }

    return true;
  }

  /**
   * 获取缓存大小
   * ⚡️ 优化：不再触发全量清理，保证 O(1) 性能
   * 过期项会在 get/has 时惰性删除，或由定期清理任务处理
   */
  size(): number {
    return this.cache.size;
  }

  /**
   * 获取所有keys
   * ⚡️ 优化：不再触发全量清理，保证 O(1) 性能
   * 过期项会在 get/has 时惰性删除，或由定期清理任务处理
   */
  keys(): string[] {
    return Array.from(this.cache.keys());
  }

  /**
   * 获取统计信息
   * ⚡️ 优化：不再触发全量清理，保证 O(1) 性能
   * 过期项会在 get/has 时惰性删除，或由定期清理任务处理
   */
  getStats(): CacheStats {
    return { ...this.stats };
  }

  /**
   * 重置统计信息
   */
  resetStats(): void {
    this.stats = {
      hits: 0,
      misses: 0,
      sets: 0,
      deletes: 0,
      evictions: 0,
      size: 0,
      hitRate: 0,
    };
  }

  /**
   * 清理过期项（LFU淘汰 - Least Frequently Used）
   * ⚠️ 性能说明：此方法使用 O(N) 复杂度遍历整个缓存
   * 适合中小规模缓存（< 1000 项）且需要按访问频率淘汰的场景
   * 如果需要 O(1) 性能，可改用纯 LRU 实现（基于 Map 插入顺序）
   */
  private evictLRU(): void {
    if (this.cache.size === 0) {
      return;
    }

    // 找到最少访问的项（LFU 算法）
    let lruKey: string | null = null;
    let minAccessCount = Infinity;
    let oldestAccess = Infinity;

    // O(N) 遍历：优先淘汰访问次数最少的，如果相同则淘汰最久未访问的
    for (const [key, item] of this.cache.entries()) {
      if (
        item.accessCount < minAccessCount ||
        (item.accessCount === minAccessCount && item.lastAccessedAt < oldestAccess)
      ) {
        minAccessCount = item.accessCount;
        oldestAccess = item.lastAccessedAt;
        lruKey = key;
      }
    }

    if (lruKey) {
      this.cache.delete(lruKey);
      if (this.config.enableStats) {
        this.stats.evictions++;
      }
    }
  }

  /**
   * 清理所有过期项
   */
  private cleanupExpired(): void {
    if (this.config.defaultTTL === 0) {
      return; // 永不过期，无需清理
    }

    const now = Date.now();
    let cleaned = 0;

    for (const [key, item] of this.cache.entries()) {
      if (item.expiresAt < now) {
        this.cache.delete(key);
        cleaned++;
      }
    }

    if (cleaned > 0 && this.config.enableStats) {
      this.stats.evictions += cleaned;
      this.updateStats();
    }
  }

  /**
   * 启动定期清理
   */
  private startCleanup(): void {
    // 每5分钟清理一次过期项
    this.cleanupInterval = setInterval(
      () => {
        this.cleanupExpired();
      },
      5 * 60 * 1000
    );

    // ✅ 关键修复：不阻止进程退出
    // 允许进程在没有其他任务时自动退出，避免定时器阻止 Node.js 进程退出
    if (this.cleanupInterval && typeof this.cleanupInterval.unref === "function") {
      this.cleanupInterval.unref();
    }
  }

  /**
   * 停止定期清理
   */
  public stopCleanup(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = undefined;
    }
  }

  /**
   * 更新命中率
   */
  private updateHitRate(): void {
    const total = this.stats.hits + this.stats.misses;
    this.stats.hitRate = total > 0 ? this.stats.hits / total : 0;
  }

  /**
   * 更新统计信息
   */
  private updateStats(): void {
    this.stats.size = this.cache.size;
    this.updateHitRate();
  }

  /**
   * 销毁缓存（清理资源）
   */
  destroy(): void {
    this.stopCleanup();
    this.clear();
  }
}

/**
 * 创建带TTL的缓存
 */
export function createCache<T = any>(ttl: number, maxSize?: number): Cache<T> {
  return new Cache<T>({
    defaultTTL: ttl,
    maxSize: maxSize || 1000,
    enableStats: true,
  });
}

/**
 * 创建无过期时间的缓存
 */
export function createPermanentCache<T = any>(maxSize?: number): Cache<T> {
  return new Cache<T>({
    defaultTTL: 0,
    maxSize: maxSize || 1000,
    enableStats: true,
  });
}

// ========== ACE服务专用缓存工具 ==========

import { EventEmitter } from "events";

/**
 * Simple async lock for concurrency control
 * Prevents race conditions in async operations
 */
export class AsyncLock {
  private locks = new Map<string, Promise<void>>();

  /**
   * Acquire lock and execute callback
   */
  async withLock<T>(key: string, callback: () => Promise<T>): Promise<T> {
    // Wait for existing lock
    while (this.locks.has(key)) {
      await this.locks.get(key);
    }

    // Create new lock
    let releaseLock: () => void;
    const lockPromise = new Promise<void>((resolve) => {
      releaseLock = resolve;
    });

    this.locks.set(key, lockPromise);

    try {
      return await callback();
    } finally {
      this.locks.delete(key);
      releaseLock!();
    }
  }

  /**
   * Check if a key is currently locked
   */
  isLocked(key: string): boolean {
    return this.locks.has(key);
  }

  /**
   * Clear all locks
   */
  clear(): void {
    this.locks.clear();
  }
}

/**
 * Read-Write Lock for concurrent read access with exclusive write
 */
export class ReadWriteLock {
  private readers = 0;
  private writers = 0;
  private pendingWriters = 0;
  private events = new EventEmitter();

  async acquireRead(): Promise<() => void> {
    // Wait if there's a writer or pending writer
    while (this.writers > 0 || this.pendingWriters > 0) {
      await new Promise<void>((resolve) => {
        this.events.once("readReady", resolve);
      });
    }

    this.readers++;

    return () => {
      this.readers--;
      if (this.readers === 0) {
        this.events.emit("writeReady");
      }
    };
  }

  async acquireWrite(): Promise<() => void> {
    this.pendingWriters++;

    // Wait for all readers and writers to finish
    while (this.readers > 0 || this.writers > 0) {
      await new Promise<void>((resolve) => {
        this.events.once("writeReady", resolve);
      });
    }

    this.pendingWriters--;
    this.writers++;

    return () => {
      this.writers--;
      this.events.emit("readReady");
      this.events.emit("writeReady");
    };
  }

  /**
   * Execute callback with read lock
   */
  async withReadLock<T>(callback: () => Promise<T>): Promise<T> {
    const release = await this.acquireRead();
    try {
      return await callback();
    } finally {
      release();
    }
  }

  /**
   * Execute callback with write lock
   */
  async withWriteLock<T>(callback: () => Promise<T>): Promise<T> {
    const release = await this.acquireWrite();
    try {
      return await callback();
    } finally {
      release();
    }
  }

  /**
   * Destroy and cleanup
   */
  destroy(): void {
    this.events.removeAllListeners();
  }
}

/**
 * Event listener tracker for preventing memory leaks
 * Tracks listeners and provides cleanup functionality
 */
export class EventListenerTracker {
  private listeners: Array<{
    emitter: EventEmitter;
    event: string;
    listener: (...args: unknown[]) => void;
  }> = [];

  /**
   * Add a tracked listener
   */
  addListener(emitter: EventEmitter, event: string, listener: (...args: unknown[]) => void): void {
    emitter.on(event, listener);
    this.listeners.push({ emitter, event, listener });
  }

  /**
   * Add a tracked once listener
   */
  addOnceListener(
    emitter: EventEmitter,
    event: string,
    listener: (...args: unknown[]) => void
  ): void {
    const wrappedListener = (...args: unknown[]) => {
      // Remove from tracking after execution
      const idx = this.listeners.findIndex(
        (l) => l.emitter === emitter && l.event === event && l.listener === wrappedListener
      );
      if (idx !== -1) {
        this.listeners.splice(idx, 1);
      }
      listener(...args);
    };

    emitter.once(event, wrappedListener);
    this.listeners.push({ emitter, event, listener: wrappedListener });
  }

  /**
   * Remove all tracked listeners
   */
  removeAll(): void {
    for (const { emitter, event, listener } of this.listeners) {
      emitter.removeListener(event, listener);
    }
    this.listeners = [];
  }

  /**
   * Get number of tracked listeners
   */
  size(): number {
    return this.listeners.length;
  }
}

/**
 * LRU Map - 简化版LRU缓存，基于Map插入顺序
 * 适用于需要O(1)性能的场景
 */
export class LRUMap<K, V> {
  private cache = new Map<K, V>();

  constructor(private maxSize: number = 1000) {
    if (maxSize <= 0) {
      throw new Error("LRU map maxSize must be positive");
    }
  }

  get(key: K): V | undefined {
    const value = this.cache.get(key);
    if (value !== undefined) {
      // Move to end (most recently used)
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else {
      // Evict if at capacity
      while (this.cache.size >= this.maxSize) {
        const oldest = this.cache.keys().next().value;
        if (oldest !== undefined) {
          this.cache.delete(oldest);
        } else {
          break;
        }
      }
    }
    this.cache.set(key, value);
  }

  has(key: K): boolean {
    return this.cache.has(key);
  }

  delete(key: K): boolean {
    return this.cache.delete(key);
  }

  clear(): void {
    this.cache.clear();
  }

  size(): number {
    return this.cache.size;
  }

  keys(): IterableIterator<K> {
    return this.cache.keys();
  }

  values(): IterableIterator<V> {
    return this.cache.values();
  }

  entries(): IterableIterator<[K, V]> {
    return this.cache.entries();
  }

  forEach(callback: (value: V, key: K) => void): void {
    this.cache.forEach(callback);
  }
}
````

## File: src/utils/retry.ts
````typescript
/**
 * 重试工具
 * 提供指数退避重试机制
 */

import { logger } from "./logger";
import { TIMEOUT, DOOM_LOOP } from "../constants";

/**
 * 重试配置
 */
export interface RetryConfig {
  /** 最大重试次数（默认：3，表示初始1次 + 重试3次 = 总共4次尝试） */
  maxRetries?: number;
  /** 初始延迟时间（毫秒，默认：1000） */
  initialDelay?: number;
  /** 最大延迟时间（毫秒，默认：30000） */
  maxDelay?: number;
  /** 退避倍数（默认：2） */
  backoffMultiplier?: number;
  /** 是否启用随机抖动（默认：true）- 防止惊群效应 */
  jitter?: boolean;
  /** 是否对4xx错误重试（默认：false） */
  retryOn4xx?: boolean;
  /**
   * 自定义错误判断函数
   * 注意：如果提供此函数，将完全接管重试判断逻辑，内置的 5xx/网络错误判断将失效
   * 如果希望基于内置逻辑扩展，请使用 defaultShouldRetry 并在函数内部自行组合
   */
  shouldRetry?: (error: unknown) => boolean;
}

/**
 * 默认重试配置
 */
const DEFAULT_CONFIG: Required<Omit<RetryConfig, "shouldRetry">> = {
  maxRetries: DOOM_LOOP.THRESHOLD,
  initialDelay: 1000,
  maxDelay: TIMEOUT.TOOL_EXECUTION,
  backoffMultiplier: 2,
  jitter: true,
  retryOn4xx: false,
};

/**
 * 默认的重试判断逻辑
 * 可以被导出供用户组合使用
 *
 * @param error - 错误对象
 * @param retryOn4xx - 是否对4xx错误重试
 * @returns 是否应该重试
 */
export function defaultShouldRetry(error: unknown, retryOn4xx: boolean = false): boolean {
  // Extract error properties safely
  const errorObj = error instanceof Error ? error : null;
  const errorMessage = errorObj?.message ?? String(error);
  const errorCode = (errorObj as { code?: string })?.code ?? "";
  const errorResponse = (error as { response?: { status?: number } })?.response;
  const responseStatus = errorResponse?.status;

  // 1. 网络错误或超时，应该重试
  if (
    errorCode === "ECONNABORTED" ||
    errorCode === "ETIMEDOUT" ||
    errorCode === "ENOTFOUND" ||
    errorCode === "ECONNREFUSED" ||
    errorMessage.includes("timeout") ||
    errorMessage.includes("network")
  ) {
    return true;
  }

  // 2. 429 Too Many Requests（无论 retryOn4xx 如何都应该重试）
  if (responseStatus === 429) {
    return true;
  }

  // 3. 5xx服务器错误，应该重试
  if (responseStatus !== undefined && responseStatus >= 500 && responseStatus < 600) {
    return true;
  }

  // 4. 4xx客户端错误，默认不重试（除非配置允许）
  if (responseStatus !== undefined && responseStatus >= 400 && responseStatus < 500) {
    return retryOn4xx;
  }

  // 其他错误不重试
  return false;
}

/**
 * 计算退避延迟（指数退避 + Jitter）
 *
 * @param attempt - 当前尝试次数（从1开始）
 * @param config - 重试配置
 * @returns 延迟时间（毫秒）
 */
function calculateBackoffDelay(
  attempt: number,
  config: Required<Omit<RetryConfig, "shouldRetry">>
): number {
  let delay = config.initialDelay * Math.pow(config.backoffMultiplier, attempt - 1);

  // 限制最大延迟
  delay = Math.min(delay, config.maxDelay);

  // 🛡️ 添加抖动 (Jitter): 随机增加 0-20% 的时间
  // Full Jitter 策略更为复杂，这里采用简单的 Decorrelated Jitter 变体
  // 防止高并发场景下的惊群效应（Thundering Herd）
  if (config.jitter) {
    const jitterFactor = 1 + Math.random() * 0.2; // 1.0 - 1.2
    delay = Math.floor(delay * jitterFactor);
  }

  return delay;
}

/**
 * 等待指定时间
 */
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * 带重试的函数执行器
 *
 * @param fn - 要执行的函数（返回Promise）
 * @param config - 重试配置
 * @returns 函数执行结果
 */
export async function retry<T>(fn: () => Promise<T>, config: RetryConfig = {}): Promise<T> {
  const finalConfig = { ...DEFAULT_CONFIG, ...config };

  let lastError: unknown;
  let attempt = 0;

  // 循环条件：尝试次数 <= 最大重试次数
  // attempt 0 是首次执行，attempt 1-N 是重试
  // maxRetries=3 表示：初始1次 + 重试3次 = 总共4次尝试
  while (attempt <= finalConfig.maxRetries) {
    try {
      const result = await fn();

      // 如果之前有重试，记录成功
      if (attempt > 0) {
        logger.info(`✅ Retry succeeded after ${attempt} retry(s)`);
      }

      return result;
    } catch (error: unknown) {
      lastError = error;
      const errorMessage = error instanceof Error ? error.message : String(error);

      // 检查是否达到最大重试次数
      if (attempt >= finalConfig.maxRetries) {
        logger.warn(
          `❌ Max retries (${finalConfig.maxRetries}) exceeded. Last error: ${errorMessage}`
        );
        throw error;
      }

      // 🛠️ 修复：判断是否应该重试
      // 如果用户提供了自定义逻辑，完全信任用户（Override 模式）
      // 否则使用默认逻辑
      let shouldRetry = false;
      if (config.shouldRetry) {
        // 用户自定义逻辑完全接管
        shouldRetry = config.shouldRetry(error);
      } else {
        // 使用默认逻辑
        shouldRetry = defaultShouldRetry(error, finalConfig.retryOn4xx);
      }

      if (!shouldRetry) {
        logger.debug(`⚠️ Error not retriable: ${errorMessage}`);
        throw error;
      }

      attempt++;

      // 计算延迟（带 Jitter）
      const delay = calculateBackoffDelay(attempt, finalConfig);

      logger.warn(
        `⚠️ Request failed: ${errorMessage}. ` +
          `Retrying attempt ${attempt}/${finalConfig.maxRetries} in ${delay}ms...`
      );

      await sleep(delay);
    }
  }

  // 理论上不会到达这里（所有错误都应该在循环内处理）
  throw lastError;
}

/**
 * 创建重试包装器
 */
export function withRetry<T extends (...args: unknown[]) => Promise<unknown>>(
  fn: T,
  config?: RetryConfig
): T {
  return ((...args: unknown[]) => {
    return retry(() => fn(...args), config);
  }) as T;
}
````

## File: src/api/middleware/authMiddleware.ts
````typescript
/**
 * ApexBridge (ABP-only) - API认证中间件
 * 专门用于客户端API的认证（使用API Keys）
 * 
 * 注意：
 * - API Key 用于节点之间的认证（WebSocket）
 * - API Keys 用于客户端连接服务器的认证（HTTP API）
 */

import { Request, Response, NextFunction } from 'express';
import { logger } from '../../utils/logger';
import { ConfigService } from '../../services/ConfigService';

const configService = ConfigService.getInstance();

/**
 * 验证 API Key 并记录使用时间
 */
function validateApiKey(token: string): { valid: boolean; apiKeyId?: string } {
  try {
    const config = configService.readConfig();
    const apiKeys = config.auth?.apiKeys || [];
    
    // 查找匹配的 API Key
    const matchedKey = apiKeys.find(apiKey => apiKey.key === token);
    
    if (matchedKey) {
      // 🆕 记录使用时间（异步更新，不阻塞请求）
      updateLastUsedTime(matchedKey.id).catch(err => {
        logger.warn(`⚠️  Failed to update last used time for API key ${matchedKey.id}:`, err);
      });
      
      return { valid: true, apiKeyId: matchedKey.id };
    }
    
    return { valid: false };
  } catch (error) {
    logger.error('❌ Error validating API key:', error);
    return { valid: false };
  }
}

/**
 * 更新 API Key 的上次使用时间（异步）
 */
async function updateLastUsedTime(apiKeyId: string): Promise<void> {
  try {
    const config = configService.readConfig();
    const apiKeys = config.auth?.apiKeys || [];
    const apiKeyIndex = apiKeys.findIndex(k => k.id === apiKeyId);
    
    if (apiKeyIndex >= 0) {
      // 更新 lastUsedAt
      const updatedApiKeys = [...apiKeys];
      updatedApiKeys[apiKeyIndex] = {
        ...updatedApiKeys[apiKeyIndex],
        lastUsedAt: Date.now()
      };
      
      // 更新配置（异步写入，不阻塞）
      configService.updateConfig({
        auth: {
          ...config.auth,
          apiKeys: updatedApiKeys
        }
      });
    }
  } catch (error) {
    // 静默失败，不影响主要认证流程
    logger.debug(`Failed to update API key last used time: ${error}`);
  }
}

export function authMiddleware(req: Request, res: Response, next: NextFunction): void {
  // 检查是否启用认证
  const config = configService.readConfig();
  if (!config.auth?.enabled) {
    // 认证未启用，直接放行
    return next();
  }
  
  // 🆕 跳过某些路径的认证（公共API和静态资源）
  const publicPaths = ['/health', '/metrics', '/vite.svg', '/favicon.ico', '/'];
  if (publicPaths.includes(req.path)) {
    return next();
  }
  
  // 🆕 跳过所有静态资源（.svg, .ico, .png, .jpg等）
  if (/\.(svg|ico|png|jpg|jpeg|gif|css|js|woff|woff2|ttf|eot)$/i.test(req.path)) {
    return next();
  }
  
  // 🆕 对于客户端API，需要验证 API Key（从配置文件读取）
  const authHeader = req.headers.authorization;
  
  if (!authHeader) {
    logger.warn('⚠️  Request without Authorization header');
    res.status(401).json({
      error: {
        message: 'Missing Authorization header',
        type: 'authentication_error'
      }
    });
    return;
  }
  
  // 验证Bearer token
  const token = authHeader.replace('Bearer ', '');
  
  // 🆕 从配置文件验证 API Key
  const validation = validateApiKey(token);
  
  if (!validation.valid) {
    logger.warn(`⚠️  Invalid API key for ${req.path}`);
    res.status(401).json({
      error: {
        message: 'Invalid API key',
        type: 'authentication_error'
      }
    });
    return;
  }
  
  res.locals.auth = {
    ...(res.locals.auth || {}),
    apiKeyId: validation.apiKeyId,
    apiKeyToken: token
  };

  logger.debug(`✅ API key validated for ${req.path} (key ID: ${validation.apiKeyId})`);
  next();
}
````

## File: src/core/tool-action/types.ts
````typescript
/**
 * Tool Action 类型定义
 * 定义 <tool_action> 标签解析相关的类型接口
 */

/**
 * 工具类型枚举
 */
export enum ToolType {
  SKILL = "skill",
  MCP = "mcp",
  BUILTIN = "builtin",
}

/**
 * 工具调用解析结果
 */
export interface ToolActionCall {
  /** 工具名称 */
  name: string;
  /** 工具类型 */
  type: ToolType;
  /** 参数键值对 */
  parameters: Record<string, string>;
  /** 原始标签文本 */
  rawText: string;
  /** 在原文中的起始位置 */
  startIndex: number;
  /** 在原文中的结束位置 */
  endIndex: number;
}

/**
 * 文本段落（非工具调用部分）
 */
export interface TextSegment {
  /** 文本内容 */
  content: string;
  /** 起始位置 */
  startIndex: number;
  /** 结束位置 */
  endIndex: number;
}

/**
 * 解析结果
 */
export interface ParseResult {
  /** 解析出的工具调用列表 */
  toolCalls: ToolActionCall[];
  /** 非工具调用的文本段 */
  textSegments: TextSegment[];
  /** 未完成的标签文本（用于流式场景） */
  pendingText: string;
}

/**
 * 流式检测结果
 */
export interface DetectionResult {
  /** 是否检测到完整标签 */
  complete: boolean;
  /** 完整的工具调用（当 complete 为 true 时） */
  toolAction?: ToolActionCall;
  /** 可安全输出的文本 */
  textToEmit: string;
  /** 需要继续缓冲的文本 */
  bufferRemainder: string;
}

/**
 * 流式检测器状态
 */
export enum DetectorState {
  /** 正常状态，无标签检测中 */
  NORMAL = "NORMAL",
  /** 检测到标签开始 <tool_action */
  TAG_OPENING = "TAG_OPENING",
  /** 标签内容收集中 */
  TAG_CONTENT = "TAG_CONTENT",
  /** 检测到闭合标签 </tool_action> */
  TAG_CLOSING = "TAG_CLOSING",
}

/**
 * 工具调度器配置
 */
export interface DispatcherConfig {
  /** 工具执行超时时间（毫秒），默认 30000 */
  timeout?: number;
  /** 最大并发执行数，默认 3 */
  maxConcurrency?: number;
}

/**
 * 工具执行结果
 */
export interface ToolExecutionResult {
  /** 执行是否成功 */
  success: boolean;
  /** 工具名称 */
  toolName: string;
  /** 执行结果（成功时） */
  result?: any;
  /** 错误信息（失败时） */
  error?: string;
  /** 执行耗时（毫秒） */
  executionTime: number;
  /** 是否对用户隐藏结果（仅用于内部 LLM 推理） */
  hiddenFromUser?: boolean;

  // 🆕 工具调用详情（成功时）
  tool_details?: {
    tool_name: string;
    input_params: Record<string, any>;
    output_content: string;
    output_metadata?: {
      token_count?: number;
      execution_time_ms?: number;
      rate_limit_remaining?: number;
      mode?: string;
    };
  };

  // 🆕 错误详情（失败时）
  error_details?: {
    error_type: string;
    error_message: string;
    error_stack?: string;
    context?: Record<string, any>;
  };
}

/**
 * 工具描述（用于生成提示词）
 */
export interface ToolDescription {
  /** 工具名称 */
  name: string;
  /** 工具描述 */
  description: string;
  /** 参数定义 */
  parameters: {
    name: string;
    type: string;
    description: string;
    required: boolean;
  }[];
}
````

## File: src/services/ConversationHistoryService.ts
````typescript
/**
 * ConversationHistoryService - 对话消息历史管理服务
 * 负责存储、查询和删除对话消息历史
 */

import Database from "better-sqlite3";
import * as fs from "fs";
import * as path from "path";
import { logger } from "../utils/logger";
import { PathService } from "./PathService";
import { Message } from "../types";

export interface ConversationMessage {
  id: number;
  conversation_id: string;
  role: "user" | "assistant" | "system";
  content: string;
  created_at: number;
  metadata?: string; // JSON string for additional metadata
}

/**
 * 对话历史服务
 */
export class ConversationHistoryService {
  private static instance: ConversationHistoryService;
  private db: Database.Database;
  private dbPath: string;

  private constructor() {
    const pathService = PathService.getInstance();
    const dataDir = pathService.getDataDir();

    // 确保数据目录存在
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }

    this.dbPath = path.join(dataDir, "conversation_history.db");
    this.db = new Database(this.dbPath);

    // 启用 WAL 模式提升性能
    this.db.pragma("journal_mode = WAL");
    // 启用外键约束
    this.db.pragma("foreign_keys = ON");

    this.initializeDatabase();
    logger.debug(`ConversationHistoryService initialized (database: ${this.dbPath})`);
  }

  /**
   * 获取单例实例
   */
  public static getInstance(): ConversationHistoryService {
    if (!ConversationHistoryService.instance) {
      ConversationHistoryService.instance = new ConversationHistoryService();
    }
    return ConversationHistoryService.instance;
  }

  /**
   * 初始化数据库表结构
   */
  private initializeDatabase(): void {
    this.db.exec(`
      -- 对话消息表
      CREATE TABLE IF NOT EXISTS conversation_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        conversation_id TEXT NOT NULL,
        role TEXT NOT NULL CHECK(role IN ('user', 'assistant', 'system')),
        content TEXT NOT NULL,
        created_at INTEGER NOT NULL,
        metadata TEXT
      );

      -- 创建索引以提升查询性能
      CREATE INDEX IF NOT EXISTS idx_conversation_id ON conversation_messages(conversation_id);
      CREATE INDEX IF NOT EXISTS idx_conversation_created ON conversation_messages(conversation_id, created_at);
      CREATE INDEX IF NOT EXISTS idx_created_at ON conversation_messages(created_at);
    `);

    logger.debug("✅ Conversation history tables initialized");
  }

  /**
   * 格式化多模态消息内容为可读格式
   * 将 content 数组转换为 "文本内容\n<img>base64...</img>\n<img>base64...</img>"
   */
  private formatMultimodalContent(content: string | any[]): string {
    if (typeof content === "string") {
      return content;
    }

    if (Array.isArray(content)) {
      const parts: string[] = [];

      for (const part of content) {
        if (part.type === "text" && part.text) {
          parts.push(part.text);
        } else if (part.type === "image_url") {
          // 提取图片URL
          let imageUrl: string = "";
          if (typeof part.image_url === "string") {
            imageUrl = part.image_url;
          } else if (part.image_url?.url) {
            imageUrl = part.image_url.url;
          }

          if (imageUrl) {
            // 使用XML标签包裹图片，方便后续解析和渲染
            parts.push(`<img>${imageUrl}</img>`);
          }
        }
      }

      return parts.join("\n");
    }

    // 其他类型（如对象），回退到JSON序列化
    return JSON.stringify(content);
  }

  /**
   * 保存消息到历史记录
   * @param conversationId 对话ID
   * @param messages 消息列表
   */
  async saveMessages(conversationId: string, messages: Message[]): Promise<void> {
    try {
      const stmt = this.db.prepare(`
        INSERT INTO conversation_messages (conversation_id, role, content, created_at, metadata)
        VALUES (?, ?, ?, ?, ?)
      `);

      const insertMany = this.db.transaction((msgs: Message[]) => {
        for (const msg of msgs) {
          // Message 类型可能没有 metadata 属性，使用类型断言或可选链
          const metadata = (msg as any).metadata ? JSON.stringify((msg as any).metadata) : null;

          // 🐾 格式化多模态消息内容
          const contentToStore = this.formatMultimodalContent(msg.content);

          stmt.run(conversationId, msg.role, contentToStore, Date.now(), metadata);
        }
      });

      insertMany(messages);
      logger.debug(
        `[ConversationHistory] Saved ${messages.length} messages for conversation: ${conversationId}`
      );
    } catch (error: any) {
      logger.error(`[ConversationHistory] Failed to save messages: ${error.message}`);
      throw error;
    }
  }

  /**
   * 获取对话消息历史
   * @param conversationId 对话ID
   * @param limit 限制返回数量，默认 100
   * @param offset 偏移量，默认 0
   * @returns 消息列表
   */
  async getMessages(
    conversationId: string,
    limit: number = 100,
    offset: number = 0
  ): Promise<ConversationMessage[]> {
    try {
      const stmt = this.db.prepare(`
        SELECT id, conversation_id, role, content, created_at, metadata
        FROM conversation_messages
        WHERE conversation_id = ?
        ORDER BY created_at ASC
        LIMIT ? OFFSET ?
      `);

      const rows = stmt.all(conversationId, limit, offset) as ConversationMessage[];
      return rows;
    } catch (error: any) {
      logger.error(`[ConversationHistory] Failed to get messages: ${error.message}`);
      throw error;
    }
  }

  /**
   * 获取对话消息总数
   * @param conversationId 对话ID
   * @returns 消息总数
   */
  async getMessageCount(conversationId: string): Promise<number> {
    try {
      const stmt = this.db.prepare(`
        SELECT COUNT(*) as count
        FROM conversation_messages
        WHERE conversation_id = ?
      `);

      const result = stmt.get(conversationId) as { count: number };
      return result.count;
    } catch (error: any) {
      logger.error(`[ConversationHistory] Failed to get message count: ${error.message}`);
      throw error;
    }
  }

  /**
   * 删除对话的所有消息历史
   * @param conversationId 对话ID
   */
  async deleteMessages(conversationId: string): Promise<void> {
    try {
      const stmt = this.db.prepare(`
        DELETE FROM conversation_messages
        WHERE conversation_id = ?
      `);

      const result = stmt.run(conversationId);
      logger.info(
        `[ConversationHistory] Deleted ${result.changes} messages for conversation: ${conversationId}`
      );
    } catch (error: any) {
      logger.error(`[ConversationHistory] Failed to delete messages: ${error.message}`);
      throw error;
    }
  }

  /**
   * 删除指定时间之前的消息（用于清理旧数据）
   * @param beforeTimestamp 时间戳（毫秒）
   * @returns 删除的消息数量
   */
  async deleteMessagesBefore(beforeTimestamp: number): Promise<number> {
    try {
      const stmt = this.db.prepare(`
        DELETE FROM conversation_messages
        WHERE created_at < ?
      `);

      const result = stmt.run(beforeTimestamp);
      logger.info(
        `[ConversationHistory] Deleted ${result.changes} messages before ${new Date(beforeTimestamp).toISOString()}`
      );
      return result.changes;
    } catch (error: any) {
      logger.error(`[ConversationHistory] Failed to delete old messages: ${error.message}`);
      throw error;
    }
  }

  /**
   * 获取所有有消息历史的对话ID
   * @returns conversation_id 列表，按最后消息时间倒序排列
   */
  async getAllConversationIds(): Promise<string[]> {
    try {
      const stmt = this.db.prepare(`
        SELECT conversation_id, MAX(created_at) as last_message_at
        FROM conversation_messages
        GROUP BY conversation_id
        ORDER BY last_message_at DESC
      `);

      const rows = stmt.all() as Array<{ conversation_id: string; last_message_at: number }>;
      return rows.map((row) => row.conversation_id);
    } catch (error) {
      logger.error("❌ Failed to get all conversation IDs:", error);
      throw error;
    }
  }

  /**
   * 获取对话的最后一条消息
   * @param conversationId 对话ID
   * @returns 最后一条消息或null（如果不存在）
   * @throws {Error} 数据库错误时抛出错误
   */
  async getLastMessage(conversationId: string): Promise<ConversationMessage | null> {
    try {
      const stmt = this.db.prepare(`
        SELECT id, conversation_id, role, content, created_at, metadata
        FROM conversation_messages
        WHERE conversation_id = ?
        ORDER BY created_at DESC
        LIMIT 1
      `);

      const row = stmt.get(conversationId) as ConversationMessage | undefined;
      return row || null;
    } catch (error: any) {
      logger.error(`[ConversationHistory] Failed to get last message: ${error.message}`);
      throw new Error(
        `Failed to get last message for conversation ${conversationId}: ${error.message}`
      );
    }
  }

  /**
   * 获取对话的第一条消息
   * @param conversationId 对话ID
   * @returns 第一条消息或null（如果不存在）
   * @throws {Error} 数据库错误时抛出错误
   */
  async getFirstMessage(conversationId: string): Promise<ConversationMessage | null> {
    try {
      const stmt = this.db.prepare(`
        SELECT id, conversation_id, role, content, created_at, metadata
        FROM conversation_messages
        WHERE conversation_id = ?
        ORDER BY created_at ASC
        LIMIT 1
      `);

      const row = stmt.get(conversationId) as ConversationMessage | undefined;
      return row || null;
    } catch (error: any) {
      logger.error(`[ConversationHistory] Failed to get first message: ${error.message}`);
      throw new Error(
        `Failed to get first message for conversation ${conversationId}: ${error.message}`
      );
    }
  }

  /**
   * 关闭数据库连接
   */
  close(): void {
    this.db.close();
    logger.info("✅ ConversationHistoryService database closed");
  }
}
````

## File: src/strategies/SingleRoundStrategy.ts
````typescript
/**
 * SingleRoundStrategy - 单轮聊天处理策略
 * 处理单次LLM调用，不启用ReAct思考循环
 */

import type { Message, ChatOptions } from '../types';
import type { ChatStrategy, ChatResult } from './ChatStrategy';
import type { LLMManager } from '../core/LLMManager';
import type { ConversationHistoryService } from '../services/ConversationHistoryService';
import { logger } from '../utils/logger';

export class SingleRoundStrategy implements ChatStrategy {
  constructor(
    private llmManager: LLMManager,
    private historyService: ConversationHistoryService
  ) {}

  getName(): string {
    return 'SingleRoundStrategy';
  }

  /**
   * 检查是否支持该选项（不支持selfThinking）
   */
  supports(options: ChatOptions): boolean {
    return !options.selfThinking?.enabled;
  }

  /**
   * 执行单轮聊天处理
   * 注意：messages 已由 ChatService 完成变量替换
   */
  async execute(messages: Message[], options: ChatOptions): Promise<ChatResult> {
    logger.debug(`[${this.getName()}] Processing ${messages.length} messages`);

    // 调用LLM
    const llmResponse = await this.llmManager.chat(messages, options);
    const aiContent = (llmResponse.choices[0]?.message?.content as string) || '';

    logger.debug(`[${this.getName()}] LLM Response: ${aiContent.substring(0, 200)}...`);

    // ChatService会统一保存历史，策略层只返回数据
    return {
      content: aiContent,
      usage: llmResponse.usage
    };
  }

  /**
   * 创建流式迭代器（流式版本）
   * 注意：messages 已由 ChatService 完成变量替换
   */
  async *stream(
    messages: Message[],
    options: ChatOptions,
    abortSignal?: AbortSignal
  ): AsyncIterableIterator<string> {
    logger.debug(`[${this.getName()}] Streaming ${messages.length} messages`);

    // 流式调用LLM
    const stream = this.llmManager.streamChat(messages, options, abortSignal);

    for await (const chunk of stream) {
      // 检查中断
      if (abortSignal?.aborted) {
        logger.debug(`[${this.getName()}] Stream aborted`);
        return;
      }

      yield chunk;
    }
  }
}
````

## File: src/core/tools/builtin/VectorSearchTool.ts
````typescript
/**
 * VectorSearchTool - 向量搜索内置工具
 * 使用LanceDB搜索相关的Skills工具
 */

import { ToolResult, BuiltInTool, ToolType } from "../../../types/tool-system";
import {
  getToolRetrievalService,
  ToolRetrievalService,
} from "../../../services/ToolRetrievalService";
import { logger } from "../../../utils/logger";
import { THRESHOLDS } from "../../../constants";

/**
 * VectorSearchTool参数接口
 */
export interface VectorSearchArgs {
  /** 搜索查询 */
  query: string;
  /** 最大返回结果数 */
  limit?: number;
  /** 相似度阈值 */
  threshold?: number;
  /** 是否包含元数据 */
  includeMetadata?: boolean;
}

/**
 * 向量搜索工具
 * 基于用户查询在Skills向量库中搜索相关工具
 */
export class VectorSearchTool {
  private static readonly DEFAULT_LIMIT = 5;
  private static readonly MAX_LIMIT = 20;

  private static get DEFAULT_THRESHOLD(): number {
    return THRESHOLDS.RELEVANT_SKILLS;
  }

  /**
   * 执行向量搜索
   * @param args 搜索参数
   * @returns 搜索结果
   */
  static async execute(args: VectorSearchArgs): Promise<ToolResult> {
    const startTime = Date.now();

    try {
      // 参数验证
      this.validateArgs(args);

      // 获取工具检索服务
      const retrievalService = getToolRetrievalService();

      logger.info(`Vector search for query: "${args.query}"`);

      // 执行搜索
      const results = await retrievalService.findRelevantSkills(
        args.query,
        args.limit || this.DEFAULT_LIMIT,
        args.threshold || this.DEFAULT_THRESHOLD
      );

      const duration = Date.now() - startTime;

      // 格式化结果
      const formattedResults = this.formatSearchResults(results, args);

      logger.info(`Vector search completed in ${duration}ms, found ${results.length} results`);

      return {
        success: true,
        output: formattedResults,
        duration,
        exitCode: 0,
      };
    } catch (error) {
      const duration = Date.now() - startTime;

      logger.error(`Vector search failed:`, error);

      return {
        success: false,
        error: this.formatError(error),
        duration,
        errorCode: "VECTOR_SEARCH_ERROR",
        exitCode: 1,
      };
    }
  }

  /**
   * 验证参数
   */
  private static validateArgs(args: VectorSearchArgs): void {
    if (!args.query || typeof args.query !== "string") {
      throw new Error("Query is required and must be a non-empty string");
    }

    if (args.query.trim().length === 0) {
      throw new Error("Query cannot be empty or whitespace only");
    }

    if (args.limit !== undefined) {
      if (typeof args.limit !== "number") {
        throw new Error("Limit must be a number");
      }
      if (args.limit < 1 || args.limit > this.MAX_LIMIT) {
        throw new Error(`Limit must be between 1 and ${this.MAX_LIMIT}`);
      }
    }

    if (args.threshold !== undefined) {
      if (typeof args.threshold !== "number") {
        throw new Error("Threshold must be a number");
      }
      if (args.threshold < 0 || args.threshold > 1) {
        throw new Error("Threshold must be between 0.0 and 1.0");
      }
    }
  }

  /**
   * 格式化搜索结果
   */
  private static formatSearchResults(
    results: Array<{
      tool: any;
      score: number;
      reason?: string;
    }>,
    args: VectorSearchArgs
  ): string {
    if (results.length === 0) {
      return `No relevant Skills found for query: "${args.query}"`;
    }

    let output = `Found ${results.length} relevant Tool(s) for: "${args.query}"\n\n`;

    results.forEach((result, index) => {
      output += this.formatResult(result, index + 1, args);
    });

    output += "\n";
    output += "=== How to Use These Tools ===\n\n";

    // 根据工具类型显示不同的使用说明
    const firstTool = results[0]?.tool;

    switch (firstTool?.type) {
      case "mcp": {
        output += "🔌 MCP Tool: Use tool_action with the tool name\n";
        output += `Example:\n`;
        output += `<tool_action name="${firstTool.name}" type="mcp">\n`;
        if (firstTool.metadata?.inputSchema?.properties) {
          const firstParam = Object.keys(firstTool.metadata.inputSchema.properties)[0];
          if (firstParam) {
            output += `  <${firstParam} value="your-value" />\n`;
          }
        }
        output += `</tool_action>\n\n`;
        break;
      }

      case "builtin": {
        output += '⚙️ Built-in Tool: Use tool_action with type="builtin"\n';
        output += `Example:\n`;
        output += `<tool_action name="${firstTool.name}" type="builtin">\n`;
        output += `</tool_action>\n\n`;
        break;
      }

      case "skill":
      default: {
        // Skill 类型
        const hasExecuteScript = firstTool?.path && this.checkIfExecutable(firstTool.path);
        if (hasExecuteScript) {
          output += "🔧 Executable Skill: Use tool_action to execute\n";
          output += `Example:\n`;
          output += `<tool_action name="${firstTool.name}" type="skill">\n`;
          if (firstTool.parameters?.properties) {
            const firstParam = Object.keys(firstTool.parameters.properties)[0];
            if (firstParam) {
              output += `  <${firstParam} value="your-value" />\n`;
            }
          }
          output += `</tool_action>\n\n`;
        } else {
          output += "📚 Knowledge Skill: Use read-skill to get full documentation\n";
          output += `Example:\n`;
          output += `<tool_action name="read-skill" type="builtin">\n`;
          output += `  <skillName value="${firstTool?.name || "skill-name"}" />\n`;
          output += `</tool_action>\n\n`;
        }
        break;
      }
    }

    output += "Note: After reading or executing, you can apply the knowledge to help the user.\n";

    return output;
  }

  /**
   * 检查 Skill 是否可执行（简单检查，实际检查在运行时）
   */
  private static checkIfExecutable(_skillPath: string): boolean {
    // 这里只是一个提示，实际的可执行性检查在 SkillsSandboxExecutor 中
    // 我们假设有 path 的 Skill 可能是可执行的
    return true;
  }

  /**
   * 格式化单个结果
   */
  private static formatResult(
    result: {
      tool: any;
      score: number;
      reason?: string;
    },
    index: number,
    args: VectorSearchArgs
  ): string {
    const tool = result.tool;

    // 根据工具类型显示不同图标和说明
    let typeIcon: string;
    let typeLabel: string;
    let typeDescription: string;

    switch (tool.type) {
      case "mcp": {
        typeIcon = "🔌";
        typeLabel = "MCP Tool";
        typeDescription = "External MCP server tool";
        break;
      }
      case "builtin": {
        typeIcon = "⚙️";
        typeLabel = "Built-in Tool";
        typeDescription = "System built-in tool";
        break;
      }
      case "skill":
      default: {
        // Skill 类型根据 parameters 判断可执行性
        const isExecutable =
          tool.parameters &&
          tool.parameters.properties &&
          Object.keys(tool.parameters.properties).length > 0;
        typeIcon = isExecutable ? "🔧" : "📚";
        typeLabel = isExecutable ? "Executable Skill" : "Knowledge Skill";
        typeDescription = isExecutable
          ? "Use tool_action to execute"
          : "Use read-skill to get full documentation";
        break;
      }
    }

    let output = `${index}. ${tool.name} [${typeIcon} ${typeLabel}]\n`;
    output += `   Score: ${(result.score * 100).toFixed(2)}%\n`;
    output += `   Description: ${tool.description}\n`;
    output += `   Type: ${typeDescription}\n`;

    if (tool.source && tool.type === "mcp") {
      output += `   Source: ${tool.source}\n`;
    }

    if (tool.tags && Array.isArray(tool.tags) && tool.tags.length > 0) {
      output += `   Tags: ${tool.tags.join(", ")}\n`;
    }

    // 显示参数（Skill 和 MCP 工具）
    if (tool.type === "skill" && tool.parameters?.properties) {
      output += `   Parameters:\n`;
      const properties = tool.parameters.properties;
      const required = tool.parameters.required || [];

      Object.entries(properties).forEach(([paramName, paramSchema]) => {
        const schema: any = paramSchema;
        const isRequired = required.includes(paramName);
        const requiredMarker = isRequired ? " (required)" : "";
        output += `     - ${paramName}${requiredMarker}: ${schema.description}\n`;

        if (schema.type) {
          output += `       Type: ${schema.type}\n`;
        }

        if (schema.default !== undefined) {
          output += `       Default: ${JSON.stringify(schema.default)}\n`;
        }

        if (schema.enum) {
          output += `       Enum: ${schema.enum.join(", ")}\n`;
        }
      });
    }

    if (args.includeMetadata && tool.metadata) {
      output += `   Metadata: ${JSON.stringify(tool.metadata, null, 2)}\n`;
    }

    if (result.reason) {
      output += `   Reason: ${result.reason}\n`;
    }

    output += "\n";
    return output;
  }

  /**
   * 格式化错误信息
   */
  private static formatError(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error occurred during vector search";
  }

  /**
   * 获取工具元数据
   */
  static getMetadata() {
    return {
      name: "vector-search",
      description:
        "Search for relevant Skills tools using vector similarity. Use this when you need to find tools to help with a task.",
      category: "search",
      level: 1,
      parameters: {
        type: "object",
        properties: {
          query: {
            type: "string",
            description: "Search query describing what kind of tool or functionality you need",
          },
          limit: {
            type: "number",
            description: `Maximum number of results to return (default: ${this.DEFAULT_LIMIT}, max: ${this.MAX_LIMIT})`,
            default: this.DEFAULT_LIMIT,
            minimum: 1,
            maximum: this.MAX_LIMIT,
          },
          threshold: {
            type: "number",
            description:
              "Similarity threshold (0.0 to 1.0, default: 0.40). Higher values = more strict matching",
            default: this.DEFAULT_THRESHOLD,
            minimum: 0.0,
            maximum: 1.0,
          },
          includeMetadata: {
            type: "boolean",
            description: "Include additional metadata in results",
            default: false,
          },
        },
        required: ["query"],
      },
    };
  }

  /**
   * 计算搜索查询的向量嵌入（备用方法）
   */
  private static async getQueryEmbedding(query: string): Promise<number[]> {
    // 这个方法将由ToolRetrievalService实现
    // 这里只是占位符
    throw new Error("getQueryEmbedding not implemented");
  }

  /**
   * 从搜索结果中提取工具参数模式（用于动态生成工具调用）
   */
  private static extractParametersFromResults(results: any[]): string {
    if (results.length === 0) {
      return "No tools found";
    }

    const tool = results[0].tool;
    if (!tool.parameters || !tool.parameters.properties) {
      return "No parameters defined";
    }

    const params = Object.entries(tool.parameters.properties).map(
      ([name, schema]: [string, any]) => {
        const required = tool.parameters.required?.includes(name) ? " (required)" : "";
        return `    ${name}${required}: ${schema.type} - ${schema.description}`;
      }
    );

    return params.join("\n");
  }
}

/**
 * 创建VectorSearchTool实例（用于注册表）
 */
export function createVectorSearchTool() {
  return {
    ...VectorSearchTool.getMetadata(),
    type: ToolType.BUILTIN,
    enabled: true,
    execute: async (args: Record<string, any>) => {
      return VectorSearchTool.execute(args as VectorSearchArgs);
    },
  } as BuiltInTool;
}
````

## File: src/services/executors/SkillsSandboxExecutor.ts
````typescript
/**
 * SkillsSandboxExecutor - Skills沙箱执行器
 * 在隔离的Node.js子进程中执行Skills，提供进程级安全沙箱
 */

import { spawn, ChildProcess } from "child_process";
import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";
import { EventEmitter } from "events";
import * as crypto from "crypto";
import { BaseToolExecutor } from "./ToolExecutor";
import {
  ToolExecuteOptions,
  ToolResult,
  SandboxExecutionOptions,
  SandboxExecutionResult,
  SkillTool,
  ToolError,
  ToolErrorCode,
} from "../../types/tool-system";
import { logger } from "../../utils/logger";
import { getSkillManager } from "../SkillManager";
import { getPermissionValidator, PermissionValidationConfig } from "../compat/PermissionValidator";

// 最大参数大小限制 (1MB)
const MAX_ARGS_SIZE = 1 * 1024 * 1024;

// 进程最大生命周期 (5分钟)
const MAX_PROCESS_LIFETIME = 5 * 60 * 1000;

/**
 * 执行统计记录
 */
interface ExecutionStats {
  callCount: number;
  successCount: number;
  totalDuration: number;
  errors: Array<{
    timestamp: number;
    error: string;
    toolName: string;
  }>;
}

/**
 * Skills沙箱执行器
 * 提供进程级隔离和资源限制的沙箱环境
 */
export class SkillsSandboxExecutor extends BaseToolExecutor {
  private stats: Map<string, ExecutionStats> = new Map();
  private activeProcesses: Map<string, ChildProcess> = new Map();
  private executionOptions: SandboxExecutionOptions;
  private processMonitor: ReturnType<typeof setInterval> | null = null;
  private readonly maxArgsSize = MAX_ARGS_SIZE;
  private readonly maxProcessLifetime = MAX_PROCESS_LIFETIME;
  private permissionConfig: PermissionValidationConfig;

  constructor(options: SandboxExecutionOptions = {}) {
    super();
    this.executionOptions = {
      timeout: 60000,
      maxOutputSize: 10 * 1024 * 1024, // 10MB
      memoryLimit: 512, // 512MB
      maxConcurrency: 3,
      allowedEnvVars: ["PATH"],
      workspacePath: path.join(os.tmpdir(), "skill-workspaces"),
      ...options,
    };

    // 初始化权限验证配置
    this.permissionConfig = {
      enabled: true,
      mode: "strict",
      logDeniedRequests: true,
      caseSensitive: true,
    };

    // 确保工作区目录存在
    this.ensureWorkspaceDirectory();

    logger.debug("SkillsSandboxExecutor initialized", {
      timeout: this.executionOptions.timeout,
      maxOutputSize: this.executionOptions.maxOutputSize,
      memoryLimit: this.executionOptions.memoryLimit,
      maxConcurrency: this.executionOptions.maxConcurrency,
      permissionValidation: this.permissionConfig,
    });
  }

  /**
   * 确保工作区目录存在
   */
  private async ensureWorkspaceDirectory(): Promise<void> {
    try {
      await fs.mkdir(this.executionOptions.workspacePath!, { recursive: true });
      logger.debug(`Workspace directory created: ${this.executionOptions.workspacePath}`);
    } catch (error) {
      logger.error("Failed to create workspace directory:", error);
      throw new Error(
        `Failed to create workspace directory: ${this.executionOptions.workspacePath}`
      );
    }
  }

  /**
   * 从执行参数中提取工具列表
   * 尝试从参数中识别 skill 需要调用的工具
   */
  private extractToolsFromArgs(args: Record<string, any>): string[] {
    const tools: string[] = [];

    // 检查 tools 参数
    if (args.tools && Array.isArray(args.tools)) {
      tools.push(...args.tools);
    }

    // 检查 requestedTools 参数
    if (args.requestedTools && Array.isArray(args.requestedTools)) {
      tools.push(...args.requestedTools);
    }

    // 检查 toolCalls 参数（OpenAI 格式）
    if (args.toolCalls && Array.isArray(args.toolCalls)) {
      for (const call of args.toolCalls) {
        if (call.name && typeof call.name === "string") {
          tools.push(call.name);
        }
      }
    }

    // 记录调试日志
    if (tools.length > 0) {
      logger.debug(`Extracted tools from args: ${tools.join(", ")}`);
    }

    return tools;
  }

  /**
   * 设置权限验证配置
   */
  public setPermissionConfig(config: PermissionValidationConfig): void {
    this.permissionConfig = { ...this.permissionConfig, ...config };
    logger.info(`Permission config updated for SkillsSandboxExecutor`, {
      config: this.permissionConfig,
    });
  }

  /**
   * 获取权限验证配置
   */
  public getPermissionConfig(): PermissionValidationConfig {
    return { ...this.permissionConfig };
  }

  /**
   * 执行Skills
   * @param options 执行选项
   * @returns 执行结果
   */
  async execute(options: ToolExecuteOptions): Promise<ToolResult> {
    const startTime = Date.now();
    const toolName = options.name;

    try {
      // 验证执行选项
      this.validateExecuteOptions(options);

      logger.info(`Executing Skills: ${toolName}`);
      logger.debug(`Skills arguments:`, options.args);

      // 权限验证：检查工具调用是否被允许
      if (this.permissionConfig.enabled) {
        const permissionValidator = getPermissionValidator(this.permissionConfig);
        const toolsToCheck = this.extractToolsFromArgs(options.args);

        if (toolsToCheck.length > 0) {
          logger.debug(`Validating permissions for skill ${toolName}`, { tools: toolsToCheck });

          const permissionResult = await permissionValidator.validatePermissions(
            toolName,
            toolsToCheck
          );

          if (!permissionResult.allowed) {
            logger.warn(`Permission denied for skill ${toolName}`, {
              deniedTools: permissionResult.deniedTools,
              reason: permissionResult.reason,
            });

            // 在 strict 模式下抛出错误
            if (this.permissionConfig.mode === "strict") {
              return this.createErrorResult(
                `Permission denied: tools [${permissionResult.deniedTools.join(", ")}] are not allowed for skill ${toolName}`,
                this.calculateDuration(startTime),
                ToolErrorCode.TOOL_EXECUTION_FAILED
              );
            }
            // warn 模式下继续执行但记录警告
          }
        }
      }

      // 检查Skills是否存在
      const skillPath = await this.getSkillPath(toolName);
      const executeScript = path.join(skillPath, "scripts", "execute.js");

      if (!(await this.fileExists(executeScript))) {
        throw new ToolError(`Skills not found: ${toolName}`, ToolErrorCode.SKILL_NOT_FOUND);
      }

      // 创建隔离工作区
      const workspaceDir = await this.createIsolatedWorkspace(toolName);
      logger.debug(`Created isolated workspace: ${workspaceDir}`);

      // 准备执行参数
      const execArgs = {
        toolName,
        args: options.args,
        workspace: workspaceDir,
        skillPath,
      };

      // 执行Skills
      const result = await this.executeInSandbox(execArgs);

      // 记录统计
      this.recordStats(toolName, true, result.duration);

      // 清理工作区（可选，可以保留用于调试）
      if (!options.args?.preserveWorkspace) {
        await this.cleanupWorkspace(workspaceDir);
      }

      logger.info(`Skills ${toolName} completed successfully in ${result.duration}ms`);

      return {
        success: true,
        output: result.stdout,
        stderr: result.stderr,
        duration: result.duration,
        exitCode: result.exitCode,
      };
    } catch (error) {
      const duration = this.calculateDuration(startTime);

      // 记录统计
      this.recordStats(toolName, false, duration, error);

      if (error instanceof ToolError) {
        logger.error(`Skills ${toolName} failed: ${error.message}`);
        return this.createErrorResult(error.message, duration, error.code);
      }

      logger.error(`Skills ${toolName} failed with unexpected error:`, error);
      return this.createErrorResult(
        `Skills execution failed: ${this.formatError(error)}`,
        duration,
        ToolErrorCode.TOOL_EXECUTION_FAILED
      );
    }
  }

  /**
   * 在沙箱中执行Skills
   */
  private async executeInSandbox(execArgs: {
    toolName: string;
    args: Record<string, any>;
    workspace: string;
    skillPath: string;
  }): Promise<SandboxExecutionResult> {
    const { toolName, args, workspace, skillPath } = execArgs;

    const startTime = Date.now();

    return new Promise((resolve, reject) => {
      // 准备进程参数
      const processArgs = this.prepareProcessArgs(args);

      // 设置环境变量（清理后的）
      const env = this.prepareCleanEnvironment();

      // 设置进程选项
      const spawnOptions = this.prepareSpawnOptions(workspace, env);

      // 启动子进程
      const executeScript = path.join(skillPath, "scripts", "execute.js");
      const process = spawn("node", [executeScript, ...processArgs], spawnOptions);

      // 记录活跃进程
      const processId = crypto.randomUUID();
      this.activeProcesses.set(processId, process);

      // 设置输出收集
      let stdout = "";
      let stderr = "";
      let outputSize = 0;
      let truncated = false;
      const maxOutputSize = this.executionOptions.maxOutputSize!;

      process.stdout?.on("data", (data: Buffer) => {
        const chunk = data.toString();

        // 检查输出大小限制
        outputSize += Buffer.byteLength(chunk);

        if (outputSize > maxOutputSize && !truncated) {
          truncated = true;
          stdout += "\n[TRUNCATED: Output exceeded size limit]";
          logger.warn(`Skills ${toolName} output exceeded size limit (${maxOutputSize} bytes)`);

          // 终止进程
          this.terminateProcess(process, "SIGKILL");

          // SIGKILL 不会触发 close 事件，需要手动清理
          this.activeProcesses.delete(processId);
        } else if (!truncated) {
          stdout += chunk;
        }
      });

      process.stderr?.on("data", (data: Buffer) => {
        const chunk = data.toString();

        if (!truncated) {
          stderr += chunk;
        }
      });

      // 设置超时
      const timeout = setTimeout(() => {
        logger.warn(
          `Skills ${toolName} execution timed out after ${this.executionOptions.timeout}ms`
        );
        this.terminateProcess(process, "SIGKILL");

        // SIGKILL 不会触发 close 事件，需要手动清理
        this.activeProcesses.delete(processId);

        const duration = this.calculateDuration(startTime);
        resolve({
          success: false,
          stdout,
          stderr: stderr || "Execution timed out",
          exitCode: -1,
          duration,
          error: `Execution timed out after ${this.executionOptions.timeout}ms`,
          truncated,
        });
      }, this.executionOptions.timeout);

      // 处理进程退出
      process.on("close", (code: number | null, signal: string | null) => {
        // 清理活跃进程记录
        this.activeProcesses.delete(processId);
        clearTimeout(timeout);

        const duration = this.calculateDuration(startTime);

        // 检查是否有错误
        if (code !== 0 || signal) {
          logger.warn(`Skills ${toolName} exited with code ${code}, signal ${signal}`);
          if (stderr && stderr.trim()) {
            logger.warn(`Skills ${toolName} stderr output:\n${stderr}`);
          }
        }

        const finalExitCode = code ?? (signal ? -1 : 0);

        resolve({
          success: code === 0 && !signal,
          stdout,
          stderr,
          exitCode: finalExitCode,
          duration,
          error: code !== 0 ? `Process exited with code ${code}` : undefined,
          truncated,
        });
      });

      // 处理进程错误
      process.on("error", (error: Error) => {
        // 清理活跃进程记录
        this.activeProcesses.delete(processId);
        clearTimeout(timeout);

        logger.error(`Skills ${toolName} process error:`, error);
        reject(error);
      });
    });
  }

  /**
   * 准备进程参数
   */
  private prepareProcessArgs(args: Record<string, any>): string[] {
    const serialized = JSON.stringify(args);

    // 检查参数大小限制
    const argsSize = Buffer.byteLength(serialized);
    if (argsSize > this.maxArgsSize) {
      throw new ToolError(
        `Tool arguments exceed maximum size limit (${this.maxArgsSize} bytes)`,
        ToolErrorCode.TOOL_EXECUTION_FAILED,
        { argsSize, maxSize: this.maxArgsSize }
      );
    }

    return [serialized];
  }

  /**
   * 准备干净的环境变量
   */
  private prepareCleanEnvironment(): NodeJS.ProcessEnv {
    const allowedVars = this.executionOptions.allowedEnvVars!;
    const env: NodeJS.ProcessEnv = {};

    // 只允许指定的环境变量
    allowedVars.forEach((varName) => {
      const value = process.env[varName];
      if (value !== undefined) {
        env[varName] = value;
      }
    });

    // 设置Node.js内存限制
    env.NODE_OPTIONS = `--max-old-space-size=${this.executionOptions.memoryLimit}`;

    // 设置其他安全选项
    env.NODE_NO_WARNINGS = "1";

    return env;
  }

  /**
   * 准备spawn选项
   */
  private prepareSpawnOptions(cwd: string, env: NodeJS.ProcessEnv): any {
    // 注意：不设置 cwd，使用脚本的绝对路径
    // workspace 只用于技能执行时的临时文件操作
    return {
      env,
      stdio: ["pipe", "pipe", "pipe"],
      shell: false, // 不使用shell，防止注入
      detached: false,
    };
  }

  /**
   * 创建隔离工作区
   */
  private async createIsolatedWorkspace(toolName: string): Promise<string> {
    const workspaceId = `${toolName}_${Date.now()}_${crypto.randomBytes(4).toString("hex")}`;
    const workspacePath = path.join(this.executionOptions.workspacePath!, workspaceId);

    try {
      await fs.mkdir(workspacePath, { recursive: true });

      // 设置只有所有者可以访问（安全最佳实践）
      await fs.chmod(workspacePath, 0o700);

      return workspacePath;
    } catch (error) {
      throw new ToolError(
        `Failed to create workspace: ${this.formatError(error)}`,
        ToolErrorCode.TOOL_EXECUTION_FAILED
      );
    }
  }

  /**
   * 清理工作区
   */
  private async cleanupWorkspace(workspacePath: string): Promise<void> {
    try {
      // 递归删除工作区目录
      await fs.rm(workspacePath, { recursive: true, force: true });
      logger.debug(`Cleaned up workspace: ${workspacePath}`);
    } catch (error) {
      logger.warn(`Failed to cleanup workspace ${workspacePath}:`, error);
      // 不抛出错误，避免影响主流程
    }
  }

  /**
   * 终止进程
   */
  private terminateProcess(process: ChildProcess, signal: string = "SIGTERM"): void {
    if (!process.killed && process.pid) {
      try {
        process.kill(signal as any);
        logger.debug(`Sent ${signal} signal to process ${process.pid}`);
      } catch (error) {
        logger.warn(`Failed to terminate process ${process.pid}:`, error);
      }
    }
  }

  /**
   * 获取Skills路径
   * 通过SkillManager查询Skill的实际路径，支持name与目录名不一致的情况
   */
  private async getSkillPath(skillName: string): Promise<string> {
    try {
      // 尝试通过SkillManager查询Skill
      const skillManager = getSkillManager();
      const skill = await skillManager.getSkillByName(skillName);

      if (skill && skill.path) {
        return skill.path;
      }

      // 如果找不到，尝试使用目录名直接拼接（兼容旧逻辑）
      const basePath = "./.data/skills";
      return path.join(basePath, skillName);
    } catch (error) {
      // 如果查询失败，回退到直接拼接
      logger.debug(`Failed to query skill path from SkillManager: ${error}`);
      const basePath = "./.data/skills";
      return path.join(basePath, skillName);
    }
  }

  /**
   * 检查文件是否存在
   */
  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 记录统计
   */
  private recordStats(toolName: string, success: boolean, duration: number, error?: any): void {
    if (!this.stats.has(toolName)) {
      this.stats.set(toolName, {
        callCount: 0,
        successCount: 0,
        totalDuration: 0,
        errors: [],
      });
    }

    const stats = this.stats.get(toolName)!;
    stats.callCount++;
    stats.totalDuration += duration;

    if (success) {
      stats.successCount++;
    } else {
      stats.errors.push({
        timestamp: Date.now(),
        error: this.formatError(error),
        toolName,
      });
    }
  }

  /**
   * 获取支持的工具列表（Skills）
   */
  listTools(): SkillTool[] {
    // Skills是动态加载的，这里返回空列表
    // 实际Skills由SkillManager管理
    return [];
  }

  /**
   * 获取执行统计
   */
  getStats(toolName?: string): Record<string, ExecutionStats> | ExecutionStats | null {
    if (toolName) {
      return this.stats.get(toolName) || null;
    }

    const allStats: Record<string, ExecutionStats> = {};
    for (const [name, stats] of this.stats) {
      allStats[name] = stats;
    }
    return allStats;
  }

  /**
   * 获取所有活跃进程
   */
  getActiveProcesses(): Array<{ pid: number; toolName: string }> {
    const processes: Array<{ pid: number; toolName: string }> = [];

    for (const process of this.activeProcesses.values()) {
      if (process.pid) {
        // 从工作区路径中提取工具名称
        const cwd = (process as any).spawnfile || "";
        const match = cwd.match(/\/data\/skills\/([^\/]+)/);
        const toolName = match ? match[1] : "unknown";

        processes.push({
          pid: process.pid,
          toolName,
        });
      }
    }

    return processes;
  }

  /**
   * 终止所有活跃进程
   */
  async terminateAllProcesses(): Promise<void> {
    const terminationPromises: Promise<void>[] = [];

    for (const process of this.activeProcesses.values()) {
      if (process.pid && !process.killed) {
        terminationPromises.push(
          new Promise((resolve) => {
            process.once("exit", () => resolve());
            try {
              process.kill("SIGKILL");
            } catch {
              resolve();
            }
          })
        );
      }
    }

    await Promise.all(terminationPromises);
    this.activeProcesses.clear();

    logger.info("Terminated all active Skills processes");
  }

  /**
   * 清理资源（优雅关闭）
   */
  async cleanup(): Promise<void> {
    logger.info("Cleaning up SkillsSandboxExecutor...");

    // 清除进程监控定时器
    if (this.processMonitor) {
      clearInterval(this.processMonitor);
      this.processMonitor = null;
    }

    // 终止所有进程
    await this.terminateAllProcesses();

    // 清理工作区
    try {
      await fs.rm(this.executionOptions.workspacePath!, { recursive: true, force: true });
      logger.debug("Cleaned up workspace directory");
    } catch (error) {
      logger.warn("Failed to cleanup workspace directory:", error);
    }

    logger.info("SkillsSandboxExecutor cleanup completed");
  }

  /**
   * 格式化错误信息
   */
  protected formatError(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error occurred in Skills sandbox";
  }
}

/**
 * Skills沙箱执行器工厂
 */
export class SkillsSandboxExecutorFactory {
  private static instance: SkillsSandboxExecutor | null = null;

  /**
   * 获取沙箱执行器实例
   */
  static getInstance(options?: SandboxExecutionOptions): SkillsSandboxExecutor {
    if (!this.instance) {
      this.instance = new SkillsSandboxExecutor(options);
    }
    return this.instance;
  }

  /**
   * 重置实例（用于测试）
   */
  static resetInstance(): void {
    this.instance = null;
  }

  /**
   * 清理所有资源（全局清理）
   */
  static async cleanupAll(): Promise<void> {
    if (this.instance) {
      await this.instance.cleanup();
      this.instance = null;
    }
  }
}

/**
 * 获取默认的Skills沙箱执行器
 */
export function getSkillsSandboxExecutor(options?: SandboxExecutionOptions): SkillsSandboxExecutor {
  return SkillsSandboxExecutorFactory.getInstance(options);
}
````

## File: src/api/websocket/WebSocketManager.ts
````typescript
/**
 * ApexBridge (ABP-only) - WebSocket管理器
 * 统一管理所有WebSocket连接和通道
 */

import { Server } from 'http';
import { WebSocketServer, WebSocket } from 'ws';
import * as crypto from 'crypto';
import type { AdminConfig } from '../../services/ConfigService';
import { logger } from '../../utils/logger';
import { ChatChannel } from './channels/ChatChannel';

/**
 * 扩展 WebSocket 类型以支持 isAlive 标记
 */
interface ExtWebSocket extends WebSocket {
  isAlive: boolean;
}

/**
 * WebSocket 管理器最小接口（用于 ChatService）
 */
export interface IWebSocketManager {
  getChannel?(name: string): {
    pushLog?(log: any): void;
  } | undefined;
}

export class WebSocketManager implements IWebSocketManager {
  /**
   * 获取通道（实现 IWebSocketManager 接口）
   * 当前实现中，ChatService 通过 ChatChannel 直接处理，此方法返回 undefined
   */
  getChannel?(name: string): {
    pushLog?(log: any): void;
  } | undefined {
    // 当前架构中，ChatService 通过 ChatChannel 直接处理 WebSocket 消息
    // 此方法保留以符合接口定义，但返回 undefined
    return undefined;
  }
  private wss!: WebSocketServer;
  private chatChannel: ChatChannel;
  private heartbeatInterval: NodeJS.Timeout | null = null;

  constructor(
    private config: AdminConfig,
    chatChannel: ChatChannel
  ) {
    this.chatChannel = chatChannel;
    logger.info('🌐 Initializing WebSocket Manager...');
  }
  
  /**
   * 初始化WebSocket服务器
   */
  initialize(server: Server): void {
    // 创建WebSocket服务器（直接绑定到HTTP server）
    this.wss = new WebSocketServer({ server });
    
    logger.debug('WebSocket Server created');
    
    // 设置连接处理器
    this.setupConnectionHandler();
    
    // 🆕 启动心跳检测
    this.setupHeartbeat();
    
    logger.debug('WebSocket Manager initialized');
  }
  
  /**
   * 设置WebSocket连接处理器
   */
  private setupConnectionHandler(): void {
    logger.info('🔧 Setting up WebSocket connection handler...');
    
    this.wss.on('connection', (ws: ExtWebSocket, request) => {
      // 🆕 初始化活跃状态
      ws.isAlive = true;
      
      // 🆕 收到 pong 时标记活跃
      ws.on('pong', () => {
        ws.isAlive = true;
      });

      const url = request.url || '';
      
      // 🛡️ 安全日志：脱敏 URL（隐藏 API Key）
      const maskedUrl = this.maskSensitiveUrl(url);
      logger.info(`📡 [WS] Connection received: ${maskedUrl}`);
      
      // 1. 优化正则：支持 v1/chat, 允许 query parameters
      // 匹配 /chat/api_key=xxx 或 /v1/chat/api_key=xxx
      // ([^/?&]+) 捕获 key 直到遇到 / 或 ? 或 &
      const chatMatch = url.match(/^\/(?:chat|v1\/chat)\/api_key=([^/?&]+)/);
      
      if (chatMatch) {
        const apiKey = chatMatch[1];
        
        // 🛡️ 安全日志：不打印 Key
        logger.debug('🔑 Verifying API Key...');

        if (this.validateApiKey(apiKey)) {
          logger.info('✅ API_Key validated, accepting chat connection');
          this.chatChannel.handleConnection(ws, apiKey, request);
        } else {
          logger.warn('⚠️ Chat connection denied: Invalid API_Key');
          ws.close(1008, 'Invalid API key');
        }
        return;
      }

      // 2. 未匹配的路径
      logger.warn(`⚠️ Unknown WebSocket path: ${maskedUrl}`);
      ws.close(1003, 'Unknown path');
    });
    
    logger.debug('Connection handler registered');
  }

  /**
   * 🛡️ 脱敏 URL，隐藏敏感信息（API Key）
   * 
   * @param url - 原始 URL
   * @returns 脱敏后的 URL
   */
  private maskSensitiveUrl(url: string): string {
    // 替换 api_key=xxx 为 api_key=***
    return url.replace(/api_key=([^/?&]+)/g, 'api_key=***');
  }
  
  /**
   * 🆕 心跳检测逻辑
   * 每 30 秒 Ping 一次，清理无响应的客户端
   */
  private setupHeartbeat(): void {
    const intervalMs = 30000; // 30 秒
    
    this.heartbeatInterval = setInterval(() => {
      this.wss.clients.forEach((ws) => {
        const extWs = ws as ExtWebSocket;
        
        if (extWs.isAlive === false) {
          logger.debug('✂️ Terminating inactive WebSocket connection');
          return extWs.terminate();
        }
        
        // 标记为假死，等待 pong 救活
        extWs.isAlive = false;
        extWs.ping();
      });
    }, intervalMs);
    
    logger.debug(`✅ Heartbeat mechanism started (interval: ${intervalMs}ms)`);
  }
  
  /**
   * 验证 API Key
   * 🛡️ 使用防时序攻击的比较方法
   * ✅ 修复：优先从配置文件读取，回退到环境变量
   */
  private validateApiKey(apiKey: string): boolean {
    // 优先从配置文件读取
    const configKey = this.config.auth?.apiKey || '';
    // 回退到环境变量（支持 API_KEY 和 ABP_API_KEY）
    const envKey = process.env.API_KEY || process.env.ABP_API_KEY || '';
    
    // 确定使用的 Key（配置文件优先）
    const expectedKey = configKey || envKey;
    
    // 如果未配置 Key，默认拒绝
    if (!expectedKey) {
      logger.warn('⚠️ API_KEY not configured (neither in config file nor environment), rejecting all connections');
      return false;
    }

    // 🛡️ 防时序攻击比较
    // 如果长度不同，直接返回 false (避免 timingSafeEqual 报错)
    if (apiKey.length !== expectedKey.length) {
      return false;
    }

    // 使用常量时间比较，防止时序攻击
    try {
      return crypto.timingSafeEqual(
        Buffer.from(apiKey),
        Buffer.from(expectedKey)
      );
    } catch (error) {
      // 如果比较失败（理论上不应该发生），记录并拒绝
      logger.error('❌ Error in API key comparison:', error);
      return false;
    }
  }
  
  /**
   * 优雅关闭
   * 在服务器关闭场景下，采用激进的关闭策略，避免等待客户端响应导致挂起
   */
  async shutdown(): Promise<void> {
    logger.info('🛑 Shutting down WebSocket Manager...');
    
    // 🆕 停止心跳检测
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
      logger.debug('✅ Heartbeat interval cleared');
    }
    
    // 关闭所有连接
    // 在服务器关闭场景下，使用 terminate() 直接断开 TCP 连接
    // 避免等待客户端响应导致关闭过程挂起
    const clientCount = this.wss.clients.size;
    if (clientCount > 0) {
      logger.debug(`Closing ${clientCount} WebSocket connection(s)...`);
      this.wss.clients.forEach((ws) => {
        // 先尝试优雅关闭，但设置短超时
        ws.close();
        
        // 如果 1 秒内客户端没有响应，强制断开
        setTimeout(() => {
          if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
            logger.debug('Force terminating unresponsive WebSocket connection');
            ws.terminate();
          }
        }, 1000);
      });
    }
    
    // 关闭WebSocket服务器
    return new Promise((resolve, reject) => {
      this.wss.close((err) => {
        if (err) {
          logger.error('❌ Error closing WebSocket server:', err);
          reject(err);
        } else {
          logger.info('✅ WebSocket server closed');
          resolve(undefined);
        }
      });
    });
  }
}
````

## File: src/core/llm/adapters/OllamaAdapter.ts
````typescript
/**
 * Ollama适配器
 */

import { BaseOpenAICompatibleAdapter } from "./BaseAdapter";
import { LLMProviderConfig, Message } from "../../../types";
import { logger } from "../../../utils/logger";
import { TIMEOUT } from "../../../constants";

export class OllamaAdapter extends BaseOpenAICompatibleAdapter {
  constructor(config: LLMProviderConfig) {
    // 对于本地服务，禁用代理
    const enhancedConfig = {
      ...config,
      // 禁用代理，避免localhost请求被转发到代理服务器
      proxy: false,
      // Ollama处理长提示词需要更长时间，设置5分钟超时
      timeout: config.timeout || TIMEOUT.SKILL_CACHE_TTL,
    };

    super("Ollama", enhancedConfig);

    logger.debug("Ollama adapter initialized", {
      baseURL: enhancedConfig.baseURL,
      timeout: enhancedConfig.timeout,
    });
  }

  /**
   * 过滤Ollama不支持的选项
   */
  protected filterOptions(options: any): any {
    const filtered: any = {};

    // Ollama支持的参数
    if (options.model !== undefined) {
      filtered.model = options.model;
    }
    if (options.temperature !== undefined) {
      filtered.temperature = options.temperature;
    }
    if (options.top_p !== undefined) {
      filtered.top_p = options.top_p;
    }
    if (options.max_tokens !== undefined) {
      filtered.num_predict = options.max_tokens; // Ollama使用num_predict而不是max_tokens
    }
    if (options.stop !== undefined) {
      filtered.stop = options.stop;
    }

    return filtered;
  }

  /**
   * 重写 embed 方法，使用 Ollama 的 /api/embeddings 端点
   */
  async embed(texts: string[], model?: string): Promise<number[][]> {
    try {
      // Ollama 0.13.5 使用 prompt 参数，不支持 input 参数
      const requestBody = {
        model: model || this.config.defaultModel,
        prompt: texts[0] || "", // Ollama 只支持单个文本
      };

      logger.debug(`[${this.providerName}] Embedding request`, {
        model: requestBody.model,
        textCount: texts.length,
        textPreview: (texts[0] || "").substring(0, 50),
      });

      // Ollama 使用 /api/embeddings 端点
      const response = await this.client.post("/api/embeddings", requestBody);

      // Ollama 格式: { embedding: [...] } 或 { embeddings: [[...]] }
      if (response.data?.embedding) {
        return [response.data.embedding];
      }
      if (response.data?.embeddings) {
        return response.data.embeddings;
      }

      // OpenAI 兼容格式
      if (response.data?.data) {
        return response.data.data.map((item: any) => item.embedding);
      }

      throw new Error("Unexpected embedding response format");
    } catch (error: any) {
      logger.error(`❌ ${this.providerName} embed error:`, error.message);
      if (error.response) {
        logger.error(`   HTTP状态: ${error.response.status}`);
        try {
          if (error.response.data && typeof error.response.data === "object") {
            logger.error(`   错误详情: ${JSON.stringify(error.response.data, null, 2)}`);
          }
        } catch (e) {
          // 序列化失败
        }
      }
      throw new Error(`${this.providerName} embedding failed: ${error.message}`);
    }
  }

  /**
   * 重写streamChat方法以正确处理多模态消息
   */
  async *streamChat(
    messages: Message[],
    options: any,
    tools?: any[],
    signal?: AbortSignal
  ): AsyncIterableIterator<string> {
    try {
      const { provider, ...apiOptions } = options;
      const filteredOptions = this.filterOptions(apiOptions);

      // 🐾 处理多模态消息（保持OpenAI标准格式）
      // Ollama 0.13.3+ 的 /chat/completions 端点支持 OpenAI 标准的 content 数组格式
      const processedMessages = messages.map((msg) => {
        if (Array.isArray(msg.content)) {
          return {
            role: msg.role,
            content: msg.content.map((part) => {
              if (part.type === "image_url") {
                // 规范化 image_url 格式，确保是 {url: string} 结构
                let imageUrl: string;
                if (typeof part.image_url === "string") {
                  imageUrl = part.image_url;
                } else if (part.image_url?.url) {
                  imageUrl = part.image_url.url;
                } else {
                  imageUrl = "";
                }

                return {
                  type: "image_url",
                  image_url: {
                    url: imageUrl,
                  },
                };
              }
              // text 类型
              return {
                type: "text",
                text: part.text || "",
              };
            }),
          };
        }
        // 普通字符串消息
        return {
          role: msg.role,
          content: msg.content,
        };
      });

      // 🐾 构建请求体 - 明确列出支持的参数
      const requestBody: any = {
        model: filteredOptions.model || options.model || this.config.defaultModel,
        messages: processedMessages,
        stream: true,
      };

      // ✅ 只添加明确支持的参数
      if (filteredOptions.temperature !== undefined) {
        requestBody.temperature = filteredOptions.temperature;
      }
      if (filteredOptions.top_p !== undefined) {
        requestBody.top_p = filteredOptions.top_p;
      }
      if (filteredOptions.num_predict !== undefined) {
        requestBody.num_predict = filteredOptions.num_predict;
      }
      if (filteredOptions.stop !== undefined) {
        requestBody.stop = filteredOptions.stop;
      }

      // ✅ 传递工具列表
      if (tools && tools.length > 0) {
        requestBody.tools = tools;
        requestBody.tool_choice = "auto";
      }

      // 打印请求详情（截断base64图片以避免日志过长）
      const debugRequestBody = JSON.parse(JSON.stringify(requestBody));
      let imageDetails: Array<{
        index: number;
        length: number;
        truncated: boolean;
        prefix: string;
      }> = [];

      if (debugRequestBody.messages) {
        debugRequestBody.messages = debugRequestBody.messages.map((msg: any) => {
          if (Array.isArray(msg.content)) {
            return {
              ...msg,
              content: msg.content.map((part: any, partIndex: number) => {
                if (part.type === "image_url" && part.image_url?.url) {
                  const url = part.image_url.url;
                  const isTruncated = url.length > 100;

                  imageDetails.push({
                    index: partIndex,
                    length: url.length,
                    truncated: isTruncated,
                    prefix: url.substring(0, 50),
                  });

                  return {
                    ...part,
                    image_url: {
                      url: isTruncated
                        ? `${url.substring(0, 100)}... (truncated, total ${url.length} chars)`
                        : url,
                    },
                  };
                }
                return part;
              }),
            };
          }
          return msg;
        });
      }

      logger.info(`[${this.providerName}] Stream request details:`, {
        model: requestBody.model,
        messageCount: messages.length,
        hasTools: !!tools,
        toolCount: tools?.length,
        hasImages: imageDetails.length > 0,
        imageDetails: imageDetails.map((img) => ({
          index: img.index,
          length: img.length,
          truncated: img.truncated,
          prefix: img.prefix,
        })),
      });

      logger.debug(
        `[${this.providerName}] Full request body (images truncated):`,
        JSON.stringify(debugRequestBody, null, 2)
      );

      // 🔍 额外验证：检查实际请求体中的图片数据是否完整
      if (imageDetails.length > 0) {
        console.log("\n==================== 🔍 调试信息 ====================");
        console.log(`消息总数: ${requestBody.messages.length}`);
        requestBody.messages.forEach((msg: any, idx: number) => {
          console.log(`\n消息 #${idx}:`);
          console.log(`  role: ${msg.role}`);
          console.log(
            `  content类型: ${Array.isArray(msg.content) ? "Array" : typeof msg.content}`
          );

          if (Array.isArray(msg.content)) {
            console.log(`  content数组长度: ${msg.content.length}`);
            msg.content.forEach((part: any, partIdx: number) => {
              console.log(`    Part #${partIdx}: type=${part.type}`);
              if (part.type === "text") {
                console.log(`      text: ${part.text?.substring(0, 50)}...`);
              } else if (part.type === "image_url" && part.image_url?.url) {
                const actualUrl = part.image_url.url;
                console.log(`      url长度: ${actualUrl.length}`);
                console.log(`      url前缀: ${actualUrl.substring(0, 50)}`);
                console.log(`      hasDataPrefix: ${actualUrl.startsWith("data:image/")}`);
                console.log(`      hasBase64: ${actualUrl.includes(";base64,")}`);
              }
            });
          } else if (typeof msg.content === "string") {
            console.log(`  content: ${msg.content.substring(0, 100)}...`);
          }
        });
        console.log("====================================================\n");
      }

      const response = await this.client.post("/chat/completions", requestBody, {
        responseType: "stream",
        signal,
      });

      // OpenAI兼容API响应格式：SSE事件流
      for await (const chunk of response.data) {
        const lines = chunk
          .toString()
          .split("\n")
          .filter((line: string) => line.trim());

        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.substring(6);

            if (data === "[DONE]") {
              return;
            }

            try {
              const parsed = JSON.parse(data);

              // 提取 reasoning_content (深度思考)
              const reasoning = parsed.choices?.[0]?.delta?.reasoning_content;

              // 提取 content (回答内容)
              const content = parsed.choices?.[0]?.delta?.content;

              // 提取 tool_calls (工具调用)
              const toolCalls = parsed.choices?.[0]?.delta?.tool_calls;

              // 只要有内容就 yield JSON 字符串
              if (reasoning || content || toolCalls) {
                yield JSON.stringify({
                  reasoning_content: reasoning,
                  content: content,
                  tool_calls: toolCalls,
                });
              }
            } catch (e) {
              // 跳过解析错误
            }
          }
        }
      }
    } catch (error: any) {
      logger.error(`❌ ${this.providerName} stream error:`, error.message);
      if (error.response) {
        logger.error(`   HTTP状态: ${error.response.status}`);

        // 尝试读取流式错误响应
        if (error.response.data) {
          try {
            // 如果是流，尝试读取所有数据
            if (
              typeof error.response.data === "object" &&
              typeof error.response.data.on === "function"
            ) {
              let errorData = "";
              error.response.data.on("data", (chunk: Buffer) => {
                errorData += chunk.toString();
              });
              error.response.data.on("end", () => {
                logger.error(`   错误详情 (stream): ${errorData}`);
              });
            } else if (typeof error.response.data === "string") {
              logger.error(`   错误详情: ${error.response.data}`);
            } else if (typeof error.response.data === "object") {
              logger.error(`   错误详情: ${JSON.stringify(error.response.data, null, 2)}`);
            } else {
              logger.error(`   错误详情类型: ${typeof error.response.data}`);
            }
          } catch (e) {
            logger.error(`   错误详情: [解析失败: ${(e as Error).message}]`);
          }
        }

        // 打印请求配置以便调试
        if (error.config) {
          logger.error(`   请求URL: ${error.config.baseURL}${error.config.url}`);
          logger.error(`   请求方法: ${error.config.method}`);
        }
      }
      throw new Error(`${this.providerName} stream request failed: ${error.message}`);
    }
  }
}
````

## File: src/core/tool-action/ToolDispatcher.ts
````typescript
/**
 * ToolDispatcher - 工具调度器
 *
 * 统一路由 tool_action 调用到内置工具或 Skills
 * 复用现有 ToolExecutorManager 基础设施，优先从 ToolRegistry 获取工具
 */

import {
  type ToolActionCall,
  type ToolExecutionResult,
  type DispatcherConfig,
  type ToolDescription,
  ToolType,
} from "./types";
import type { BuiltInTool, SkillTool, ToolResult } from "../../types/tool-system";
import { BuiltInToolsRegistry, getBuiltInToolsRegistry } from "../../services/BuiltInToolsRegistry";
import { SkillsSandboxExecutor } from "../../services/executors/SkillsSandboxExecutor";
import { getSkillManager } from "../../services/SkillManager";
import { mcpIntegration } from "../../services/MCPIntegrationService";
import { toolRegistry, ToolStatus } from "../tool/registry";
import type { Tool } from "../tool/tool";
import { logger } from "../../utils/logger";
import { ErrorClassifier } from "../../utils/error-classifier";
import { ErrorType } from "../../types/trajectory";

/**
 * 默认配置常量
 */
const DEFAULT_TIMEOUT = 30000;
const DEFAULT_MAX_CONCURRENCY = 3;

const DEFAULT_CONFIG: Required<DispatcherConfig> = {
  timeout: DEFAULT_TIMEOUT,
  maxConcurrency: DEFAULT_MAX_CONCURRENCY,
};

/**
 * 工具调度器
 * 负责将 tool_action 调用路由到正确的执行器
 */
export class ToolDispatcher {
  private config: Required<DispatcherConfig>;
  private builtInRegistry: BuiltInToolsRegistry;
  private skillExecutor: SkillsSandboxExecutor;

  constructor(config: DispatcherConfig = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.builtInRegistry = getBuiltInToolsRegistry();
    this.skillExecutor = new SkillsSandboxExecutor({
      timeout: this.config.timeout,
      maxConcurrency: this.config.maxConcurrency,
    });
  }

  /**
   * 调度执行工具调用
   * 优先从 ToolRegistry 获取工具，回退到原有逻辑
   * @param toolCall 工具调用
   * @returns 执行结果
   */
  async dispatch(toolCall: ToolActionCall): Promise<ToolExecutionResult> {
    const startTime = Date.now();
    const { name, type, parameters } = toolCall;

    logger.info(`[ToolDispatcher] Dispatching tool call: ${name} (type: ${type})`);
    logger.debug(`[ToolDispatcher] Parameters:`, parameters);

    try {
      // 优先从 ToolRegistry 获取工具
      const toolInfo = await toolRegistry.get(name);
      if (toolInfo) {
        logger.debug(`[ToolDispatcher] Found tool in ToolRegistry: ${name}`);
        return await this.executeToolInfo(toolInfo, parameters, startTime);
      }

      // 回退到原有逻辑：根据工具类型路由到不同的执行器
      switch (type) {
        case ToolType.BUILTIN:
          logger.debug(`[ToolDispatcher] Executing as built-in tool: ${name}`);
          return await this.executeBuiltInTool(name, parameters, startTime);

        case ToolType.SKILL:
          logger.debug(`[ToolDispatcher] Executing as Skill: ${name}`);
          return await this.executeSkillTool(name, parameters, startTime);

        case ToolType.MCP:
          logger.debug(`[ToolDispatcher] Executing as MCP tool: ${name}`);
          return await this.executeMCPTool(name, parameters, startTime);

        default:
          logger.warn(`[ToolDispatcher] Unknown tool type: ${type}`);
          return {
            success: false,
            toolName: name,
            error: `Unknown tool type: ${type}`,
            executionTime: Date.now() - startTime,
          };
      }
    } catch (error) {
      const executionTime = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : String(error);

      logger.error(`[ToolDispatcher] Tool execution failed: ${name}`, error);

      return {
        success: false,
        toolName: name,
        error: errorMessage,
        executionTime,
      };
    }
  }

  /**
   * 使用 Tool.Info 执行工具调用
   * @param tool 工具信息
   * @param parameters 工具参数
   * @param startTime 开始时间
   * @returns 执行结果
   */
  private async executeToolInfo(
    tool: Tool.Info,
    parameters: Record<string, string>,
    startTime: number
  ): Promise<ToolExecutionResult> {
    logger.debug(`[ToolDispatcher] Executing tool from ToolRegistry: ${tool.id}`);

    try {
      // 创建超时 Promise
      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => {
          reject(new Error(`Tool execution timeout after ${this.config.timeout}ms`));
        }, this.config.timeout);
      });

      // 初始化工具获取执行函数
      const toolInit = await tool.init();
      const abortController = new AbortController();

      // 创建执行上下文
      const ctx: Tool.Context = {
        sessionID: "",
        messageID: "",
        agent: "dispatcher",
        abort: abortController.signal,
        metadata: () => {},
      };

      // 执行工具
      const result = await Promise.race([toolInit.execute(parameters, ctx), timeoutPromise]);

      const executionTime = Date.now() - startTime;
      const outputContent = String(result.output || "");

      logger.info(`[ToolDispatcher] Tool ${tool.id} executed successfully in ${executionTime}ms`);

      return {
        success: true,
        toolName: tool.id,
        result: result.output,
        executionTime,
        tool_details: {
          tool_name: tool.id,
          input_params: parameters,
          output_content: outputContent,
          output_metadata: {
            token_count: ErrorClassifier.estimateTokens(outputContent),
            execution_time_ms: executionTime,
            ...result.metadata,
          },
        },
      };
    } catch (error) {
      const executionTime = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : String(error);

      const errorType = ErrorClassifier.classifyError(error);
      const errorDetails = {
        error_type: errorType,
        error_message: errorMessage,
        error_stack: error instanceof Error ? error.stack : undefined,
        context: {
          tool_name: tool.id,
          input_params: parameters,
          timestamp: Date.now(),
          execution_time_ms: executionTime,
        },
      };

      logger.error(`[ToolDispatcher] Tool execution failed: ${tool.id}`, {
        error_type: errorType,
        error_message: errorMessage,
        stack: error instanceof Error ? error.stack : undefined,
      });

      // 更新工具状态为 unhealthy
      await toolRegistry.updateStatus(tool.id, ToolStatus.UNHEALTHY, errorMessage);

      return {
        success: false,
        toolName: tool.id,
        error: errorMessage,
        executionTime,
        error_details: errorDetails,
      };
    }
  }

  /**
   * 执行内置工具
   */
  private async executeBuiltInTool(
    name: string,
    parameters: Record<string, string>,
    startTime: number
  ): Promise<ToolExecutionResult> {
    const builtInTool = this.builtInRegistry.getTool(name);
    if (builtInTool && builtInTool.enabled) {
      return await this.executeBuiltIn(builtInTool, parameters, startTime);
    }

    logger.warn(`[ToolDispatcher] Built-in tool not found or disabled: ${name}`);
    return {
      success: false,
      toolName: name,
      error: `Built-in tool not found or disabled: ${name}`,
      executionTime: Date.now() - startTime,
    };
  }

  /**
   * 执行 Skill 工具
   */
  private async executeSkillTool(
    name: string,
    parameters: Record<string, string>,
    startTime: number
  ): Promise<ToolExecutionResult> {
    logger.debug(`[ToolDispatcher] Trying to execute as Skill: ${name}`);
    const skillResult = await this.executeSkill(name, parameters, startTime);
    if (skillResult) {
      return skillResult;
    }

    logger.warn(`[ToolDispatcher] Skill not found: ${name}`);
    return {
      success: false,
      toolName: name,
      error: `Skill not found: ${name}`,
      executionTime: Date.now() - startTime,
    };
  }

  /**
   * 执行 MCP 工具
   */
  private async executeMCPTool(
    name: string,
    parameters: Record<string, string>,
    startTime: number
  ): Promise<ToolExecutionResult> {
    try {
      logger.info(`[ToolDispatcher] Calling MCP tool: ${name}`);

      // 调用 MCP 工具
      const result = await mcpIntegration.callTool({
        toolName: name,
        arguments: parameters,
      });

      const executionTime = Date.now() - startTime;

      // 🆕 成功情况：返回详细信息
      if (result.success) {
        const outputContent = String(result.content || "");
        return {
          success: true,
          toolName: name,
          result: result.content,
          executionTime,
          tool_details: {
            tool_name: name,
            input_params: parameters,
            output_content: outputContent,
            output_metadata: {
              token_count: ErrorClassifier.estimateTokens(outputContent),
              execution_time_ms: executionTime,
            },
          },
        };
      }

      // 🆕 失败情况：分类错误类型
      const errorType = ErrorClassifier.classifyError(
        new Error(result.error?.message || "MCP tool execution failed")
      );
      const errorDetails = {
        error_type: errorType,
        error_message: result.error?.message || "MCP tool execution failed",
        context: {
          tool_name: name,
          input_params: parameters,
          timestamp: Date.now(),
          execution_time_ms: executionTime,
        },
      };

      logger.error(`[ToolDispatcher] MCP tool execution failed: ${name}`, {
        error_type: errorType,
        error_message: result.error?.message,
        params: parameters,
      });

      // 更新工具状态为 unhealthy
      await toolRegistry.updateStatus(name, ToolStatus.UNHEALTHY, result.error?.message);

      return {
        success: false,
        toolName: name,
        error: result.error?.message || "MCP tool execution failed",
        executionTime,
        error_details: errorDetails,
      };
    } catch (error: any) {
      // 🆕 捕获异常：分类错误类型
      const errorType = ErrorClassifier.classifyError(error);
      const errorDetails = {
        error_type: errorType,
        error_message: error.message || "MCP tool execution failed",
        error_stack: error.stack,
        context: {
          tool_name: name,
          input_params: parameters,
          timestamp: Date.now(),
          execution_time_ms: Date.now() - startTime,
        },
      };

      logger.error(`[ToolDispatcher] MCP tool execution failed: ${name}`, {
        error_type: errorType,
        error_message: error.message,
        stack: error.stack,
      });

      // 更新工具状态为 unhealthy
      await toolRegistry.updateStatus(name, ToolStatus.UNHEALTHY, error.message);

      return {
        success: false,
        toolName: name,
        error: error.message || "MCP tool execution failed",
        executionTime: Date.now() - startTime,
        error_details: errorDetails,
      };
    }
  }

  /**
   * 执行内置工具
   */
  private async executeBuiltIn(
    tool: BuiltInTool,
    parameters: Record<string, string>,
    startTime: number
  ): Promise<ToolExecutionResult> {
    logger.debug(`[ToolDispatcher] Executing built-in tool: ${tool.name}`);

    // 转换参数类型
    const typedArgs = this.convertParameters(parameters, tool.parameters);

    // 创建超时 Promise
    const timeoutPromise = new Promise<ToolResult>((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Tool execution timeout after ${this.config.timeout}ms`));
      }, this.config.timeout);
    });

    // 执行工具
    const result = await Promise.race([
      this.builtInRegistry.execute({ name: tool.name, args: typedArgs }),
      timeoutPromise,
    ]);

    const executionTime = Date.now() - startTime;

    // 🆕 成功情况：返回详细信息
    if (result.success) {
      const outputContent = String(result.output || "");
      const isHiddenTool = tool.name === "vector-search";
      return {
        success: true,
        toolName: tool.name,
        result: result.output,
        executionTime,
        hiddenFromUser: isHiddenTool,
        tool_details: {
          tool_name: tool.name,
          input_params: typedArgs,
          output_content: outputContent,
          output_metadata: {
            token_count: ErrorClassifier.estimateTokens(outputContent),
            execution_time_ms: executionTime,
          },
        },
      };
    }

    // 🆕 失败情况：分类错误类型
    const errorType = ErrorClassifier.classifyError(new Error(result.error));
    const errorDetails = {
      error_type: errorType,
      error_message: result.error || "Unknown error",
      context: {
        tool_name: tool.name,
        input_params: typedArgs,
        timestamp: Date.now(),
        execution_time_ms: executionTime,
      },
    };

    logger.error(`[ToolDispatcher] Built-in tool execution failed: ${tool.name}`, {
      error_type: errorType,
      error_message: result.error,
      params: typedArgs,
    });

    // 更新工具状态为 unhealthy
    await toolRegistry.updateStatus(tool.name, ToolStatus.UNHEALTHY, result.error);

    return {
      success: false,
      toolName: tool.name,
      error: result.error,
      executionTime,
      error_details: errorDetails,
    };
  }

  /**
   * 执行 Skill（可执行型 Skill）
   */
  private async executeSkill(
    name: string,
    parameters: Record<string, string>,
    startTime: number
  ): Promise<ToolExecutionResult | null> {
    try {
      logger.debug(`[ToolDispatcher] Attempting to execute Skill: ${name}`);

      // 转换参数（Skills 也需要类型转换）
      const typedArgs = this.convertParameters(parameters, null);

      // 执行 Skill
      const result = await this.skillExecutor.execute({
        name,
        args: typedArgs,
      });

      const executionTime = Date.now() - startTime;

      // 如果 Skill 不存在，返回 null（让调度器继续尝试其他路径）
      if (!result.success && result.error?.includes("not found")) {
        logger.debug(`[ToolDispatcher] Skill not found: ${name}`);
        return null;
      }

      // 🆕 成功情况：返回详细信息
      if (result.success) {
        const outputContent = String(result.output || "");
        return {
          success: true,
          toolName: name,
          result: result.output,
          executionTime,
          tool_details: {
            tool_name: name,
            input_params: typedArgs,
            output_content: outputContent,
            output_metadata: {
              token_count: ErrorClassifier.estimateTokens(outputContent),
              execution_time_ms: executionTime,
            },
          },
        };
      }

      // 🆕 失败情况：分类错误类型
      const errorType = ErrorClassifier.classifyError(new Error(result.error));
      const errorDetails = {
        error_type: errorType,
        error_message: result.error || "Unknown error",
        context: {
          tool_name: name,
          input_params: typedArgs,
          timestamp: Date.now(),
          execution_time_ms: executionTime,
        },
      };

      logger.error(`[ToolDispatcher] Skill execution failed: ${name}`, {
        error_type: errorType,
        error_message: result.error,
        params: typedArgs,
      });

      // 更新工具状态为 unhealthy
      await toolRegistry.updateStatus(name, ToolStatus.UNHEALTHY, result.error);

      return {
        success: false,
        toolName: name,
        error: result.error,
        executionTime,
        error_details: errorDetails,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);

      // 如果是 Skill 不存在的错误，返回 null
      if (errorMessage.includes("not found") || errorMessage.includes("does not exist")) {
        logger.debug(`[ToolDispatcher] Skill does not exist: ${name}`);
        return null;
      }

      // 🆕 其他错误，分类并记录详细信息
      const errorType = ErrorClassifier.classifyError(error);
      const errorDetails = {
        error_type: errorType,
        error_message: errorMessage,
        error_stack: error instanceof Error ? error.stack : undefined,
        context: {
          tool_name: name,
          input_params: this.convertParameters(parameters, null),
          timestamp: Date.now(),
          execution_time_ms: Date.now() - startTime,
        },
      };

      logger.error(`[ToolDispatcher] Skill execution error: ${name}`, {
        error_type: errorType,
        error_message: errorMessage,
        stack: error instanceof Error ? error.stack : undefined,
      });

      // 更新工具状态为 unhealthy
      await toolRegistry.updateStatus(name, ToolStatus.UNHEALTHY, errorMessage);

      return {
        success: false,
        toolName: name,
        error: errorMessage,
        executionTime: Date.now() - startTime,
        error_details: errorDetails,
      };
    }
  }

  /**
   * 转换参数类型（字符串 -> 实际类型）
   */
  private convertParameters(params: Record<string, string>, schema: any): Record<string, any> {
    const result: Record<string, any> = {};

    for (const [key, value] of Object.entries(params)) {
      const propSchema = schema?.properties?.[key];

      if (!propSchema) {
        result[key] = value;
        continue;
      }

      switch (propSchema.type) {
        case "number":
          result[key] = Number(value);
          break;
        case "boolean":
          result[key] = value === "true" || value === "1";
          break;
        case "array":
          try {
            result[key] = JSON.parse(value);
          } catch {
            result[key] = value.split(",").map((s) => s.trim());
          }
          break;
        case "object":
          try {
            result[key] = JSON.parse(value);
          } catch {
            result[key] = value;
          }
          break;
        default:
          result[key] = value;
      }
    }

    return result;
  }

  /**
   * 执行 Skill Direct 模式 - 直接返回 SKILL.md 内容，无需沙箱执行
   * 用于 FR-37~FR-40 场景
   * @param toolName 工具名称（包含 skill: 前缀或直接是 Skill 名称）
   * @param parameters 工具参数
   * @returns 执行结果
   */
  async executeDirect(
    toolName: string,
    parameters: Record<string, string>
  ): Promise<ToolExecutionResult> {
    const startTime = Date.now();

    // 提取 Skill 名称（支持带 skill: 前缀）
    let skillName = toolName;
    if (toolName.startsWith("skill:")) {
      skillName = toolName.substring(6);
    }

    logger.info(`[ToolDispatcher] Executing Skill Direct: ${skillName}`);

    try {
      const skillManager = getSkillManager();
      const result = await skillManager.executeDirect(skillName, parameters);

      return {
        success: true,
        toolName: toolName,
        result: result,
        executionTime: Date.now() - startTime,
        tool_details: {
          tool_name: toolName,
          input_params: parameters,
          output_content: result,
          output_metadata: {
            token_count: ErrorClassifier.estimateTokens(result),
            execution_time_ms: Date.now() - startTime,
            mode: "direct",
          },
        },
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorType = ErrorClassifier.classifyError(error);
      const errorDetails = {
        error_type: errorType,
        error_message: errorMessage,
        context: {
          tool_name: toolName,
          input_params: parameters,
          timestamp: Date.now(),
          execution_time_ms: Date.now() - startTime,
        },
      };

      logger.error(`[ToolDispatcher] Skill Direct execution failed: ${skillName}`, {
        error_type: errorType,
        error_message: errorMessage,
      });

      return {
        success: false,
        toolName: toolName,
        error: errorMessage,
        executionTime: Date.now() - startTime,
        error_details: errorDetails,
      };
    }
  }

  /**
   * 检查工具是否存在
   * @param name 工具名称
   * @returns 是否存在
   */
  hasTool(name: string): boolean {
    const builtIn = this.builtInRegistry.getTool(name);
    return !!builtIn?.enabled;
  }

  /**
   * 获取可用工具列表
   * @returns 工具描述列表
   */
  getAvailableTools(): ToolDescription[] {
    const tools: ToolDescription[] = [];

    // Built-in tools
    const builtInTools = this.builtInRegistry.listTools();
    for (const tool of builtInTools) {
      tools.push(this.convertToDescription(tool));
    }

    // MCP tools
    const mcpTools = mcpIntegration.getAllTools();
    for (const { serverId, tools: serverTools } of mcpTools) {
      for (const tool of serverTools) {
        tools.push(this.convertMcpToolToDescription(tool, serverId));
      }
    }

    return tools;
  }

  /**
   * Convert MCP tool definition to description format
   */
  private convertMcpToolToDescription(
    tool: { name: string; description: string; inputSchema?: any },
    serverId: string
  ): ToolDescription {
    const parameters: ToolDescription['parameters'] = [];

    if (tool.inputSchema?.properties) {
      for (const [name, prop] of Object.entries(tool.inputSchema.properties)) {
        const propObj = prop as { type?: string; description?: string };
        parameters.push({
          name,
          type: propObj.type || 'string',
          description: propObj.description || '',
          required: tool.inputSchema.required?.includes(name) ?? false,
        });
      }
    }

    return {
      name: tool.name,
      description: `[MCP:${serverId}] ${tool.description}`,
      parameters,
    };
  }

  /**
   * Convert tool definition to description format
   */
  private convertToDescription(tool: BuiltInTool | SkillTool): ToolDescription {
    const parameters: ToolDescription["parameters"] = [];

    if (tool.parameters?.properties) {
      for (const [name, prop] of Object.entries(tool.parameters.properties)) {
        parameters.push({
          name,
          type: prop.type,
          description: prop.description,
          required: tool.parameters.required?.includes(name) ?? false,
        });
      }
    }

    return {
      name: tool.name,
      description: tool.description,
      parameters,
    };
  }
}

/**
 * 生成工具描述文本（用于系统提示词）
 * @param tools 工具描述列表
 * @returns 格式化的工具描述文本
 */
export function generateToolPrompt(tools: ToolDescription[]): string {
  if (tools.length === 0) {
    return `
## 可用工具

当前没有可用的工具。
`;
  }

  const toolDescriptions = tools
    .map((tool) => {
      const paramList =
        tool.parameters.length > 0
          ? tool.parameters
              .map(
                (p) =>
                  `  - \`${p.name}\` (${p.type}${p.required ? ", 必需" : ""}): ${p.description}`
              )
              .join("\n")
          : "  无参数";

      return `
### ${tool.name}
${tool.description}

**参数:**
${paramList}
`;
    })
    .join("\n");

  return `
## 可用工具

你可以通过以下格式调用工具：

\`\`\`xml
<tool_action name="工具名称">
  <参数名 value="参数值" />
</tool_action>
\`\`\`

### 工具列表
${toolDescriptions}

### 使用说明
1. 在需要使用工具时，输出完整的 \`<tool_action>\` 标签
2. 标签必须包含 \`name\` 属性指定工具名称
3. 参数使用子标签 \`<参数名 value="值" />\` 格式传递
4. 系统会自动执行工具并返回结果
5. 你可以根据工具结果继续思考和行动

### 示例
\`\`\`xml
<tool_action name="vector-search">
  <query value="读取文件相关的工具" />
  <limit value="5" />
</tool_action>
\`\`\`
`;
}
````

## File: src/types/llm-models.ts
````typescript
/**
 * LLM 配置架构 v2.0 - 类型定义
 *
 * 支持多模型类型的两级配置结构
 */

/**
 * 模型类型枚举
 */
export enum LLMModelType {
  NLP = "nlp", // 聊天/文本生成
  EMBEDDING = "embedding", // 文本向量化
  RERANK = "rerank", // 结果重排序
  IMAGE = "image", // 图像生成
  MULTIMODAL = "multimodal", // 多模态（文本+图像）
  AUDIO = "audio", // 语音处理
  OTHER = "other", // 其他类型
}

/**
 * 提供商基础配置
 */
export interface ProviderBaseConfig {
  apiKey?: string; // API 密钥（可选，Ollama 不需要）
  baseURL: string; // API 基础 URL
  timeout?: number; // 超时时间（毫秒）
  maxRetries?: number; // 最大重试次数
  customHeaders?: Record<string, string>; // 自定义请求头
  proxy?: boolean | any; // 代理配置（false 表示禁用代理）
  [key: string]: any; // 其他自定义配置
}

/**
 * LLM 提供商记录
 */
export interface LLMProviderV2 {
  id: number;
  provider: string; // 提供商标识 (openai, deepseek)
  name: string; // 显示名称
  description?: string; // 提供商描述
  baseConfig: ProviderBaseConfig; // 基础配置
  enabled: boolean;
  createdAt: number;
  updatedAt: number;
}

/**
 * 上下文和记忆配置
 */
export interface ContextConfig {
  maxContextLength?: number; // 最大上下文长度
  contextWindowType?: "sliding" | "fixed"; // 上下文窗口类型
  memoryRetention?: number; // 记忆保留时间（秒）
  contextCompression?: boolean; // 是否启用上下文压缩
  contextStrategy?: "truncate" | "summarize" | "sliding"; // 上下文溢出策略
}

/**
 * 输出控制配置
 */
export interface OutputConfig {
  maxOutputTokens?: number; // 最大输出 tokens
  minOutputTokens?: number; // 最小输出 tokens
  outputFormat?: "text" | "json" | "xml" | "markdown"; // 输出格式
  streamingEnabled?: boolean; // 是否启用流式输出
  chunkSize?: number; // 流式输出块大小
  stopSequences?: string[]; // 停止序列
  responseFormat?: object; // 响应格式规范（用于 json 模式）
}

/**
 * 高级生成配置
 */
export interface GenerationConfig {
  topP?: number; // Top-P 采样
  frequencyPenalty?: number; // 频率惩罚
  presencePenalty?: number; // 存在惩罚
  repetitionPenalty?: number; // 重复惩罚
  seed?: number; // 随机种子
  logitBias?: Record<string, number>; // Logit 偏差
  numSequences?: number; // 生成的序列数量
  bestOf?: number; // 生成多个序列并返回最佳
}

/**
 * 性能和缓存配置
 */
export interface PerformanceConfig {
  cacheEnabled?: boolean; // 是否启用缓存
  cacheTTL?: number; // 缓存 TTL（秒）
  batchSize?: number; // 批处理大小
  requestTimeout?: number; // 请求超时（毫秒）
  retryBackoff?: "exponential" | "linear"; // 重试退避策略
  maxConcurrentRequests?: number; // 最大并发请求数
  enableMetrics?: boolean; // 是否启用性能指标
}

/**
 * 模型配置
 */
export interface ModelConfig {
  // 基础配置
  contextWindow?: number; // 上下文窗口大小
  maxTokens?: number; // 最大生成 tokens
  temperature?: number; // 温度参数
  dimensions?: number; // 向量维度（Embedding 模型）
  topK?: number; // Top-K（Rerank 模型）

  // ⭐ 新增配置
  contextConfig?: ContextConfig; // 上下文和记忆配置
  outputConfig?: OutputConfig; // 输出控制配置
  generationConfig?: GenerationConfig; // 高级生成配置
  performanceConfig?: PerformanceConfig; // 性能和缓存配置

  // 扩展参数
  [key: string]: any; // 其他模型特定参数
}

/**
 * LLM 模型记录
 */
export interface LLMModelV2 {
  id: number;
  providerId: number; // 关联提供商 ID
  modelKey: string; // 模型标识 (gpt-4, deepseek-chat)
  modelName: string; // 显示名称
  modelType: LLMModelType; // 模型类型
  modelConfig: ModelConfig; // 模型配置
  apiEndpointSuffix?: string; // API 端点后缀
  enabled: boolean;
  isDefault: boolean; // 是否为该类型的默认模型
  isAceEvolution: boolean; // ACE进化专用模型字段（已废弃，2026-01-11）
  displayOrder: number; // 显示排序
  createdAt: number;
  updatedAt: number;
}

/**
 * 完整模型信息（包含提供商信息）
 */
export interface LLMModelFull extends LLMModelV2 {
  provider: string; // 提供商标识
  providerName: string; // 提供商名称
  providerBaseConfig: ProviderBaseConfig; // 提供商基础配置
  providerEnabled: boolean; // 提供商是否启用
  // ACE层级标记字段（已废弃，2026-01-11）
  isAceLayerL1?: boolean;
  isAceLayerL2?: boolean;
  isAceLayerL3?: boolean;
  isAceLayerL4?: boolean;
  isAceLayerL5?: boolean;
  isAceLayerL6?: boolean;
}

/**
 * 创建提供商输入
 */
export interface CreateProviderInput {
  provider: string; // 提供商标识
  name: string; // 显示名称
  description?: string; // 描述
  baseConfig: ProviderBaseConfig; // 基础配置
  enabled?: boolean; // 是否启用（默认 true）
}

/**
 * 更新提供商输入
 */
export interface UpdateProviderInput {
  name?: string;
  description?: string;
  baseConfig?: Partial<ProviderBaseConfig>;
  enabled?: boolean;
}

/**
 * 创建模型输入
 */
export interface CreateModelInput {
  modelKey: string; // 模型标识
  modelName: string; // 显示名称
  modelType: LLMModelType; // 模型类型
  modelConfig?: ModelConfig; // 模型配置
  apiEndpointSuffix?: string; // API 端点后缀
  enabled?: boolean; // 是否启用（默认 true）
  isDefault?: boolean; // 是否默认（默认 false）
  isAceEvolution?: boolean; // ACE进化专用字段（已废弃，2026-01-11）
  displayOrder?: number; // 显示排序（默认 0）
}

/**
 * 更新模型输入
 */
export interface UpdateModelInput {
  modelName?: string;
  modelConfig?: Partial<ModelConfig>;
  apiEndpointSuffix?: string;
  enabled?: boolean;
  isDefault?: boolean;
  isAceEvolution?: boolean; // ACE进化专用字段（已废弃，2026-01-11）
  displayOrder?: number;
}

/**
 * 模型查询参数
 */
export interface ModelQueryParams {
  providerId?: number; // 按提供商筛选
  modelType?: LLMModelType; // 按类型筛选
  enabled?: boolean; // 按启用状态筛选
  isDefault?: boolean; // 仅查询默认模型
}

/**
 * API 端点映射配置
 */
export interface EndpointMapping {
  [provider: string]: {
    [modelType: string]: string; // 端点后缀
  };
}

/**
 * 端点映射配置项
 */
export interface ProviderEndpointConfig {
  nlp?: string;
  embedding?: string;
  rerank?: string;
  image?: string;
  audio?: string;
  [key: string]: string | undefined;
}
````

## File: src/core/variable/VariableEngine.ts
````typescript
/**
 * Variable Engine Implementation - Unified Version
 *
 * 统一的变量引擎实现
 * 职责：对固定格式{{placeholder}}进行变量替换
 * 特点：支持缓存、批量处理、递归解析
 *
 * 修复内容：
 * - M-004: 添加 MAX_CACHE_SIZE = 10000 限制
 * - 实现 LRU 缓存淘汰策略
 */

import { logger } from "../../utils/logger";
import type { Message } from "../../types";

/** M-004: 缓存最大大小限制 */
const MAX_CACHE_SIZE = 10000;

interface CacheEntry {
  resolved: string;
  timestamp: number;
  /** LRU: 最近访问时间 */
  lastAccessed: number;
}

export interface VariableEngineConfig {
  /** 是否启用缓存（默认true） */
  enableCache?: boolean;
  /** 缓存TTL毫秒数（默认30000ms） */
  cacheTtlMs?: number;
  /** 是否启用递归解析（默认true） */
  enableRecursion?: boolean;
  /** 最大递归深度（默认10） */
  maxRecursionDepth?: number;
}

/**
 * 变量引擎实现 - 统一版
 */
export class VariableEngine {
  private options: {
    enableRecursion: boolean;
    maxRecursionDepth: number;
    placeholderPattern: RegExp;
  };

  // M-004: 缓存相关 - 添加 LRU 支持
  private cache = new Map<string, CacheEntry>();
  private enableCache: boolean;
  private cacheTtlMs: number;

  constructor(config?: VariableEngineConfig) {
    // 配置选项
    this.options = {
      enableRecursion: config?.enableRecursion ?? true,
      maxRecursionDepth: config?.maxRecursionDepth ?? 10,
      placeholderPattern: /\{\{([^}]+)\}\}/g,
    };

    // 缓存配置
    this.enableCache = config?.enableCache ?? true;
    this.cacheTtlMs = config?.cacheTtlMs ?? 30000; // 默认30秒
  }

  /**
   * 解析内容中的所有变量占位符
   *
   * @param content - 要解析的内容
   * @param variables - 变量键值对映射
   * @param options - 解析选项
   * @returns 解析后的内容
   */
  async resolveAll(
    content: string,
    variables: Record<string, string> = {},
    options?: { fillEmptyOnMissing?: boolean }
  ): Promise<string> {
    if (!content || typeof content !== "string") {
      return content;
    }

    const fillEmptyOnMissing = options?.fillEmptyOnMissing ?? false;

    // 如果禁用递归，直接解析一次
    if (!this.options.enableRecursion) {
      return this.resolveOnce(content, variables, fillEmptyOnMissing);
    }

    // 启用递归解析
    let result = content;
    let depth = 0;
    let previousResult = "";

    // 最多递归 maxRecursionDepth 次，或直到结果不再变化
    while (depth < this.options.maxRecursionDepth) {
      previousResult = result;
      result = await this.resolveOnce(result, variables, fillEmptyOnMissing);

      // 如果结果不再变化，说明没有更多变量需要解析
      if (result === previousResult) {
        break;
      }

      depth++;
    }

    if (depth >= this.options.maxRecursionDepth) {
      logger.warn(
        `[VariableEngine] Max recursion depth (${this.options.maxRecursionDepth}) reached.`
      );
    }

    return result;
  }

  /**
   * 单次解析（不递归）
   */
  private async resolveOnce(
    content: string,
    variables: Record<string, string>,
    fillEmptyOnMissing: boolean = false
  ): Promise<string> {
    // 确保使用全局标志
    const pattern = new RegExp(this.options.placeholderPattern.source, "g");
    const matches = Array.from(content.matchAll(pattern));

    if (matches.length === 0) {
      return content;
    }

    // 提取唯一的变量键，避免重复解析
    const uniqueKeys = new Set<string>();
    for (const match of matches) {
      const key = match[1]?.trim();
      if (key) {
        uniqueKeys.add(key);
      }
    }

    let result = content;

    // 对每个唯一的变量键进行解析和替换
    for (const variableKey of uniqueKeys) {
      try {
        const resolvedValue = await this.resolveVariable(variableKey, variables);

        if (resolvedValue !== null) {
          // 使用正则全局替换，并使用回调函数防止 '$' 字符解析错误
          // 转义变量键中的特殊字符，构建精确的正则模式
          const keyPattern = new RegExp(
            `\\{\\{\\s*${this.escapeRegex(variableKey)}\\s*\\}\\}`,
            "g"
          );

          // 使用回调函数确保替换值被视为纯文本，不会被解析为特殊替换模式
          result = result.replace(keyPattern, () => resolvedValue);
        } else {
          // 如果无法解析
          if (fillEmptyOnMissing) {
            // 自动填充为空字符串
            const keyPattern = new RegExp(
              `\\{\\{\\s*${this.escapeRegex(variableKey)}\\s*\\}\\}`,
              "g"
            );
            result = result.replace(keyPattern, "");
            logger.debug(
              `[VariableEngine] Variable "${variableKey}" not found, filled with empty string`
            );
          } else {
            // 保留原始占位符
            logger.debug(
              `[VariableEngine] Variable "${variableKey}" not resolved, keeping original placeholder`
            );
          }
        }
      } catch (error: any) {
        logger.warn(
          `[VariableEngine] Failed to resolve variable "${variableKey}": ${error.message || error}`
        );
        // 解析失败时保留原始占位符
      }
    }

    return result;
  }

  /**
   * 解析单个变量
   *
   * @param content - 要解析的内容
   * @param key - 要解析的变量键
   * @param variables - 变量键值对映射
   * @returns 解析后的值，如果未找到则返回 null
   */
  async resolveSingle(
    content: string,
    key: string,
    variables: Record<string, string> = {}
  ): Promise<string | null> {
    // 检查内容中是否包含该变量
    const pattern = this.options.placeholderPattern;
    const variablePattern = new RegExp(
      `\\{\\{${key.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\}\\}`,
      "g"
    );

    if (!variablePattern.test(content)) {
      return null;
    }

    return this.resolveVariable(key, variables);
  }

  /**
   * 解析变量值（内部方法）
   */
  private async resolveVariable(
    key: string,
    variables: Record<string, string>
  ): Promise<string | null> {
    // 直接从variables映射中查找
    if (key in variables) {
      const value = variables[key];
      logger.debug(`[VariableEngine] Variable "${key}" resolved with value: ${value}`);
      return String(value);
    }

    // 变量未找到
    return null;
  }

  /**
   * 转义正则表达式特殊字符
   */
  private escapeRegex(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  /**
   * 检测文本中是否包含未替换的占位符
   *
   * @param text - 要检测的文本
   * @returns true如果包含占位符，否则false
   */
  hasPlaceholders(text: string): boolean {
    if (!text || typeof text !== "string") {
      return false;
    }
    return this.options.placeholderPattern.test(text);
  }

  /**
   * 提取文本中所有的占位符key
   *
   * @param text - 要提取的文本
   * @returns 占位符key数组
   */
  getPlaceholderKeys(text: string): string[] {
    if (!text || typeof text !== "string") {
      return [];
    }

    const pattern = new RegExp(this.options.placeholderPattern.source, "g");
    const matches = Array.from(text.matchAll(pattern));
    const keys = new Set<string>();

    for (const match of matches) {
      const key = match[1]?.trim();
      if (key) {
        keys.add(key);
      }
    }

    return Array.from(keys);
  }

  /**
   * 重置引擎（保持接口兼容，简化版无实际操作）
   */
  reset(): void {
    this.clearCache();
    logger.debug("[VariableEngine] Engine reset");
  }

  /**
   * 获取配置选项
   */
  getOptions(): Readonly<{
    enableRecursion: boolean;
    maxRecursionDepth: number;
    placeholderPattern: RegExp;
  }> {
    return { ...this.options };
  }

  // ==================== 批量处理方法 ====================

  /**
   * 批量解析消息中的变量（带缓存）
   * @param messages 消息数组
   * @param variables 变量键值对映射
   * @returns 解析后的消息数组
   */
  async resolveMessages(
    messages: Message[],
    variables: Record<string, string> = {}
  ): Promise<Message[]> {
    if (!messages || messages.length === 0) {
      return [];
    }

    logger.debug(`[VariableEngine] Resolving variables in ${messages.length} messages`);

    return Promise.all(messages.map((msg) => this.resolveMessage(msg, variables)));
  }

  /**
   * 解析单条消息（带缓存）
   */
  private async resolveMessage(msg: Message, variables: Record<string, string>): Promise<Message> {
    // 🐾 多模态消息直接返回，不做任何处理
    if (!msg.content || typeof msg.content !== "string") {
      // 🔍 DEBUG: 检查多模态消息是否完整
      if (Array.isArray(msg.content)) {
        const imageCount = msg.content.filter((p) => p.type === "image_url").length;
        if (imageCount > 0) {
          logger.debug(
            `[VariableEngine] Multimodal message detected, passing through unchanged (${imageCount} images)`
          );

          // 验证图片数据完整性
          msg.content.forEach((part, idx) => {
            if (part.type === "image_url") {
              const url = typeof part.image_url === "string" ? part.image_url : part.image_url?.url;
              if (url) {
                logger.debug(
                  `[VariableEngine] Image #${idx}: ${url.length} chars, has ;base64, marker: ${url.includes(";base64,")}`
                );
              }
            }
          });
        }
      }
      return msg;
    }

    const originalContent = msg.content;
    const originalLength = originalContent.length;

    // 如果启用缓存，检查缓存
    if (this.enableCache) {
      const cacheKey = `${originalContent}:${JSON.stringify(variables)}`;
      const cached = this.getFromCache(cacheKey);
      if (cached) {
        const age = Date.now() - cached.timestamp;
        logger.debug(`[VariableEngine] Cache hit (${msg.role}, ${age}ms old)`);
        return { ...msg, content: cached.resolved };
      }
    }

    try {
      const resolvedContent = await this.resolveAll(originalContent, variables);

      if (originalLength !== resolvedContent.length) {
        logger.debug(
          `[VariableEngine] Variable resolved (${msg.role}): ${originalLength} → ${resolvedContent.length} chars`
        );
      }

      // M-004: 存入缓存（带 LRU 策略）
      if (this.enableCache) {
        const cacheKey = `${originalContent}:${JSON.stringify(variables)}`;
        this.addToCache(cacheKey, resolvedContent);
      }

      return { ...msg, content: resolvedContent };
    } catch (error: any) {
      logger.warn(
        `[VariableEngine] Variable resolution failed for message (${msg.role}), using original: ${error.message || error}`
      );
      return { ...msg, content: originalContent };
    }
  }

  // ==================== 缓存管理方法 ====================

  /**
   * M-004: 添加缓存条目（带 LRU 淘汰策略）
   */
  private addToCache(key: string, value: string): void {
    if (!this.enableCache) return;

    // 如果缓存已满，执行 LRU 淘汰
    if (this.cache.size >= MAX_CACHE_SIZE) {
      this.evictLRU();
    }

    const now = Date.now();
    this.cache.set(key, {
      resolved: value,
      timestamp: now,
      lastAccessed: now,
    });
  }

  /**
   * M-004: LRU 缓存淘汰 - 移除最近最少使用的条目
   */
  private evictLRU(): void {
    let oldestEntry: [string, CacheEntry] | null = null;

    for (const entry of this.cache.entries()) {
      if (!oldestEntry || entry[1].lastAccessed < oldestEntry[1].lastAccessed) {
        oldestEntry = entry;
      }
    }

    if (oldestEntry) {
      this.cache.delete(oldestEntry[0]);
      logger.debug(
        `[VariableEngine] LRU cache eviction: removed "${oldestEntry[0].substring(0, 50)}..."`
      );
    }
  }

  /**
   * 获取缓存条目（更新访问时间）
   */
  private getFromCache(key: string): CacheEntry | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    const now = Date.now();
    const age = now - entry.timestamp;

    if (age > this.cacheTtlMs) {
      this.cache.delete(key);
      return null;
    }

    // 更新访问时间（用于 LRU）
    entry.lastAccessed = now;
    return entry;
  }

  /**
   * 清理缓存
   */
  clearCache(): void {
    const size = this.cache.size;
    this.cache.clear();
    if (size > 0) {
      logger.debug(`[VariableEngine] Cache cleared (${size} entries)`);
    }
  }

  /**
   * 获取缓存统计信息
   */
  getCacheStats(): { size: number; ttlMs: number; enabled: boolean; maxSize: number } {
    return {
      size: this.cache.size,
      ttlMs: this.cacheTtlMs,
      enabled: this.enableCache,
      maxSize: MAX_CACHE_SIZE,
    };
  }

  /**
   * 清理过期缓存条目
   */
  cleanupExpiredCache(): number {
    if (!this.enableCache) return 0;

    const now = Date.now();
    let cleanedCount = 0;

    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.cacheTtlMs) {
        this.cache.delete(key);
        cleanedCount++;
      }
    }

    if (cleanedCount > 0) {
      logger.debug(`[VariableEngine] Cleaned ${cleanedCount} expired cache entries`);
    }

    return cleanedCount;
  }
}
````

## File: src/services/LLMConfigService.ts
````typescript
/**
 * LLMConfigService - LLM 配置管理服务
 *
 * 支持两级配置结构：提供商 + 模型
 * 支持多模型类型：NLP, Embedding, Rerank 等
 */

import Database from "better-sqlite3";
import * as fs from "fs";
import * as path from "path";
import { logger } from "../utils/logger";
import { PathService } from "./PathService";
import {
  LLMModelType,
  LLMProviderV2,
  LLMModelV2,
  LLMModelFull,
  CreateProviderInput,
  UpdateProviderInput,
  CreateModelInput,
  UpdateModelInput,
  ModelQueryParams,
  ProviderBaseConfig,
  ModelConfig,
} from "../types/llm-models";

/**
 * LLM 配置服务
 */
export class LLMConfigService {
  private static instance: LLMConfigService;
  private db: Database.Database;
  private dbPath: string;

  private constructor() {
    const pathService = PathService.getInstance();
    const dataDir = pathService.getDataDir();

    // 确保数据目录存在
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }

    this.dbPath = path.join(dataDir, "llm_providers.db");
    this.db = new Database(this.dbPath);

    // 启用 WAL 模式提升性能
    this.db.pragma("journal_mode = WAL");
    // 启用外键约束
    this.db.pragma("foreign_keys = ON");

    this.initializeDatabase();
    logger.debug(`LLMConfigService initialized (database: ${this.dbPath})`);
  }

  /**
   * 获取单例实例
   */
  public static getInstance(): LLMConfigService {
    if (!LLMConfigService.instance) {
      LLMConfigService.instance = new LLMConfigService();
    }
    return LLMConfigService.instance;
  }

  /**
   * 初始化数据库表结构
   */
  private initializeDatabase(): void {
    this.db.exec(`
      -- 提供商表
      CREATE TABLE IF NOT EXISTS llm_providers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        provider TEXT NOT NULL UNIQUE,
        name TEXT NOT NULL,
        description TEXT,
        base_config TEXT NOT NULL,
        enabled INTEGER DEFAULT 1,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        CHECK(enabled IN (0, 1))
      );

      -- 模型表
      CREATE TABLE IF NOT EXISTS llm_models (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        provider_id INTEGER NOT NULL,
        model_key TEXT NOT NULL,
        model_name TEXT NOT NULL,
        model_type TEXT NOT NULL,
        model_config TEXT NOT NULL,
        api_endpoint_suffix TEXT,
        enabled INTEGER DEFAULT 1,
        is_default INTEGER DEFAULT 0,
        is_ace_evolution INTEGER DEFAULT 0,
        display_order INTEGER DEFAULT 0,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        FOREIGN KEY (provider_id) REFERENCES llm_providers(id) ON DELETE CASCADE,
        UNIQUE(provider_id, model_key),
        CHECK(enabled IN (0, 1)),
        CHECK(is_default IN (0, 1)),
        CHECK(is_ace_evolution IN (0, 1))
        -- ⚠️ 移除 model_type 的 CHECK 约束，避免扩展枚举时数据库报错
        -- 完全依赖 TypeScript 层面的校验（validateModelInput）
      );

      -- 提供商索引
      CREATE INDEX IF NOT EXISTS idx_provider ON llm_providers(provider);
      CREATE INDEX IF NOT EXISTS idx_provider_enabled ON llm_providers(enabled);

      -- 模型索引
      CREATE INDEX IF NOT EXISTS idx_model_provider ON llm_models(provider_id);
      CREATE INDEX IF NOT EXISTS idx_model_type ON llm_models(model_type);
      CREATE INDEX IF NOT EXISTS idx_model_enabled ON llm_models(enabled);
      CREATE INDEX IF NOT EXISTS idx_model_default ON llm_models(is_default);
      CREATE INDEX IF NOT EXISTS idx_model_key ON llm_models(model_key);
      CREATE INDEX IF NOT EXISTS idx_model_type_default ON llm_models(model_type, is_default);
    `);

    // 扩展模型表，添加ACE层级标记字段（先检查列是否存在）
    const columns = this.db.prepare("PRAGMA table_info(llm_models)").all() as Array<{
      name: string;
    }>;
    const columnNames = new Set(columns.map((c) => c.name));

    const aceLayerColumns = [
      "is_ace_layer_l1",
      "is_ace_layer_l2",
      "is_ace_layer_l3",
      "is_ace_layer_l4",
      "is_ace_layer_l5",
      "is_ace_layer_l6",
    ];

    for (const col of aceLayerColumns) {
      if (!columnNames.has(col)) {
        this.db.exec(`ALTER TABLE llm_models ADD COLUMN ${col} INTEGER DEFAULT 0`);
      }
    }

    // ACE层级索引
    this.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_model_ace_l1 ON llm_models(is_ace_layer_l1);
      CREATE INDEX IF NOT EXISTS idx_model_ace_l2 ON llm_models(is_ace_layer_l2);
      CREATE INDEX IF NOT EXISTS idx_model_ace_l3 ON llm_models(is_ace_layer_l3);
      CREATE INDEX IF NOT EXISTS idx_model_ace_l4 ON llm_models(is_ace_layer_l4);
      CREATE INDEX IF NOT EXISTS idx_model_ace_l5 ON llm_models(is_ace_layer_l5);
      CREATE INDEX IF NOT EXISTS idx_model_ace_l6 ON llm_models(is_ace_layer_l6);
    `);

    logger.debug(
      "✅ LLM v2 tables initialized (ACE layer support retained for backward compatibility)"
    );
  }

  /**
   * 初始化默认提供商（如果不存在）
   * 在服务器启动时调用，确保有可用的提供商配置
   * 仅插入提供商，不包含模型（模型需单独配置）
   */
  public initializeDefaultProviders(): void {
    try {
      // 检查是否已存在提供商
      const existingProviders = this.listProviders();
      if (existingProviders.length > 0) {
        logger.debug(
          `✅ Providers already exist (${existingProviders.length}), skipping initialization`
        );
        return;
      }

      logger.info("🔄 No providers found, initializing default providers...");

      const now = Date.now();
      const defaultProviders = [
        {
          provider: "openai",
          name: "OpenAI",
          description: "OpenAI GPT 系列模型 - 功能强大，支持多模态",
          baseConfig: {
            apiKey: process.env.OPENAI_API_KEY || "your-openai-api-key",
            baseURL: "https://api.openai.com/v1",
            timeout: 60000,
            maxRetries: 3,
          },
          enabled: true,
        },
        {
          provider: "deepseek",
          name: "DeepSeek",
          description: "DeepSeek AI - 高性价比聊天和代码模型",
          baseConfig: {
            apiKey: process.env.DEEPSEEK_API_KEY || "your-deepseek-api-key",
            baseURL: "https://api.deepseek.com/v1",
            timeout: 60000,
            maxRetries: 3,
          },
          enabled: true,
        },
        {
          provider: "zhipu",
          name: "智谱 AI",
          description: "智谱清言 - 国产大模型，支持中英文",
          baseConfig: {
            apiKey: process.env.ZHIPU_API_KEY || "your-zhipu-api-key",
            baseURL: "https://open.bigmodel.cn/api/paas/v4",
            timeout: 60000,
            maxRetries: 3,
          },
          enabled: true,
        },
        {
          provider: "claude",
          name: "Claude",
          description: "Anthropic Claude - 长上下文能力突出",
          baseConfig: {
            apiKey: process.env.CLAUDE_API_KEY || "your-claude-api-key",
            baseURL: "https://api.anthropic.com/v1",
            timeout: 60000,
            maxRetries: 3,
          },
          enabled: true,
        },
        {
          provider: "ollama",
          name: "Ollama (本地)",
          description: "Ollama 本地部署 - 无需 API Key，支持自定义模型",
          baseConfig: {
            apiKey: null,
            baseURL: "http://localhost:11434",
            timeout: 60000,
            maxRetries: 3,
          },
          enabled: true,
        },
        {
          provider: "custom",
          name: "Custom (自定义)",
          description: "自定义 OpenAI 兼容 API - 用于其他兼容服务",
          baseConfig: {
            apiKey: process.env.CUSTOM_API_KEY || "your-custom-api-key",
            baseURL: "https://api.openai.com/v1",
            timeout: 60000,
            maxRetries: 3,
          },
          enabled: true,
        },
      ];

      const insertStmt = this.db.prepare(`
        INSERT INTO llm_providers (provider, name, description, base_config, enabled, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
      `);

      for (const p of defaultProviders) {
        try {
          insertStmt.run(
            p.provider,
            p.name,
            p.description,
            JSON.stringify(p.baseConfig),
            p.enabled ? 1 : 0,
            now,
            now
          );
          const status = p.enabled ? "✅" : "⚪";
          logger.info(`${status} Initialized provider: ${p.name} (${p.provider})`);
        } catch (error: any) {
          logger.error(`❌ Failed to initialize provider ${p.provider}:`, error.message);
        }
      }

      logger.info(
        `✅ Default providers initialized (${defaultProviders.length} providers, 0 models)`
      );
    } catch (error: any) {
      logger.error("❌ Failed to initialize default providers:", error);
    }
  }

  // ==================== 提供商管理 ====================

  /**
   * 列出所有提供商
   */
  public listProviders(): LLMProviderV2[] {
    const rows = this.db
      .prepare(
        `
      SELECT id, provider, name, description, base_config, enabled, created_at, updated_at
      FROM llm_providers
      ORDER BY id ASC
    `
      )
      .all() as Array<{
      id: number;
      provider: string;
      name: string;
      description: string | null;
      base_config: string;
      enabled: number;
      created_at: number;
      updated_at: number;
    }>;

    return rows.map((row) => this.mapProviderRow(row));
  }

  /**
   * 获取单个提供商
   */
  public getProvider(id: number): LLMProviderV2 | null {
    const row = this.db
      .prepare(
        `
      SELECT id, provider, name, description, base_config, enabled, created_at, updated_at
      FROM llm_providers
      WHERE id = ?
    `
      )
      .get(id) as any;

    return row ? this.mapProviderRow(row) : null;
  }

  /**
   * 根据标识获取提供商
   */
  public getProviderByKey(provider: string): LLMProviderV2 | null {
    const row = this.db
      .prepare(
        `
      SELECT id, provider, name, description, base_config, enabled, created_at, updated_at
      FROM llm_providers
      WHERE provider = ?
    `
      )
      .get(provider) as any;

    return row ? this.mapProviderRow(row) : null;
  }

  /**
   * 创建提供商
   */
  public createProvider(input: CreateProviderInput): LLMProviderV2 {
    // 验证输入
    this.validateProviderInput(input);

    // 检查是否已存在（非Custom类型只允许一个实例）
    if (input.provider !== "custom") {
      const existing = this.getProviderByKey(input.provider);
      if (existing) {
        throw new Error(
          `Provider already exists: ${input.provider}. Each provider type can only have one instance, except for Custom providers.`
        );
      }
    }

    const now = Date.now();
    const result = this.db
      .prepare(
        `
      INSERT INTO llm_providers (provider, name, description, base_config, enabled, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `
      )
      .run(
        input.provider,
        input.name,
        input.description || null,
        JSON.stringify(input.baseConfig),
        input.enabled !== false ? 1 : 0,
        now,
        now
      );

    const created = this.getProvider(result.lastInsertRowid as number);
    if (!created) {
      throw new Error("Failed to create provider");
    }

    logger.info(`✅ Created provider: ${created.name} (${created.provider})`);
    return created;
  }

  /**
   * 更新提供商
   */
  public updateProvider(id: number, input: UpdateProviderInput): LLMProviderV2 {
    const existing = this.getProvider(id);
    if (!existing) {
      throw new Error(`Provider not found: ${id}`);
    }

    const updates: string[] = [];
    const values: any[] = [];

    if (input.name !== undefined) {
      updates.push("name = ?");
      values.push(input.name);
    }

    if (input.description !== undefined) {
      updates.push("description = ?");
      values.push(input.description);
    }

    if (input.baseConfig !== undefined) {
      // 合并配置
      const mergedConfig = {
        ...existing.baseConfig,
        ...input.baseConfig,
      };
      updates.push("base_config = ?");
      values.push(JSON.stringify(mergedConfig));
    }

    if (input.enabled !== undefined) {
      updates.push("enabled = ?");
      values.push(input.enabled ? 1 : 0);
    }

    if (updates.length === 0) {
      return existing;
    }

    updates.push("updated_at = ?");
    values.push(Date.now());
    values.push(id);

    this.db
      .prepare(
        `
      UPDATE llm_providers
      SET ${updates.join(", ")}
      WHERE id = ?
    `
      )
      .run(...values);

    const updated = this.getProvider(id)!;
    logger.info(`✅ Updated provider: ${updated.name} (id: ${id})`);
    return updated;
  }

  /**
   * 删除提供商（级联删除所有模型）
   */
  public deleteProvider(id: number): void {
    const existing = this.getProvider(id);
    if (!existing) {
      throw new Error(`Provider not found: ${id}`);
    }

    // 检查关联的模型数量
    const modelCount = this.db
      .prepare("SELECT COUNT(*) as count FROM llm_models WHERE provider_id = ?")
      .get(id) as any;

    this.db.prepare("DELETE FROM llm_providers WHERE id = ?").run(id);

    logger.info(
      `✅ Deleted provider: ${existing.name} (id: ${id}), cascaded ${modelCount.count} models`
    );
  }

  // ==================== 模型管理 ====================

  /**
   * 列出模型（支持多种筛选）
   */
  public listModels(params: ModelQueryParams = {}): LLMModelFull[] {
    let sql = `
      SELECT 
        m.id, m.provider_id, m.model_key, m.model_name, m.model_type,
        m.model_config, m.api_endpoint_suffix, m.enabled, m.is_default, m.is_ace_evolution,
        m.display_order, m.created_at, m.updated_at,
        p.provider, p.name as provider_name, p.base_config, p.enabled as provider_enabled
      FROM llm_models m
      JOIN llm_providers p ON m.provider_id = p.id
      WHERE 1=1
    `;

    const conditions: string[] = [];
    const values: any[] = [];

    if (params.providerId !== undefined) {
      conditions.push("m.provider_id = ?");
      values.push(params.providerId);
    }

    if (params.modelType !== undefined) {
      conditions.push("m.model_type = ?");
      values.push(params.modelType);
    }

    if (params.enabled !== undefined) {
      conditions.push("m.enabled = ?");
      values.push(params.enabled ? 1 : 0);
    }

    if (params.isDefault !== undefined) {
      conditions.push("m.is_default = ?");
      values.push(params.isDefault ? 1 : 0);
    }

    if (conditions.length > 0) {
      sql += " AND " + conditions.join(" AND ");
    }

    sql += " ORDER BY m.provider_id, m.model_type, m.display_order, m.id";

    const rows = this.db.prepare(sql).all(...values) as any[];
    return rows.map((row) => this.mapModelFullRow(row));
  }

  /**
   * 获取单个模型
   */
  public getModel(modelId: number): LLMModelFull | null {
    const row = this.db
      .prepare(
        `
      SELECT 
        m.id, m.provider_id, m.model_key, m.model_name, m.model_type,
        m.model_config, m.api_endpoint_suffix, m.enabled, m.is_default, m.is_ace_evolution,
        m.display_order, m.created_at, m.updated_at,
        p.provider, p.name as provider_name, p.base_config, p.enabled as provider_enabled
      FROM llm_models m
      JOIN llm_providers p ON m.provider_id = p.id
      WHERE m.id = ?
    `
      )
      .get(modelId) as any;

    return row ? this.mapModelFullRow(row) : null;
  }

  /**
   * 获取默认模型
   */
  public getDefaultModel(modelType: LLMModelType): LLMModelFull | null {
    const row = this.db
      .prepare(
        `
      SELECT 
        m.id, m.provider_id, m.model_key, m.model_name, m.model_type,
        m.model_config, m.api_endpoint_suffix, m.enabled, m.is_default, m.is_ace_evolution,
        m.display_order, m.created_at, m.updated_at,
        p.provider, p.name as provider_name, p.base_config, p.enabled as provider_enabled
      FROM llm_models m
      JOIN llm_providers p ON m.provider_id = p.id
      WHERE m.model_type = ?
        AND m.is_default = 1
        AND m.enabled = 1
        AND p.enabled = 1
      LIMIT 1
    `
      )
      .get(modelType) as any;

    return row ? this.mapModelFullRow(row) : null;
  }

  /**
   * 创建模型
   */
  public createModel(providerId: number, input: CreateModelInput): LLMModelV2 {
    // 验证提供商存在
    const provider = this.getProvider(providerId);
    if (!provider) {
      throw new Error(`Provider not found: ${providerId}`);
    }

    // 验证输入
    this.validateModelInput(input);

    // 检查是否已存在
    const existing = this.db
      .prepare(
        `
      SELECT id FROM llm_models WHERE provider_id = ? AND model_key = ?
    `
      )
      .get(providerId, input.modelKey);

    if (existing) {
      throw new Error(`Model already exists: ${input.modelKey}`);
    }

    // ✅ 使用事务确保原子性：如果插入失败，清除默认模型的操作也会回滚
    const createTransaction = this.db.transaction(() => {
      // 1. 如果设置为默认模型，先取消同类型的其他默认模型
      if (input.isDefault) {
        this.clearDefaultModel(input.modelType);
      }

      // 2. 插入新模型
      const now = Date.now();
      const result = this.db
        .prepare(
          `
        INSERT INTO llm_models (
          provider_id, model_key, model_name, model_type,
          model_config, api_endpoint_suffix, enabled, is_default, is_ace_evolution,
          display_order, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `
        )
        .run(
          providerId,
          input.modelKey,
          input.modelName,
          input.modelType,
          JSON.stringify(input.modelConfig || {}),
          input.apiEndpointSuffix || null,
          input.enabled !== false ? 1 : 0,
          input.isDefault ? 1 : 0,
          input.isAceEvolution ? 1 : 0,
          input.displayOrder || 0,
          now,
          now
        );

      return result.lastInsertRowid;
    });

    const newModelId = createTransaction();

    const created = this.getModel(newModelId as number);
    if (!created) {
      throw new Error("Failed to create model");
    }

    logger.info(
      `✅ Created model: ${created.modelName} (${created.modelKey}) [${created.modelType}]`
    );
    return created;
  }

  /**
   * 更新模型
   */
  public updateModel(modelId: number, input: UpdateModelInput): LLMModelV2 {
    const existing = this.getModel(modelId);
    if (!existing) {
      throw new Error(`Model not found: ${modelId}`);
    }

    // ✅ 使用事务确保原子性：如果更新失败，清除默认模型的操作也会回滚
    const updateTransaction = this.db.transaction(() => {
      const updates: string[] = [];
      const values: any[] = [];

      if (input.modelName !== undefined) {
        updates.push("model_name = ?");
        values.push(input.modelName);
      }

      if (input.modelConfig !== undefined) {
        // 合并配置
        const mergedConfig = {
          ...existing.modelConfig,
          ...input.modelConfig,
        };
        updates.push("model_config = ?");
        values.push(JSON.stringify(mergedConfig));
      }

      if (input.apiEndpointSuffix !== undefined) {
        updates.push("api_endpoint_suffix = ?");
        values.push(input.apiEndpointSuffix);
      }

      if (input.enabled !== undefined) {
        updates.push("enabled = ?");
        values.push(input.enabled ? 1 : 0);
      }

      if (input.isDefault !== undefined) {
        // 如果设置为默认模型，且当前不是默认模型，先取消同类型的其他默认模型
        if (input.isDefault && !existing.isDefault) {
          this.clearDefaultModel(existing.modelType);
        }
        updates.push("is_default = ?");
        values.push(input.isDefault ? 1 : 0);
      }

      if (input.isAceEvolution !== undefined) {
        // 如果设置为ACE进化模型，先取消其他模型的标记
        if (input.isAceEvolution && !existing.isAceEvolution) {
          this.clearAceEvolutionModel();
        }
        updates.push("is_ace_evolution = ?");
        values.push(input.isAceEvolution ? 1 : 0);
      }

      if (input.displayOrder !== undefined) {
        updates.push("display_order = ?");
        values.push(input.displayOrder);
      }

      if (updates.length === 0) {
        return; // 没有更新，直接返回
      }

      updates.push("updated_at = ?");
      values.push(Date.now());
      values.push(modelId);

      this.db
        .prepare(
          `
        UPDATE llm_models
        SET ${updates.join(", ")}
        WHERE id = ?
      `
        )
        .run(...values);
    });

    updateTransaction();

    const updated = this.getModel(modelId)!;
    logger.info(`✅ Updated model: ${updated.modelName} (id: ${modelId})`);
    return updated;
  }

  /**
   * 删除模型
   */
  public deleteModel(modelId: number): void {
    const existing = this.getModel(modelId);
    if (!existing) {
      throw new Error(`Model not found: ${modelId}`);
    }

    this.db.prepare("DELETE FROM llm_models WHERE id = ?").run(modelId);

    logger.info(`✅ Deleted model: ${existing.modelName} (id: ${modelId})`);
  }

  // ==================== 查询方法 ====================

  /**
   * 获取提供商的所有模型
   */
  public getProviderModels(providerId: number): LLMModelV2[] {
    return this.listModels({ providerId }).map((full) => this.fullToModel(full));
  }

  /**
   * 按类型获取所有模型
   */
  public getModelsByType(modelType: LLMModelType): LLMModelFull[] {
    return this.listModels({ modelType, enabled: true });
  }

  /**
   * 获取所有默认模型
   */
  public getAllDefaultModels(): Map<LLMModelType, LLMModelFull> {
    const models = this.listModels({ isDefault: true, enabled: true });
    const map = new Map<LLMModelType, LLMModelFull>();

    models.forEach((model) => {
      map.set(model.modelType as LLMModelType, model);
    });

    return map;
  }

  // ==================== 辅助方法 ====================

  /**
   * 清除某类型的默认模型标记
   */
  private clearDefaultModel(modelType: LLMModelType): void {
    this.db
      .prepare(
        `
      UPDATE llm_models
      SET is_default = 0, updated_at = ?
      WHERE model_type = ? AND is_default = 1
    `
      )
      .run(Date.now(), modelType);
  }

  /**
   * 清除ACE进化模型标记
   */
  private clearAceEvolutionModel(): void {
    this.db
      .prepare(
        `
      UPDATE llm_models
      SET is_ace_evolution = 0, updated_at = ?
      WHERE is_ace_evolution = 1
    `
      )
      .run(Date.now());
  }

  /**
   * 获取ACE进化专用模型
   */
  public getAceEvolutionModel(): LLMModelFull | null {
    const row = this.db
      .prepare(
        `
      SELECT 
        m.id, m.provider_id, m.model_key, m.model_name, m.model_type,
        m.model_config, m.api_endpoint_suffix, m.enabled, m.is_default, m.is_ace_evolution,
        m.display_order, m.created_at, m.updated_at,
        p.provider, p.name as provider_name, p.base_config, p.enabled as provider_enabled
      FROM llm_models m
      JOIN llm_providers p ON m.provider_id = p.id
      WHERE m.is_ace_evolution = 1
        AND m.enabled = 1
        AND p.enabled = 1
      LIMIT 1
    `
      )
      .get() as any;

    return row ? this.mapModelFullRow(row) : null;
  }

  /**
   * 验证提供商输入
   */
  private validateProviderInput(input: CreateProviderInput): void {
    if (!input.provider || input.provider.trim().length === 0) {
      throw new Error("provider is required");
    }

    if (!input.name || input.name.trim().length === 0) {
      throw new Error("name is required");
    }

    if (!input.baseConfig || typeof input.baseConfig !== "object") {
      throw new Error("baseConfig is required and must be an object");
    }

    if (!input.baseConfig.baseURL) {
      throw new Error("baseConfig.baseURL is required");
    }
  }

  /**
   * 验证模型输入
   */
  private validateModelInput(input: CreateModelInput): void {
    if (!input.modelKey || input.modelKey.trim().length === 0) {
      throw new Error("modelKey is required");
    }

    if (!input.modelName || input.modelName.trim().length === 0) {
      throw new Error("modelName is required");
    }

    if (!input.modelType) {
      throw new Error("modelType is required");
    }

    // 验证模型类型
    const validTypes = Object.values(LLMModelType);
    if (!validTypes.includes(input.modelType)) {
      throw new Error(`Invalid modelType: ${input.modelType}`);
    }
  }

  /**
   * 映射提供商行数据
   */
  private mapProviderRow(row: any): LLMProviderV2 {
    return {
      id: row.id,
      provider: row.provider,
      name: row.name,
      description: row.description,
      baseConfig: JSON.parse(row.base_config),
      enabled: row.enabled === 1,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };
  }

  /**
   * 映射完整模型行数据
   */
  private mapModelFullRow(row: any): LLMModelFull {
    return {
      id: row.id,
      providerId: row.provider_id,
      modelKey: row.model_key,
      modelName: row.model_name,
      modelType: row.model_type as LLMModelType,
      modelConfig: JSON.parse(row.model_config),
      apiEndpointSuffix: row.api_endpoint_suffix,
      enabled: row.enabled === 1,
      isDefault: row.is_default === 1,
      isAceEvolution: row.is_ace_evolution === 1,
      displayOrder: row.display_order,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      provider: row.provider,
      providerName: row.provider_name,
      providerBaseConfig: JSON.parse(row.base_config),
      providerEnabled: row.provider_enabled === 1,
    };
  }

  /**
   * 从完整模型提取模型信息
   */
  private fullToModel(full: LLMModelFull): LLMModelV2 {
    const { provider, providerName, providerBaseConfig, providerEnabled, ...model } = full;
    return model;
  }

  /**
   * 关闭数据库连接
   */
  public close(): void {
    this.db.close();
  }
}
````

## File: src/services/SkillManager.ts
````typescript
/**
 * SkillManager - Skills生命周期管理器
 * 负责Skills的安装、卸载、修改和查询，支持ZIP包自动解压和结构验证
 * 集成 ToolRegistry 进行统一工具管理
 */

import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";
import * as crypto from "crypto";
import YAML from "js-yaml";
import matter from "gray-matter";
import AdmZip from "adm-zip";
import {
  SkillTool,
  SkillInstallOptions,
  SkillListOptions,
  SkillListResult,
  SkillMetadata,
  ToolError,
  ToolErrorCode,
  ToolType,
} from "../types/tool-system";
import { ToolRetrievalService } from "./ToolRetrievalService";
import { SkillsSandboxExecutor, getSkillsSandboxExecutor } from "./executors/SkillsSandboxExecutor";
import { toolRegistry, ToolType as RegistryToolType } from "../core/tool/registry";
import type { Tool } from "../core/tool/tool";
import { logger } from "../utils/logger";
import { PathService } from "./PathService";
import {
  ClaudeCodeSkillParser,
  getClaudeCodeSkillParser,
  LifecycleManager,
  getLifecycleManager,
  ParsedClaudeSkill,
  SkillLifecycleHooks,
  ParseError,
} from "./compat";

/**
 * 安装结果
 */
export interface InstallResult {
  success: boolean;
  message: string;
  skillName?: string;
  installedAt?: Date;
  duration?: number;
  vectorized?: boolean;
}

/**
 * 卸载结果
 */
export interface UninstallResult {
  success: boolean;
  message: string;
  skillName?: string;
  uninstalledAt?: Date;
  duration?: number;
}

/**
 * 更新结果
 */
export interface UpdateResult {
  success: boolean;
  message: string;
  skillName?: string;
  updatedAt?: Date;
  duration?: number;
  reindexed?: boolean;
}

/**
 * Skills管理器
 * 管理Skills的完整生命周期：安装、卸载、更新、查询
 */
export class SkillManager {
  private static instance: SkillManager | null = null;
  private readonly skillsBasePath: string;
  private readonly retrievalService: ToolRetrievalService;
  private readonly skillsExecutor: SkillsSandboxExecutor;
  private readonly skillParser: ClaudeCodeSkillParser;
  private readonly lifecycleManager: LifecycleManager;
  private initializationPromise: Promise<void> | null = null;

  /**
   * 创建SkillManager实例
   * @param skillsBasePath Skills存储基础路径
   * @param retrievalService 检索服务实例
   */
  protected constructor(skillsBasePath?: string, retrievalService?: ToolRetrievalService) {
    // 使用 PathService 获取正确的路径
    const pathService = PathService.getInstance();
    const dataDir = pathService.getDataDir();
    this.skillsBasePath = skillsBasePath || path.join(dataDir, "skills");

    // 确保 skills 目录存在
    this.ensureSkillsDirectory();

    // 使用 PathService 获取正确的向量数据库路径
    const vectorDbPath = path.join(dataDir, "skills.lance");

    this.retrievalService =
      retrievalService ||
      new ToolRetrievalService({
        vectorDbPath,
        model: "all-MiniLM-L6-v2",
        dimensions: 384,
        similarityThreshold: 0.4,
        cacheSize: 1000,
      });
    // 初始化 Skills 执行器
    this.skillsExecutor = getSkillsSandboxExecutor();

    // 初始化兼容层组件
    this.skillParser = getClaudeCodeSkillParser();
    this.lifecycleManager = getLifecycleManager();

    logger.debug("SkillManager initialized", {
      skillsBasePath,
    });

    // 启动异步初始化，但不阻塞构造函数
    this.initializationPromise = this.initializeSkillsIndex().catch((error) => {
      logger.error("Failed to initialize skills index during startup:", error);
      // 即使失败也标记为完成，避免永久阻塞
      throw error;
    });
  }

  /**
   * 安装Skills
   * @param zipBuffer ZIP压缩包Buffer
   * @param options 安装选项
   * @returns 安装结果
   */
  async installSkill(zipBuffer: Buffer, options: SkillInstallOptions = {}): Promise<InstallResult> {
    const startTime = Date.now();

    try {
      // 解压ZIP包到临时目录
      const tempDir = await this.extractZipToTemp(zipBuffer);
      logger.debug(`Extracted ZIP to temp directory: ${tempDir}`);

      // 验证Skills结构
      const metadata = await this.validateSkillStructure(tempDir, options.validationLevel);
      logger.debug("Skills structure validation passed", { metadata });

      // 检查名称冲突
      const targetDir = path.join(this.skillsBasePath, metadata.name);
      const exists = await this.directoryExists(targetDir);

      if (exists) {
        if (!options.overwrite) {
          throw new ToolError(
            `Skill '${metadata.name}' already exists. Use overwrite: true to replace.`,
            ToolErrorCode.SKILL_ALREADY_EXISTS
          );
        }

        // 先卸载已存在的版本
        await this.uninstallSkillInternal(metadata.name);
        logger.info(`Overwriting existing skill: ${metadata.name}`);
      }

      // 执行预安装钩子
      const installContext = this.lifecycleManager.createContext(
        metadata.name,
        targetDir,
        metadata,
        undefined,
        options.validationLevel
      );
      await this.lifecycleManager.preInstall(installContext);

      // 移动Skills到目标目录
      await fs.mkdir(path.dirname(targetDir), { recursive: true });
      await fs.rename(tempDir, targetDir);
      logger.debug(`Moved Skills to target: ${targetDir}`);

      // 创建.vectorized标识文件（用于索引状态跟踪）
      const vectorizedFile = path.join(targetDir, ".vectorized");
      await fs.writeFile(vectorizedFile, "");

      // 添加到向量检索索引（如果包含metadata）
      let vectorized = false;
      if (!options.skipVectorization) {
        try {
          await this.retrievalService.indexSkill({
            name: metadata.name,
            description: metadata.description,
            tags: metadata.tags || [],
            path: targetDir,
            version: metadata.version,
            metadata: metadata,
          });
          await fs.writeFile(
            vectorizedFile,
            `indexed: ${new Date().toISOString()}\nversion: ${metadata.version}`
          );
          vectorized = true;
          logger.info("Skill vectorized successfully", { skillName: metadata.name });
        } catch (error) {
          logger.warn("Skill vectorization failed", {
            skillName: metadata.name,
            error: error instanceof Error ? error.message : error,
          });
        }
      }

      const duration = Date.now() - startTime;

      // 执行后安装钩子
      await this.lifecycleManager.postInstall(installContext);

      return {
        success: true,
        message: `Skill '${metadata.name}' installed successfully`,
        skillName: metadata.name,
        installedAt: new Date(),
        duration,
        vectorized,
      };
    } catch (error) {
      const duration = Date.now() - startTime;

      logger.error("Skill installation failed:", error);

      if (error instanceof ToolError) {
        throw error;
      }

      throw new ToolError(
        `Skill installation failed: ${this.formatError(error)}`,
        ToolErrorCode.SKILL_INVALID_STRUCTURE,
        { duration }
      );
    }
  }

  /**
   * 卸载Skills
   * @param skillName Skills名称
   * @returns 卸载结果
   */
  async uninstallSkill(skillName: string): Promise<UninstallResult> {
    return this.uninstallSkillInternal(skillName, true);
  }

  /**
   * 内部卸载Skills（可跳过部分检查）
   */
  private async uninstallSkillInternal(
    skillName: string,
    validateExists: boolean = true
  ): Promise<UninstallResult> {
    const startTime = Date.now();

    try {
      const skillPath = path.join(this.skillsBasePath, skillName);

      // 检查是否存在
      if (validateExists) {
        const exists = await this.directoryExists(skillPath);
        if (!exists) {
          throw new ToolError(`Skill '${skillName}' not found`, ToolErrorCode.SKILL_NOT_FOUND);
        }
      }

      // 获取元数据用于生命周期钩子
      let metadata: SkillMetadata | undefined;
      try {
        metadata = await this.parseSkillMetadata(skillPath);
      } catch {
        // 如果无法获取元数据，仍然继续卸载
      }

      // 执行预卸载钩子
      const uninstallContext = this.lifecycleManager.createContext(skillName, skillPath, metadata);
      await this.lifecycleManager.preUninstall(uninstallContext);

      // 从向量检索中移除
      try {
        await this.retrievalService.removeSkill(skillName);
        logger.debug("Removed Skill from vector index", { skillName });
      } catch (error) {
        logger.warn("Failed to remove Skill from vector index", {
          skillName,
          error: error instanceof Error ? error.message : error,
        });
      }

      // 删除Skills目录
      await fs.rm(skillPath, { recursive: true, force: true });

      // 执行后卸载钩子
      await this.lifecycleManager.postUninstall(uninstallContext);

      const duration = Date.now() - startTime;

      return {
        success: true,
        message: `Skill '${skillName}' uninstalled successfully`,
        skillName,
        uninstalledAt: new Date(),
        duration,
      };
    } catch (error) {
      const duration = Date.now() - startTime;

      logger.error("Skill uninstallation failed:", error);

      if (error instanceof ToolError) {
        throw error;
      }

      throw new ToolError(
        `Skill uninstallation failed: ${this.formatError(error)}`,
        ToolErrorCode.TOOL_EXECUTION_FAILED,
        { duration }
      );
    }
  }

  /**
   * 更新Skills描述
   * @param skillName Skills名称
   * @param newDescription 新描述
   * @returns 更新结果
   */
  async updateSkill(skillName: string, newDescription: string): Promise<UpdateResult> {
    const startTime = Date.now();

    try {
      // 验证描述长度
      if (newDescription.length > 1024) {
        throw new ToolError(
          `Description too long (${newDescription.length} chars). Maximum 1024 characters allowed.`,
          ToolErrorCode.SKILL_INVALID_STRUCTURE
        );
      }

      const skillPath = path.join(this.skillsBasePath, skillName);

      // 检查Skills是否存在
      if (!(await this.directoryExists(skillPath))) {
        throw new ToolError(`Skill '${skillName}' not found`, ToolErrorCode.SKILL_NOT_FOUND);
      }

      // 获取当前元数据
      const currentMetadata = await this.parseSkillMetadata(skillPath);

      // 执行预更新钩子
      const updateContext = this.lifecycleManager.createContext(
        skillName,
        skillPath,
        currentMetadata
      );
      await this.lifecycleManager.preUpdate(updateContext);

      const skillMdPath = path.join(skillPath, "SKILL.md");

      // 读取并解析SKILL.md
      if (!(await this.fileExists(skillMdPath))) {
        throw new ToolError(
          `SKILL.md not found in Skill '${skillName}'`,
          ToolErrorCode.SKILL_INVALID_STRUCTURE
        );
      }

      const content = await fs.readFile(skillMdPath, "utf8");
      const parsed = matter(content);

      // 更新描述
      parsed.data.description = newDescription;
      parsed.data.updatedAt = new Date().toISOString();

      // 重新生成文件
      const yamlStr = YAML.dump(parsed.data, { indent: 2 });
      const newContent = `---\n${yamlStr}---\n${parsed.content}`;
      await fs.writeFile(skillMdPath, newContent);

      // 因为描述变更，需要重新向量化
      let reindexed = false;
      try {
        // 重新读取元数据
        const updatedMetadata = await this.parseSkillMetadata(skillPath);

        // 先移除旧的向量，再添加新的
        await this.retrievalService.removeSkill(updatedMetadata.name);
        await this.retrievalService.indexSkill({
          name: updatedMetadata.name,
          description: updatedMetadata.description,
          tags: updatedMetadata.tags || [],
          path: skillPath,
          version: updatedMetadata.version,
          metadata: updatedMetadata,
        });

        // 更新.vectorized标识
        const vectorizedFile = path.join(skillPath, ".vectorized");
        await fs.writeFile(
          vectorizedFile,
          `reindexed: ${new Date().toISOString()}\nversion: ${updatedMetadata.version}`
        );

        reindexed = true;
        logger.info("Skill reindexed after update", { skillName });
      } catch (error) {
        logger.warn("Failed to reindex Skill after update", {
          skillName,
          error: error instanceof Error ? error.message : error,
        });
      }

      const duration = Date.now() - startTime;

      // 执行后更新钩子
      await this.lifecycleManager.postUpdate(updateContext);

      return {
        success: true,
        message: `Skill '${skillName}' updated successfully`,
        skillName,
        updatedAt: new Date(),
        duration,
        reindexed,
      };
    } catch (error) {
      const duration = Date.now() - startTime;

      logger.error("Skill update failed:", error);

      if (error instanceof ToolError) {
        throw error;
      }

      throw new ToolError(
        `Skill update failed: ${this.formatError(error)}`,
        ToolErrorCode.TOOL_EXECUTION_FAILED,
        { duration }
      );
    }
  }

  /**
   * 列出已安装的Skills
   * @param options 查询选项
   * @returns Skills列表结果
   */
  async listSkills(options: SkillListOptions = {}): Promise<SkillListResult> {
    try {
      // 确保目录存在
      await this.ensureSkillsDirectory();
      // 扫描Skills目录
      const entries = await fs.readdir(this.skillsBasePath, { withFileTypes: true });
      const skillDirs = entries.filter((entry) => entry.isDirectory()).map((entry) => entry.name);

      // 加载所有Skills元数据
      const skills: SkillTool[] = [];
      for (const skillName of skillDirs) {
        try {
          const skillPath = path.join(this.skillsBasePath, skillName);
          const metadata = await this.parseSkillMetadata(skillPath);

          skills.push({
            name: metadata.name,
            type: ToolType.SKILL,
            description: metadata.description,
            parameters: metadata.parameters || {
              type: "object",
              properties: {},
              required: [],
            },
            version: metadata.version,
            tags: metadata.tags,
            author: metadata.author,
            enabled: true,
            path: skillPath,
            level: 1,
          });
        } catch (error) {
          logger.warn(`Failed to load Skill metadata: ${skillName}`, {
            error: error instanceof Error ? error.message : error,
          });
        }
      }

      // 应用过滤
      let filtered = skills;

      // 按名称过滤
      if (options.name) {
        const nameFilter = options.name.toLowerCase();
        filtered = filtered.filter(
          (skill) =>
            skill.name.toLowerCase().includes(nameFilter) ||
            skill.description.toLowerCase().includes(nameFilter)
        );
      }

      // 按标签过滤
      if (options.tags && options.tags.length > 0) {
        filtered = filtered.filter((skill) =>
          skill.tags.some((tag) => options.tags!.includes(tag))
        );
      }

      // 排序
      const sortBy = options.sortBy || "name";
      const sortOrder = options.sortOrder || "asc";
      filtered.sort((a, b) => {
        let aVal: any, bVal: any;

        switch (sortBy) {
          case "name":
            aVal = a.name;
            bVal = b.name;
            break;
          case "updatedAt":
          case "installedAt":
            // 使用名称作为后备排序
            aVal = a.name;
            bVal = b.name;
            break;
          default:
            aVal = a.name;
            bVal = b.name;
        }

        const compare = String(aVal).localeCompare(String(bVal));
        return sortOrder === "desc" ? -compare : compare;
      });

      // 分页
      const page = options.page || 1;
      const limit = options.limit || 50;
      const startIndex = (page - 1) * limit;
      const endIndex = startIndex + limit;
      const paginated = filtered.slice(startIndex, endIndex);

      return {
        skills: paginated,
        total: filtered.length,
        page,
        limit,
        totalPages: Math.ceil(filtered.length / limit),
      };
    } catch (error) {
      logger.error("Failed to list skills:", error);
      throw new ToolError(
        `Failed to list skills: ${this.formatError(error)}`,
        ToolErrorCode.TOOL_EXECUTION_FAILED
      );
    }
  }

  /**
   * 检查Skills是否存在
   * @param skillName Skills名称
   * @returns 是否存在
   */
  async isSkillExist(skillName: string): Promise<boolean> {
    const skillPath = path.join(this.skillsBasePath, skillName);
    return this.directoryExists(skillPath);
  }

  /**
   * 解压ZIP到临时目录
   */
  private async extractZipToTemp(zipBuffer: Buffer): Promise<string> {
    // 创建临时目录
    const tempId = `${Date.now()}_${crypto.randomBytes(4).toString("hex")}`;
    const tempDir = path.join(os.tmpdir(), "skill-install", tempId);

    await fs.mkdir(tempDir, { recursive: true });

    // 使用adm-zip解压
    const zip = new AdmZip(zipBuffer);
    zip.extractAllTo(tempDir, true);

    logger.debug("Extracted ZIP to temp directory", { tempDir });

    return tempDir;
  }

  /**
   * 验证Skills结构
   */
  private async validateSkillStructure(
    skillPath: string,
    validationLevel: SkillInstallOptions["validationLevel"] = "basic"
  ): Promise<SkillMetadata> {
    // 检查必需文件
    const requiredFiles = ["SKILL.md"];

    for (const file of requiredFiles) {
      const filePath = path.join(skillPath, file);
      if (!(await this.fileExists(filePath))) {
        throw new ToolError(
          `Required file missing: ${file}`,
          ToolErrorCode.SKILL_INVALID_STRUCTURE
        );
      }
    }

    // 解析SKILL.md
    const metadata = await this.parseSkillMetadata(skillPath);

    // 严格验证（检查脚本文件是否存在）
    if (validationLevel === "strict") {
      const scriptsDir = path.join(skillPath, "scripts");
      if (!(await this.directoryExists(scriptsDir))) {
        throw new ToolError(
          "Scripts directory not found in strict validation mode",
          ToolErrorCode.SKILL_INVALID_STRUCTURE
        );
      }

      const executeScript = path.join(scriptsDir, "execute.js");
      if (!(await this.fileExists(executeScript))) {
        throw new ToolError(
          "execute.js not found in scripts directory",
          ToolErrorCode.SKILL_INVALID_STRUCTURE
        );
      }
    }

    return metadata;
  }

  /**
   * 解析Skills元数据
   * 使用 ClaudeCodeSkillParser 支持 Claude Code 格式
   */
  private async parseSkillMetadata(skillPath: string): Promise<SkillMetadata> {
    try {
      // 使用兼容层解析器
      const parsedSkill = await this.skillParser.parse(skillPath);

      // 注册生命周期钩子（如果有 hooks）
      if (parsedSkill.compatibility.hooks) {
        this.lifecycleManager.registerHooks(parsedSkill.metadata.name, {
          hooks: parsedSkill.compatibility.hooks,
        } as SkillLifecycleHooks);
      }

      logger.debug("Parsed skill metadata using compat layer", {
        name: parsedSkill.metadata.name,
        source: parsedSkill.compatibility.source,
      });

      return parsedSkill.metadata;
    } catch (error: unknown) {
      // 如果兼容层解析失败，回退到原有解析逻辑
      if (error instanceof ParseError) {
        logger.warn("Compat parser failed, falling back to legacy parser", {
          error: error.message,
        });
        return this.parseSkillMetadataLegacy(skillPath);
      }
      throw error;
    }
  }

  /**
   * 原有解析逻辑（向后兼容）
   */
  private async parseSkillMetadataLegacy(skillPath: string): Promise<SkillMetadata> {
    const skillMdPath = path.join(skillPath, "SKILL.md");

    if (!(await this.fileExists(skillMdPath))) {
      throw new ToolError(
        `SKILL.md not found in ${skillPath}`,
        ToolErrorCode.SKILL_INVALID_STRUCTURE
      );
    }

    const content = await fs.readFile(skillMdPath, "utf8");
    const parsed = matter(content);

    // 检查必需字段
    const requiredFields = ["name", "description", "version"];
    for (const field of requiredFields) {
      if (!parsed.data[field]) {
        throw new ToolError(
          `Required metadata field missing: ${field}`,
          ToolErrorCode.SKILL_INVALID_STRUCTURE
        );
      }
    }

    return {
      name: parsed.data.name,
      description: parsed.data.description,
      category: parsed.data.category || "uncategorized",
      tools: parsed.data.tools || [],
      version: parsed.data.version,
      tags: parsed.data.tags || [],
      author: parsed.data.author,
      dependencies: parsed.data.dependencies || [],
      parameters: parsed.data.parameters,
    };
  }

  /**
   * 检查目录是否存在
   */
  private async directoryExists(dirPath: string): Promise<boolean> {
    try {
      const stat = await fs.stat(dirPath);
      return stat.isDirectory();
    } catch {
      return false;
    }
  }

  /**
   * 检查文件是否存在
   */
  private async fileExists(filePath: string): Promise<boolean> {
    try {
      const stat = await fs.stat(filePath);
      return stat.isFile();
    } catch {
      return false;
    }
  }

  /**
   * 确保Skills目录存在，不存在则创建
   */
  private async ensureSkillsDirectory(): Promise<void> {
    try {
      const exists = await this.directoryExists(this.skillsBasePath);
      if (!exists) {
        await fs.mkdir(this.skillsBasePath, { recursive: true });
        logger.info(`Created skills directory: ${this.skillsBasePath}`);
      }
    } catch (error) {
      logger.warn(`Failed to create skills directory: ${this.skillsBasePath}`, error);
    }
  }

  /**
   * 格式化错误信息
   */
  private formatError(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error occurred";
  }

  /**
   * 获取指定Skills
   * @param skillName Skills名称
   * @returns Skills信息
   */
  async getSkillByName(skillName: string): Promise<SkillTool | null> {
    const skillPath = path.join(this.skillsBasePath, skillName);

    if (!(await this.directoryExists(skillPath))) {
      return null;
    }

    try {
      const metadata = await this.parseSkillMetadata(skillPath);

      return {
        name: metadata.name,
        type: ToolType.SKILL,
        description: metadata.description,
        parameters: metadata.parameters || {
          type: "object",
          properties: {},
          required: [],
        },
        version: metadata.version,
        tags: metadata.tags,
        author: metadata.author,
        enabled: true,
        path: skillPath,
        level: 1,
      };
    } catch (error) {
      logger.warn(`Failed to load Skill metadata: ${skillName}`, {
        error: error instanceof Error ? error.message : error,
      });
      return null;
    }
  }

  /**
   * 获取Skills统计信息
   * @returns 统计信息
   */
  async getStatistics(): Promise<{
    total: number;
    byTag: Record<string, number>;
    recentlyInstalled: string[];
  }> {
    const skills = await this.listSkills({ limit: 1000 });

    const byTag: Record<string, number> = {};
    for (const skill of skills.skills) {
      for (const tag of skill.tags) {
        byTag[tag] = (byTag[tag] || 0) + 1;
      }
    }

    return {
      total: skills.total,
      byTag,
      recentlyInstalled: skills.skills.slice(0, 5).map((s) => s.name),
    };
  }

  /**
   * 获取ToolRetrievalService实例
   */
  getRetrievalService(): ToolRetrievalService {
    return this.retrievalService;
  }

  /**
   * 等待初始化完成
   * 外部调用者可以使用此方法等待Skills索引初始化完成
   * @returns Promise，在初始化完成时resolve
   */
  async waitForInitialization(): Promise<void> {
    if (this.initializationPromise) {
      try {
        await this.initializationPromise;
      } catch (error) {
        // 初始化失败，但不阻止系统继续运行
        logger.warn("Skills initialization failed, but system will continue", {
          error: error instanceof Error ? error.message : error,
        });
      }
    }
  }

  /**
   * 初始化Skills索引
   * 在SkillManager创建时自动调用，扫描并索引所有已存在的Skills
   */
  private async initializeSkillsIndex(): Promise<void> {
    logger.debug("Initializing skills index during startup");

    try {
      // 等待检索服务初始化完成
      await this.retrievalService.initialize();

      // 扫描并索引所有Skills
      await this.retrievalService.scanAndIndexAllSkills(this.skillsBasePath);

      // 注册所有 Skills 到 ToolRegistry
      const { skills } = await this.listSkills({ limit: 1000 });
      for (const skill of skills) {
        await this.registerSkillTool(skill);
      }
      logger.info(`[SkillManager] Registered ${skills.length} skills to ToolRegistry`);

      logger.debug("Skills index initialization completed");
    } catch (error) {
      logger.error("❌ Failed to initialize skills index:", error);
      // 抛出错误，让waitForInitialization捕获
      throw error;
    }
  }

  /**
   * 将 SkillTool 转换为 Tool.Info 格式
   * @param skill SkillTool 定义
   * @returns Tool.Info 格式
   */
  private convertToToolInfo(skill: SkillTool): Tool.Info {
    const executor = this.skillsExecutor;
    return {
      id: skill.name,
      init: async () => ({
        description: skill.description,
        parameters: skill.parameters,
        execute: async (args, ctx) => {
          // 调用实际的 Skill 执行器
          const result = await executor.execute({
            name: skill.name,
            args,
          });
          return {
            title: skill.name,
            metadata: {
              success: result.success,
              duration: result.duration,
              exitCode: result.exitCode,
            },
            output: result.success ? result.output : result.error,
          };
        },
      }),
    };
  }

  /**
   * 注册 Skill 工具到 ToolRegistry
   * @param skill SkillTool 定义
   */
  async registerSkillTool(skill: SkillTool): Promise<void> {
    const toolInfo = this.convertToToolInfo(skill);
    await toolRegistry.register(toolInfo, RegistryToolType.SKILL);
    logger.debug(`Registered skill to ToolRegistry: ${skill.name}`);
  }

  /**
   * Skill Direct 模式 - 直接返回 SKILL.md 内容，无需沙箱执行
   * 用于 FR-37~FR-40 场景
   * @param skillName Skill 名称
   * @param args 工具参数
   * @returns SKILL.md 内容
   */
  async executeDirect(skillName: string, args: Record<string, unknown>): Promise<string> {
    const skillPath = path.join(this.skillsBasePath, skillName);
    const skillMdPath = path.join(skillPath, "SKILL.md");

    // 检查 Skill 是否存在
    if (!(await this.directoryExists(skillPath))) {
      throw new ToolError(`Skill '${skillName}' not found`, ToolErrorCode.SKILL_NOT_FOUND);
    }

    // 读取 SKILL.md
    if (!(await this.fileExists(skillMdPath))) {
      throw new ToolError(
        `SKILL.md not found in Skill '${skillName}'`,
        ToolErrorCode.SKILL_INVALID_STRUCTURE
      );
    }

    const content = await fs.readFile(skillMdPath, "utf8");
    const parsed = matter(content);

    // 返回 SKILL.md 的内容部分（不含 frontmatter）
    logger.debug(`[SkillManager] Direct execution for skill: ${skillName}`);
    return parsed.content;
  }

  /**
   * 获取单例实例
   */
  static getInstance(
    skillsBasePath?: string,
    retrievalService?: ToolRetrievalService
  ): SkillManager {
    if (!SkillManager.instance) {
      SkillManager.instance = new SkillManager(skillsBasePath, retrievalService);
    }
    return SkillManager.instance;
  }

  /**
   * 重置实例（用于测试）
   */
  static resetInstance(): void {
    SkillManager.instance = null;
  }
}

/**
 * 获取默认的SkillManager
 */
export function getSkillManager(
  skillsBasePath?: string,
  retrievalService?: ToolRetrievalService
): SkillManager {
  return SkillManager.getInstance(skillsBasePath, retrievalService);
}
````

## File: src/core/stream-orchestrator/types.ts
````typescript
/**
 * ReAct流式处理 - 基础类型定义
 */

// ── ReAct配置选项 ──────────────────────────────────────────────────────
export interface ReActOptions {
  /** 最大迭代次数，防止无限循环 (默认: 50) */
  maxIterations?: number;

  /** 总超时时间(ms) (默认: 300000, 5分钟) */
  timeoutMs?: number;

  /** 是否启用思考过程流式输出 (默认: true) */
  enableThinking?: boolean;

  /** 工具并发执行数 (默认: 3) */
  maxConcurrentTools?: number;

  /** 是否启用流式工具支持 (默认: false) */
  enableStreamingTools?: boolean;

  /** 是否启用 tool_action 标签解析 (默认: true) */
  enableToolActionParsing?: boolean;

  /** tool_action 工具执行超时时间(ms) (默认: 30000) */
  toolActionTimeout?: number;

  /** LLM提供商 (默认: 系统默认) */
  provider?: string;

  /** LLM模型 (默认: 系统默认) */
  model?: string;

  /** 温度参数 (默认: 0.7) */
  temperature?: number;

  /** 最大Token数 */
  maxTokens?: number;

  /** 中止信号 */
  signal?: AbortSignal;

  /** 其他LLM参数 */
  [key: string]: any;
}

// ── 流式事件类型 ────────────────────────────────────────────────────────
export type StreamEventType =
  | 'reasoning-start'   // 推理开始
  | 'reasoning'         // 推理内容（流式）
  | 'reasoning-delta'   // 推理内容增量
  | 'reasoning-end'     // 推理结束
  | 'step-start'        // 步骤开始
  | 'step-finish'       // 步骤完成
  | 'content'           // 内容输出
  | 'tool_start'        // 工具调用开始
  | 'tool_end'          // 工具调用结束
  | 'done'              // 完成
  | 'error';            // 错误

// ── 流式事件定义 ────────────────────────────────────────────────────────
export interface StreamEvent {
  /** 事件类型 */
  type: StreamEventType;

  /** 事件数据 */
  data: any;

  /** 时间戳 */
  timestamp: number;

  /** ReAct迭代轮次 */
  iteration: number;

  /** 步骤编号（step-start/step-finish事件使用） */
  stepNumber?: number;
}

// ── 工具调用定义 ────────────────────────────────────────────────────────
export interface ToolCall {
  /** 工具调用ID */
  id: string;

  /** 工具索引 (用于合并分块) */
  index?: number;

  /** 函数信息 */
  function: {
    /** 工具名称 */
    name: string;

    /** 参数 (JSON字符串) */
    arguments: string;
  };

  /** 工具类型 */
  type: 'function';
}

// ── 工具结果定义 ────────────────────────────────────────────────────────
export interface ToolResult {
  /** 工具调用ID */
  toolCallId: string;

  /** 工具名称 */
  name: string;

  /** 执行状态 */
  status: 'success' | 'error';

  /** 执行结果 */
  result: any;

  /** 错误信息 (status为error时) */
  error?: string;

  /** 执行耗时(ms) */
  durationMs?: number;
}

// ── LLM适配器接口 ───────────────────────────────────────────────────────
export interface LLMOptions {
  /** 工具列表 */
  tools?: Array<{
    type: 'function';
    function: {
      name: string;
      description: string;
      parameters: any;
    };
  }>;

  /** 是否启用思考过程 */
  enableThinking?: boolean;

  /** 模型名称 */
  model?: string;

  /** 温度参数 */
  temperature?: number;

  /** 最大Token数 */
  maxTokens?: number;

  /** 其他参数 */
  [key: string]: any;
}

/**
 * LLM适配器接口
 * 抽象不同LLM提供商的差异
 */
export interface LLMAdapter {
  /**
   * 流式聊天
   * @param messages 消息列表
   * @param options 选项
   * @param tools 可用工具列表
   * @param signal 中止信号
   */
  streamChat(
    messages: any[],
    options?: LLMOptions,
    tools?: any[],  // ✅ 新增：工具列表
    signal?: AbortSignal
  ): AsyncGenerator<any, void, void>;
}

// ── 工具接口定义 ────────────────────────────────────────────────────────
/**
 * 工具接口
 * 支持三种执行模式：同步、Promise、AsyncGenerator
 */
export interface Tool {
  /** 工具名称 (唯一标识) */
  name: string;

  /** 工具描述 */
  description: string;

  /** 参数JSON Schema */
  parameters: any;

  /**
   * 执行函数
   * @param args 参数对象
   * @param signal 中止信号
   * @returns 可以是同步值、Promise或AsyncGenerator(流式)
   */
  execute(args: any, signal?: AbortSignal): any | Promise<any> | AsyncGenerator<any>;

  /** 是否为流式工具 */
  isStreaming?: boolean;
}

// ── Doom Loop 检测器 ─────────────────────────────────────────────────────
export interface DoomLoopDetector {
  /** 工具调用历史 */
  toolCallHistory: { name: string; args: unknown }[];

  /** Doom Loop 阈值（默认3次） */
  doomLoopThreshold: number;

  /** 检测是否进入 Doom Loop */
  check(name: string, args: unknown): boolean;

  /** 重置检测器 */
  reset(): void;
}

// ── 运行时上下文 ────────────────────────────────────────────────────────
export interface ReActRuntimeContext {
  /** 当前迭代次数 */
  iteration: number;

  /** 最大迭代次数 */
  maxIterations: number;

  /** 是否启用思考流式输出 */
  enableThinking: boolean;

  /** 工具调用累积 */
  toolCalls: Map<number, ToolCall>;

  /** 累积内容 */
  accumulatedContent: string;

  /** 中止信号 */
  signal: AbortSignal;

  /** 步骤计数器（用于步骤边界事件） */
  stepNumber: number;

  /** Doom Loop 检测器 */
  doomLoopDetector: DoomLoopDetector;
}

// ── 批处理任务定义 ───────────────────────────────────────────────────────
export interface BatchTask {
  /** 任务ID */
  taskId: string;

  /** 消息列表 */
  messages: any[];

  /** ReAct选项 */
  options?: Partial<ReActOptions>;
}

export interface BatchResult {
  /** 任务ID */
  taskId: string;

  /** 执行结果 */
  result: any[];

  /** 时间戳 */
  timestamp: number;
}
````

## File: src/core/llm/adapters/BaseAdapter.ts
````typescript
/**
 * BaseAdapter - LLM适配器基类
 * 提供通用的OpenAI兼容适配器实现
 */

import axios, { AxiosInstance } from "axios";
import { Message, ChatOptions, LLMResponse, LLMProviderConfig } from "../../../types";
import { logger } from "../../../utils/logger";
import { retry, RetryConfig } from "../../../utils/retry";
import { logErrorResponse, createErrorMessage } from "../../../utils/error-serializer";

/**
 * Axios 请求配置接口
 */
export interface AxiosRequestConfig {
  baseURL: string;
  headers: Record<string, string>;
  timeout: number;
  proxy?:
    | false
    | {
        host: string;
        port: number;
        protocol?: string;
        auth?: {
          username: string;
          password: string;
        };
      };
}

/**
 * OpenAI 兼容 API 请求体接口
 */
export interface OpenAIRequestBody {
  model: string;
  messages: Array<{
    role: string;
    content:
      | string
      | Array<{
          type: string;
          text?: string;
          image_url?: string | { url: string };
        }>;
    name?: string;
  }>;
  stream: boolean;
  temperature?: number;
  top_p?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
  repetition_penalty?: number;
  seed?: number;
  logit_bias?: Record<string, number>;
  max_tokens?: number;
  response_format?: { type: string };
  stop?: string[];
  tools?: unknown[];
  tool_choice?: string;
}

/**
 * OpenAI 兼容 API 响应接口
 */
export interface OpenAIResponse {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<{
    index: number;
    message?: {
      role: string;
      content: string;
      tool_calls?: unknown[];
    };
    finish_reason?: string;
  }>;
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
  };
}

/**
 * LLM适配器接口
 */
export interface ILLMAdapter {
  chat(messages: Message[], options: ChatOptions, signal?: AbortSignal): Promise<LLMResponse>;
  streamChat(
    messages: Message[],
    options: ChatOptions,
    tools?: any[],
    signal?: AbortSignal
  ): AsyncIterableIterator<string>;
  getModels(): Promise<string[]>;
  embed?(texts: string[], model?: string): Promise<number[][]>;
}

/**
 * OpenAI 兼容 API 请求体接口
 */
export interface OpenAIRequestBody {
  model: string;
  messages: Array<{
    role: string;
    content:
      | string
      | Array<{
          type: string;
          text?: string;
          image_url?: string | { url: string };
        }>;
    name?: string;
  }>;
  stream: boolean;
  temperature?: number;
  top_p?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
  repetition_penalty?: number;
  seed?: number;
  logit_bias?: Record<string, number>;
  max_tokens?: number;
  response_format?: { type: string };
  stop?: string[];
  tools?: unknown[];
  tool_choice?: string;
}

/**
 * OpenAI 兼容 API 响应接口
 */
export interface OpenAIResponse {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<{
    index: number;
    message?: {
      role: string;
      content: string;
      tool_calls?: unknown[];
    };
    finish_reason?: string;
  }>;
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
  };
}

/**
 * LLM适配器接口
 */
export interface ILLMAdapter {
  chat(messages: Message[], options: ChatOptions, signal?: AbortSignal): Promise<LLMResponse>;
  streamChat(
    messages: Message[],
    options: ChatOptions,
    tools?: any[],
    signal?: AbortSignal
  ): AsyncIterableIterator<string>;
  getModels(): Promise<string[]>;
  embed?(texts: string[], model?: string): Promise<number[][]>;
}

/**
 * OpenAI兼容适配器基类
 */
export abstract class BaseOpenAICompatibleAdapter implements ILLMAdapter {
  protected client: AxiosInstance;
  protected providerName: string;
  protected config: LLMProviderConfig;

  constructor(providerName: string, config: LLMProviderConfig) {
    this.providerName = providerName;
    this.config = config;

    // 构建axios配置
    const axiosConfig: AxiosRequestConfig = {
      baseURL: config.baseURL,
      headers: {
        ...(config.apiKey && { Authorization: `Bearer ${config.apiKey}` }),
        "Content-Type": "application/json",
      },
      timeout: config.timeout || 60000,
    };

    // 如果配置中指定了proxy，使用它
    if (config.proxy !== undefined) {
      axiosConfig.proxy = config.proxy;
    }

    this.client = axios.create(axiosConfig);

    logger.debug(
      `${providerName} adapter initialized (${config.baseURL}${config.proxy === false ? ", proxy disabled" : ""})`
    );
  }

  /**
   * 过滤选项（子类可覆盖）
   */
  protected filterOptions(options: ChatOptions): ChatOptions {
    return options;
  }

  /**
   * 构建请求体（子类可覆盖）
   * 🆕 支持新的配置结构
   * 🆕 支持多模态消息（文本+图像）
   */
  protected buildRequestBody(messages: Message[], options: ChatOptions): OpenAIRequestBody {
    const { provider, ...apiOptions } = options;
    const filteredOptions = this.filterOptions(apiOptions);

    // 🐾 处理消息格式（支持多模态）
    const processedMessages = messages.map((msg) => {
      if (Array.isArray(msg.content)) {
        // 多模态消息：转换为OpenAI兼容格式
        return {
          ...msg,
          content: msg.content.map((part) => {
            if (part.type === "image_url") {
              return {
                type: "image_url",
                image_url: part.image_url,
              };
            }
            return {
              type: "text",
              text: part.text || "",
            };
          }),
        };
      }
      // 纯文本消息
      return {
        ...msg,
        content: msg.content,
      };
    });

    // 🐾 构建基础请求体
    const requestBody: OpenAIRequestBody = {
      model: options.model || this.config.defaultModel,
      messages: processedMessages as OpenAIRequestBody["messages"],
      stream: false,
      temperature: options.temperature,
    };

    // 🐾 处理温度参数（基础配置）
    if (options.temperature !== undefined) {
      requestBody.temperature = options.temperature;
    }

    // 🐾 处理生成配置（GenerationConfig）
    if (options.generationConfig) {
      const gc = options.generationConfig;

      // Top-P 采样
      if (gc.topP !== undefined) {
        requestBody.top_p = gc.topP;
      }

      // 频率惩罚
      if (gc.frequencyPenalty !== undefined) {
        requestBody.frequency_penalty = gc.frequencyPenalty;
      }

      // 存在惩罚
      if (gc.presencePenalty !== undefined) {
        requestBody.presence_penalty = gc.presencePenalty;
      }

      // 重复惩罚
      if (gc.repetitionPenalty !== undefined) {
        requestBody.repetition_penalty = gc.repetitionPenalty;
      }

      // 随机种子
      if (gc.seed !== undefined) {
        requestBody.seed = gc.seed;
      }

      // Logit 偏差
      if (gc.logitBias) {
        requestBody.logit_bias = gc.logitBias;
      }
    }

    // 🐾 处理输出配置（OutputConfig）
    if (options.outputConfig) {
      const oc = options.outputConfig;

      // 最大输出 tokens
      if (oc.maxOutputTokens !== undefined) {
        requestBody.max_tokens = oc.maxOutputTokens;
      }

      // 输出格式
      if (oc.outputFormat === "json") {
        requestBody.response_format = { type: "json_object" };
      } else if (oc.outputFormat === "text") {
        requestBody.response_format = { type: "text" };
      }

      // 停止序列
      if (oc.stopSequences && oc.stopSequences.length > 0) {
        requestBody.stop = oc.stopSequences;
      }
    }

    return requestBody;
  }

  async chat(
    messages: Message[],
    options: ChatOptions,
    signal?: AbortSignal
  ): Promise<LLMResponse> {
    const maxRetries = this.config.maxRetries || 3;
    const retryConfig: RetryConfig = {
      maxRetries,
      initialDelay: 1000,
      maxDelay: 10000,
      backoffMultiplier: 2,
      retryOn4xx: false,
      shouldRetry: (error: any) => {
        if (signal?.aborted || error.name === "AbortError" || error.code === "ERR_CANCELED") {
          return false;
        }
        if (
          error.response?.status === 400 ||
          error.response?.status === 401 ||
          error.response?.status === 403 ||
          error.response?.status === 404
        ) {
          return false;
        }
        return true;
      },
    };

    return retry(async () => {
      try {
        const requestBody = this.buildRequestBody(messages, options);

        logger.debug(`[${this.providerName}] Request body`, {
          model: requestBody.model,
          messageCount: messages.length,
        });

        const response = await this.client.post("/chat/completions", requestBody, {
          signal,
        });

        return response.data;
      } catch (error: any) {
        if (signal?.aborted || error.name === "AbortError" || error.code === "ERR_CANCELED") {
          throw error;
        }

        logErrorResponse(this.providerName, error, "chat");
        throw new Error(createErrorMessage(this.providerName, error));
      }
    }, retryConfig);
  }

  async *streamChat(
    messages: Message[],
    options: ChatOptions,
    tools?: any[],
    signal?: AbortSignal
  ): AsyncIterableIterator<string> {
    try {
      const { provider, ...apiOptions } = options;
      const filteredOptions = this.filterOptions(apiOptions);

      // 🐾 处理消息格式（支持多模态）
      const processedMessages = messages.map((msg) => {
        if (Array.isArray(msg.content)) {
          return {
            ...msg,
            content: msg.content.map((part) => {
              if (part.type === "image_url") {
                return {
                  type: "image_url",
                  image_url: part.image_url,
                };
              }
              return {
                type: "text",
                text: part.text || "",
              };
            }),
          };
        }
        return {
          ...msg,
          content: msg.content,
        };
      });

      // 🐾 构建基础请求体（与 buildRequestBody 保持一致）
      const requestBody: OpenAIRequestBody = {
        model: options.model || this.config.defaultModel,
        messages: processedMessages,
        stream: true,
        ...filteredOptions,
      };

      // ✅ 新增：传递给LLM的工具列表
      if (tools && tools.length > 0) {
        requestBody.tools = tools;
        requestBody.tool_choice = "auto";
      }

      // 🐾 处理温度参数
      if (options.temperature !== undefined) {
        requestBody.temperature = options.temperature;
      }

      // 🐾 处理生成配置
      if (options.generationConfig) {
        const gc = options.generationConfig;
        if (gc.topP !== undefined) requestBody.top_p = gc.topP;
        if (gc.frequencyPenalty !== undefined) requestBody.frequency_penalty = gc.frequencyPenalty;
        if (gc.presencePenalty !== undefined) requestBody.presence_penalty = gc.presencePenalty;
        if (gc.repetitionPenalty !== undefined)
          requestBody.repetition_penalty = gc.repetitionPenalty;
        if (gc.seed !== undefined) requestBody.seed = gc.seed;
        if (gc.logitBias) requestBody.logit_bias = gc.logitBias;
      }

      // 🐾 处理输出配置
      if (options.outputConfig) {
        const oc = options.outputConfig;
        if (oc.maxOutputTokens !== undefined) requestBody.max_tokens = oc.maxOutputTokens;
        if (oc.outputFormat === "json") {
          requestBody.response_format = { type: "json_object" };
        } else if (oc.outputFormat === "text") {
          requestBody.response_format = { type: "text" };
        }
        if (oc.stopSequences && oc.stopSequences.length > 0) {
          requestBody.stop = oc.stopSequences;
        }
      }

      logger.debug(`[${this.providerName}] Stream request`, {
        model: requestBody.model,
        messageCount: messages.length,
        hasTools: !!tools,
        toolCount: tools?.length,
      });

      const response = await this.client.post("/chat/completions", requestBody, {
        responseType: "stream",
        signal,
      });

      for await (const chunk of response.data) {
        const lines = chunk
          .toString()
          .split("\n")
          .filter((line: string) => line.trim());

        for (const line of lines) {
          if (line.startsWith("data: ")) {
            const data = line.substring(6);

            if (data === "[DONE]") {
              return;
            }

            try {
              const parsed = JSON.parse(data);

              // 提取 reasoning_content (深度思考)
              const reasoning = parsed.choices?.[0]?.delta?.reasoning_content;

              // 提取 content (回答内容)
              const content = parsed.choices?.[0]?.delta?.content;

              // 提取 tool_calls (工具调用)
              const toolCalls = parsed.choices?.[0]?.delta?.tool_calls;

              // 只要有内容就 yield JSON 字符串
              if (reasoning || content || toolCalls) {
                yield JSON.stringify({
                  reasoning_content: reasoning,
                  content: content,
                  tool_calls: toolCalls,
                });
              }
            } catch (e) {
              // Skip parse errors
            }
          }
        }
      }
    } catch (error: any) {
      logger.error(`❌ ${this.providerName} stream error:`, error.message);
      if (error.response) {
        logger.error(`   HTTP状态: ${error.response.status}`);
        // 🐛 修复：安全序列化，避免循环引用
        try {
          if (error.response.data && typeof error.response.data === "object") {
            // 只序列化 data 字段，避免序列化整个 response 对象
            logger.error(`   错误详情: ${JSON.stringify(error.response.data, null, 2)}`);
          } else {
            logger.error(`   错误详情: ${error.response.data || "无详细信息"}`);
          }
        } catch (e) {
          // 如果序列化失败，只记录错误消息
          logger.error(`   错误详情: [无法序列化响应数据]`);
        }
      }
      throw new Error(`${this.providerName} stream request failed: ${error.message}`);
    }
  }

  async getModels(): Promise<string[]> {
    try {
      const response = await this.client.get("/models");
      const models = response.data.data || response.data.models || [];
      return models.map((m: any) => m.id || m.name);
    } catch (error: any) {
      logger.warn(`⚠️  Failed to get models from ${this.providerName}:`, error.message);
      throw error;
    }
  }

  /**
   * 生成文本向量嵌入（OpenAI 兼容格式）
   */
  async embed(texts: string[], model?: string): Promise<number[][]> {
    try {
      const requestBody = {
        model: model || this.config.defaultModel,
        input: texts,
      };

      logger.debug(`[${this.providerName}] Embedding request`, {
        model: requestBody.model,
        textCount: texts.length,
      });

      const response = await this.client.post("/embeddings", requestBody);

      // OpenAI 格式: { data: [{ embedding: [...] }] }
      if (response.data?.data) {
        return response.data.data.map((item: any) => item.embedding);
      }

      // Ollama 格式: { embedding: [...] } 或 { embeddings: [[...]] }
      if (response.data?.embedding) {
        return [response.data.embedding];
      }
      if (response.data?.embeddings) {
        return response.data.embeddings;
      }

      throw new Error("Unexpected embedding response format");
    } catch (error: any) {
      logErrorResponse(this.providerName, error, "embed");
      throw new Error(`${this.providerName} embedding failed: ${error.message}`);
    }
  }
}
````

## File: src/api/middleware/validationSchemas.ts
````typescript
/**
 * Validation Schemas - API 端点验证模式定义
 *
 * 为所有 API 端点定义 JSON Schema 验证模式
 */

import { ValidationSchema } from "./validationMiddleware";

/**
 * 聊天补全请求验证模式
 */
export const chatCompletionSchema: ValidationSchema = {
  body: {
    type: "object",
    required: ["messages"],
    properties: {
      model: {
        type: "string",
        pattern: "^[a-zA-Z0-9._:-]+$",
        maxLength: 100,
      },
      messages: {
        type: "array",
        minItems: 1,
        maxItems: 100,
        items: {
          type: "object",
          required: ["role", "content"],
          properties: {
            role: {
              type: "string",
              enum: ["system", "user", "assistant"],
            },
            content: {
              anyOf: [
                { type: "string", maxLength: 100000 },
                {
                  type: "array",
                  maxItems: 50,
                  items: {
                    type: "object",
                    required: ["type"],
                    properties: {
                      type: {
                        type: "string",
                        enum: ["text", "image_url"],
                      },
                      text: {
                        type: "string",
                        maxLength: 50000,
                      },
                      image_url: {
                        type: "object",
                        properties: {
                          url: {
                            type: "string",
                            maxLength: 10000000, // ✅ 修复：增加到10MB，支持大型图片的base64编码
                          },
                        },
                        required: ["url"],
                      },
                    },
                  },
                },
              ],
            },
            name: {
              type: "string",
              maxLength: 100,
            },
          },
        },
      },
      temperature: {
        type: "number",
        minimum: 0,
        maximum: 2,
        default: 1,
      },
      max_tokens: {
        type: "integer",
        minimum: 1,
        maximum: 4096,
      },
      top_p: {
        type: "number",
        minimum: 0,
        maximum: 1,
      },
      frequency_penalty: {
        type: "number",
        minimum: -2,
        maximum: 2,
      },
      presence_penalty: {
        type: "number",
        minimum: -2,
        maximum: 2,
      },
      stop: {
        oneOf: [
          {
            type: "string",
            maxLength: 100,
          },
          {
            type: "array",
            items: {
              type: "string",
              maxLength: 100,
            },
            maxItems: 4,
          },
        ],
      },
      n: {
        type: "integer",
        minimum: 1,
        maximum: 10,
      },
      stream: {
        type: "boolean",
        default: false,
      },
      user: {
        type: "string",
        maxLength: 100,
      },
      agent_id: {
        type: "string",
        pattern: "^[a-zA-Z0-9._-]+$",
        maxLength: 100,
      },
      selfThinking: {
        type: "object",
        properties: {
          enabled: {
            type: "boolean",
          },
          maxIterations: {
            type: "integer",
            minimum: 1,
            maximum: 100,
            default: 50,
          },
          includeThoughtsInResponse: {
            type: "boolean",
            default: true,
          },
          systemPrompt: {
            type: "string",
            maxLength: 10000,
          },
          additionalPrompts: {
            type: "array",
            items: {
              type: "string",
              maxLength: 2000,
            },
            maxItems: 10,
          },
          tools: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                  pattern: "^[a-zA-Z0-9_]+$",
                  maxLength: 50,
                },
                description: {
                  type: "string",
                  maxLength: 500,
                },
                parameters: {
                  type: "object",
                },
              },
              required: ["name", "description", "parameters"],
            },
            maxItems: 20,
          },
          enableStreamThoughts: {
            type: "boolean",
            default: false,
          },
        },
      },
    },
  },
};

/**
 * 模型列表请求验证模式
 */
export const modelsListSchema: ValidationSchema = {
  query: {
    type: "object",
    properties: {
      provider: {
        type: "string",
        pattern: "^[a-zA-Z0-9._-]+$",
        maxLength: 50,
      },
    },
  },
};

/**
 * 中断请求验证模式
 */
export const interruptRequestSchema: ValidationSchema = {
  body: {
    type: "object",
    required: ["requestId"],
    properties: {
      requestId: {
        type: "string",
        pattern: "^[a-zA-Z0-9._-]+$",
        minLength: 1,
        maxLength: 200,
      },
    },
  },
};

/**
 * 模型预添加验证模式
 */
export const validateModelBeforeAddSchema: ValidationSchema = {
  body: {
    type: "object",
    required: ["provider", "baseConfig", "model"],
    properties: {
      provider: {
        type: "string",
        enum: ["openai", "deepseek", "zhipu", "claude", "ollama", "custom"],
      },
      baseConfig: {
        type: "object",
        required: ["apiKey"],
        properties: {
          apiKey: {
            type: "string",
            minLength: 1,
          },
          baseURL: {
            type: "string",
            format: "uri",
            pattern: "^https?://",
          },
          timeout: {
            type: "integer",
            minimum: 1000,
            maximum: 60000,
          },
          maxRetries: {
            type: "integer",
            minimum: 0,
            maximum: 5,
          },
        },
      },
      model: {
        type: "string",
        pattern: "^[a-zA-Z0-9._-]+$",
        minLength: 1,
        maxLength: 100,
      },
    },
  },
};
````

## File: src/core/stream-orchestrator/ReActEngine.ts
````typescript
/**
 * ReAct Engine - ReAct流式处理核心引擎
 *
 * 事件驱动的ReAct推理引擎，支持：
 * - 链式思考 (Chain-of-Thought) 流式输出
 * - 工具并发执行
 * - 异步生成器
 * - 零阻塞SSE推送
 * - tool_action 标签解析
 * - Doom Loop 检测
 * - 步骤边界事件
 */

import { ToolExecutor } from "./ToolExecutor";
import { StreamTagDetector } from "../tool-action/StreamTagDetector";
import { ToolDispatcher } from "../tool-action/ToolDispatcher";
import { ToolActionParser } from "../tool-action/ToolActionParser";
import type { ToolActionCall } from "../tool-action/types";
import type {
  LLMAdapter,
  LLMOptions,
  ToolCall,
  StreamEvent,
  ReActOptions,
  ReActRuntimeContext,
  DoomLoopDetector,
} from "./types";
import { logger } from "../../utils/logger";
import { TIMEOUT, LIMITS, DOOM_LOOP } from "../../constants";

/**
 * Doom Loop 检测器实现
 * 检测重复的工具调用模式，防止无限循环
 */
export class DoomLoopDetectorImpl implements DoomLoopDetector {
  toolCallHistory: { name: string; args: unknown }[];
  doomLoopThreshold: number;

  constructor(threshold: number = DOOM_LOOP.THRESHOLD) {
    this.toolCallHistory = [];
    this.doomLoopThreshold = threshold;
  }

  check(name: string, args: unknown): boolean {
    // 添加到历史记录
    this.toolCallHistory.push({ name, args });

    // 只保留最近 N 次调用
    const maxHistory = this.doomLoopThreshold * 2;
    if (this.toolCallHistory.length > maxHistory) {
      this.toolCallHistory = this.toolCallHistory.slice(-maxHistory);
    }

    // 检查最近 N 次调用是否完全相同
    if (this.toolCallHistory.length < this.doomLoopThreshold) {
      return false;
    }

    const recentCalls = this.toolCallHistory.slice(-this.doomLoopThreshold);
    const lastCall = recentCalls[recentCalls.length - 1];

    // 检查所有最近调用是否与最后一次相同
    const isDoomLoop = recentCalls.every(
      (call) =>
        call.name === lastCall.name && JSON.stringify(call.args) === JSON.stringify(lastCall.args)
    );

    if (isDoomLoop) {
      logger.warn(
        `[ReActEngine] Doom Loop detected: ${name} called ${this.doomLoopThreshold} times with same args`
      );
    }

    return isDoomLoop;
  }

  reset(): void {
    this.toolCallHistory = [];
  }
}

export class ReActEngine {
  private toolExecutor: ToolExecutor;
  private defaultOptions: Required<ReActOptions>;
  private toolDispatcher: ToolDispatcher;
  public tools: any[] = [];

  constructor(options: Partial<ReActOptions> = {}) {
    this.toolExecutor = new ToolExecutor({
      maxConcurrency: options.maxConcurrentTools ?? LIMITS.MAX_CONCURRENT_TOOLS,
    });

    this.toolDispatcher = new ToolDispatcher({
      timeout: options.toolActionTimeout ?? TIMEOUT.TOOL_EXECUTION,
      maxConcurrency: options.maxConcurrentTools ?? LIMITS.MAX_CONCURRENT_TOOLS,
    });

    this.defaultOptions = {
      maxIterations: options.maxIterations ?? LIMITS.MAX_ITERATIONS,
      timeoutMs: options.timeoutMs ?? 300_000,
      enableThinking: options.enableThinking ?? true,
      maxConcurrentTools: options.maxConcurrentTools ?? LIMITS.MAX_CONCURRENT_TOOLS,
      enableStreamingTools: options.enableStreamingTools ?? false,
      enableToolActionParsing: options.enableToolActionParsing ?? true,
      toolActionTimeout: options.toolActionTimeout ?? TIMEOUT.TOOL_EXECUTION,
      provider: options.provider ?? undefined,
      model: options.model ?? undefined,
      temperature: options.temperature ?? 0.7,
      maxTokens: options.maxTokens ?? undefined,
      signal: undefined,
    };
  }

  /**
   * 增强的 XML 内容转义
   * 处理所有 XML 特殊字符，防止破坏 XML 结构
   * 包括：基本转义、CDATA 保护、注释、处理指令
   * @param content 原始内容
   * @returns 转义后的安全内容
   */
  private escapeXmlContent(content: string): string {
    if (!content || typeof content !== "string") {
      return "";
    }

    return content
      .replace(/&/g, "&#x26;") // 必须最先处理
      .replace(/</g, "&#x3C;")
      .replace(/>/g, "&#x3E;")
      .replace(/"/g, "&#x22;")
      .replace(/'/g, "&#x27;")
      .replace(/<!--/g, "&#x3C;!--") // 注释开始标记保护
      .replace(/-->/g, "--&#x3E;") // 注释结束标记保护
      .replace(/<\?/g, "&#x3C;?") // 处理指令开始保护
      .replace(/\?>/g, "?&#x3E;") // 处理指令结束保护
      .replace(/\]\]>/g, "]]&#x3E;"); // CDATA 结束保护
  }

  /**
   * 执行ReAct循环
   * @param messages 消息历史
   * @param llmClient LLM适配器
   * @param runtimeOptions 运行时选项（继承默认选项）
   * @yields StreamEvent 流式事件
   * @returns 最终答案
   */
  async *execute(
    messages: any[],
    llmClient: LLMAdapter,
    runtimeOptions?: Partial<ReActOptions>
  ): AsyncGenerator<StreamEvent, string, void> {
    const options = { ...this.defaultOptions, ...runtimeOptions };
    // 使用外部传入的 signal，如果没有则创建新的
    const signal = options.signal || new AbortController().signal;

    // 初始化 Doom Loop 检测器
    const doomLoopDetector = new DoomLoopDetectorImpl(DOOM_LOOP.THRESHOLD);

    try {
      // 发送 reasoning-start 事件
      // yield {
      //   type: "reasoning-start",
      //   data: { message: "开始推理" },
      //   timestamp: Date.now(),
      //   iteration: 0,
      // };

      for (let iteration = 0; iteration < options.maxIterations; iteration++) {
        const chunk = yield* this.runIteration(
          messages,
          llmClient,
          {
            iteration,
            maxIterations: options.maxIterations,
            enableThinking: options.enableThinking,
            toolCalls: new Map(),
            accumulatedContent: "",
            signal,
            stepNumber: 0,
            doomLoopDetector,
          },
          options,
          signal
        );

        if (chunk) {
          // 发送 reasoning-end 事件
          // yield {
          //   type: "reasoning-end",
          //   data: { message: "推理完成" },
          //   timestamp: Date.now(),
          //   iteration,
          // };
          return chunk;
        }
      }

      throw new Error("Max iterations reached");
    } finally {
      this.toolExecutor.clear();
    }
  }

  /**
   * 单轮ReAct迭代
   */
  private async *runIteration(
    messages: any[],
    llmClient: LLMAdapter,
    context: ReActRuntimeContext,
    options: Required<ReActOptions>,
    signal: AbortSignal
  ): AsyncGenerator<StreamEvent, string | null, void> {
    const { provider, model, temperature, maxTokens } = options;
    const llmOptions: LLMOptions = {
      enableThinking: context.enableThinking,
      model,
      provider,
      temperature,
      maxTokens,
    };

    const llmStream = llmClient.streamChat(
      messages,
      llmOptions,
      this.tools.length > 0 ? this.tools : undefined,
      signal
    );

    let assistantMessage = { role: "assistant", content: "" };
    let toolCalls: ToolCall[] = [];
    let inThinking = false;
    let thinkingBuffer = "";
    let stepStartTime = Date.now();

    // 初始化流式标签检测器
    const streamDetector = options.enableToolActionParsing ? new StreamTagDetector() : null;
    let detectedToolActions: ToolActionCall[] = [];

    for await (const chunk of llmStream) {
      if (signal.aborted) {
        throw new Error("Aborted");
      }

      if (chunk.type === "reasoning") {
        // 流式输出每一个 reasoning chunk（不仅仅是第一个）
        if (context.enableThinking) {
          // 使用 reasoning-delta 事件替代 reasoning 事件
          yield {
            type: "reasoning-delta",
            data: chunk.content,
            timestamp: Date.now(),
            iteration: context.iteration,
            stepNumber: context.stepNumber,
          };
        }
        thinkingBuffer += chunk.content;
        inThinking = true;
        continue;
      }

      if (inThinking && thinkingBuffer) {
        thinkingBuffer = "";
        inThinking = false;
      }

      // 原生 tool_calls 优先处理
      if (chunk.type === "tool_calls") {
        toolCalls = chunk.tool_calls || [];
      }

      if (chunk.type === "content") {
        // 如果启用了标签解析且没有原生 tool_calls
        if (streamDetector && toolCalls.length === 0) {
          // 🔍 调试日志：显示收到的 content
          logger.debug(
            `[ReActEngine] Processing content chunk (${chunk.content.length} chars): ${chunk.content.substring(0, 100)}...`
          );

          const detection = streamDetector.processChunk(chunk.content);

          // 🔍 调试日志：显示检测结果
          logger.debug(
            `[ReActEngine] Detection result: complete=${detection.complete}, hasToolAction=${!!detection.toolAction}, textToEmit="${detection.textToEmit?.substring(0, 50)}...", bufferRemainder="${detection.bufferRemainder?.substring(0, 50)}..."`
          );

          // 输出非标签文本
          if (detection.textToEmit) {
            assistantMessage.content += detection.textToEmit;
            yield {
              type: "content",
              data: detection.textToEmit,
              timestamp: Date.now(),
              iteration: context.iteration,
              stepNumber: context.stepNumber,
            };
          }

          // 检测到完整的工具调用标签
          if (detection.complete && detection.toolAction) {
            logger.info(`[ReActEngine] ✅ Detected tool_action: ${detection.toolAction.name}`);
            detectedToolActions.push(detection.toolAction);

            // 输出完整的标签内容到前端，让用户看到 LLM 的工具调用
            const tagContent = detection.toolAction.rawText;
            assistantMessage.content += tagContent;
            yield {
              type: "content",
              data: tagContent,
              timestamp: Date.now(),
              iteration: context.iteration,
              stepNumber: context.stepNumber,
            };
          }
        } else {
          // 不启用标签解析或已有原生 tool_calls，直接输出
          assistantMessage.content += chunk.content;
          yield {
            type: "content",
            data: chunk.content,
            timestamp: Date.now(),
            iteration: context.iteration,
            stepNumber: context.stepNumber,
          };
        }
      }
    }

    // 刷新流式检测器的缓冲区
    if (streamDetector) {
      const remainingText = streamDetector.flush();
      logger.debug(
        `[ReActEngine] Flushing detector buffer: "${remainingText?.substring(0, 100) || "(empty)"}..."`
      );
      if (remainingText) {
        // 🔍 检查 flush 后的内容是否包含未处理的标签
        if (remainingText.includes("<tool_action")) {
          logger.warn(`[ReActEngine] ⚠️ Buffer contains unprocessed tool_action tag!`);
          // 尝试解析缓冲区中的标签
          const parser = new ToolActionParser();
          const parseResult = parser.parse(remainingText);
          if (parseResult.toolCalls.length > 0) {
            logger.info(
              `[ReActEngine] Found ${parseResult.toolCalls.length} tool_action(s) in buffer`
            );
            for (const toolCall of parseResult.toolCalls) {
              detectedToolActions.push(toolCall);
            }
          }
        }

        assistantMessage.content += remainingText;
        yield {
          type: "content",
          data: remainingText,
          timestamp: Date.now(),
          iteration: context.iteration,
          stepNumber: context.stepNumber,
        };
      }
    }

    // 优先处理原生 tool_calls
    if (toolCalls.length > 0) {
      // 增加步骤计数器并发送 step-start 事件
      context.stepNumber++;
      // yield {
      //   type: "step-start",
      //   data: { stepNumber: context.stepNumber, toolCount: toolCalls.length },
      //   timestamp: stepStartTime,
      //   iteration: context.iteration,
      //   stepNumber: context.stepNumber,
      // };

      // yield {
      //   type: "tool_start",
      //   data: { toolCalls },
      //   timestamp: Date.now(),
      //   iteration: context.iteration,
      //   stepNumber: context.stepNumber,
      // };

      const results = await this.toolExecutor.executeAll(toolCalls, context.iteration, (result) => {
        context.accumulatedContent += JSON.stringify(result);
      });

      // yield {
      //   type: "tool_end",
      //   data: { results: Array.from(results.values()) },
      //   timestamp: Date.now(),
      //   iteration: context.iteration,
      //   stepNumber: context.stepNumber,
      // };

      // 发送 step-finish 事件
      const stepCost = Date.now() - stepStartTime;
      // yield {
      //   type: "step-finish",
      //   data: {
      //     stepNumber: context.stepNumber,
      //     reason: "tool_completed",
      //     cost: stepCost,
      //     tokens: { input: 0, output: 0, reasoning: 0, cache: { read: 0, write: 0 } },
      //   },
      //   timestamp: Date.now(),
      //   iteration: context.iteration,
      //   stepNumber: context.stepNumber,
      // };

      const toolMessages = Array.from(results.entries()).map(([call, result]) => ({
        role: "tool",
        tool_call_id: call.id,
        name: call.function.name,
        content: typeof result.result === "string" ? result.result : JSON.stringify(result.result),
      }));

      messages.push(assistantMessage, ...toolMessages);

      return null;
    }

    // 处理标签式工具调用
    if (detectedToolActions.length > 0) {
      // 增加步骤计数器并发送 step-start 事件
      context.stepNumber++;
      // yield {
      //   type: "step-start",
      //   data: { stepNumber: context.stepNumber, toolCount: detectedToolActions.length },
      //   timestamp: stepStartTime,
      //   iteration: context.iteration,
      //   stepNumber: context.stepNumber,
      // };

      // yield {
      //   type: "tool_start",
      //   data: { toolActions: detectedToolActions },
      //   timestamp: Date.now(),
      //   iteration: context.iteration,
      //   stepNumber: context.stepNumber,
      // };

      const toolResults: any[] = [];

      for (const toolAction of detectedToolActions) {
        // Doom Loop 检测
        if (context.doomLoopDetector.check(toolAction.name, toolAction.parameters)) {
          logger.warn(`[ReActEngine] 🚫 Preventing doom loop: ${toolAction.name}`);
          toolResults.push({
            success: false,
            error: "Doom loop detected: repeated tool call with same arguments",
            result: null,
          });
          continue;
        }

        const result = await this.toolDispatcher.dispatch(toolAction);
        toolResults.push(result);
      }

      // 过滤掉需要隐藏的结果，只推送用户可见的结果
      const visibleResults = toolResults.filter((r) => !r.hiddenFromUser);

      // yield {
      //   type: "tool_end",
      //   data: { results: visibleResults },
      //   timestamp: Date.now(),
      //   iteration: context.iteration,
      //   stepNumber: context.stepNumber,
      // };

      // 发送 step-finish 事件
      const stepCost = Date.now() - stepStartTime;
      // yield {
      //   type: "step-finish",
      //   data: {
      //     stepNumber: context.stepNumber,
      //     reason: "tool_completed",
      //     cost: stepCost,
      //     tokens: { input: 0, output: 0, reasoning: 0, cache: { read: 0, write: 0 } },
      //   },
      //   timestamp: Date.now(),
      //   iteration: context.iteration,
      //   stepNumber: context.stepNumber,
      // };

      // 对于标签式工具调用，使用 user 消息格式传递工具结果
      // 因为没有原生 tool_calls，不能使用 role: 'tool' 格式
      // 只包含用户可见的结果
      const visiblePairs = detectedToolActions
        .map((action, index) => ({ action, result: toolResults[index] }))
        .filter((pair) => !pair.result.hiddenFromUser);

      const toolResultsText = visiblePairs
        .map(({ action, result }) => {
          const status = result.success ? "success" : "error";
          const resultContent = result.success
            ? typeof result.result === "string"
              ? result.result
              : JSON.stringify(result.result)
            : result.error;
          // 增强的 XML 转义：处理所有特殊字符
          const safeResultContent = this.escapeXmlContent(resultContent);

          return `[SYSTEM_FEEDBACK]
                <tool_output name="${action.name}" status="${status}">
                  ${safeResultContent}
                </tool_output>`;
        })
        .join("\n\n");

      // 将 assistant 输出的内容（包含 tool_action 标签）和工具结果添加到消息历史
      messages.push(assistantMessage);
      messages.push({
        role: "user",
        content: toolResultsText,
      });

      return null;
    }

    // 无工具调用时，将 assistantMessage 添加到消息历史（保存思考过程）
    if (assistantMessage.content) {
      messages.push(assistantMessage);
    }

    return assistantMessage.content;
  }
}
````

## File: src/core/LLMManager.ts
````typescript
/**
 * LLMManager - LLM 管理器（新架构）
 *
 * 使用两级配置结构（提供商 + 模型）
 * 支持多模型类型（NLP, Embedding, Rerank 等）
 * 配置从 SQLite 数据库加载，支持运行时热更新
 */

import { Message, ChatOptions, LLMResponse } from "../types";
import { logger } from "../utils/logger";
import { LLMConfigService } from "../services/LLMConfigService";
import { ModelRegistry } from "../services/ModelRegistry";
import { LLMModelType, LLMModelFull } from "../types/llm-models";
import { buildApiUrl } from "../config/endpoint-mappings";
import { LLMAdapterFactory, ILLMAdapter } from "./llm/adapters";
import { LIMITS, TIMEOUT, DOOM_LOOP } from "../constants";

/**
 * 适配器缓存条目
 */
interface AdapterCacheEntry {
  adapter: ILLMAdapter;
  configHash: string;
  lastUsed: number;
}

/**
 * LLM 管理器（新架构）
 */
export class LLMManager {
  // 提供商级别适配器缓存（启动时加载）
  private adapters: Map<string, ILLMAdapter> = new Map();
  // 模型级别适配器缓存（动态创建，按需缓存）
  private modelAdapterCache: Map<string, AdapterCacheEntry> = new Map();
  private modelRegistry: ModelRegistry;
  private configService: LLMConfigService;

  // 缓存配置
  private readonly MAX_CACHE_SIZE = LIMITS.ADAPTER_CACHE_SIZE;
  private readonly CACHE_TTL_MS = TIMEOUT.ADAPTER_CACHE_TTL;

  constructor() {
    this.configService = LLMConfigService.getInstance();
    this.modelRegistry = ModelRegistry.getInstance();

    logger.debug("🤖 Initializing LLM Manager (new architecture)...");
    this.loadProviders();
  }

  /**
   * 从数据库加载所有启用的提供商
   */
  private loadProviders(): void {
    try {
      const providers = this.configService.listProviders().filter((p) => p.enabled);

      if (providers.length === 0) {
        logger.warn("⚠️  No enabled LLM providers found");
        return;
      }

      // 为每个提供商创建适配器
      for (const provider of providers) {
        try {
          // 使用提供商的 baseConfig 创建适配器
          const adapter = LLMAdapterFactory.create(provider.provider, {
            apiKey: provider.baseConfig.apiKey,
            baseURL: provider.baseConfig.baseURL,
            defaultModel: "", // 模型由调用时指定
            timeout: provider.baseConfig.timeout,
            maxRetries: provider.baseConfig.maxRetries,
          });

          this.adapters.set(provider.provider, adapter);
          logger.debug(`Loaded provider: ${provider.provider} (${provider.name})`);
        } catch (error: any) {
          logger.error(`❌ Failed to create adapter for ${provider.provider}:`, error.message);
        }
      }

      logger.debug(`Loaded ${this.adapters.size} LLM providers`);
    } catch (error: any) {
      logger.error("❌ Failed to load providers:", error);
    }
  }

  /**
   * 聊天补全（自动选择 NLP 模型）- 使用适配器缓存优化性能
   */
  async chat(messages: Message[], options?: ChatOptions): Promise<LLMResponse> {
    try {
      // 1. 确定使用哪个模型
      let model: LLMModelFull | null = null;

      if (options?.provider && options?.model) {
        // 指定了提供商和模型
        model = this.modelRegistry.findModel(options.provider, options.model);
      } else if (options?.provider) {
        // 只指定了提供商，使用该提供商的默认 NLP 模型
        const provider = this.configService.getProviderByKey(options.provider);
        if (provider) {
          const models = this.configService.listModels({
            providerId: provider.id,
            modelType: LLMModelType.NLP,
            isDefault: true,
            enabled: true,
          });
          model = models[0] || null;
        }
      } else {
        // 使用默认 NLP 模型
        model = this.modelRegistry.getDefaultModel(LLMModelType.NLP);
      }

      if (!model) {
        throw new Error("No NLP model available");
      }

      // 2. 获取或创建适配器（使用缓存）
      const adapter = await this.getOrCreateModelAdapter(model);

      // 3. 调用聊天
      logger.debug(`💬 Using model: ${model.modelName} (${model.provider}/${model.modelKey})`);

      return await adapter.chat(messages, {
        ...options,
        model: model.modelKey,
      });
    } catch (error: any) {
      logger.error("❌ Chat failed:", error);
      throw error;
    }
  }

  /**
   * 获取或创建模型级别的适配器（带缓存）
   */
  private async getOrCreateModelAdapter(model: LLMModelFull): Promise<ILLMAdapter> {
    const cacheKey = `${model.provider}:${model.modelKey}`;
    const configHash = this.computeConfigHash(model);

    let entry = this.modelAdapterCache.get(cacheKey);

    // 检查缓存是否有效
    if (
      entry &&
      entry.configHash === configHash &&
      Date.now() - entry.lastUsed < this.CACHE_TTL_MS
    ) {
      entry.lastUsed = Date.now();
      logger.debug(`[LLMManager] Cache hit for adapter: ${cacheKey}`);
      return entry.adapter;
    }

    // 创建新适配器
    const apiUrl = model.apiEndpointSuffix
      ? buildApiUrl(model.providerBaseConfig.baseURL, model.apiEndpointSuffix)
      : model.providerBaseConfig.baseURL;

    const adapter = LLMAdapterFactory.create(model.provider, {
      apiKey: model.providerBaseConfig.apiKey,
      baseURL: apiUrl,
      defaultModel: model.modelKey,
      timeout: model.providerBaseConfig.timeout || TIMEOUT.LLM_REQUEST,
      maxRetries: model.providerBaseConfig.maxRetries || DOOM_LOOP.THRESHOLD,
    });

    // 更新缓存
    if (this.modelAdapterCache.size >= this.MAX_CACHE_SIZE) {
      this.evictOldestEntry();
    }
    this.modelAdapterCache.set(cacheKey, {
      adapter,
      configHash,
      lastUsed: Date.now(),
    });

    logger.debug(`[LLMManager] Created new adapter for: ${cacheKey}`);
    return adapter;
  }

  /**
   * 计算模型配置哈希值（用于检测配置变化）
   */
  private computeConfigHash(model: LLMModelFull): string {
    const configStr = JSON.stringify({
      apiKey: model.providerBaseConfig.apiKey,
      baseURL: model.providerBaseConfig.baseURL,
      apiEndpointSuffix: model.apiEndpointSuffix,
      modelKey: model.modelKey,
      timeout: model.providerBaseConfig.timeout,
      maxRetries: model.providerBaseConfig.maxRetries,
    });
    return this.simpleHash(configStr);
  }

  /**
   * 简单的字符串哈希函数
   */
  private simpleHash(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return hash.toString(16);
  }

  /**
   * 驱逐最旧的缓存条目
   */
  private evictOldestEntry(): void {
    let oldestKey: string | null = null;
    let oldestTime = Infinity;

    for (const [key, entry] of this.modelAdapterCache.entries()) {
      if (entry.lastUsed < oldestTime) {
        oldestTime = entry.lastUsed;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.modelAdapterCache.delete(oldestKey);
      logger.debug(`[LLMManager] Evicted oldest cache entry: ${oldestKey}`);
    }
  }

  /**
   * 流式聊天补全
   */
  async *streamChat(
    messages: Message[],
    options?: ChatOptions,
    abortSignal?: AbortSignal
  ): AsyncIterableIterator<string> {
    logger.debug(`[LLMManager.streamChat] Input options: ${JSON.stringify(options)}`);

    const model = await this.getActiveModel(options);

    if (!model) {
      throw new Error("No NLP model available");
    }

    const adapter = await this.getOrCreateAdapter(model);

    logger.debug(
      `💬 Streaming with model: ${model.modelName} (${model.provider}/${model.modelKey})`
    );

    // 调用适配器的 streamChat 方法
    // ✅ 修复：正确传递参数（没有tools）
    yield* adapter.streamChat(
      messages,
      {
        ...options,
        model: model.modelKey,
      },
      undefined,
      abortSignal
    );
  }

  /**
   * 获取活跃的模型（辅助方法）
   */
  private async getActiveModel(options?: ChatOptions): Promise<LLMModelFull | null> {
    logger.debug(
      `[LLMManager.getActiveModel] Input options: provider=${options?.provider}, model=${options?.model}`
    );

    if (options?.provider && options?.model) {
      logger.debug(
        `[LLMManager.getActiveModel] Searching for model: ${options.provider}/${options.model}`
      );
      const foundModel = this.modelRegistry.findModel(options.provider, options.model);
      logger.debug(`[LLMManager.getActiveModel] Found model: ${foundModel?.modelName || "null"}`);
      return foundModel;
    } else if (options?.provider) {
      const provider = this.configService.getProviderByKey(options.provider);
      if (provider) {
        const models = this.configService.listModels({
          providerId: provider.id,
          modelType: LLMModelType.NLP,
          isDefault: true,
          enabled: true,
        });
        return models[0] || null;
      }
    }

    logger.debug("[LLMManager.getActiveModel] Using system default model");
    return this.modelRegistry.getDefaultModel(LLMModelType.NLP);
  }

  /**
   * 获取或创建适配器（辅助方法）
   */
  private async getOrCreateAdapter(model: LLMModelFull): Promise<ILLMAdapter> {
    const adapter = this.adapters.get(model.provider);
    if (adapter) {
      return adapter;
    }

    // 动态创建适配器
    const apiUrl = model.apiEndpointSuffix
      ? buildApiUrl(model.providerBaseConfig.baseURL, model.apiEndpointSuffix)
      : model.providerBaseConfig.baseURL;

    const freshAdapter = LLMAdapterFactory.create(model.provider, {
      apiKey: model.providerBaseConfig.apiKey,
      baseURL: apiUrl,
      defaultModel: model.modelKey,
      timeout: model.providerBaseConfig.timeout || TIMEOUT.LLM_REQUEST,
      maxRetries: model.providerBaseConfig.maxRetries || DOOM_LOOP.THRESHOLD,
    });

    this.adapters.set(model.provider, freshAdapter);
    return freshAdapter;
  }

  /**
   * 文本向量化（使用 Embedding 模型）
   * 采用两级优先级选择模型：
   * 1. 优先级1：SQLite 中配置的默认 embedding 模型（is_default = 1）
   * 2. 优先级2：.env 配置中的 EMBEDDING_PROVIDER 和 EMBEDDING_MODEL
   */
  async embed(texts: string[]): Promise<number[][]> {
    try {
      // 1. 优先级1：SQLite 全局默认 embedding 模型
      let model = this.modelRegistry.getDefaultModel(LLMModelType.EMBEDDING);

      // 2. 优先级2：回退到 .env 配置
      if (!model) {
        const envProvider = process.env.EMBEDDING_PROVIDER;
        const envModel = process.env.EMBEDDING_MODEL;

        if (envProvider && envModel) {
          model = this.modelRegistry.findModel(envProvider, envModel);
          if (model) {
            logger.info(`[LLMManager] Using .env embedding config: ${envProvider}/${envModel}`);
          }
        } else if (envModel && !envProvider) {
          // 尝试从模型名称推断 provider
          const match = envModel.match(/^([a-zA-Z0-9]+)-/);
          if (match) {
            const inferredProvider = match[1];
            logger.info(
              `[LLMManager] Using .env model with inferred provider: ${inferredProvider}/${envModel}`
            );
            model = this.modelRegistry.findModel(inferredProvider, envModel);
          }
        }
      }

      // 3. 验证模型可用性
      if (!model) {
        throw new Error(
          "No embedding model available. " +
            "Please configure an embedding model in SQLite (set is_default=1) or set EMBEDDING_PROVIDER and EMBEDDING_MODEL in .env"
        );
      }

      // 4. 获取对应的适配器
      const adapter = this.adapters.get(model.provider);
      if (!adapter) {
        throw new Error(`No adapter found for provider: ${model.provider}`);
      }

      // 5. 检查适配器是否支持 embed 方法
      if (!adapter.embed) {
        throw new Error(`Adapter for ${model.provider} does not support embedding`);
      }

      // 6. 调用 Embedding API
      logger.debug(
        `🔢 Using embedding model: ${model.modelName} (${model.provider}/${model.modelKey})`
      );

      const embeddings = await adapter.embed(texts, model.modelKey);

      logger.debug(
        `✅ Generated ${embeddings.length} embeddings with ${embeddings[0]?.length || 0} dimensions`
      );

      return embeddings;
    } catch (error: any) {
      logger.error("❌ Embed failed:", error);
      throw error;
    }
  }

  /**
   * 刷新配置（重新加载提供商）
   */
  public refresh(): void {
    logger.info("🔄 Refreshing LLM Manager...");
    this.adapters.clear();
    this.modelAdapterCache.clear();
    this.loadProviders();
    this.modelRegistry.forceRefresh();
  }

  /**
   * 获取可用的提供商列表
   */
  public getAvailableProviders(): string[] {
    return Array.from(this.adapters.keys());
  }

  /**
   * 检查提供商是否可用
   */
  public hasProvider(provider: string): boolean {
    return this.adapters.has(provider);
  }

  /**
   * 更新提供商配置（数据库 + 内存）
   */
  async updateProvider(id: number, input: any): Promise<void> {
    // 更新数据库
    this.configService.updateProvider(id, input);

    // 刷新内存
    this.refresh();
  }

  /**
   * 获取所有模型（用于 API）
   */
  public getAllModels(): Array<{ id: string; provider: string; model: string; type: string }> {
    const models = this.modelRegistry.getAllModels();
    return models.map((m) => ({
      id: `${m.provider}/${m.modelKey}`,
      provider: m.provider,
      model: m.modelKey,
      type: m.modelType,
    }));
  }
}
````

## File: src/core/ProtocolEngine.ts
````typescript
/**
 * Protocol Engine - 协议引擎核心
 * 统一封装协议解析、变量解析和插件管理功能
 */

import { createVariableEngine, IVariableEngine } from "./variable";
import type { AdminConfig } from "../services/ConfigService";
import { logger } from "../utils/logger";
import { ABPProtocolParser } from "./protocol/ABPProtocolParser";
import { ABPProtocolConfig } from "../types/abp";
import { RAGService } from "abp-rag-sdk";
import { TIMEOUT } from "../constants";

/**
 * 扩展配置接口
 * 用于支持 RAG 和 ABP 配置，避免过度使用 as any
 */
export interface ExtendedAdminConfig extends AdminConfig {
  abp?: Partial<ABPProtocolConfig>;
  rag?: {
    enabled: boolean;
    workDir?: string;
    vectorizer?: {
      baseURL?: string;
      apiKey?: string;
      model?: string;
      dimensions?: number;
      dim?: number; // 兼容别名
      batch?: number;
      timeout?: number;
    };
  };
  debugMode?: boolean;
}

export class ProtocolEngine {
  public abpParser!: ABPProtocolParser; // 使用 ! 断言，因为在 constructor 调用的 initializeCore 中必然赋值
  public variableEngine!: IVariableEngine; // 使用接口类型，提供完整的类型安全和代码提示
  public ragService?: RAGService; // 修正类型

  constructor(private config: ExtendedAdminConfig) {
    logger.info("🧠 Initializing Protocol Engine (ABP only)...");
    this.initializeCore();
  }

  /**
   * 初始化核心组件
   */
  initializeCore(): void {
    // 使用默认值合并配置
    const abpConfig: ABPProtocolConfig = {
      dualProtocolEnabled: false,
      errorRecoveryEnabled: true,
      jsonRepair: { enabled: true, strict: false },
      noiseStripping: { enabled: true, aggressive: false },
      boundaryValidation: { enabled: true, strict: false },
      fallback: { enabled: true, toPlainText: true },
      variable: { cacheEnabled: true, cacheTTL: TIMEOUT.CLEANUP_INTERVAL },
      ...this.config.abp,
    };

    this.abpParser = new ABPProtocolParser(abpConfig);
    logger.debug("ABPProtocolParser initialized");

    this.variableEngine = createVariableEngine();
    logger.debug("VariableEngine initialized");
  }

  /**
   * 获取ABP协议解析器
   *
   * @returns ABP协议解析器
   */
  getABPParser(): ABPProtocolParser {
    return this.abpParser;
  }

  /**
   * 获取RAG服务实例
   * 用于访问 abp-rag-sdk 的 RAG 能力
   *
   * @returns RAG服务实例，如果未初始化则返回 undefined
   */
  getRAGService(): RAGService | undefined {
    return this.ragService;
  }

  /**
   * 规范化 RAG Vectorizer 配置
   * 提取 URL 规范化逻辑，避免在 initialize 中过度耦合
   *
   * @param vectorizer - RAG vectorizer 配置
   * @returns 规范化后的配置对象
   */
  private normalizeVectorizerConfig(vectorizer?: ExtendedAdminConfig["rag"]["vectorizer"]): any {
    if (!vectorizer) {
      return undefined;
    }

    const baseURL = vectorizer.baseURL?.trim();
    let apiUrl: string | undefined;

    if (baseURL && baseURL.length > 0) {
      const normalizedBase = baseURL.replace(/\/+$/, "");
      const hasEmbeddingsSuffix = normalizedBase.toLowerCase().endsWith("/embeddings");
      apiUrl = hasEmbeddingsSuffix ? normalizedBase : `${normalizedBase}/embeddings`;
    }

    if (!apiUrl) {
      logger.warn("⚠️ RAG vectorizer baseURL missing, embeddings API will not be reachable");
    }

    const resolvedConfig: Record<string, unknown> = {
      apiKey: vectorizer.apiKey,
      model: vectorizer.model,
      dimensions: vectorizer.dimensions || vectorizer.dim,
      batchSize: vectorizer.batch,
      timeout: vectorizer.timeout,
    };

    if (apiUrl) {
      resolvedConfig.apiUrl = apiUrl;
    }

    return resolvedConfig;
  }

  async initialize(): Promise<void> {
    try {
      // --- RAG Service Initialization ---
      if (this.config.rag?.enabled) {
        try {
          const memBefore = process.memoryUsage();
          logger.info(
            `[Memory] Before RAG Service init - RSS: ${Math.round(memBefore.rss / 1024 / 1024)}MB`
          );

          this.ragService = new RAGService();
          const ragConfig = this.config.rag;
          const vectorizerConfig = this.normalizeVectorizerConfig(ragConfig.vectorizer);

          await this.ragService.initialize({
            workDir: ragConfig.workDir || "./vector_store",
            vectorizer: vectorizerConfig,
            debug: this.config.debugMode,
          });

          const memAfter = process.memoryUsage();
          logger.info(
            `[Memory] After RAG Service init - RSS: ${Math.round(memAfter.rss / 1024 / 1024)}MB, Delta: +${Math.round((memAfter.rss - memBefore.rss) / 1024 / 1024)}MB`
          );
          logger.debug("RAG Service initialized");
        } catch (error: any) {
          logger.warn(`⚠️ RAG service initialization failed: ${error?.message || error}`);
          // 即使 RAG 失败，也不应该阻断后续 Providers 的注册
          this.ragService = undefined;
        }
      }

      // --- Variable Providers Registration ---
      // 简化版：移除提供者模式，变量由调用方直接传入
      logger.debug("✅ VariableEngine initialized (simplified version, no providers)");
    } catch (error) {
      logger.error("❌ Failed to initialize Protocol Engine:", error);
      throw error;
    }
  }

  getPluginCount(): number {
    return 0;
  }

  getPlugins() {
    return [];
  }

  /**
   * 优雅关闭
   * 清理所有资源，包括 RAG Service 的生命周期管理
   */
  async shutdown(): Promise<void> {
    logger.info("🛑 Shutting down Protocol Engine...");

    try {
      // 1. 清理 Variable Engine
      if (this.variableEngine) {
        if (typeof this.variableEngine.reset === "function") {
          this.variableEngine.reset();
        }
        logger.info("✅ Variable engine reset");
      }

      // 2. 🆕 关键修复：清理 RAG Service（防止资源泄漏）
      if (this.ragService) {
        // 使用类型安全的接口调用 RAGService 的清理方法
        // RAGService 可能实现 shutdown/close/destroy 之一
        interface RAGServiceCleanup {
          shutdown?: () => Promise<void>;
          close?: () => Promise<void>;
          destroy?: () => Promise<void>;
        }
        const ragCleanup = this.ragService as RAGServiceCleanup | undefined;

        if (ragCleanup?.shutdown) {
          await ragCleanup.shutdown();
          logger.info("✅ RAG Service shut down");
        } else if (ragCleanup?.close) {
          await ragCleanup.close();
          logger.info("✅ RAG Service closed");
        } else if (ragCleanup?.destroy) {
          await ragCleanup.destroy();
          logger.info("✅ RAG Service destroyed");
        } else {
          logger.debug("⚠️ RAG Service has no explicit cleanup method, skipping");
        }
        this.ragService = undefined;
      }

      logger.info("✅ Protocol Engine shut down successfully");
    } catch (error) {
      logger.error("❌ Error during Protocol Engine shutdown:", error);
      // Shutdown 错误通常记录即可，不建议抛出，除非需要上层通过 exit code 反应
    }
  }
}
````

## File: .gitignore
````
# ApexBridge Project Git Ignore

## Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

## Build outputs
dist/
build/
out/
trash
*.tsbuildinfo

## TypeScript compiled files (prevent accidental compilation to src/)
*.js
*.js.map
*.d.ts
*.d.ts.map

## Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

## IDE and editor files
.vscode/
.claude/
.github/
.idea/
*.swp
*.swo
*~

## OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

## Logs
logs/
*.log

## Runtime data
pids/
*.pid
*.seed
*.pid.lock

## Coverage directory used by tools like istanbul
coverage/
*.lcov

## nyc test coverage
.nyc_output/

## Dependency directories
jspm_packages/

## Optional npm cache directory
.npm

## Optional eslint cache
.eslintcache

## Optional REPL history
.node_repl_history

## Output of 'npm pack'
*.tgz

## Yarn Integrity file
.yarn-integrity

## parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

## next.js build output
.next

## nuxt.js build output
.nuxt

## vuepress build output
.vuepress/dist

## Serverless directories
.serverless

## FuseBox cache
.fusebox/

## DynamoDB Local files
.dynamodb/

## TernJS port file
.tern-port

## Stores VSCode versions used for testing VSCode extensions
.vscode-test

## Vector store directories (RAG service)
vector_store/
*.hnsw
*.indices

## Plugin generated files
plugins/*/node_modules/
plugins/*/dist/
plugins/*/cache/

## Test databases
*.db
*.sqlite
*.sqlite3

## Temporary files
tmp/
temp/
*.tmp

## Backup files
*.bak
*.backup

## Local configuration overrides
config/local.*
config/development.*
config/production.*
config/admin-config.json

## Monitoring and analytics data
*.log.*
monitoring/
analytics/

## Security and audit files
*.audit
*.security

## Local development overrides
.env.local
settings.local.json

## AI/ML model files (large, should not be in repo)
*.model
*.pkl
*.h5
*.pb

## Custom tool outputs
tools/output/
scripts/output/

## Performance profiling data
*.prof
*.cpuprofile
*.heapprofile

## Memory dumps
*.dmp
*.mdmp

## Docker volumes (for local development)
docker-volumes/

## Kubernetes secrets (never commit actual secrets)
*.secret
*.key
*.pem
*.crt
*.p12

## Local testing configurations
jest.local.json
webpack.local.js

## Documentation build outputs
docs/build/
docs/.cache/

## Experimental features flags
features.local.json

## User-specific data
users/
profiles/
user-data/
# Database files
.data
# Runtime logs
logs/*.log
opencode/
````

## File: src/strategies/ReActStrategy.ts
````typescript
/**
 * ReActStrategy - ReAct聊天处理策略
 * 实现自我思考循环，支持工具调用和流式输出
 * 集成新工具系统：内置工具 + Skills外置工具 + tool_action标签解析
 */

import type { Message, ChatOptions } from "../types";
import type { ChatStrategy, ChatResult, StrategyPrepareResult } from "./ChatStrategy";
import type { LLMManager } from "../core/LLMManager";
import type { ConversationHistoryService } from "../services/ConversationHistoryService";
import { ReActEngine } from "../core/stream-orchestrator/ReActEngine";
import { LLMManagerAdapter } from "../core/stream-orchestrator/LLMAdapter";
import { BuiltInToolsRegistry } from "../services/BuiltInToolsRegistry";
import { ToolRetrievalService } from "../services/ToolRetrievalService";
import { BuiltInExecutor } from "../services/executors/BuiltInExecutor";
import { SkillsSandboxExecutor } from "../services/executors/SkillsSandboxExecutor";
import { generateToolPrompt, ToolDispatcher } from "../core/tool-action";
import { getSkillManager } from "../services/SkillManager";
import type { Tool } from "../core/stream-orchestrator/types";
import type { SkillTool, BuiltInTool } from "../types/tool-system";
import { logger } from "../utils/logger";
import { extractTextFromMessage } from "../utils/message-utils";
import { TIMEOUT, LIMITS, THRESHOLDS } from "../constants";
import { SKILL_TIMEOUT_MS } from "../constants/retention";

export class ReActStrategy implements ChatStrategy {
  private builtInRegistry: BuiltInToolsRegistry;
  private toolRetrievalService: ToolRetrievalService;
  private builtInExecutor: BuiltInExecutor;
  private skillsExecutor: SkillsSandboxExecutor;
  private toolDispatcher: ToolDispatcher;
  private availableTools: any[] = [];

  // 自动注销机制：追踪动态注册Skills的最后访问时间
  private dynamicSkillsLastAccess: Map<string, number> = new Map();
  private cleanupTimer: NodeJS.Timeout | null = null;
  private readonly SKILL_TIMEOUT_MS = SKILL_TIMEOUT_MS;

  constructor(
    private llmManager: LLMManager,
    private historyService: ConversationHistoryService
  ) {
    // 初始化工具系统组件
    this.builtInRegistry = new BuiltInToolsRegistry();

    // 使用 SkillManager 中已经初始化好的 ToolRetrievalService 实例
    // 避免创建重复的数据库和实例
    const skillManager = getSkillManager();
    this.toolRetrievalService = skillManager.getRetrievalService();

    this.builtInExecutor = new BuiltInExecutor();
    this.skillsExecutor = new SkillsSandboxExecutor();
    this.toolDispatcher = new ToolDispatcher();

    // 启动自动清理定时器
    this.startCleanupTimer();

    logger.debug("ReActStrategy initialized");
  }

  getName(): string {
    return "ReActStrategy";
  }

  /**
   * 检查是否支持该选项（需要selfThinking.enabled）
   */
  supports(options: ChatOptions): boolean {
    return !!options.selfThinking?.enabled;
  }

  /**
   * 准备阶段：初始化工具系统并返回需要注入的变量
   * ChatService 会在变量替换阶段使用这些变量
   */
  async prepare(messages: Message[], options: ChatOptions): Promise<StrategyPrepareResult> {
    logger.debug(`[${this.getName()}] Preparing strategy - initializing tool system`);

    // 1. 初始化工具系统（工具发现与注册）
    await this.initializeToolSystem(messages);

    // 2. 生成工具提示词内容
    const toolPromptContent = this.generateToolPromptContent();

    // 3. 返回需要注入的变量
    return {
      variables: {
        available_tools: toolPromptContent,
      },
    };
  }

  /**
   * 执行ReAct聊天处理
   * 注意：messages 已由 ChatService 完成变量替换
   */
  async execute(messages: Message[], options: ChatOptions): Promise<ChatResult> {
    const startTime = Date.now();
    const includeThoughtsInResponse = options.selfThinking?.includeThoughtsInResponse ?? true;

    logger.info(`[${this.getName()}] Starting ReAct execution with new tool system`);

    // 初始化 ReAct 引擎（启用 tool_action 标签解析）
    const reactEngine = new ReActEngine({
      maxIterations: options.selfThinking?.maxIterations ?? LIMITS.MAX_ITERATIONS,
      enableThinking: options.selfThinking?.enableStreamThoughts ?? true,
      maxConcurrentTools: LIMITS.MAX_CONCURRENT_TOOLS,
      enableToolActionParsing: options.selfThinking?.enableToolActionParsing ?? true,
      toolActionTimeout: options.selfThinking?.toolActionTimeout ?? TIMEOUT.TOOL_EXECUTION,
      provider: options.provider,
      model: options.model,
      temperature: options.temperature,
      maxTokens: options.max_tokens,
    });

    // 将可用工具传递给ReActEngine
    if (this.availableTools.length > 0) {
      (reactEngine as any).tools = this.availableTools;
      logger.debug(`[${this.getName()}] Passed ${this.availableTools.length} tools to ReActEngine`);
    }

    // 执行 ReAct 循环
    const thinkingProcess: string[] = [];
    let finalContent = "";
    let iterations = 0;

    try {
      const llmClient = new LLMManagerAdapter(this.llmManager);
      const stream = reactEngine.execute(messages, llmClient, {});

      for await (const event of stream) {
        iterations = event.iteration;

        if (event.type === "reasoning-delta") {
          thinkingProcess.push(event.data);
        } else if (event.type === "content") {
          finalContent += event.data;
        }
        // 注意：工具执行由ReActEngine内部处理，这里只关注思考过程和最终内容
      }

      logger.debug(`[${this.getName()}] ReAct completed in ${iterations} iterations`);

      // 返回结果（包含原始思考过程，供ChatService统一保存）
      return {
        content: finalContent,
        iterations,
        thinkingProcess: includeThoughtsInResponse ? thinkingProcess.join("\n") : undefined,
        rawThinkingProcess: thinkingProcess, // 原始思考过程
        usage: undefined, // TODO: 从LLMClient获取usage
      };
    } catch (error) {
      logger.error(`[${this.getName()}] ReAct execution failed: ${error}`);
      throw error;
    }
  }

  /**
   * 创建流式迭代器（ReAct流式版本）
   * 注意：messages 已由 ChatService 完成变量替换
   */
  async *stream(
    messages: Message[],
    options: ChatOptions,
    abortSignal?: AbortSignal
  ): AsyncIterableIterator<any> {
    logger.debug(`[${this.getName()}] Streaming ReAct execution`);

    // 初始化工具系统
    await this.initializeToolSystem(messages);

    // 初始化 ReAct 引擎（启用 tool_action 标签解析）
    const reactEngine = new ReActEngine({
      maxIterations: options.selfThinking?.maxIterations ?? LIMITS.MAX_ITERATIONS,
      enableThinking: options.selfThinking?.enableStreamThoughts ?? true,
      maxConcurrentTools: LIMITS.MAX_CONCURRENT_TOOLS,
      enableToolActionParsing: options.selfThinking?.enableToolActionParsing ?? true,
      toolActionTimeout: options.selfThinking?.toolActionTimeout ?? TIMEOUT.TOOL_EXECUTION,
      provider: options.provider,
      model: options.model,
      temperature: options.temperature,
      maxTokens: options.max_tokens,
    });

    // 将工具传递给 ReActEngine
    reactEngine.tools = this.availableTools;
    logger.debug(`[${this.getName()}] Passed ${this.availableTools.length} tools to ReActEngine`);

    const llmClient = new LLMManagerAdapter(this.llmManager);
    const stream = reactEngine.execute(messages, llmClient, { signal: abortSignal });

    // 收集用于历史记录的数据
    const collectedThinking: string[] = [];
    let collectedContent = "";

    for await (const event of stream) {
      // 检查中断
      if (abortSignal?.aborted) {
        logger.debug(`[${this.getName()}] ReAct stream aborted`);
        return;
      }

      // 流式输出事件
      // 输出 JSON 格式字符串，与 SingleRoundStrategy 保持一致，便于前端 parseLLMChunk 解析
      switch (event.type) {
        case "reasoning-start":
          // 推理开始事件
          yield JSON.stringify({
            event_type: "reasoning-start",
            data: event.data,
            iteration: event.iteration,
          });
          break;

        case "reasoning-delta": {
          // 推理内容增量（替换原来的 reasoning 事件）
          const reasoningChunk = JSON.stringify({
            reasoning_content: event.data,
            content: null,
            step_number: event.stepNumber,
            iteration: event.iteration,
          });
          yield reasoningChunk;
          collectedThinking.push(event.data);
          break;
        }

        case "reasoning-end":
          // 推理结束事件
          yield JSON.stringify({
            event_type: "reasoning-end",
            data: event.data,
            iteration: event.iteration,
          });
          break;

        case "step-start":
          // 步骤开始事件
          yield JSON.stringify({
            event_type: "step-start",
            data: event.data,
            iteration: event.iteration,
            step_number: event.stepNumber,
          });
          break;

        case "step-finish":
          // 步骤完成事件
          yield JSON.stringify({
            event_type: "step-finish",
            data: event.data,
            iteration: event.iteration,
            step_number: event.stepNumber,
          });
          break;

        case "content": {
          const contentChunk = JSON.stringify({
            reasoning_content: null,
            content: event.data,
            step_number: event.stepNumber,
            iteration: event.iteration,
          });
          yield contentChunk;
          collectedContent += event.data;
          break;
        }

        case "tool_start":
          yield JSON.stringify({
            event_type: "tool_start",
            data: event.data,
            iteration: event.iteration,
            step_number: event.stepNumber,
          });
          break;

        case "tool_end":
          yield JSON.stringify({
            event_type: "tool_end",
            data: event.data,
            iteration: event.iteration,
            step_number: event.stepNumber,
          });
          break;

        case "done":
          yield JSON.stringify({
            event_type: "done",
            data: event.data,
            iteration: event.iteration,
          });
          break;

        case "error":
          yield JSON.stringify({
            event_type: "error",
            data: event.data,
            iteration: event.iteration,
          });
          break;

        default:
          // 未知事件类型，直接输出
          yield JSON.stringify(event);
      }
    }

    // ChatService会统一保存历史，策略层只返回数据
    // 返回收集的思考过程和内容
    return {
      content: collectedContent,
      rawThinkingProcess: collectedThinking,
    };
  }

  /**
   * 生成工具提示词内容（用于变量替换）
   */
  private generateToolPromptContent(): string {
    const toolDescriptions = this.toolDispatcher.getAvailableTools();

    if (toolDescriptions.length === 0) {
      logger.debug(`[${this.getName()}] No tools available, returning empty prompt`);
      return "当前没有可用的工具。";
    }

    const toolPromptText = generateToolPrompt(toolDescriptions);
    logger.debug(`[${this.getName()}] Generated tool prompt with ${toolDescriptions.length} tools`);
    return toolPromptText;
  }

  /**
   * 初始化工具系统（工具发现与注册）
   */
  private async initializeToolSystem(messages: Message[]): Promise<void> {
    const startTime = Date.now();

    try {
      // 1. 加载所有内置工具到执行器
      const builtInTools = this.builtInRegistry.listAllTools();
      logger.debug(`[${this.getName()}] Found ${builtInTools.length} built-in tools`);

      // 2. 尝试向量检索相关Skills（可选，失败不影响内置工具）
      let relevantSkills: any[] = [];
      try {
        // 确保 ToolRetrievalService 已初始化（加载 embedding 模型配置）
        await this.toolRetrievalService.initialize();

        const query = messages[messages.length - 1]
          ? extractTextFromMessage(messages[messages.length - 1])
          : "";
        relevantSkills = await this.toolRetrievalService.findRelevantSkills(
          query,
          LIMITS.VECTOR_SEARCH_MAX_RESULTS, // limit
          THRESHOLDS.RELEVANT_SKILLS // threshold
        );
        logger.debug(`[${this.getName()}] Found ${relevantSkills.length} relevant Skills`);

        // 将检索到的Skills注册为代理工具，使其可以通过ToolDispatcher访问
        for (const skill of relevantSkills) {
          this.registerSkillAsBuiltInTool(skill.tool);
        }
      } catch (skillError) {
        // Skills 检索失败，降级处理：只使用内置工具
        logger.warn(
          `[${this.getName()}] Skills retrieval failed, using built-in tools only:`,
          skillError instanceof Error ? skillError.message : skillError
        );
        relevantSkills = [];
      }

      // 3. 构建工具列表（内置工具 + Skills）
      this.availableTools = [
        ...builtInTools.map((tool) => ({
          type: "function" as const,
          function: {
            name: tool.name,
            description: tool.description,
            parameters: tool.parameters,
          },
        })),
        ...relevantSkills.map((skill) => ({
          type: "function" as const,
          function: {
            name: skill.tool.name,
            description: skill.tool.description,
            parameters: skill.tool.parameters,
          },
        })),
      ];

      logger.debug(`[${this.getName()}] Tool system initialized in ${Date.now() - startTime}ms`);
      logger.info(
        `[${this.getName()}] Available tools: ${builtInTools.length} built-in + ${relevantSkills.length} Skills`
      );

      // 记录动态技能状态
      if (relevantSkills.length > 0) {
        logger.info(`[${this.getName()}] ${this.getDynamicSkillsStatus()}`);
      }
    } catch (error) {
      logger.error(`[${this.getName()}] Tool system initialization failed:`, error);
      // 完全失败时，确保清空工具列表
      this.availableTools = [];
    }
  }

  /**
   * 将Skill注册为内置工具代理
   * 这样Skill就可以通过ToolDispatcher访问
   */
  private registerSkillAsBuiltInTool(skill: SkillTool): void {
    // 创建代理工具，执行时调用Skills执行器
    const proxyTool: BuiltInTool = {
      name: skill.name,
      description: skill.description,
      type: "BUILTIN" as any, // 强制设置为BUILTIN类型
      category: skill.tags?.join(", ") || "skill",
      enabled: true,
      level: skill.level,
      parameters: skill.parameters,
      execute: async (args: Record<string, any>) => {
        // 更新最后访问时间
        this.dynamicSkillsLastAccess.set(skill.name, Date.now());

        const result = await this.skillsExecutor.execute({
          name: skill.name,
          args,
        });

        return {
          success: result.success,
          output: result.success ? result.output : result.error,
          duration: result.duration,
          exitCode: result.exitCode,
        };
      },
    };

    // 记录技能注册时间和最后访问时间
    const now = Date.now();
    this.dynamicSkillsLastAccess.set(skill.name, now);

    // 注册到内置工具注册表
    this.builtInRegistry.registerTool(proxyTool);
    logger.debug(
      `[${this.getName()}] Registered skill proxy: ${skill.name} at ${new Date(now).toISOString()}`
    );
  }

  /**
   * 启动自动清理定时器
   * 每分钟检查一次，超过5分钟未使用的Skills将被自动注销
   * 添加防重复启动保护
   */
  private startCleanupTimer(): void {
    if (this.cleanupTimer) {
      logger.debug(`[${this.getName()}] Cleanup timer already running, skipping`);
      return;
    }

    this.cleanupTimer = setInterval(() => {
      this.cleanupUnusedSkills();
    }, 60 * 1000); // 每分钟执行一次

    logger.debug(`[${this.getName()}] Auto-cleanup timer started (interval: 60s, timeout: 5min)`);
  }

  /**
   * 清理超过5分钟未使用的Skills
   * 减少上下文占用，优化性能
   */
  private cleanupUnusedSkills(): void {
    const now = Date.now();
    const skillsToRemove: string[] = [];

    // 找出超过5分钟未使用的技能
    for (const [skillName, lastAccessTime] of this.dynamicSkillsLastAccess.entries()) {
      if (now - lastAccessTime > this.SKILL_TIMEOUT_MS) {
        skillsToRemove.push(skillName);
      }
    }

    if (skillsToRemove.length > 0) {
      logger.debug(`[${this.getName()}] Auto-cleanup starting: ${this.getDynamicSkillsStatus()}`);

      for (const skillName of skillsToRemove) {
        // 从动态追踪中移除
        this.dynamicSkillsLastAccess.delete(skillName);

        // 从内置工具注册表中注销
        this.builtInRegistry.unregisterTool(skillName);

        // 从可用工具列表中移除
        this.availableTools = this.availableTools.filter(
          (tool) => tool.function.name !== skillName
        );

        logger.info(`[${this.getName()}] Auto-unregistered unused skill: ${skillName}`);
      }

      logger.info(
        `[${this.getName()}] Auto-cleanup completed: ${skillsToRemove.length} skills removed`
      );
      logger.info(
        `[${this.getName()}] Remaining active skills: ${this.dynamicSkillsLastAccess.size}`
      );
    }
  }

  /**
   * 停止自动清理定时器
   * 用于资源清理
   */
  private stopCleanupTimer(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = null;
      logger.info(`[${this.getName()}] Auto-cleanup timer stopped`);
    }
  }

  /**
   * 关闭策略并清理资源
   * 供外部调用，确保定时器被正确清理
   */
  public shutdown(): void {
    this.stopCleanupTimer();
    logger.info(`[${this.getName()}] Strategy shutdown completed`);
  }

  /**
   * 获取当前动态注册技能的状态
   * 用于调试和监控
   */
  private getDynamicSkillsStatus(): string {
    const now = Date.now();
    const statuses: string[] = [];

    for (const [skillName, lastAccessTime] of this.dynamicSkillsLastAccess.entries()) {
      const age = Math.floor((now - lastAccessTime) / 1000);
      const timeStr =
        age < 60
          ? `${age}s ago`
          : age < 3600
            ? `${Math.floor(age / 60)}m ago`
            : `${Math.floor(age / 3600)}h ago`;
      statuses.push(`${skillName} (${timeStr})`);
    }

    return statuses.length > 0
      ? `Active skills: ${statuses.join(", ")}`
      : "No active dynamic skills";
  }
}
````

## File: src/services/ConfigService.ts
````typescript
/**
 * ConfigService - 简化配置管理服务
 *
 * 重构说明：
 * - 类型定义迁移到 types/config/ 目录
 * - 配置加载逻辑迁移到 ConfigLoader
 * - 配置验证逻辑迁移到 ConfigValidator
 * - 配置写入逻辑迁移到 ConfigWriter
 * - 主服务仅保留协调逻辑
 *
 * ACE 功能已删除 (2026-01-11)
 */

import { logger } from "../utils/logger";
import { ConfigLoader, ConfigValidator, ConfigWriter } from "../utils/config";
import {
  DEFAULT_CONFIG,
  createDefaultRateLimitSettings,
  DEFAULT_REDIS_CONFIG,
} from "../utils/config-constants";
import type {
  AdminConfig,
  SystemConfig,
  FullConfig,
  SystemSecurityConfig,
  EnvironmentConfig,
  DatabaseConfig,
  PathsConfig,
  ApiKeyInfo,
  RateLimitSettings,
  RedisConfig,
  RateLimitStrategyType,
  RateLimitStrategyConfig,
  RateLimitMatcherConfig,
  RateLimitRuleConfig,
  RateLimitHeadersConfig,
} from "../types/config/index";

/**
 * 配置服务
 *
 * 单例模式，协调 ConfigLoader、ConfigValidator、ConfigWriter
 */
export class ConfigService {
  private static instance: ConfigService | null = null;
  private readonly loader: ConfigLoader;
  private readonly validator: ConfigValidator;
  private readonly writer: ConfigWriter;

  private constructor() {
    this.loader = ConfigLoader.getInstance();
    this.validator = new ConfigValidator();
    this.writer = new ConfigWriter();
  }

  /**
   * 获取单例实例
   */
  public static getInstance(): ConfigService {
    if (!ConfigService.instance) {
      ConfigService.instance = new ConfigService();
    }
    return ConfigService.instance;
  }

  // ==================== 配置读取方法 ====================

  /**
   * 读取配置（同步）
   */
  public readConfig(): AdminConfig {
    return this.loader.loadSync();
  }

  /**
   * 读取配置（异步）
   */
  public async readConfigAsync(): Promise<AdminConfig> {
    return this.loader.loadAsync();
  }

  /**
   * 获取当前配置（兼容性方法）
   */
  public getCurrentConfig(): AdminConfig {
    return this.readConfig();
  }

  /**
   * 加载配置（兼容性方法）
   */
  public loadConfig(): AdminConfig {
    return this.readConfig();
  }

  // ==================== 配置写入方法 ====================

  /**
   * 写入配置（同步）
   */
  public writeConfig(config: AdminConfig): void {
    this.loader.writeSync(config);
  }

  /**
   * 写入配置（异步）
   */
  public async writeConfigAsync(config: AdminConfig): Promise<void> {
    await this.loader.writeAsync(config);
  }

  // ==================== 配置更新方法 ====================

  /**
   * 更新配置（异步）
   */
  public async updateConfigAsync(updates: Partial<AdminConfig>): Promise<AdminConfig> {
    return this.writer.updateAsync(updates);
  }

  /**
   * 更新配置（同步）
   */
  public updateConfig(updates: Partial<AdminConfig>): AdminConfig {
    return this.writer.update(updates);
  }

  // ==================== 配置重载方法 ====================

  /**
   * 重载配置（清除缓存）
   */
  public reloadConfig(): AdminConfig {
    this.loader.clearCache();
    return this.readConfig();
  }

  /**
   * 重载（兼容性方法）
   */
  public reload(): AdminConfig {
    return this.reloadConfig();
  }

  // ==================== 配置验证方法 ====================

  /**
   * 验证配置
   */
  public validateConfig(config: AdminConfig): {
    valid: boolean;
    errors: string[];
    warnings?: string[];
  } {
    return this.validator.validate(config);
  }

  /**
   * 验证系统配置（环境变量）
   */
  public validateSystemConfig(): { valid: boolean; errors: string[]; warnings: string[] } {
    const systemConfig = this.getSystemConfig();
    const errors: string[] = [];
    const warnings: string[] = [];

    if (!systemConfig.security.abpApiKey) {
      errors.push("ABP_API_KEY 未设置（环境变量）");
    }

    if (!systemConfig.security.jwtSecret) {
      errors.push("JWT_SECRET 未设置（环境变量）");
    }

    if (systemConfig.port < 1 || systemConfig.port > 65535) {
      errors.push(`PORT 必须在 1-65535 范围内，当前值：${systemConfig.port}`);
    }

    if (!systemConfig.paths.rootDir) {
      errors.push("APEX_BRIDGE_ROOT_DIR 未设置");
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }

  // ==================== 系统配置方法 ====================

  /**
   * 检查是否已完成初始化设置
   */
  public isSetupCompleted(): boolean {
    try {
      const config = this.readConfig();
      return !!(config?.auth?.apiKey && config.auth.apiKey.trim() !== "");
    } catch (error) {
      logger.error("检查初始化状态失败:", error);
      return false;
    }
  }

  /**
   * 获取系统级配置（从环境变量读取）
   */
  public getSystemConfig(): SystemConfig {
    const port = parseInt(process.env.PORT || "3000", 10);
    const autostart = process.env.APEX_BRIDGE_AUTOSTART !== "false";

    return {
      port,
      autostart,
      paths: this.getPathsConfig(),
      security: this.getSystemSecurityConfig(),
      environment: this.getEnvironmentConfig(),
      database: this.getDatabaseConfig(),
    };
  }

  /**
   * 获取应用级配置（从 JSON 读取）
   */
  public getAppConfig(): Partial<AdminConfig> {
    const config = this.readConfig();
    return {
      setup_completed: config.setup_completed,
      api: config.api,
      llm: config.llm,
      auth: config.auth,
      performance: config.performance,
      redis: config.redis,
      security: config.security,
    };
  }

  /**
   * 获取完整配置（env 优先，JSON 作为后备）
   */
  public getFullConfig(): FullConfig {
    const systemConfig = this.getSystemConfig();
    const appConfig = this.getAppConfig();

    return {
      port: systemConfig.port,
      autostart: systemConfig.autostart,
      paths: systemConfig.paths,
      systemSecurity: systemConfig.security,
      environment: systemConfig.environment,
      database: systemConfig.database,
      setup_completed: appConfig.setup_completed,
      api: appConfig.api,
      auth: {
        ...appConfig.auth,
        apiKey: systemConfig.security.abpApiKey,
        jwtSecret: systemConfig.security.jwtSecret,
      },
      performance: appConfig.performance,
      redis: appConfig.redis,
      appSecurity: appConfig.security,
    };
  }

  // ==================== 私有辅助方法 ====================

  private getPathsConfig(): PathsConfig {
    return {
      rootDir: process.env.APEX_BRIDGE_ROOT_DIR || process.cwd(),
      configDir: process.env.APEX_BRIDGE_CONFIG_DIR || `${process.cwd()}/config`,
      dataDir: process.env.APEX_BRIDGE_DATA_DIR || `${process.cwd()}/.data`,
      logDir: process.env.APEX_BRIDGE_LOG_DIR || `${process.cwd()}/logs`,
      vectorStoreDir: process.env.APEX_BRIDGE_VECTOR_STORE_DIR || `${process.cwd()}/.data/lancedb`,
    };
  }

  private getSystemSecurityConfig(): SystemSecurityConfig {
    return {
      abpApiKey: process.env.ABP_API_KEY || "",
      jwtSecret: process.env.JWT_SECRET || "",
      constitutionPath: process.env.CONSTITUTION_PATH || "./config/constitution.md",
    };
  }

  private getEnvironmentConfig(): EnvironmentConfig {
    return {
      nodeEnv: process.env.NODE_ENV || "development",
      logLevel: process.env.LOG_LEVEL || "info",
      logFile: process.env.LOG_FILE || "./logs/apex-bridge.log",
      maxRequestSize: process.env.MAX_REQUEST_SIZE || "100mb",
      securityLogLevel: process.env.SECURITY_LOG_LEVEL || "warn",
      securityLogEnabled: process.env.SECURITY_LOG_ENABLED !== "false",
      verboseLogging: process.env.VERBOSE_LOGGING === "true",
    };
  }

  private getDatabaseConfig(): DatabaseConfig {
    return {
      sqlitePath: process.env.SQLITE_PATH || "./.data/llm_providers.db",
      lancedbPath: process.env.LANCEDB_PATH || "./.data/lancedb",
    };
  }
}

// ==================== 导出兼容 ====================

// 导出常量（保持原有导出位置）
export {
  DEFAULT_CONFIG,
  DEFAULT_REDIS_CONFIG,
  createDefaultRateLimitSettings,
} from "../utils/config-constants";

// 导出类型（保持原有导出位置）
export type {
  ApiKeyInfo,
  RateLimitSettings,
  RedisConfig,
  AdminConfig,
  RateLimitStrategyType,
  RateLimitStrategyConfig,
  RateLimitMatcherConfig,
  RateLimitRuleConfig,
  RateLimitHeadersConfig,
  SystemConfig,
  FullConfig,
} from "../types/config/index";
````

## File: src/services/ToolRetrievalService.ts
````typescript
/**
 * ToolRetrievalService - 工具检索服务
 * 提供LanceDB向量数据库和语义搜索能力
 */

import * as lancedb from "@lancedb/lancedb";
import { Index } from "@lancedb/lancedb";
import * as arrow from "apache-arrow";
import * as fs from "fs/promises";
import * as path from "path";
import { createHash } from "crypto";
import matter from "gray-matter";
import {
  ToolRetrievalConfig,
  SkillTool,
  ToolRetrievalResult,
  ToolError,
  ToolErrorCode,
  ToolType,
} from "../types/tool-system";
import { LLMModelType } from "../types/llm-models";
import { logger } from "../utils/logger";
import { LLMConfigService } from "./LLMConfigService";
import { THRESHOLDS } from "../constants";
import { IndexConfigOptimizer } from "./tool-retrieval/IndexConfigOptimizer";

// LLMManager 延迟导入，避免循环依赖
let llmManagerInstance: any = null;

// 异步互斥锁，保护初始化过程
let initializationPromise: Promise<void> | null = null;

/**
 * 工具向量表接口（支持 Skills 和 MCP 工具）
 */
interface ToolsTable {
  id: string;
  name: string;
  description: string;
  tags: string[];
  path?: string; // Skills 的路径，MCP 工具可能没有
  version?: string; // Skills 的版本，MCP 工具可能没有
  source?: string; // MCP 服务器 ID 或 skill 名称
  toolType: "skill" | "mcp" | "builtin"; // 工具类型
  metadata: string; // JSON字符串格式
  vector: number[]; // 普通数组，不是 Float32Array
  indexedAt: Date;
}

/**
 * 工具检索服务
 */
export class ToolRetrievalService {
  private db: lancedb.Connection | null = null;
  private table: lancedb.Table | null = null;
  private config: ToolRetrievalConfig;
  private isInitialized = false;
  private dimensionsCache: number | null = null;
  private llmConfigService: any = null;
  private optimizer: IndexConfigOptimizer;

  constructor(config: ToolRetrievalConfig) {
    this.config = config;
    this.optimizer = new IndexConfigOptimizer();
    logger.info("ToolRetrievalService created with config:", {
      vectorDbPath: config.vectorDbPath,
      model: config.model,
      dimensions: config.dimensions,
    });
  }

  /**
   * 获取实际的向量维度（从数据库配置的模型）
   */
  private async getActualDimensions(): Promise<number> {
    // 如果缓存中有，直接返回
    if (this.dimensionsCache !== null) {
      return this.dimensionsCache;
    }

    try {
      // 延迟导入避免循环依赖
      if (!this.llmConfigService) {
        const { LLMConfigService } = await import("./LLMConfigService");
        this.llmConfigService = LLMConfigService.getInstance();
      }

      // 获取默认的embedding模型
      const embeddingModel = this.llmConfigService.getDefaultModel("embedding");

      if (embeddingModel) {
        // modelConfig 已经是解析好的对象
        const dimensions = embeddingModel.modelConfig?.dimensions || this.config.dimensions;

        logger.info(
          `Using actual embedding model dimensions: ${dimensions} (model: ${embeddingModel.modelName})`
        );

        // 缓存维度
        this.dimensionsCache = dimensions;
        return dimensions;
      }
    } catch (error) {
      logger.warn("Failed to get actual dimensions from database, using config default:", error);
    }

    // 回退到配置中的维度
    return this.config.dimensions;
  }

  /**
   * 更新配置维度（用于动态更新）
   */
  public async updateDimensions(dimensions: number): Promise<void> {
    if (this.dimensionsCache !== dimensions) {
      this.dimensionsCache = dimensions;
      this.config.dimensions = dimensions;

      logger.info(`Updated ToolRetrievalService dimensions to: ${dimensions}`);

      // 如果已经初始化，需要重新初始化表结构
      if (this.isInitialized && this.table) {
        logger.warn("Dimensions updated after initialization, consider reinitializing the service");
      }
    }
  }
  async initialize(): Promise<void> {
    // 快速检查：如果已初始化，直接返回
    if (this.isInitialized) {
      logger.debug("ToolRetrievalService is already initialized");
      return;
    }

    // 使用互斥锁防止并发初始化
    // 如果已经有初始化正在进行，等待它完成
    if (initializationPromise) {
      logger.debug("ToolRetrievalService initialization in progress, waiting...");
      await initializationPromise;
      // 等待完成后再次检查，防止初始化失败后重复尝试
      if (this.isInitialized) {
        return;
      }
      // 如果初始化失败，重新尝试
    }

    // 创建初始化 promise
    initializationPromise = this.doInitialize();

    try {
      await initializationPromise;
    } finally {
      initializationPromise = null;
    }
  }

  /**
   * 实际的初始化逻辑
   */
  private async doInitialize(): Promise<void> {
    const startTime = Date.now();

    try {
      logger.info("Initializing ToolRetrievalService...");

      // 获取实际的向量维度
      const actualDimensions = await this.getActualDimensions();
      if (actualDimensions !== this.config.dimensions) {
        logger.info(`Updating dimensions from ${this.config.dimensions} to ${actualDimensions}`);
        this.config.dimensions = actualDimensions;
      }

      // 1. 连接到LanceDB
      await this.connectToLanceDB();

      // 2. 创建或打开向量表
      await this.initializeSkillsTable();

      this.isInitialized = true;

      const duration = Date.now() - startTime;
      logger.debug(`ToolRetrievalService initialized in ${duration}ms`);
    } catch (error) {
      logger.error("ToolRetrievalService initialization failed:", error);
      this.isInitialized = false; // 重置状态，允许重试
      throw new ToolError(
        `ToolRetrievalService initialization failed: ${this.formatError(error)}`,
        ToolErrorCode.VECTOR_DB_ERROR
      );
    }
  }

  /**
   * 连接到LanceDB
   */
  private async connectToLanceDB(): Promise<void> {
    try {
      // 确保数据库目录存在
      await fs.mkdir(this.config.vectorDbPath, { recursive: true });

      // 连接到LanceDB
      this.db = await lancedb.connect(this.config.vectorDbPath);

      logger.info(`Connected to LanceDB at: ${this.config.vectorDbPath}`);
    } catch (error) {
      logger.error("Failed to connect to LanceDB:", error);
      throw new ToolError(
        `Failed to connect to LanceDB: ${this.formatError(error)}`,
        ToolErrorCode.VECTOR_DB_ERROR
      );
    }
  }

  /**
   * 检查表的向量维度是否匹配
   * 直接从表的 schema 读取实际的向量维度
   */
  private async checkTableDimensions(tableName: string): Promise<boolean> {
    try {
      logger.debug(`Checking table dimensions for: ${tableName}`);

      // 打开表
      const tempTable = await this.db!.openTable(tableName);

      // 从表的 schema 中获取实际的向量维度
      const actualDimension = await this.getTableVectorDimension(tempTable);

      if (actualDimension === null) {
        logger.warn(`Could not determine vector dimension from table schema`);
        return false;
      }

      const configDimension = this.config.dimensions;
      const matches = actualDimension === configDimension;

      if (matches) {
        logger.info(`Table dimensions match: config=${configDimension}, actual=${actualDimension}`);
      } else {
        logger.info(
          `Table dimensions mismatch: config=${configDimension}, actual=${actualDimension}`
        );
      }

      return matches;
    } catch (error) {
      logger.error("Failed to check table dimensions:", error);
      return false;
    }
  }

  /**
   * 从表的 schema 中获取向量字段的维度
   */
  private async getTableVectorDimension(table: lancedb.Table): Promise<number | null> {
    try {
      // 获取表的 Arrow schema
      const schema = await table.schema();

      // 查找 vector 字段
      const vectorField = schema.fields.find((f: { name: string }) => f.name === "vector");

      if (!vectorField) {
        logger.warn("No vector field found in table schema");
        return null;
      }

      // FixedSizeList 类型在 Arrow 中表示向量
      // FixedSizeList<List<Float32>, dimension>
      const type = vectorField.type;

      // 检查是否是 FixedSizeList 类型
      if (type && typeof type === "object" && "children" in type) {
        // FixedSizeList 有 children 字段，第二个元素是维度
        // 例如: FixedSizeList(List<Float32>, 768)
        if (Array.isArray((type as { children: unknown }).children)) {
          // children[1] 是表示维度的字面量或对象
          const dimensionValue = (
            type as { children: [unknown, { value?: number; length?: number }] }
          ).children;
          if (dimensionValue[1] && typeof dimensionValue[1] === "object") {
            return dimensionValue[1].value || dimensionValue[1].length || null;
          }
        }
      }

      // 备选方案：直接从 type 对象获取维度
      // LanceDB FixedSizeList 的 type 可能有 numChildren 或类似属性
      if ("numChildren" in type) {
        return (type as { numChildren: number }).numChildren;
      }

      logger.warn(`Unknown vector field type: ${JSON.stringify(type)}`);
      return null;
    } catch (error) {
      logger.error("Failed to get table vector dimension:", error);
      return null;
    }
  }

  /**
   * 初始化Skills向量表
   */
  private async initializeSkillsTable(): Promise<void> {
    try {
      const tableName = "skills";

      // 尝试直接打开表，如果失败则说明表不存在
      try {
        this.table = await this.db!.openTable(tableName);
        logger.info(`Table '${tableName}' exists, checking dimensions...`);

        // 表已存在，检查维度是否匹配
        const dimensionsMatch = await this.checkTableDimensions(tableName);
        logger.info(`Dimension check result: ${dimensionsMatch ? "MATCH" : "MISMATCH"}`);

        if (!dimensionsMatch) {
          // 维度不匹配，需要重新创建表
          logger.warn(`Table dimensions mismatch. Dropping and recreating table: ${tableName}`);

          // 完全删除旧表（包括物理文件）
          await this.dropTableCompletely(tableName);
          logger.info(`Dropped existing table: ${tableName}`);

          // 强制重新索引：删除所有 .vectorized 文件
          await this.forceReindexSkills();

          // 继续创建新表
        } else {
          // 维度匹配，使用现有表
          logger.info(`Using existing table: ${tableName}`);

          // 获取表中的记录数
          const count = await this.getTableCount();
          logger.info(`Table contains ${count} vector records`);

          // 检查是否需要添加新字段（MCP支持）
          await this.checkAndAddMissingFields(tableName);

          // 创建向量索引
          await this.createVectorIndex();
          return;
        }
      } catch (openError: any) {
        // 表不存在，继续创建新表
        logger.info(
          `Table '${tableName}' does not exist (${openError.message}), will create new table`
        );
      }

      // 创建新表 - 使用 Apache Arrow Schema（支持 Skills 和 MCP 工具）
      const schema = new arrow.Schema([
        new arrow.Field("id", new arrow.Utf8(), false),
        new arrow.Field("name", new arrow.Utf8(), false),
        new arrow.Field("description", new arrow.Utf8(), false),
        new arrow.Field(
          "tags",
          new arrow.List(new arrow.Field("item", new arrow.Utf8(), true)),
          false
        ),
        new arrow.Field("path", new arrow.Utf8(), true), // 可选，Skill 才有
        new arrow.Field("version", new arrow.Utf8(), true), // 可选，Skill 才有
        new arrow.Field("source", new arrow.Utf8(), true), // MCP 服务器 ID 或 skill 名称
        new arrow.Field("toolType", new arrow.Utf8(), false), // 'skill' | 'mcp'
        new arrow.Field("metadata", new arrow.Utf8(), false), // 对象存储为JSON字符串
        new arrow.Field(
          "vector",
          new arrow.FixedSizeList(
            this.config.dimensions,
            new arrow.Field("item", new arrow.Float32(), true)
          ),
          false
        ),
        new arrow.Field("indexedAt", new arrow.Timestamp(arrow.TimeUnit.MICROSECOND), false),
      ]);

      // 创建空表
      this.table = await this.db!.createTable(tableName, [], { schema });

      logger.info(`Created new table: ${tableName} with ${this.config.dimensions} dimensions`);

      // 创建向量索引
      await this.createVectorIndex();

      // 索引所有 Skills（新表或重新创建的表需要重新索引）
      logger.info("Indexing all skills...");
      await this.scanAndIndexAllSkills();
      logger.info("Skills indexing completed");
    } catch (error) {
      logger.error("Failed to initialize Skills table:", error);
      throw error;
    }
  }

  /**
   * 检查并添加缺失的字段（为MCP支持）
   */
  private async checkAndAddMissingFields(tableName: string): Promise<void> {
    try {
      // 尝试插入一个包含所有字段的测试记录
      const testVector = new Array(this.config.dimensions).fill(0.0);

      const testRecord = {
        id: `field-check-${Date.now()}`,
        name: "Field Check",
        description: "Checking for missing fields",
        tags: [],
        path: null,
        version: null,
        source: null, // MCP 字段
        toolType: "mcp", // MCP 字段
        metadata: "{}",
        vector: testVector,
        indexedAt: new Date(),
      };

      await this.table!.add([testRecord]);
      logger.info("All fields (including MCP fields) are present");

      // 删除测试记录
      await this.table!.delete(`id == "${testRecord.id}"`);
    } catch (error: any) {
      // 检查是否是字段缺失错误
      if (error.message && error.message.includes("Found field not in schema")) {
        logger.warn("Table is missing MCP-related fields. Recreating table...");

        // 删除旧表并重新创建
        await this.db!.dropTable(tableName);
        logger.info(`Dropped existing table for recreation: ${tableName}`);

        // 重新创建表
        const schema = new arrow.Schema([
          new arrow.Field("id", new arrow.Utf8(), false),
          new arrow.Field("name", new arrow.Utf8(), false),
          new arrow.Field("description", new arrow.Utf8(), false),
          new arrow.Field(
            "tags",
            new arrow.List(new arrow.Field("item", new arrow.Utf8(), true)),
            false
          ),
          new arrow.Field("path", new arrow.Utf8(), true),
          new arrow.Field("version", new arrow.Utf8(), true),
          new arrow.Field("source", new arrow.Utf8(), true), // MCP 服务器 ID 或 skill 名称
          new arrow.Field("toolType", new arrow.Utf8(), false), // 'skill' | 'mcp'
          new arrow.Field("metadata", new arrow.Utf8(), false),
          new arrow.Field(
            "vector",
            new arrow.FixedSizeList(
              this.config.dimensions,
              new arrow.Field("item", new arrow.Float32(), true)
            ),
            false
          ),
          new arrow.Field("indexedAt", new arrow.Timestamp(arrow.TimeUnit.MICROSECOND), false),
        ]);

        this.table = await this.db!.createTable(tableName, [], { schema });
        logger.info(`Recreated table: ${tableName} with MCP support`);

        // 重新创建索引
        await this.createVectorIndex();
      } else {
        // 其他错误，重新抛出
        throw error;
      }
    }
  }

  /**
   * 完全删除表和物理文件
   * 确保残留的 .lance 文件不会导致后续查询错误
   */
  private async dropTableCompletely(tableName: string): Promise<void> {
    try {
      // 首先从 LanceDB 删除表
      await this.db!.dropTable(tableName);
      logger.info(`Dropped table from LanceDB: ${tableName}`);

      // 然后手动删除物理文件确保完全清理
      const tablePath = path.join(this.config.vectorDbPath, tableName);
      try {
        await fs.rm(tablePath, { recursive: true, force: true });
        logger.info(`Completely removed physical files: ${tablePath}`);
      } catch (rmError: any) {
        if (rmError.code !== "ENOENT") {
          logger.warn(`Failed to remove physical files (may not exist): ${rmError.message}`);
        }
      }
    } catch (error) {
      logger.error("Failed to drop table completely:", error);
      throw error;
    }
  }

  /**
   * 创建向量索引
   */
  private async createVectorIndex(): Promise<void> {
    if (!this.table) {
      return;
    }

    try {
      const rowCount = await this.table.countRows();
      const dimension = this.config.dimensions;

      const optimizationResult = this.optimizer.calculateOptimalConfig(
        rowCount,
        dimension,
        0.95,
        false
      );

      logger.info(`[ToolRetrieval] ${optimizationResult.reasoning}`);

      await this.table.createIndex("vector", {
        config: Index.ivfPq({
          numPartitions: optimizationResult.config.numPartitions,
          numSubVectors: optimizationResult.config.numSubVectors,
        }),
        replace: true,
      });

      logger.info(
        `[ToolRetrieval] Created optimized vector index: ${optimizationResult.config.numPartitions} partitions, ` +
          `${optimizationResult.config.numSubVectors} sub-vectors, ` +
          `est. recall: ${(optimizationResult.estimatedRecall * 100).toFixed(1)}%`
      );
    } catch (error) {
      logger.debug("Vector index may already exist:", error);
    }
  }

  /**
   * 获取表名列表
   */
  private async getTableNames(): Promise<string[]> {
    if (!this.db) {
      return [];
    }

    try {
      // LanceDB的连接对象可能有不同的API
      // 这里假设可以直接访问表列表
      return [];
    } catch (error) {
      logger.warn("Failed to get table names:", error);
      return [];
    }
  }

  /**
   * 获取表的记录数
   */
  private async getTableCount(): Promise<number> {
    try {
      if (!this.table) {
        return 0;
      }

      // 使用count查询
      const count = await this.table.countRows();
      return count;
    } catch (error) {
      logger.warn("Failed to get table count:", error);
      return 0;
    }
  }

  /**
   * 为Skills生成向量嵌入
   */
  async getEmbedding(skill: {
    name: string;
    description: string;
    tags: string[];
  }): Promise<number[]> {
    try {
      logger.debug(`Generating embedding for skill: ${skill.name}`);

      // 优先使用远程 embedding API（数据库配置的模型）
      return await this.generateRemoteEmbedding(skill);
    } catch (error) {
      logger.error(`Failed to generate embedding for ${skill.name}:`, error);
      throw new ToolError(
        `Embedding generation failed: ${this.formatError(error)}`,
        ToolErrorCode.EMBEDDING_MODEL_ERROR
      );
    }
  }

  /**
   * 使用远程API生成嵌入（通过 LLMManager 调用数据库配置的 embedding 模型）
   */
  private async generateRemoteEmbedding(skill: {
    name: string;
    description: string;
    tags: string[];
  }): Promise<number[]> {
    try {
      // 延迟导入 LLMManager，避免循环依赖
      if (!llmManagerInstance) {
        const { LLMManager } = await import("../core/LLMManager");
        llmManagerInstance = new LLMManager();
      }

      // 准备文本（名称 + 描述 + 标签）
      const text = this.prepareEmbeddingText(skill);

      // 调用 LLMManager.embed() - 会自动使用数据库配置的默认 embedding 模型
      const embeddings = await llmManagerInstance.embed([text]);

      // 验证嵌入结果完整性
      if (!embeddings) {
        logger.error("[ToolRetrievalService] Embedding result is null or undefined");
        throw new Error("Embedding generation returned null or undefined");
      }

      if (!Array.isArray(embeddings)) {
        logger.error("[ToolRetrievalService] Embedding result is not an array", {
          type: typeof embeddings,
        });
        throw new Error("Embedding result is not an array");
      }

      if (embeddings.length === 0) {
        logger.error("[ToolRetrievalService] Embedding result array is empty");
        throw new Error("Empty embedding result array");
      }

      if (!embeddings[0] || !Array.isArray(embeddings[0])) {
        logger.error("[ToolRetrievalService] First embedding is null or not an array");
        throw new Error("First embedding is null or not an array");
      }

      logger.debug(`Generated remote embedding: ${embeddings[0].length} dimensions`);

      return embeddings[0];
    } catch (error) {
      logger.error("Remote embedding generation failed:", error);
      throw error;
    }
  }

  /**
   * 准备嵌入文本
   */
  private prepareEmbeddingText(skill: {
    name: string;
    description: string;
    tags: string[];
  }): string {
    const parts = [skill.name, skill.description, ...(skill.tags || [])];

    return parts.join(" ").trim();
  }

  /**
   * 索引Skills（插入向量到数据库）
   */
  async indexSkill(skill: {
    name: string;
    description: string;
    tags: string[];
    path: string;
    version?: string;
    metadata?: Record<string, any>;
    tools?: any[]; // 新增 tools 参数
  }): Promise<void> {
    try {
      logger.info(`Indexing skill: ${skill.name}`);

      // 生成唯一ID
      const skillId = this.generateSkillId(skill.name);

      // 生成向量嵌入
      const vector = await this.getEmbedding(skill);

      // 准备记录数据 - 向量保持为普通数组格式（LanceDB要求）
      // 将 tools 转换为 parameters 格式以兼容现有代码
      const tools = skill.tools || [];
      const parameters =
        tools.length > 0
          ? {
              type: "object",
              properties: tools.reduce((acc: any, tool: any) => {
                // 将每个工具作为参数
                acc[tool.name] = {
                  type: "object",
                  description: tool.description || "",
                  properties: tool.input_schema?.properties || {},
                  required: tool.input_schema?.required || [],
                };
                return acc;
              }, {}),
              required: tools
                .filter((t: any) => t.input_schema?.required?.length > 0)
                .map((t: any) => t.name),
            }
          : { type: "object", properties: {}, required: [] };

      const record: ToolsTable = {
        id: skillId,
        name: skill.name,
        description: skill.description,
        tags: skill.tags || [],
        path: skill.path,
        version: skill.version || "1.0.0",
        source: skill.name,
        toolType: "skill",
        metadata: JSON.stringify({
          ...skill.metadata,
          tools: skill.tools || [],
          parameters: parameters, // 存储 parameters 信息
        }), // 转换为JSON字符串以匹配schema
        vector: vector, // 保持为普通数组，不要转换为 Float32Array
        indexedAt: new Date(),
      };

      // 检查是否已存在（更新模式）
      await this.removeSkill(skill.name);

      // 插入到向量表 - 使用类型断言适配 LanceDB API
      await this.table!.add([record as unknown as Record<string, unknown>]);

      logger.info(`Skill indexed successfully: ${skill.name} (${vector.length} dimensions)`);
    } catch (error) {
      logger.error(`Failed to index skill ${skill.name}:`, error);
      throw error;
    }
  }

  /**
   * 生成Skills ID
   */
  private generateSkillId(name: string): string {
    return createHash("md5").update(name).digest("hex");
  }

  /**
   * 从向量表中删除Skills
   * 使用覆盖表的方式真正删除记录
   */
  async removeSkill(skillName: string): Promise<void> {
    try {
      const skillId = this.generateSkillId(skillName);
      logger.info(`Removing skill: ${skillName} (id: ${skillId})`);

      // 确保服务已初始化
      if (!this.isInitialized || !this.table) {
        logger.warn("ToolRetrievalService not initialized, skipping remove");
        return;
      }

      // 获取所有记录
      const allRecords = await this.table.query().limit(10000).toArray();

      // 过滤掉要删除的记录
      const filteredRecords = allRecords.filter((record: any) => {
        const recordId = record.id || record.item?.id;
        return recordId !== skillId;
      });

      // 如果没有变化，直接返回
      if (filteredRecords.length === allRecords.length) {
        logger.debug(`Skill ${skillName} not found in index, skipping delete`);
        return;
      }

      logger.info(`Rebuilding table: ${allRecords.length} -> ${filteredRecords.length} records`);

      // 删除旧表
      await this.dropTableCompletely("skills");

      // 重新创建表
      await this.initializeSkillsTable();

      // 重新插入保留的记录
      if (filteredRecords.length > 0) {
        // 转换记录格式
        const recordsToAdd = filteredRecords.map((record: any) => {
          const data = record.item || record;
          return {
            id: data.id,
            name: data.name,
            description: data.description,
            tags: data.tags || [],
            path: data.path || null,
            version: data.version || null,
            source: data.source || null,
            toolType: data.toolType || "skill",
            metadata:
              typeof data.metadata === "string"
                ? data.metadata
                : JSON.stringify(data.metadata || {}),
            vector: data.vector ? Array.from(data.vector) : [],
            indexedAt: new Date(data.indexedAt || Date.now()),
          };
        });

        await this.table.add(recordsToAdd as unknown as Record<string, unknown>[]);
        logger.info(`Re-inserted ${recordsToAdd.length} records`);
      }

      logger.info(`Skill ${skillName} removed from index successfully`);
    } catch (error) {
      logger.warn(`Failed to remove skill ${skillName}:`, error);
      // 不抛出错误，允许继续执行
    }
  }

  /**
   * 搜索相关Skills
   */
  async findRelevantSkills(
    query: string,
    limit: number = 5,
    threshold: number = THRESHOLDS.RELEVANT_SKILLS
  ): Promise<ToolRetrievalResult[]> {
    try {
      logger.info(`Searching relevant skills for query: "${query}"`);

      // 确保服务已初始化
      if (!this.isInitialized) {
        logger.warn("ToolRetrievalService not initialized, initializing now...");
        await this.initialize();
      }

      // 检查表是否存在
      if (!this.table) {
        throw new ToolError(
          "Vector table is not initialized. Please call initialize() first.",
          ToolErrorCode.VECTOR_DB_ERROR
        );
      }

      // 生成查询向量
      const queryVector = await this.getEmbedding({
        name: query,
        description: query,
        tags: [],
      });

      // 执行向量搜索
      // 使用余弦相似度进行搜索
      const vectorQuery = this.table
        .query()
        .nearestTo(queryVector) // 使用nearestTo进行向量搜索
        .distanceType("cosine") // 设置距离类型为余弦相似度
        .limit(limit * 2); // 获取多一些结果以应用阈值过滤

      const results = await vectorQuery.toArray();

      // 格式化和过滤结果
      const formattedResults = await this.formatSearchResults(results, limit, threshold);

      logger.info(`Found ${formattedResults.length} relevant skill(s)`);

      return formattedResults;
    } catch (error) {
      logger.error(`Skills search failed for query "${query}":`, error);
      throw new ToolError(
        `Skills search failed: ${this.formatError(error)}`,
        ToolErrorCode.VECTOR_DB_ERROR
      );
    }
  }

  /**
   * 格式化搜索结果
   */
  private async formatSearchResults(
    results: any,
    limit: number,
    threshold: number
  ): Promise<ToolRetrievalResult[]> {
    const formatted: ToolRetrievalResult[] = [];

    // LanceDB返回的结果格式可能不同
    // 这里假设results是一个数组
    const resultArray = Array.isArray(results) ? results : [results];

    for (const result of resultArray.slice(0, limit)) {
      try {
        // 获取相似度分数
        // LanceDB 返回的是 _distance (余弦距离)，需要转换为相似度
        // 余弦距离范围 [0, 2]，所以相似度 = 1 - distance/2
        // 正确的转换公式：cosine_similarity = 1 - (cosine_distance / 2)
        let score: number;
        if (result._distance !== undefined) {
          // LanceDB 返回的是余弦距离，范围 [0, 2]
          // 相似度 = 1 - distance/2
          score = Math.max(0, 1 - result._distance / 2);
        } else if (result.score !== undefined) {
          score = result.score;
        } else if (result.similarity !== undefined) {
          score = result.similarity;
        } else {
          score = 0;
        }

        // 应用阈值过滤
        if (score < threshold) {
          logger.debug(
            `Filtered out result with score ${score.toFixed(4)} < threshold ${threshold}`
          );
          continue;
        }

        // 获取数据
        const data: ToolsTable = result.item || result;

        // 解析metadata JSON字符串
        let metadata = {};
        try {
          if (typeof data.metadata === "string") {
            metadata = JSON.parse(data.metadata);
          } else {
            metadata = data.metadata || {};
          }
        } catch (e) {
          logger.warn("Failed to parse metadata JSON:", e);
          metadata = {};
        }

        // 根据工具类型返回不同格式
        let tool: any;

        if (data.toolType === "mcp") {
          // MCP 工具格式
          tool = {
            name: data.name,
            description: data.description,
            type: "mcp" as const,
            source: data.source,
            tags: data.tags,
            metadata: {
              ...metadata,
              version: data.version,
              path: data.path,
            },
          };
        } else if (data.toolType === "builtin") {
          // Builtin 工具格式
          tool = {
            name: data.name,
            description: data.description,
            type: "builtin" as const,
            tags: data.tags,
            version: data.version,
            path: data.path,
            metadata: {
              ...metadata,
              builtin: true,
            },
          };
        } else {
          // Skill 工具格式（保持向后兼容）
          tool = {
            name: data.name,
            description: data.description,
            type: "skill" as const,
            tags: data.tags,
            version: data.version,
            path: data.path,
            parameters: (metadata as any).parameters || {
              type: "object",
              properties: {},
              required: [],
            },
            enabled: true,
            level: 1,
          };
        }

        formatted.push({
          tool,
          score,
          reason: `Vector similarity: ${(score * 100).toFixed(2)}%`,
        });
      } catch (error) {
        logger.warn("Failed to format search result:", error);
      }
    }

    return formatted;
  }

  /**
   * 扫描并索引所有已安装的Skills
   */
  async scanAndIndexAllSkills(skillsDir: string = "./.data/skills"): Promise<void> {
    try {
      logger.info(`Scanning skills directory: ${skillsDir}`);

      // 检查目录是否存在
      try {
        await fs.access(skillsDir);
      } catch (error) {
        logger.warn(`Skills directory does not exist: ${skillsDir}`);
        return;
      }

      // 获取所有Skills目录
      const entries = await fs.readdir(skillsDir, { withFileTypes: true });
      const skillDirs = entries.filter((entry) => entry.isDirectory()).map((entry) => entry.name);

      logger.info(`Found ${skillDirs.length} skill directories`);

      // 索引每个Skills
      let indexedCount = 0;
      let skippedCount = 0;
      const failedSkills: { name: string; error: string }[] = [];

      for (const skillName of skillDirs) {
        try {
          const skillPath = path.join(skillsDir, skillName);
          const vectorizedFile = path.join(skillPath, ".vectorized");

          // 检查.vectorized文件
          let needReindex = true;

          if (await this.fileExists(vectorizedFile)) {
            // 检查是否需要重新索引
            needReindex = await this.checkReindexRequired(skillPath, vectorizedFile);
          }

          if (needReindex) {
            // 读取SKILL.md
            const skillData = await this.readSkillMetadata(skillPath);

            // 索引Skills
            await this.indexSkill({
              ...skillData,
              path: skillPath,
            });

            // 创建/更新.vectorized文件
            await this.updateVectorizedFile(vectorizedFile, skillPath);

            indexedCount++;
            logger.debug(`Indexed skill: ${skillName}`);
          } else {
            skippedCount++;
            logger.debug(`Skipping unchanged skill: ${skillName}`);
          }
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          failedSkills.push({ name: skillName, error: errorMessage });
          logger.error(`Failed to index skill ${skillName}:`, error);
        }
      }

      // 报告失败的技能
      if (failedSkills.length > 0) {
        logger.error(
          `[ToolRetrievalService] ${failedSkills.length} skill(s) failed to index: ` +
            failedSkills.map((s) => `${s.name}`).join(", ")
        );
      }

      logger.info(
        `Skills scanning completed: ${indexedCount} indexed, ${skippedCount} skipped, ${failedSkills.length} failed`
      );
    } catch (error) {
      logger.error("Failed to scan and index skills:", error);
      throw error;
    }
  }

  /**
   * 检查是否需要重新索引
   */
  private async checkReindexRequired(skillPath: string, vectorizedFile: string): Promise<boolean> {
    try {
      // 读取.vectorized文件
      const vectorizedContent = await fs.readFile(vectorizedFile, "utf8");
      const vectorizedData = JSON.parse(vectorizedContent);

      // 计算当前SKILL.md的哈希
      const skillMdPath = path.join(skillPath, "SKILL.md");
      const skillContent = await fs.readFile(skillMdPath, "utf8");
      const currentHash = createHash("md5").update(skillContent).digest("hex");
      const currentSize = Buffer.byteLength(skillContent);

      // 比较哈希和大小
      return currentHash !== vectorizedData.skillHash || currentSize !== vectorizedData.skillSize;
    } catch (error) {
      // 文件不存在或解析失败，需要索引
      return true;
    }
  }

  /**
   * 读取Skills元数据（从SKILL.md）
   */
  private async readSkillMetadata(skillPath: string): Promise<{
    name: string;
    description: string;
    tags: string[];
    version?: string;
    tools?: any[];
  }> {
    const skillMdPath = path.join(skillPath, "SKILL.md");

    // 读取文件
    const content = await fs.readFile(skillMdPath, "utf8");

    // 使用 gray-matter 解析 YAML Frontmatter
    const parsed = matter(content);

    if (!parsed.data.name || !parsed.data.description) {
      throw new Error("SKILL.md must contain name and description");
    }

    return {
      name: parsed.data.name,
      description: parsed.data.description,
      tags: Array.isArray(parsed.data.tags) ? parsed.data.tags : [],
      version: parsed.data.version || "1.0.0",
      tools: parsed.data.tools || [], // 提取 tools 字段
    };
  }

  /**
   * 更新.vectorized文件
   */
  private async updateVectorizedFile(vectorizedFile: string, skillPath: string): Promise<void> {
    try {
      const skillMdPath = path.join(skillPath, "SKILL.md");
      const skillContent = await fs.readFile(skillMdPath, "utf8");
      const skillHash = createHash("md5").update(skillContent).digest("hex");
      const skillSize = Buffer.byteLength(skillContent);

      const vectorizedData = {
        indexedAt: Date.now(),
        skillSize,
        skillHash,
      };

      await fs.writeFile(vectorizedFile, JSON.stringify(vectorizedData, null, 2));

      logger.debug(`Updated .vectorized file: ${vectorizedFile}`);
    } catch (error) {
      logger.warn(`Failed to update .vectorized file:`, error);
    }
  }

  /**
   * 检查文件是否存在
   */
  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * 强制重新索引所有 Skills（删除所有 .vectorized 文件）
   */
  private async forceReindexSkills(): Promise<void> {
    try {
      const skillsDir = "./.data/skills";

      // 检查目录是否存在，不存在则跳过
      try {
        await fs.access(skillsDir);
      } catch {
        logger.info(`Skills directory does not exist, skipping force reindex`);
        return;
      }

      // 获取所有Skills目录
      const entries = await fs.readdir(skillsDir, { withFileTypes: true });
      const skillDirs = entries.filter((entry) => entry.isDirectory()).map((entry) => entry.name);

      logger.info(`Force reindexing ${skillDirs.length} skills...`);

      // 删除每个技能的 .vectorized 文件
      for (const skillName of skillDirs) {
        const skillPath = path.join(skillsDir, skillName);
        const vectorizedFile = path.join(skillPath, ".vectorized");

        try {
          await fs.unlink(vectorizedFile);
          logger.debug(`Deleted .vectorized file for skill: ${skillName}`);
        } catch (error: any) {
          // 文件不存在，忽略
          if (error.code !== "ENOENT") {
            logger.warn(`Failed to delete .vectorized file for ${skillName}:`, error);
          }
        }
      }

      logger.info("Force reindex preparation completed");
    } catch (error) {
      logger.warn("Failed to force reindex skills:", error);
    }
  }

  /**
   * 获取服务统计信息
   */
  getStatistics() {
    return {
      initialized: this.isInitialized,
      config: this.config,
      embeddingModel: "using-llm-manager", // 通过 LLMManager 动态获取
    };
  }

  /**
   * 清理资源
   * 正确关闭数据库连接，防止资源泄漏
   */
  async cleanup(): Promise<void> {
    logger.info("Cleaning up ToolRetrievalService...");

    try {
      // 关闭数据库连接
      if (this.db) {
        try {
          await this.db.close();
          logger.info("LanceDB connection closed successfully");
        } catch (error) {
          logger.warn("Error closing LanceDB connection:", error);
        }
        this.db = null;
      }

      this.table = null;
      this.isInitialized = false;

      // 清理模块级单例状态
      resetToolRetrievalService();

      logger.info("ToolRetrievalService cleanup completed");
    } catch (error) {
      logger.error("ToolRetrievalService cleanup failed:", error);
      throw new ToolError(
        `ToolRetrievalService cleanup failed: ${this.formatError(error)}`,
        ToolErrorCode.VECTOR_DB_ERROR
      );
    }
  }

  /**
   * 索引多个工具（支持 Skills 和 MCP 工具）
   * @param tools 工具数组
   */
  async indexTools(tools: any[]): Promise<void> {
    try {
      logger.info(`[ToolRetrieval] Indexing ${tools.length} tools...`);

      const records: ToolsTable[] = [];

      for (const tool of tools) {
        try {
          // 生成唯一ID
          const toolId = this.generateToolId(tool);

          // 获取工具的向量嵌入
          const vector = await this.getEmbeddingForTool(tool);

          // 准备记录数据
          const record: ToolsTable = {
            id: toolId,
            name: tool.name,
            description: tool.description,
            tags: tool.tags || [],
            path: tool.path, // Skill 可能有，MCP 工具没有
            version: tool.version, // Skill 可能有，MCP 工具没有
            source: tool.source || tool.name, // MCP 服务器 ID 或 skill 名称
            toolType: tool.type || "skill", // 默认为 skill
            metadata: JSON.stringify(tool.metadata || {}),
            vector: vector,
            indexedAt: new Date(),
          };

          records.push(record);
        } catch (error) {
          logger.error(`[ToolRetrieval] Failed to index tool ${tool.name}:`, error);
          // 继续索引其他工具
        }
      }

      if (records.length > 0) {
        // 删除已存在的记录
        for (const record of records) {
          await this.removeTool(record.id);
        }

        // 批量插入
        await this.table!.add(records as unknown as Record<string, unknown>[]);

        logger.info(`[ToolRetrieval] Successfully indexed ${records.length} tools`);
      } else {
        logger.warn("[ToolRetrieval] No tools were indexed");
      }
    } catch (error) {
      logger.error("[ToolRetrieval] Failed to index tools:", error);
      throw error;
    }
  }

  /**
   * 生成工具ID（支持 Skills 和 MCP 工具）
   */
  private generateToolId(tool: any): string {
    const source = tool.source || tool.name;
    return createHash("md5").update(`${tool.type}:${source}:${tool.name}`).digest("hex");
  }

  /**
   * 获取工具的向量嵌入（统一处理 Skills 和 MCP 工具）
   */
  private async getEmbeddingForTool(tool: any): Promise<number[]> {
    // 构造工具的文本描述
    const text = `${tool.name}\n${tool.description}\n${(tool.tags || []).join(" ")}`;

    // 使用现有的getEmbedding方法
    // 需要构造一个类似SkillTool的对象
    const mockSkill = {
      name: tool.name,
      description: tool.description,
      tags: tool.tags || [],
      metadata: tool.metadata || {},
    };

    return this.getEmbedding(mockSkill);
  }

  /**
   * 从向量表中删除工具
   */
  async removeTool(toolId: string): Promise<void> {
    try {
      await this.table!.delete(`id = "${toolId}"`);
      logger.debug(`[ToolRetrieval] Removed tool: ${toolId}`);
    } catch (error) {
      logger.error(`[ToolRetrieval] Failed to remove tool ${toolId}:`, error);
    }
  }

  /**
   * 格式化错误信息
   */
  private formatError(error: any): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === "string") {
      return error;
    }
    return "Unknown error occurred in ToolRetrievalService";
  }
}

/**
 * 工具检索服务实例（单例）
 */
let instance: ToolRetrievalService | null = null;

/**
 * 获取工具检索服务实例
 */
export function getToolRetrievalService(config?: ToolRetrievalConfig): ToolRetrievalService {
  if (!instance) {
    if (!config) {
      // 使用默认配置（维度会在初始化时动态获取）
      config = {
        vectorDbPath: "./.data",
        model: "nomic-embed-text:latest",
        cacheSize: 1000,
        dimensions: 768, // 初始值，会在初始化时被实际模型维度覆盖
        similarityThreshold: THRESHOLDS.RELEVANT_SKILLS,
        maxResults: 10,
      };
    }
    instance = new ToolRetrievalService(config);
  }
  return instance;
}

/**
 * 重置工具检索服务实例（用于测试）
 */
export function resetToolRetrievalService(): void {
  instance = null;
}
````

## File: src/api/controllers/ChatController.ts
````typescript
/**
 * ApexBridge 聊天控制器
 * Playbook 和 ACE 功能已删除 (2026-01-11)
 * 处理HTTP聊天请求
 */

import { Request, Response } from "express";
import { ChatService } from "../../services/ChatService";
import { LLMManager as LLMClient } from "../../core/LLMManager";
import { InterruptRequest, InterruptResponse } from "../../types/request-abort";
import { LLMModelType } from "../../types/llm-models";
import { Message } from "../../types";
import { logger } from "../../utils/logger";
import { parseChatRequest } from "../../api/validators/chat-request-validator";
import type { ChatRequestOptions } from "../../api/validators/chat-request-validator";
import { normalizeUsage, buildChatResponse } from "../../api/utils/response-formatter";
import { parseLLMChunk } from "../../api/utils/stream-parser";

export class ChatController {
  private chatService: ChatService;
  private llmClient: LLMClient | null;

  constructor(chatService: ChatService, llmClient: LLMClient | null) {
    this.chatService = chatService;
    this.llmClient = llmClient;
  }

  /**
   * 提取多模态消息（包含图片URL的消息）
   * @param messages 消息数组
   * @returns 包含多模态内容的消息数组
   */
  private extractMultimodalMessages(messages: any[]): any[] {
    return messages.filter(
      (m: any) => Array.isArray(m.content) && m.content.some((p: any) => p.type === "image_url")
    );
  }

  /**
   * 记录多模态消息的调试信息
   * @param messages 消息数组
   */
  private logMultimodalMessages(messages: any[]): void {
    const multimodalMessages = this.extractMultimodalMessages(messages);
    if (multimodalMessages.length === 0) {
      return;
    }

    logger.debug(`[ChatController] Received ${multimodalMessages.length} multimodal messages`);

    messages.forEach((msg: any, idx: number) => {
      if (Array.isArray(msg.content)) {
        logger.debug(
          `[ChatController] Message[${idx}] has array content with ${msg.content.length} parts`
        );
        msg.content.forEach((part: any, pIdx: number) => {
          if (part.type === "image_url") {
            const url = typeof part.image_url === "string" ? part.image_url : part.image_url?.url;
            if (url) {
              logger.debug(
                `[ChatController] Message[${idx}].content[${pIdx}]: image_url with ${url.length} chars, has ;base64,: ${url.includes(";base64,")}`
              );
            }
          }
        });
      }
    });
  }

  /**
   * POST /v1/chat/completions
   * OpenAI兼容的聊天API
   */
  async chatCompletions(req: Request, res: Response): Promise<void> {
    try {
      const body = req.body;

      // DEBUG: 检查原始请求中的消息格式
      if (body.messages && Array.isArray(body.messages)) {
        this.logMultimodalMessages(body.messages);
      }

      const validation = parseChatRequest(body);
      if (!validation.success) {
        logger.warn("[ChatController] Invalid request:", validation.error);
        res.status(400).json({
          error: {
            message: validation.error || "Invalid request parameters",
            type: "invalid_request",
          },
        });
        return;
      }

      const options = validation.data;
      const messages = body.messages;

      // DEBUG: 检查验证后的消息格式
      const multimodalAfterValidation = messages.filter(
        (m: any) => Array.isArray(m.content) && m.content.some((p: any) => p.type === "image_url")
      ).length;
      if (multimodalAfterValidation > 0) {
        logger.debug(
          `[ChatController] After validation: ${multimodalAfterValidation} multimodal messages`
        );
      } else if (body.messages.some((m: any) => Array.isArray(m.content))) {
        logger.warn("[ChatController] Multimodal messages lost after validation!");
      }

      // 深度思考模式：强制流式输出思考过程
      await this.handleStreamResponse(res, messages, options);
    } catch (error: any) {
      logger.error("Error in chatCompletions:", error);

      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * 获取实际使用的模型（处理回退逻辑）
   */
  private async getActualModel(options: ChatRequestOptions): Promise<string> {
    logger.debug(
      `[ChatController.getActualModel] Input options.model: ${options.model}, options.provider: ${options.provider}`
    );

    if (options.model) {
      logger.debug(`[ChatController.getActualModel] Using specified model: ${options.model}`);
      return options.model;
    }

    logger.debug(
      "[ChatController.getActualModel] No model specified, getting default from LLMManager"
    );
    try {
      const llmClient = await this.getLLMClient();
      const models = llmClient.getAllModels();
      const defaultModel = models.find((m) => m.type === LLMModelType.NLP);
      if (defaultModel) {
        logger.debug(`[ChatController.getActualModel] Using default model: ${defaultModel.id}`);
        return defaultModel.id;
      }
    } catch (error) {
      logger.warn("[ChatController] Failed to get default model, using fallback");
    }

    logger.debug("[ChatController.getActualModel] Using fallback model: gpt-4");
    return "gpt-4";
  }

  /**
   * 处理流式响应
   */
  private async handleStreamResponse(
    res: Response,
    messages: Message[],
    options: ChatRequestOptions
  ): Promise<void> {
    const actualModel = await this.getActualModel(options);
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");
    res.setHeader("X-Accel-Buffering", "no");

    const responseId = `chatcmpl-${Date.now()}`;
    let chunkIndex = 0;

    // 检查是否启用思考过程流式输出
    const enableStreamThoughts = options.selfThinking?.enableStreamThoughts ?? false;

    try {
      for await (const chunk of this.chatService.streamMessage(messages, options)) {
        // 处理元数据标记（必须完全匹配，避免误拦截）
        if (chunk.startsWith("__META__:")) {
          const metaJson = chunk.substring(9);
          try {
            const metaData = JSON.parse(metaJson);

            if (metaData.type === "requestId") {
              res.write(`data: ${JSON.stringify({ requestId: metaData.value })}\n\n`);
            } else if (metaData.type === "interrupted") {
              const interruptedChunk = {
                id: responseId,
                object: "chat.completion.chunk",
                created: Math.floor(Date.now() / 1000),
                model: actualModel,
                choices: [
                  {
                    index: 0,
                    delta: { content: "" },
                    finish_reason: "stop",
                  },
                ],
              };
              res.write(`data: ${JSON.stringify(interruptedChunk)}\n\n`);
              res.write("data: [DONE]\n\n");
              res.end();
              logger.info(`Stream interrupted for request ${responseId}`);
              return;
            }
            continue;
          } catch (parseError) {
            logger.warn("[ChatController] Failed to parse meta chunk:", metaJson);
            continue;
          }
        }

        if (chunk.startsWith("__META__")) {
          logger.warn(
            "[ChatController] Unhandled META chunk detected, skipping:",
            chunk.substring(0, 50)
          );
          continue;
        }

        // 如果未启用思考流式输出，跳过思考过程标记
        if (
          !enableStreamThoughts &&
          (chunk.startsWith("__THOUGHT") ||
            chunk.startsWith("__ACTION") ||
            chunk.startsWith("__OBSERVATION") ||
            chunk.startsWith("__ANSWER"))
        ) {
          continue;
        }

        // 处理思考过程元数据（仅当启用时）
        if (chunk.startsWith("__THOUGHT_START__:")) {
          try {
            const data = JSON.parse(chunk.substring(18).trim());
            res.write(`event: thought_start\n`);
            res.write(
              `data: ${JSON.stringify({
                iteration: data.iteration,
                timestamp: data.timestamp,
              })}\n\n`
            );
            chunkIndex++;
          } catch (e) {
            logger.warn("[ChatController] Failed to parse thought_start:", e);
          }
          continue;
        }

        if (chunk.startsWith("__THOUGHT__:")) {
          try {
            const data = JSON.parse(chunk.substring(12).trim());
            const sseData = {
              id: responseId,
              object: "chat.completion.chunk",
              created: Math.floor(Date.now() / 1000),
              model: actualModel,
              choices: [
                {
                  index: 0,
                  delta: {
                    content: data.content,
                    role: "assistant",
                  },
                  finish_reason: null,
                },
              ],
              _type: "thought",
              _iteration: data.iteration,
            };
            res.write(`data: ${JSON.stringify(sseData)}\n\n`);
            chunkIndex++;
          } catch (e) {
            logger.warn("[ChatController] Failed to parse thought:", e);
          }
          continue;
        }

        if (chunk.startsWith("__THOUGHT_END__:")) {
          try {
            const data = JSON.parse(chunk.substring(16).trim());
            res.write(`event: thought_end\n`);
            res.write(`data: ${JSON.stringify({ iteration: data.iteration })}\n\n`);
            chunkIndex++;
          } catch (e) {
            logger.warn("[ChatController] Failed to parse thought_end:", e);
          }
          continue;
        }

        if (chunk.startsWith("__ACTION_START__:")) {
          try {
            const data = JSON.parse(chunk.substring(17).trim());
            res.write(`event: action_start\n`);
            res.write(
              `data: ${JSON.stringify({
                iteration: data.iteration,
                tool: data.tool,
                params: data.params,
              })}\n\n`
            );
            chunkIndex++;
          } catch (e) {
            logger.warn("[ChatController] Failed to parse action_start:", e);
          }
          continue;
        }

        if (chunk.startsWith("__OBSERVATION__:")) {
          try {
            const data = JSON.parse(chunk.substring(16).trim());
            res.write(`event: observation\n`);
            res.write(
              `data: ${JSON.stringify({
                iteration: data.iteration,
                tool: data.tool,
                result: data.result,
                error: data.error,
              })}\n\n`
            );
            chunkIndex++;
          } catch (e) {
            logger.warn("[ChatController] Failed to parse observation:", e);
          }
          continue;
        }

        if (chunk.startsWith("__ANSWER_START__:")) {
          res.write(`event: answer_start\n`);
          res.write(`data: {}\n\n`);
          chunkIndex++;
          continue;
        }

        if (chunk.startsWith("__ANSWER__:")) {
          try {
            const data = JSON.parse(chunk.substring(11).trim());
            const sseData = {
              id: responseId,
              object: "chat.completion.chunk",
              created: Math.floor(Date.now() / 1000),
              model: actualModel,
              choices: [
                {
                  index: 0,
                  delta: { content: data.content },
                  finish_reason: null,
                },
              ],
              _type: "answer",
            };
            res.write(`data: ${JSON.stringify(sseData)}\n\n`);
            chunkIndex++;
          } catch (e) {
            logger.warn("[ChatController] Failed to parse answer:", e);
          }
          continue;
        }

        if (chunk.startsWith("__ANSWER_END__:")) {
          res.write(`event: answer_end\n`);
          res.write(`data: {}\n\n`);
          chunkIndex++;
          continue;
        }

        // 解析LLM的嵌套JSON格式
        const parsedChunk = parseLLMChunk(chunk);

        if (parsedChunk.isReasoning) {
          const sseData = {
            id: responseId,
            object: "chat.completion.chunk",
            created: Math.floor(Date.now() / 1000),
            model: actualModel,
            choices: [
              {
                index: 0,
                delta: {
                  reasoning_content: parsedChunk.content,
                  content: null,
                },
                finish_reason: null,
              },
            ],
          };
          res.write(`data: ${JSON.stringify(sseData)}\n\n`);
        } else {
          const sseData = {
            id: responseId,
            object: "chat.completion.chunk",
            created: Math.floor(Date.now() / 1000),
            model: actualModel,
            choices: [
              {
                index: 0,
                delta: {
                  reasoning_content: null,
                  content: parsedChunk.content,
                },
                finish_reason: null,
              },
            ],
          };
          res.write(`data: ${JSON.stringify(sseData)}\n\n`);
        }
        chunkIndex++;
      }

      res.write("data: [DONE]\n\n");

      // 发送 conversationId 事件（方便前端保存）
      if (options.conversationId) {
        res.write(`event: conversation_id\n`);
        res.write(`data: ${JSON.stringify({ conversationId: options.conversationId })}\n\n`);
      }

      res.end();

      logger.info(`Streamed ${chunkIndex} chunks for request ${responseId}`);
    } catch (streamError: any) {
      logger.error("Error during streaming:", streamError);

      res.write(
        `data: ${JSON.stringify({
          error: {
            message: streamError.message,
            type: "server_error",
          },
        })}\n\n`
      );
      res.end();
    }
  }

  /**
   * 处理普通响应
   */
  private async handleNormalResponse(
    res: Response,
    messages: Message[],
    options: ChatRequestOptions
  ): Promise<void> {
    const result = await this.chatService.processMessage(messages, options);
    const actualModel = await this.getActualModel(options);

    const usage = normalizeUsage(result.usage);
    const response = buildChatResponse(result.content, actualModel, usage, options.conversationId);

    res.json(response);
    logger.info("Completed non-stream chat request");
  }

  /**
   * 获取 LLM 客户端（支持懒加载）
   */
  private async getLLMClient(): Promise<LLMClient> {
    if (this.llmClient) {
      return this.llmClient;
    }

    try {
      const { LLMManager } = await import("../../core/LLMManager");
      const client = new LLMManager() as LLMClient;
      if (!client) {
        throw new Error("LLMClient not available. Please configure LLM providers in admin panel.");
      }
      this.llmClient = client;
      return client;
    } catch (error: any) {
      throw new Error(`Failed to initialize LLMClient: ${error.message || error}`);
    }
  }

  /**
   * GET /v1/models
   * 获取可用模型列表
   */
  async getModels(req: Request, res: Response): Promise<void> {
    try {
      const llmClient = await this.getLLMClient();
      const models = await llmClient.getAllModels();

      res.json({
        object: "list",
        data: models.map((m) => ({
          id: m.id,
          object: "model",
          owned_by: m.provider,
          created: Math.floor(Date.now() / 1000),
        })),
      });

      logger.info(`Returned ${models.length} models`);
    } catch (error: any) {
      logger.error("Error in getModels:", error);

      const statusCode =
        error.message?.includes("not available") || error.message?.includes("Failed to initialize")
          ? 503
          : 500;

      res.status(statusCode).json({
        error: {
          message: error.message || "Failed to fetch models",
          type: statusCode === 503 ? "service_unavailable" : "server_error",
        },
      });
    }
  }

  /**
   * POST /v1/interrupt
   * 中断正在进行的请求
   */
  async interruptRequest(req: Request, res: Response): Promise<void> {
    try {
      const body: InterruptRequest = req.body;
      const { requestId } = body;

      if (!requestId || typeof requestId !== "string") {
        res.status(400).json({
          success: false,
          error: "Bad Request",
          message: "Missing or invalid requestId",
        });
        return;
      }

      logger.info(`[ChatController] Interrupt request for: ${requestId}`);

      const interrupted = await this.chatService.interruptRequest(requestId);

      if (interrupted) {
        const response: InterruptResponse = {
          success: true,
          message: "Request interrupted successfully",
          requestId: requestId,
          interrupted: true,
        };

        logger.info(`Request interrupted: ${requestId}`);
        res.json(response);
      } else {
        const response: InterruptResponse = {
          success: false,
          message: "Request not found or already completed",
          requestId: requestId,
          reason: "not_found",
        };

        logger.warn(`Request not found for interrupt: ${requestId}`);
        res.status(404).json(response);
      }
    } catch (error: any) {
      logger.error("Error in interruptRequest:", error);

      const response: InterruptResponse = {
        success: false,
        message: error.message || "Failed to interrupt request",
        error: error.toString(),
      };

      res.status(500).json(response);
    }
  }

  /**
   * DELETE /v1/chat/sessions/:conversationId
   * 删除会话
   */
  async deleteSession(req: Request, res: Response): Promise<void> {
    try {
      const conversationId = req.params.conversationId;

      if (!conversationId) {
        res.status(400).json({
          error: {
            message: "conversationId is required",
            type: "invalid_request",
          },
        });
        return;
      }

      await this.chatService.endSession(conversationId);

      res.json({
        success: true,
        message: "Session deleted successfully",
      });
    } catch (error: any) {
      logger.error("Error in deleteSession:", error);
      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * GET /v1/chat/sessions/:conversationId
   * 获取会话状态
   */
  async getSession(req: Request, res: Response): Promise<void> {
    try {
      const conversationId = req.params.conversationId;

      if (!conversationId) {
        res.status(400).json({
          error: {
            message: "conversationId is required",
            type: "invalid_request",
          },
        });
        return;
      }

      // 获取会话ID
      const sessionId = this.chatService.getSessionIdByConversationId(conversationId);

      if (!sessionId) {
        res.status(404).json({
          error: {
            message: "Session not found",
            type: "not_found",
          },
        });
        return;
      }

      // 获取消息数量
      const messageCount = await this.chatService.getConversationMessageCount(conversationId);
      const lastMessage = await this.chatService.getConversationLastMessage(conversationId);

      const sessionState = {
        sessionId,
        conversationId,
        status: "active",
        messageCount,
        lastActivityAt: lastMessage?.created_at || Date.now(),
        metadata: {
          hasHistory: messageCount > 0,
        },
      };

      res.json({
        success: true,
        data: sessionState,
      });
    } catch (error: any) {
      logger.error("Error in getSession:", error);
      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * GET /v1/chat/sessions/active
   * 获取会话列表
   */
  async getActiveSessions(req: Request, res: Response): Promise<void> {
    try {
      // 获取所有有对话历史的会话
      const conversationIds = await this.chatService.getAllConversationsWithHistory();

      // 获取会话详细信息
      const sessions = await Promise.all(
        conversationIds.map(async (sessionId) => {
          try {
            const messageCount = await this.chatService.getConversationMessageCount(sessionId);
            const lastMessage = await this.chatService.getConversationLastMessage(sessionId);
            const firstMessage = await this.chatService.getConversationFirstMessage(sessionId);

            return {
              sessionId,
              conversationId: sessionId,
              status: "active",
              messageCount,
              lastActivityAt: lastMessage?.created_at || 0,
              lastMessage: lastMessage?.content?.substring(0, 100) || "",
              firstMessage: firstMessage?.content?.substring(0, 100) || "",
            };
          } catch (error: any) {
            logger.warn(
              `[ChatController] Failed to get session info for ${sessionId}: ${error.message}`
            );
            return null;
          }
        })
      );

      const activeSessions = sessions.filter((s) => s !== null);

      res.json({
        success: true,
        data: {
          sessions: activeSessions,
          total: activeSessions.length,
        },
      });
    } catch (error: any) {
      logger.error("Error in getActiveSessions:", error);
      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * GET /v1/chat/sessions/:conversationId/history
   * 获取会话历史
   */
  async getSessionHistory(req: Request, res: Response): Promise<void> {
    try {
      const { conversationId } = req.params;
      const { type = "all", limit = "100" } = req.query;

      if (!conversationId) {
        res.status(400).json({
          error: {
            message: "conversationId is required",
            type: "invalid_request",
          },
        });
        return;
      }

      // 验证会话是否存在
      const sessionId = this.chatService.getSessionIdByConversationId(conversationId);
      if (!sessionId) {
        res.status(404).json({
          error: {
            message: "Session not found",
            type: "not_found",
          },
        });
        return;
      }

      const history: any = {};
      const limitNum = parseInt(limit as string) || 100;

      // 获取会话基本信息
      if (type === "all" || type === "state") {
        const messageCount = await this.chatService.getConversationMessageCount(conversationId);
        const lastMessage = await this.chatService.getConversationLastMessage(conversationId);

        history.sessionState = {
          sessionId,
          conversationId,
          status: "active",
          messageCount,
          lastActivityAt: lastMessage?.created_at || Date.now(),
        };
      }

      // 基础历史（ACE遥测已删除）
      if (type === "all" || type === "telemetry") {
        history.telemetry = [];
        history.note = "ACE telemetry deleted (2026-01-11)";
      }

      if (type === "all" || type === "directives") {
        history.directives = [];
        history.note = "ACE directives deleted (2026-01-11)";
      }

      res.json({
        success: true,
        data: history,
      });
    } catch (error: any) {
      logger.error("Error in getSessionHistory:", error);
      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * GET /v1/chat/sessions/:conversationId/messages
   * 获取对话消息历史
   */
  async getConversationMessages(req: Request, res: Response): Promise<void> {
    try {
      const { conversationId } = req.params;
      const { limit = "100", offset = "0" } = req.query;

      if (!conversationId) {
        res.status(400).json({
          error: {
            message: "conversationId is required",
            type: "invalid_request",
          },
        });
        return;
      }

      const messages = await this.chatService.getConversationHistory(
        conversationId,
        parseInt(limit as string) || 100,
        parseInt(offset as string) || 0
      );

      const total = await this.chatService.getConversationMessageCount(conversationId);

      res.json({
        success: true,
        data: {
          messages,
          total,
          limit: parseInt(limit as string) || 100,
          offset: parseInt(offset as string) || 0,
        },
      });
    } catch (error: any) {
      logger.error("Error in getConversationMessages:", error);
      res.status(500).json({
        error: {
          message: error.message || "Internal server error",
          type: "server_error",
        },
      });
    }
  }

  /**
   * POST /v1/chat/simple-stream
   * 简化版流式聊天接口（专为前端看板娘设计）
   */
  async simpleChatStream(req: Request, res: Response): Promise<void> {
    try {
      const { messages } = req.body;
      const body = req.body;

      if (!messages || !Array.isArray(messages)) {
        res.status(400).json({
          error: {
            message: "messages is required and must be an array",
            type: "validation_error",
          },
        });
        return;
      }

      const options: ChatRequestOptions = {
        provider: body.provider,
        model: body.model,
        temperature: body.temperature,
        max_tokens: body.max_tokens,
        stream: true,
        user: body.user,
      };

      if (!options.model) {
        res.status(400).json({
          error: {
            message: "model is required",
            type: "validation_error",
          },
        });
        return;
      }

      await this.handleStreamResponse(res, messages, options);
    } catch (error: any) {
      logger.error("Error in simpleChatStream:", error);

      if (!res.headersSent) {
        res.status(500).json({
          error: {
            message: error.message || "Internal server error",
            type: "server_error",
          },
        });
      }
    }
  }

  /**
   * 发送 SSE 事件数据
   * @param res 响应对象
   * @param data 要发送的数据
   * @param eventType 事件类型（可选）
   */
  private sendSSEData(res: Response, data: object, eventType?: string): void {
    if (eventType) {
      res.write(`event: ${eventType}\n`);
    }
    res.write(`data: ${JSON.stringify(data)}\n\n`);
  }

  /**
   * 处理元数据块（requestId, interrupted 等）
   * @param res 响应对象
   * @param chunk 数据块
   * @param responseId 响应ID
   * @param actualModel 实际使用的模型
   * @returns 是否成功处理
   */
  private async handleMetaChunk(
    res: Response,
    chunk: string,
    responseId: string,
    actualModel: string
  ): Promise<boolean> {
    const metaJson = chunk.substring(9);
    try {
      const metaData = JSON.parse(metaJson);

      if (metaData.type === "requestId") {
        this.sendSSEData(res, { requestId: metaData.value });
        return true;
      } else if (metaData.type === "interrupted") {
        const interruptedChunk = {
          id: responseId,
          object: "chat.completion.chunk",
          created: Math.floor(Date.now() / 1000),
          model: actualModel,
          choices: [
            {
              index: 0,
              delta: { content: "" },
              finish_reason: "stop",
            },
          ],
        };
        res.write(`data: ${JSON.stringify(interruptedChunk)}\n\n`);
        res.write("data: [DONE]\n\n");
        res.end();
        logger.info(`Stream interrupted for request ${responseId}`);
        return true;
      }
      return false;
    } catch (parseError) {
      logger.warn("[ChatController] Failed to parse meta chunk:", metaJson);
      return false;
    }
  }

  /**
   * 处理思考过程事件
   * @param res 响应对象
   * @param chunk 数据块
   * @param chunkIndex 块索引
   * @param responseId 响应ID
   * @param actualModel 实际使用的模型
   * @param eventType 事件类型：start/content/end
   * @returns 处理后的块索引
   */
  private handleThoughtEvent(
    res: Response,
    chunk: string,
    chunkIndex: number,
    responseId: string,
    actualModel: string,
    eventType: "start" | "content" | "end"
  ): number {
    try {
      let data: any;
      let eventName: string;

      if (eventType === "start") {
        const jsonStr = chunk.substring(18).trim();
        data = JSON.parse(jsonStr);
        eventName = "thought_start";
        this.sendSSEData(
          res,
          {
            iteration: data.iteration,
            timestamp: data.timestamp,
          },
          eventName
        );
      } else if (eventType === "content") {
        const jsonStr = chunk.substring(12).trim();
        data = JSON.parse(jsonStr);
        const sseData = {
          id: responseId,
          object: "chat.completion.chunk",
          created: Math.floor(Date.now() / 1000),
          model: actualModel,
          choices: [
            {
              index: 0,
              delta: {
                content: data.content,
                role: "assistant",
              },
              finish_reason: null,
            },
          ],
          _type: "thought",
          _iteration: data.iteration,
        };
        res.write(`data: ${JSON.stringify(sseData)}\n\n`);
      } else if (eventType === "end") {
        const jsonStr = chunk.substring(16).trim();
        data = JSON.parse(jsonStr);
        eventName = "thought_end";
        this.sendSSEData(res, { iteration: data.iteration }, eventName);
      }

      return chunkIndex + 1;
    } catch (e) {
      logger.warn(`[ChatController] Failed to parse thought ${eventType}:`, e);
      return chunkIndex;
    }
  }

  /**
   * 处理动作开始事件
   * @param res 响应对象
   * @param chunk 数据块
   * @param chunkIndex 块索引
   * @returns 处理后的块索引
   */
  private handleActionStartEvent(res: Response, chunk: string, chunkIndex: number): number {
    try {
      const jsonStr = chunk.substring(17).trim();
      const data = JSON.parse(jsonStr);
      this.sendSSEData(
        res,
        {
          iteration: data.iteration,
          tool: data.tool,
          params: data.params,
        },
        "action_start"
      );
      return chunkIndex + 1;
    } catch (e) {
      logger.warn("[ChatController] Failed to parse action_start:", e);
      return chunkIndex;
    }
  }

  /**
   * 处理观察事件
   * @param res 响应对象
   * @param chunk 数据块
   * @param chunkIndex 块索引
   * @returns 处理后的块索引
   */
  private handleObservationEvent(res: Response, chunk: string, chunkIndex: number): number {
    try {
      const jsonStr = chunk.substring(16).trim();
      const data = JSON.parse(jsonStr);
      this.sendSSEData(
        res,
        {
          iteration: data.iteration,
          tool: data.tool,
          result: data.result,
          error: data.error,
        },
        "observation"
      );
      return chunkIndex + 1;
    } catch (e) {
      logger.warn("[ChatController] Failed to parse observation:", e);
      return chunkIndex;
    }
  }

  /**
   * 处理答案事件
   * @param res 响应对象
   * @param chunk 数据块
   * @param chunkIndex 块索引
   * @param responseId 响应ID
   * @param actualModel 实际使用的模型
   * @param eventType 事件类型：start/content/end
   * @returns 处理后的块索引
   */
  private handleAnswerEvent(
    res: Response,
    chunk: string,
    chunkIndex: number,
    responseId: string,
    actualModel: string,
    eventType: "start" | "content" | "end"
  ): number {
    try {
      if (eventType === "start") {
        res.write(`event: answer_start\n`);
        res.write(`data: {}\n\n`);
      } else if (eventType === "content") {
        const jsonStr = chunk.substring(11).trim();
        const data = JSON.parse(jsonStr);
        const sseData = {
          id: responseId,
          object: "chat.completion.chunk",
          created: Math.floor(Date.now() / 1000),
          model: actualModel,
          choices: [
            {
              index: 0,
              delta: { content: data.content },
              finish_reason: null,
            },
          ],
          _type: "answer",
        };
        res.write(`data: ${JSON.stringify(sseData)}\n\n`);
      } else if (eventType === "end") {
        res.write(`event: answer_end\n`);
        res.write(`data: {}\n\n`);
      }

      return chunkIndex + 1;
    } catch (e) {
      logger.warn(`[ChatController] Failed to parse answer ${eventType}:`, e);
      return chunkIndex;
    }
  }

  /**
   * 发送流结束事件
   * @param res 响应对象
   * @param responseId 响应ID
   * @param conversationId 会话ID（可选）
   * @param chunkIndex 块索引
   * @returns 处理后的块索引
   */
  private sendStreamEndEvents(
    res: Response,
    responseId: string,
    conversationId?: string,
    chunkIndex?: number
  ): number {
    res.write("data: [DONE]\n\n");

    if (conversationId) {
      res.write(`event: conversation_id\n`);
      res.write(`data: ${JSON.stringify({ conversationId })}\n\n`);
    }

    res.end();
    logger.info(`Streamed ${chunkIndex || 0} chunks for request ${responseId}`);
    return -1; // 表示流已结束
  }

  /**
   * 路由数据块到对应的处理方法
   * @param chunk 数据块
   * @param res 响应对象
   * @param responseId 响应ID
   * @param actualModel 实际使用的模型
   * @param enableStreamThoughts 是否启用思考流式输出
   * @param chunkIndex 块索引
   * @returns -1 表示流已结束，0 表示未处理，正数表示处理后的索引
   */
  private routeChunk(
    chunk: string,
    res: Response,
    responseId: string,
    actualModel: string,
    enableStreamThoughts: boolean,
    chunkIndex: number
  ): number {
    // 处理元数据块
    if (chunk.startsWith("__META__:")) {
      const handled = this.handleMetaChunk(res, chunk, responseId, actualModel);
      if (handled) return 0;
    }

    // 处理思考过程事件（如果未启用思考流式输出则跳过）
    if (!enableStreamThoughts) {
      if (chunk.startsWith("__THOUGHT_START__:")) {
        return this.handleThoughtEvent(res, chunk, chunkIndex, responseId, actualModel, "start");
      }
      if (chunk.startsWith("__THOUGHT__:")) {
        return this.handleThoughtEvent(res, chunk, chunkIndex, responseId, actualModel, "content");
      }
      if (chunk.startsWith("__THOUGHT_END__:")) {
        return this.handleThoughtEvent(res, chunk, chunkIndex, responseId, actualModel, "end");
      }
      if (chunk.startsWith("__ACTION")) return chunkIndex;
      if (chunk.startsWith("__OBSERVATION")) return chunkIndex;
      if (chunk.startsWith("__ANSWER")) return chunkIndex;
    } else {
      if (chunk.startsWith("__THOUGHT_START__:")) {
        return this.handleThoughtEvent(res, chunk, chunkIndex, responseId, actualModel, "start");
      }
      if (chunk.startsWith("__THOUGHT__:")) {
        return this.handleThoughtEvent(res, chunk, chunkIndex, responseId, actualModel, "content");
      }
      if (chunk.startsWith("__THOUGHT_END__:")) {
        return this.handleThoughtEvent(res, chunk, chunkIndex, responseId, actualModel, "end");
      }
      if (chunk.startsWith("__ACTION_START__:")) {
        return this.handleActionStartEvent(res, chunk, chunkIndex);
      }
      if (chunk.startsWith("__OBSERVATION__:")) {
        return this.handleObservationEvent(res, chunk, chunkIndex);
      }
      if (chunk.startsWith("__ANSWER_START__:")) {
        return this.handleAnswerEvent(res, chunk, chunkIndex, responseId, actualModel, "start");
      }
      if (chunk.startsWith("__ANSWER__:")) {
        return this.handleAnswerEvent(res, chunk, chunkIndex, responseId, actualModel, "content");
      }
      if (chunk.startsWith("__ANSWER_END__:")) {
        return this.handleAnswerEvent(res, chunk, chunkIndex, responseId, actualModel, "end");
      }
    }

    return -2; // 表示需要作为普通块处理
  }
}
````

## File: src/types/index.ts
````typescript
/**
 * ApexBridge (ABP-only) - TypeScript类型定义
 */

// 重新导出 ace-core 类型（ACE 已删除，保留空导出以兼容）
// export type * from "./ace-core.d.ts";

export interface Message {
  role: "system" | "user" | "assistant";
  content: string | ContentPart[];
  name?: string;
}

export interface ContentPart {
  type: "text" | "image_url";
  text?: string;
  image_url?: string | { url: string };
}

export interface ChatOptions {
  provider?: string; // 指定使用的提供商（openai, deepseek, zhipu, claude, ollama, custom）
  model?: string;
  temperature?: number;
  max_tokens?: number;
  top_p?: number;
  stream?: boolean;
  loopTimeout?: number; // 循环总超时时间（毫秒，默认5分钟）
  agentId?: string; // 🆕 Agent ID，用于指定人格（如"小文"、"default"）
  userId?: string; // 请求方可选 userId，用于记忆命名空间
  conversationId?: string; // 🆕 对话ID（前端传入）
  sessionId?: string; // 🆕 会话ID（内部使用，由 ChatService 自动生成）
  // 🆕 自我思考循环配置（ReAct模式）
  selfThinking?: {
    enabled?: boolean; // 是否启用自我思考循环（ReAct模式）
    maxIterations?: number; // 最大思考循环次数（默认50）
    includeThoughtsInResponse?: boolean; // 是否在响应中包含思考过程（默认true）
    systemPrompt?: string; // 可注入的基础系统提示词
    additionalPrompts?: string[]; // 额外的提示词段落
    tools?: ToolDefinition[]; // 工具定义
    enableStreamThoughts?: boolean; // 是否流式输出思考过程
    enableToolActionParsing?: boolean; // 是否启用 tool_action 标签解析（默认true）
    toolActionTimeout?: number; // tool_action 工具执行超时时间（毫秒，默认30000）
  };
  // ACE编排模式配置已删除 (2026-01-11)
  // 如需恢复，可从 trash/ 目录恢复备份

  // 🆕 上下文压缩配置
  contextCompression?: {
    enabled?: boolean; // 是否启用上下文压缩（默认false）
    strategy?: "truncate" | "prune" | "summary" | "hybrid"; // 压缩策略
    contextLimit?: number; // 模型上下文限制（覆盖默认值）
    outputReserve?: number; // 输出保留空间（Tokens，默认4000）
    preserveSystemMessage?: boolean; // 是否保留系统消息（默认true）
    minMessageCount?: number; // 最小保留消息数（默认1）
    // 🆕 OpenCode压缩决策配置
    openCodeConfig?: {
      auto?: boolean; // 是否启用自动压缩（默认: true）
      prune?: boolean; // 是否启用受保护修剪（默认: true）
      overflowThreshold?: number; // 溢出检测阈值（Tokens，默认: 4000）
      protectTools?: boolean; // 是否保护关键工具输出（默认: true）
      summaryOnSevere?: boolean; // 严重溢出时是否生成摘要（默认: true）
      severeThreshold?: number; // 严重溢出阈值（上下文比例，默认: 0.8）
    };
  };
  // 注意: [key: string]: any 允许任意属性扩展
  // L-003 建议: 在使用时进行类型守卫检查
  [key: string]: any;
}

export interface LLMResponse {
  id: string;
  object: string;
  created: number;
  model: string;
  choices: Array<{
    index: number;
    message?: Message;
    delta?: Partial<Message>;
    finish_reason?: string;
  }>;
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
  };
}

export interface LLMProviderConfig {
  apiKey?: string;
  baseURL: string;
  defaultModel: string;
  timeout?: number;
  maxRetries?: number;
  proxy?: boolean | any; // 代理配置（false 表示禁用代理）
}

// ABP-only: 运行时直接使用 AdminConfig 作为配置源
// 为了避免核心层依赖 services/ConfigService，这里定义独立的 LLMConfig 类型
export interface LLMConfig {
  defaultProvider?: string;
  openai?: LLMProviderConfig;
  deepseek?: LLMProviderConfig;
  zhipu?: LLMProviderConfig & { mode?: "default" | "coding" };
  claude?: LLMProviderConfig;
  ollama?: Omit<LLMProviderConfig, "apiKey">; // 本地推理一般不需要 apiKey
  custom?: LLMProviderConfig;
}

// ==================== WebSocket相关类型 ====================

export interface WebSocketMessage {
  type: string;
  data?: any;
}

export interface ABPLogMessage extends WebSocketMessage {
  type:
    | "connection_ack"
    | "abp_log"
    | "notification"
    | "ai_stream"
    | "heartbeat"
    | "proactive_message";
  data?: any;
}

// 🆕 工具定义接口
export interface ToolDefinition {
  name: string;
  description: string;
  parameters: { [key: string]: any };
}

// 配置接口统一导出（可选，也可以直接从各模块导入）
export * from "./config";

// 导出 Reflector 相关类型
export * from "./reflector";

// ==================== Message V2 类型 ====================
export * from "./message-v2";

// ==================== Tool State 类型 ====================
export * from "./tool-state";

// ==================== Enhanced Skill Types (Phase 1) ====================
export * from "./enhanced-skill";
````

## File: src/server.ts
````typescript
/**
 * ApexBridge Server - 主服务器入口（ABP-only）
 */

// 全局错误处理 - 必须在最顶层，任何导入之前
process.on("unhandledRejection", (reason: any) => {
  console.error("FATAL UNHANDLED REJECTION:", reason?.message || reason);
  process.exit(99);
});

process.on("uncaughtException", (error: any) => {
  console.error("FATAL UNCAUGHT EXCEPTION:", error?.message || error);
  process.exit(99);
});

// 加载环境变量（必须在其他导入之前）
import dotenv from "dotenv";
import path from "path";
dotenv.config({ path: path.resolve(__dirname, "../.env") });

import express from "express";
import cors from "cors";
import { Server } from "http";
import { WebSocketServer } from "ws";
import { ProtocolEngine, ExtendedAdminConfig } from "./core/ProtocolEngine";
// 向后兼容
import { LLMManager as LLMClient } from "./core/LLMManager";
import { EventBus } from "./core/EventBus";
import { ChatService } from "./services/ChatService";
import { ChatController } from "./api/controllers/ChatController";
import { authMiddleware } from "./api/middleware/authMiddleware";
import { rateLimitMiddleware } from "./api/middleware/rateLimitMiddleware";
import { errorHandler } from "./api/middleware/errorHandler";
import { logger } from "./utils/logger";
import type { AdminConfig } from "./services/ConfigService";
import { WebSocketManager } from "./api/websocket/WebSocketManager";
import { ChatChannel } from "./api/websocket/channels/ChatChannel";
import { ConfigService } from "./services/ConfigService";
import { PathService } from "./services/PathService";
import { ToolRetrievalService } from "./services/ToolRetrievalService";
import { ApplicationWarmupService } from "./services/warmup/ApplicationWarmupService";

// 验证中间件
import { initializeCustomValidators } from "./api/middleware/customValidators";
import { createValidationMiddleware } from "./api/middleware/validationMiddleware";
import {
  chatCompletionSchema,
  modelsListSchema,
  interruptRequestSchema,
  validateModelBeforeAddSchema,
} from "./api/middleware/validationSchemas";
// 清理中间件
import { createSanitizationMiddleware } from "./api/middleware/sanitizationMiddleware";
// 安全头中间件
import { createSecurityHeadersMiddleware } from "./api/middleware/securityHeadersMiddleware";
// 安全日志中间件
import { createSecurityLoggerMiddleware } from "./api/middleware/securityLoggerMiddleware";
// 审计日志中间件
import { createAuditLoggerMiddleware } from "./api/middleware/auditLoggerMiddleware";
// Skills管理路由
import skillRoutes from "./api/routes/skillRoutes";
// MCP管理路由
import mcpRoutes from "./api/routes/mcpRoutes";

export class ABPIntelliCore {
  private app: express.Application;
  private server: Server;
  private wss: WebSocketServer | null = null;
  private protocolEngine: ProtocolEngine | null = null;
  private llmClient: LLMClient | null = null;
  private eventBus: EventBus;
  private chatService: ChatService | null = null;
  private websocketManager: WebSocketManager | null = null;
  private chatChannel: ChatChannel | null = null;
  private configService: ConfigService;

  constructor() {
    this.app = express();
    this.server = new Server(this.app);
    this.eventBus = EventBus.getInstance();
    this.configService = ConfigService.getInstance();

    logger.info("🧠 ApexBridge Server initializing...");
  }

  async initialize(): Promise<void> {
    try {
      // 1. 基础服务初始化 (Config, Path, DB)
      const pathService = PathService.getInstance();
      pathService.ensureAllDirs();
      logger.debug("✅ All required directories ensured");

      // 统一使用 getFullConfig 读取配置（env 优先）
      const fullConfig = this.configService.getFullConfig();
      const config = this.configService.readConfig();

      // 创建 ExtendedAdminConfig（合并系统级和应用级配置）
      const extendedConfig: ExtendedAdminConfig = {
        ...config,
        port: fullConfig.port,
        maxRequestSize: fullConfig.environment.maxRequestSize,
      } as ExtendedAdminConfig;

      // 验证系统级配置（环境变量）
      const systemValidation = this.configService.validateSystemConfig();
      if (!systemValidation.valid) {
        logger.error("❌ System configuration errors:");
        systemValidation.errors.forEach((err) => logger.error(`   - ${err}`));
        throw new Error("System configuration validation failed");
      }
      if (systemValidation.warnings.length > 0) {
        systemValidation.warnings.forEach((warn) => logger.warn(`⚠️ ${warn}`));
      }

      // 验证应用级配置（如果设置未完成，跳过严格验证）
      if (!this.configService.isSetupCompleted()) {
        logger.warn("⚠️ Configuration not fully setup (missing API Key)");
      } else {
        const validation = this.configService.validateConfig(config);
        if (!validation.valid) {
          throw new Error(`Configuration errors:\n${validation.errors.join("\n")}`);
        }
      }
      logger.debug("✅ Configuration loaded");

      // 初始化LLM配置服务（确保SQLite数据库和表已创建）
      const { LLMConfigService } = await import("./services/LLMConfigService");
      const llmConfigService = LLMConfigService.getInstance(); // 触发 DB 初始化
      logger.debug("✅ LLMConfigService initialized");

      // 自动初始化默认提供商（如果不存在）
      llmConfigService.initializeDefaultProviders();

      // 初始化SkillManager（确保在ChatService之前）
      const { SkillManager } = await import("./services/SkillManager");
      const skillManager = SkillManager.getInstance();

      // 等待Skills索引初始化完成
      await skillManager.waitForInitialization();
      logger.debug("✅ SkillManager initialized");

      // 🚀 应用启动预热（在数据库和索引初始化后执行）
      // 预热向量索引、嵌入缓存和搜索缓存，避免冷启动延迟
      const warmupService = new ApplicationWarmupService();
      logger.info("🚀 Starting application warm-up...");
      const warmupStatus = await warmupService.warmup();

      if (warmupStatus.isComplete) {
        logger.info(`✅ Warm-up completed in ${warmupStatus.totalDuration}ms`);
      } else {
        logger.warn(`⚠️ Warm-up completed with ${warmupStatus.errors.length} errors`);
        warmupStatus.errors.forEach((err) => logger.warn(`   - ${err}`));
      }

      // 从数据库加载已注册的MCP服务器
      const { mcpIntegration } = await import("./services/MCPIntegrationService");
      await mcpIntegration.loadServersFromDatabase();
      logger.debug("✅ MCP servers loaded from database");

      // 2. 核心引擎初始化
      this.protocolEngine = new ProtocolEngine(extendedConfig);
      await this.protocolEngine.initialize();
      logger.debug("✅ Protocol Engine initialized");

      // 3. 业务服务初始化 (ChatService)
      const { LLMManager } = await import("./core/LLMManager");
      const llmManager = new LLMManager();
      logger.debug("✅ LLMManager initialized");

      // 使用工厂创建 ChatService
      const { ChatServiceFactory } = await import("./services/chat/ChatServiceFactory");
      const factory = new ChatServiceFactory();
      this.chatService = factory.create(this.protocolEngine, llmManager, this.eventBus);
      logger.debug("✅ ChatService initialized (created via factory)");

      // 4. 接口层初始化 (WebSocket & HTTP Routes)
      // ⚠️ 关键调整：先初始化 ChatService，再初始化 WS，最后绑定 Server
      this.setupWebSocket(extendedConfig);

      // 注入 WS Manager 到 ChatService
      if (this.websocketManager) {
        this.chatService.setWebSocketManager(this.websocketManager);
      }

      // 5. 设置中间件
      this.setupMiddleware();

      // 6. 设置路由
      await this.setupRoutes();

      // 7. 启动HTTP服务器（所有初始化完成后才启动）
      const apiHost = extendedConfig.api?.host || "0.0.0.0";
      const apiPort = fullConfig.port; // ✅ 从系统配置读取
      this.server.listen(apiPort, apiHost, () => {
        logger.info(`🚀 ApexBridge running on http://${apiHost}:${apiPort}`);
      });

      // 8. 设置优雅关闭
      this.setupGracefulShutdown();
    } catch (error) {
      logger.error("❌ Failed to initialize ApexBridge:", error);
      process.exit(1);
    }
  }

  private setupMiddleware(): void {
    // 初始化自定义验证器（在中间件之前）
    initializeCustomValidators();

    // 安全headers（配置 Helmet.js）
    this.app.use(createSecurityHeadersMiddleware());

    // CORS
    this.app.use(
      cors({
        origin: (origin, callback) => {
          // 允许所有来源（生产环境应该配置具体来源）
          callback(null, true);
        },
        credentials: true,
        methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With"],
        exposedHeaders: ["X-RateLimit-Limit", "X-RateLimit-Remaining", "X-RateLimit-Reset"],
      })
    );

    // Body解析
    this.app.use(express.json({ limit: process.env.MAX_REQUEST_SIZE || "100mb" })); // ✅ 增加到 100MB
    this.app.use(express.urlencoded({ extended: true, limit: "100mb" }));

    // 🔍 DEBUG: 在最早的地方记录请求
    this.app.use((req, res, next) => {
      if (req.path === "/v1/chat/completions" && req.method === "POST") {
        logger.debug(`[Server] Received POST /v1/chat/completions`);
        logger.debug(`[Server] Body present: ${!!req.body}`);
        logger.debug(`[Server] Content-Type: ${req.headers["content-type"]}`);
        if (req.body?.messages) {
          logger.debug(`[Server] Messages count: ${req.body.messages.length}`);
          const multimodal = req.body.messages.filter(
            (m: any) =>
              Array.isArray(m.content) && m.content.some((p: any) => p.type === "image_url")
          ).length;
          logger.debug(`[Server] Multimodal messages: ${multimodal}`);
        }
      }
      next();
    });

    // 限流保护
    this.app.use(rateLimitMiddleware);

    // 输入清理（在验证之前，清理潜在危险字符）
    this.app.use(
      createSanitizationMiddleware({
        skipFields: ["password", "apiKey", "token", "url"], // ✅ 跳过 url 字段（包括 image_url.url）
      })
    );

    const securityLogEnvLevel = (process.env.SECURITY_LOG_LEVEL || "warn").toLowerCase();
    const allowedLevels = new Set(["debug", "info", "warn", "error", "off"]);
    const normalizedLogLevel = allowedLevels.has(securityLogEnvLevel)
      ? (securityLogEnvLevel as "debug" | "info" | "warn" | "error" | "off")
      : "warn";
    const securityLogEnabled =
      process.env.SECURITY_LOG_ENABLED !== "false" && normalizedLogLevel !== "off";

    logger.info(`[SecurityLogger] enabled=${securityLogEnabled} level=${normalizedLogLevel}`);

    // 安全日志中间件（记录安全相关事件）
    this.app.use(createSecurityLoggerMiddleware());

    // 审计日志中间件（记录关键操作）
    this.app.use(createAuditLoggerMiddleware());

    // 认证中间件
    this.app.use(authMiddleware);
  }

  private async setupRoutes(): Promise<void> {
    if (!this.protocolEngine) {
      throw new Error("Protocol Engine not initialized");
    }

    if (!this.chatService) {
      throw new Error("ChatService must be initialized before setting up routes");
    }

    // LLMClient采用懒加载机制，不在启动时初始化
    // 首次使用时（如聊天请求）会自动创建 LLMManager 实例（从 SQLite 加载配置）

    // 注册聊天API
    // 创建控制器（LLMClient采用懒加载）
    const chatController = new ChatController(this.chatService, null as any);

    // 聊天API（临时禁用 AJV 验证中间件，只使用 parseChatRequest）
    this.app.post(
      "/v1/chat/completions",
      // createValidationMiddleware(chatCompletionSchema),  // ❌ 临时禁用：可能截断大型图片数据
      (req, res) => chatController.chatCompletions(req, res)
    );

    // 🆕 会话管理API
    // ⚠️ 重要：更具体的路由必须在参数化路由之前注册

    // 🆕 获取活动会话列表（必须在 /:conversationId 之前）
    this.app.get("/v1/chat/sessions/active", (req, res) =>
      chatController.getActiveSessions(req, res)
    );

    // 🆕 获取会话历史（ACE Engine 内部日志，必须在 /:conversationId 之前）
    this.app.get("/v1/chat/sessions/:conversationId/history", (req, res) =>
      chatController.getSessionHistory(req, res)
    );

    // 🆕 获取对话消息历史（用户对话消息，必须在 /:conversationId 之前）
    this.app.get("/v1/chat/sessions/:conversationId/messages", (req, res) =>
      chatController.getConversationMessages(req, res)
    );

    // 获取单个会话（参数化路由，放在最后）
    this.app.get("/v1/chat/sessions/:conversationId", (req, res) =>
      chatController.getSession(req, res)
    );

    // 删除会话
    this.app.delete("/v1/chat/sessions/:conversationId", (req, res) =>
      chatController.deleteSession(req, res)
    );

    // 模型列表API（添加验证中间件）
    this.app.get("/v1/models", createValidationMiddleware(modelsListSchema), (req, res) =>
      chatController.getModels(req, res)
    );

    // 请求中断API（添加验证中间件）
    this.app.post("/v1/interrupt", createValidationMiddleware(interruptRequestSchema), (req, res) =>
      chatController.interruptRequest(req, res)
    );

    // LLM 配置管理 API（两级结构：提供商 + 模型）
    const ProviderController = await import("./api/controllers/ProviderController");
    const ModelController = await import("./api/controllers/ModelController");

    // 提供商管理
    this.app.get("/api/llm/providers", ProviderController.listProviders);
    this.app.get("/api/llm/providers/adapters", ProviderController.listAdapters);
    this.app.get("/api/llm/providers/:id", ProviderController.getProvider);
    this.app.post("/api/llm/providers/test-connect", ProviderController.testProviderConnection);
    this.app.post(
      "/api/llm/providers/validate-model",
      createValidationMiddleware(validateModelBeforeAddSchema),
      ProviderController.validateModelBeforeAdd
    );
    this.app.post("/api/llm/providers", ProviderController.createProvider);
    this.app.put("/api/llm/providers/:id", ProviderController.updateProvider);
    this.app.delete("/api/llm/providers/:id", ProviderController.deleteProvider);

    // 模型管理
    this.app.get("/api/llm/providers/:providerId/models", ModelController.listProviderModels);
    this.app.get("/api/llm/providers/:providerId/models/:modelId", ModelController.getModel);
    this.app.post("/api/llm/providers/:providerId/models", ModelController.createModel);
    this.app.put("/api/llm/providers/:providerId/models/:modelId", ModelController.updateModel);
    this.app.delete("/api/llm/providers/:providerId/models/:modelId", ModelController.deleteModel);

    // 模型查询（跨提供商）
    this.app.get("/api/llm/models", ModelController.queryModels);
    this.app.get("/api/llm/models/default", ModelController.getDefaultModel);

    /**
     * Skills管理API
     * 管理skills的生命周期：安装、卸载、查询
     */
    this.app.use("/api/skills", skillRoutes);

    /**
     * MCP管理API
     * 管理MCP服务器的生命周期：注册、注销、工具调用
     */
    this.app.use("/api/mcp", mcpRoutes);

    /**
     * 健康检查
     */
    this.app.get("/health", (req, res) => {
      res.json({
        status: "ok",
        version: "2.0.0",
        uptime: process.uptime(),
        plugins: this.protocolEngine!.getPluginCount(),
        activeRequests: this.chatService?.getActiveRequestCount() || 0,
      });
    });

    // 错误处理（必须最后注册）
    this.app.use(errorHandler);

    logger.debug("✅ Routes configured");
  }

  /**
   * 设置WebSocket服务器（使用独立实现）
   */
  private setupWebSocket(config: AdminConfig): void {
    if (!this.chatService) {
      throw new Error("ChatService must be initialized before WebSocket");
    }

    try {
      this.chatChannel = new ChatChannel(this.chatService);
      this.websocketManager = new WebSocketManager(config, this.chatChannel);
      this.websocketManager.initialize(this.server);
      logger.debug("✅ WebSocket server ready");
    } catch (error) {
      logger.error("❌ Failed to setup WebSocket server:", error);
      throw error;
    }
  }

  private setupGracefulShutdown(): void {
    const shutdown = async (signal: string) => {
      logger.info(`\n🛑 Received ${signal}, shutting down gracefully...`);

      // 停止接受新请求
      this.server.close(() => {
        logger.info("✅ HTTP server closed");
      });

      // 关闭WebSocket
      if (this.websocketManager) {
        await this.websocketManager.shutdown();
      }

      // 停止 ChatService 清理定时器
      if (this.chatService) {
        this.chatService.stopCleanupTimer();
        logger.info("✅ ChatService cleanup timer stopped");
      }

      // 关闭协议引擎
      if (this.protocolEngine) {
        await this.protocolEngine.shutdown();
      }

      // 关闭MCP服务
      const { mcpIntegration } = await import("./services/MCPIntegrationService");
      await mcpIntegration.shutdown();

      logger.info("👋 ApexBridge shut down successfully");
      process.exit(0);
    };

    process.on("SIGINT", () => shutdown("SIGINT"));
    process.on("SIGTERM", () => shutdown("SIGTERM"));
  }
}

// 启动服务器（ABP-only）
const shouldAutostart = process.env.APEX_BRIDGE_AUTOSTART !== "false";
if (shouldAutostart) {
  const server = new ABPIntelliCore();
  server.initialize().catch((error) => {
    logger.error("💥 Fatal error during initialization:", error);
    process.exit(1);
  });
}
````

## File: src/services/ChatService.ts
````typescript
/**
 * ChatService - 聊天服务（重构版）
 * 处理聊天请求的完整生命周期
 *
 * 职责：
 * - 协调各子服务完成聊天请求处理
 * - 不再直接创建内部服务，而是通过依赖注入
 */

import { ProtocolEngine } from "../core/ProtocolEngine";
import { LLMManager } from "../core/LLMManager";
import { EventBus } from "../core/EventBus";
import { Message, ChatOptions } from "../types";
import { logger } from "../utils/logger";
import { generateRequestId } from "../utils/request-id";
import { IWebSocketManager } from "../api/websocket/WebSocketManager";
import { ConversationHistoryService, type ConversationMessage } from "./ConversationHistoryService";
import { SessionManager } from "./SessionManager";
import { RequestTracker } from "./RequestTracker";
import type { ChatStrategy, ChatResult } from "../strategies/ChatStrategy";
import { MessagePreprocessor } from "./chat/MessagePreprocessor";
import { ConversationSaver } from "./chat/ConversationSaver";
import { StrategySelector } from "./chat/StrategySelector";
import { TIMEOUT } from "../constants";
import { ModelRegistry } from "./ModelRegistry";
import { getContextCompressionService } from "./context-compression";

export class ChatService {
  private conversationHistoryService: ConversationHistoryService;

  constructor(
    private protocolEngine: ProtocolEngine,
    private llmManager: LLMManager,
    private eventBus: EventBus,
    private messagePreprocessor: MessagePreprocessor,
    private conversationSaver: ConversationSaver,
    private strategySelector: StrategySelector,
    private sessionManager: SessionManager,
    private requestTracker: RequestTracker
  ) {
    // 初始化 ConversationHistoryService
    this.conversationHistoryService = ConversationHistoryService.getInstance();
    logger.debug("[ChatService] Initialized with ConversationHistoryService");
  }

  /**
   * 设置WebSocket管理器
   */
  setWebSocketManager(manager: IWebSocketManager): void {
    this.requestTracker = new RequestTracker(manager, TIMEOUT.SKILL_CACHE_TTL);
    logger.debug("[ChatService] WebSocketManager attached to RequestTracker");
  }

  /**
   * 注册活动请求（代理到RequestTracker）
   */
  private registerRequest(
    requestId: string,
    abortController: AbortController,
    context?: any
  ): void {
    this.requestTracker.register(requestId, abortController, context);
  }

  /**
   * 中断请求（代理到RequestTracker）
   */
  async interruptRequest(requestId: string): Promise<boolean> {
    return this.requestTracker.interrupt(requestId);
  }

  /**
   * 获取或创建会话（代理到SessionManager）
   */
  private async getOrCreateSession(
    agentId: string | undefined,
    userId: string | undefined,
    conversationId: string
  ): Promise<string | null> {
    return this.sessionManager.getOrCreate(agentId, userId, conversationId);
  }

  /**
   * 主要入口：处理聊天消息
   */
  async processMessage(messages: Message[], options: ChatOptions = {}): Promise<any> {
    const requestId = options.requestId || generateRequestId();

    logger.info(
      `[ChatService] Processing message (requestId: ${requestId}, stream: ${options.stream || false})`
    );

    try {
      // 1. 获取或创建会话（必须在处理消息之前）
      const conversationId = options.conversationId as string | undefined;

      if (conversationId) {
        const sessionId = await this.getOrCreateSession(
          options.agentId,
          options.userId,
          conversationId
        );

        if (sessionId) {
          options.sessionId = sessionId;
          logger.debug(`[ChatService] Processing message with session: ${sessionId}`);
        }
      } else {
        logger.debug("[ChatService] Processing message without session (no conversationId)");
      }

      // 2. 选择策略
      const strategy = this.strategySelector.select(options);

      // 3. 调用策略的 prepare 方法获取需要注入的变量
      let strategyVariables: Record<string, string> = {};
      if (strategy.prepare) {
        const prepareResult = await strategy.prepare(messages, options);
        strategyVariables = prepareResult.variables;
        logger.debug(
          `[ChatService] Strategy ${strategy.getName()} provided ${Object.keys(strategyVariables).length} variables`
        );
      }

      // 4. 统一消息预处理（系统提示词注入 + 变量替换）
      const preprocessResult = await this.messagePreprocessor.preprocess(
        messages,
        options,
        strategyVariables
      );
      const processedMessages = preprocessResult.messages;

      // 5. 应用上下文压缩
      // 默认启用（遵循 ContextCompressionService.defaultConfig.enabled = true）
      let messagesForLLM = processedMessages;
      const compressionEnabled = options.contextCompression?.enabled ?? true;
      if (compressionEnabled) {
        // 获取模型上下文限制
        const model = ModelRegistry.getInstance().findModel(
          options.provider || "default",
          options.model || "default"
        );
        const contextLimit = model?.modelConfig?.contextWindow || 8000;

        // 应用压缩
        const compressionResult = await getContextCompressionService().compress(
          processedMessages,
          contextLimit,
          options
        );

        messagesForLLM = compressionResult.messages;

        // 记录压缩统计信息
        if (compressionResult.stats.savingsRatio > 0) {
          logger.debug(
            `[ChatService] Context compression: ${(compressionResult.stats.savingsRatio * 100).toFixed(1)}% saved, ` +
              `${compressionResult.stats.originalTokens} -> ${compressionResult.stats.compactedTokens} tokens`
          );
        }
      }

      // 6. 检查是否为流式模式
      if (options.stream) {
        // 流式模式，返回 AsyncGenerator
        return strategy.execute(messagesForLLM, options) as AsyncIterableIterator<any>;
      } else {
        // 普通模式，返回 ChatResult
        const result = (await strategy.execute(messagesForLLM, options)) as ChatResult;

        // 7. 更新会话元数据
        if (options.sessionId && result?.usage) {
          await this.conversationSaver
            .updateSessionMetadata(options.sessionId, result.usage)
            .catch((err: Error) => {
              logger.error(`[ChatService] Failed to update session metadata: ${err.message}`, {
                stack: err.stack,
                sessionId: options.sessionId,
                requestId,
              });
            });
        }

        // 8. 统一保存对话历史（非流式模式）
        if (options.conversationId) {
          await this.conversationSaver.save(
            options.conversationId,
            messages, // 保存原始消息，不含系统提示词
            result.content,
            result.rawThinkingProcess,
            options.selfThinking?.enabled
          );
        }

        return result;
      }
    } catch (error: any) {
      logger.error("Error in ChatService.processMessage:", error);
      throw error;
    }
  }

  /**
   * 任务复杂度评估（供外部调用或未来扩展）
   */
  estimateTaskComplexity(query: string): number {
    let score = 0;

    // 关键词检测
    const complexKeywords = [
      "项目",
      "系统",
      "应用",
      "网站",
      "平台",
      "开发",
      "构建",
      "实现",
      "设计",
      "完整",
      "全面",
      "综合",
    ];

    complexKeywords.forEach((keyword) => {
      if (query.includes(keyword)) {
        score += 0.15;
      }
    });

    // 长度检测
    if (query.length > 100) {
      score += 0.2;
    } else if (query.length > 50) {
      score += 0.1;
    }

    // 多步骤检测
    const stepKeywords = ["首先", "然后", "接着", "最后", "第一", "第二", "第三"];
    stepKeywords.forEach((keyword) => {
      if (query.includes(keyword)) {
        score += 0.1;
      }
    });

    // 列表检测（1. 2. 或 - 等）
    if (/\d+[\.\)]\s|^[-*]\s/m.test(query)) {
      score += 0.2;
    }

    return Math.min(score, 1.0);
  }

  /**
   * WebSocket适配方法 - 创建聊天完成（兼容OpenAI格式）
   */
  async createChatCompletion(params: {
    messages: Message[];
    model?: string;
    temperature?: number;
    max_tokens?: number;
    stream?: boolean;
  }): Promise<any> {
    const { messages, model, temperature, max_tokens, stream } = params;

    const options: ChatOptions = {
      model,
      temperature,
      max_tokens,
      stream: false,
    };

    if (stream) {
      throw new Error("createChatCompletion不支持流式响应，请使用createStreamChatCompletion");
    }

    return this.processMessage(messages, options);
  }

  /**
   * WebSocket适配方法 - 创建流式聊天完成
   */
  async *createStreamChatCompletion(params: {
    messages: Message[];
    model?: string;
    temperature?: number;
    max_tokens?: number;
    stream?: boolean;
  }): AsyncIterableIterator<any> {
    const { messages, model, temperature, max_tokens } = params;

    const options: ChatOptions = {
      model,
      temperature,
      max_tokens,
      stream: true,
    };

    for await (const chunk of this.streamMessage(messages, options)) {
      yield {
        type: "stream_chunk",
        payload: chunk,
      };
    }
  }

  async *streamMessage(
    messages: Message[],
    options: ChatOptions = {},
    abortSignal?: AbortSignal
  ): AsyncIterableIterator<string> {
    const requestId = options.requestId || generateRequestId();
    const abortController = new AbortController();

    logger.info(`[ChatService] Streaming message (requestId: ${requestId})`);

    // 收集完整响应，用于保存对话历史
    let fullContent = "";
    const collectedThinking: string[] = [];

    try {
      // 注册请求（用于中断）
      this.registerRequest(requestId, abortController, { messages, options });

      // 监听外部中断信号
      if (abortSignal) {
        abortSignal.addEventListener("abort", () => {
          abortController.abort();
          logger.debug(`[ChatService] External abort signal received for ${requestId}`);
        });
      }

      // 1. 选择策略
      const strategy = this.strategySelector.select(options);

      // 2. 调用策略的 prepare 方法获取需要注入的变量
      let strategyVariables: Record<string, string> = {};
      if (strategy.prepare) {
        const prepareResult = await strategy.prepare(messages, options);
        strategyVariables = prepareResult.variables;
        logger.debug(
          `[ChatService] Strategy ${strategy.getName()} provided ${Object.keys(strategyVariables).length} variables`
        );
      }

      // 3. 统一消息预处理
      const preprocessResult = await this.messagePreprocessor.preprocess(
        messages,
        options,
        strategyVariables
      );
      const processedMessages = preprocessResult.messages;

      // 4. 应用上下文压缩
      // 默认启用（遵循 ContextCompressionService.defaultConfig.enabled = true）
      let messagesForLLM = processedMessages;
      const compressionEnabled = options.contextCompression?.enabled ?? true;
      if (compressionEnabled) {
        // 获取模型上下文限制
        const model = ModelRegistry.getInstance().findModel(
          options.provider || "default",
          options.model || "default"
        );
        const contextLimit = model?.modelConfig?.contextWindow || 8000;

        // 应用压缩
        const compressionResult = await getContextCompressionService().compress(
          processedMessages,
          contextLimit,
          options
        );

        messagesForLLM = compressionResult.messages;

        // 记录压缩统计信息
        if (compressionResult.stats.savingsRatio > 0) {
          logger.debug(
            `[ChatService] Context compression (stream): ${(compressionResult.stats.savingsRatio * 100).toFixed(1)}% saved, ` +
              `${compressionResult.stats.originalTokens} -> ${compressionResult.stats.compactedTokens} tokens`
          );
        }
      }

      // 5. 执行流式处理
      for await (const chunk of strategy.stream(messagesForLLM, options, abortController.signal)) {
        if (abortController.signal.aborted) {
          logger.debug(`[ChatService] Stream aborted for ${requestId}`);
          break;
        }

        // 尝试解析 JSON 收集 thinking 和 content
        try {
          const parsed = JSON.parse(chunk);
          if (parsed.reasoning_content) {
            collectedThinking.push(parsed.reasoning_content);
          }
          if (parsed.content) {
            fullContent += parsed.content;
          }
        } catch {
          fullContent += chunk;
        }

        yield chunk;
      }
    } finally {
      // 清理请求追踪
      this.requestTracker.unregister(requestId);
      logger.debug(`[ChatService] Stream completed for ${requestId}`);

      // 统一保存对话历史（流式模式）
      const conversationId = options.conversationId;
      if (conversationId && !abortController.signal.aborted) {
        await this.conversationSaver.save(
          conversationId,
          messages,
          fullContent,
          collectedThinking.length > 0 ? collectedThinking : undefined,
          options.selfThinking?.enabled
        );
      }
    }
  }

  /**
   * 获取服务状态
   */
  getStatus(): any {
    return {
      activeRequests: this.requestTracker.getActiveRequestCount(),
      sessionCount: this.sessionManager.getSessionCount(),
      llmManagerReady: !!this.llmManager,
      strategies: this.strategySelector.getStrategyNames(),
    };
  }

  /**
   * 获取会话管理器（供外部使用）
   */
  getSessionManager(): SessionManager {
    return this.sessionManager;
  }

  /**
   * 获取请求追踪器（供外部使用）
   */
  getRequestTracker(): RequestTracker {
    return this.requestTracker;
  }

  /**
   * 结束会话（代理到SessionManager）
   */
  async endSession(conversationId: string): Promise<void> {
    await this.sessionManager.archive(conversationId);
  }

  /**
   * 获取所有有对话历史的会话ID（代理到ConversationHistoryService）
   */
  async getAllConversationsWithHistory(): Promise<string[]> {
    return this.conversationHistoryService?.getAllConversationIds() || [];
  }

  /**
   * 获取会话ID通过对话ID（代理到SessionManager）
   */
  getSessionIdByConversationId(conversationId: string): string | undefined {
    return this.sessionManager.getSessionId(conversationId);
  }

  /**
   * 获取对话历史（代理到ConversationHistoryService）
   */
  async getConversationHistory(
    conversationId: string,
    limit: number = 100,
    offset: number = 0
  ): Promise<Message[]> {
    const historyService = this.conversationHistoryService;
    if (!historyService) {
      return [];
    }
    const messages = await historyService.getMessages(conversationId, limit, offset);
    return messages as Message[];
  }

  /**
   * 获取对话消息数量（代理到ConversationHistoryService）
   */
  async getConversationMessageCount(conversationId: string): Promise<number> {
    const historyService = this.conversationHistoryService || null;
    return historyService?.getMessageCount(conversationId) || 0;
  }

  /**
   * 获取对话最后一条消息（代理到ConversationHistoryService）
   */
  async getConversationLastMessage(conversationId: string): Promise<ConversationMessage | null> {
    const historyService = this.conversationHistoryService || null;
    return historyService?.getLastMessage(conversationId) || null;
  }

  /**
   * 获取对话第一条消息（代理到ConversationHistoryService）
   */
  async getConversationFirstMessage(conversationId: string): Promise<ConversationMessage | null> {
    const historyService = this.conversationHistoryService || null;
    return historyService?.getFirstMessage(conversationId) || null;
  }

  /**
   * 获取活动请求数量（代理到RequestTracker）
   */
  getActiveRequestCount(): number {
    return this.requestTracker.getActiveRequestCount();
  }

  /**
   * 停止清理定时器（代理到RequestTracker）
   */
  stopCleanupTimer(): void {
    this.requestTracker.stopCleanupTimer();
  }
}
````
